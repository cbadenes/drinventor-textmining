{
  "uri" : "sig2009-a21-adams_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a21-adams_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Gaussian KD-Trees for Fast High-Dimensional Filtering",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "a4a47bc96d74385241245c68c3a8687c9b86685f5a4cfc13ac6acec3ac565c00", "owa", "10.1145", "1531326.1531327", "name", "identification", "possible", "gaussian", "kd-tree", "fast", "High-Dimensional", "Filtering", "Andrew", "Adams", "Natasha", "Gelfand", "Stanford", "University", "Nokia", "Research", "Figure", "gaussian", "kd-tree", "accelerate", "broad", "class", "non-linear", "filter", "include", "bilateral", "-lrb-", "left", "-rrb-", "non-local", "means", "-lrb-", "middle", "-rrb-", "novel", "non-local", "means", "geometry", "-lrb-", "right", "-rrb-", "we", "propose", "method", "accelerate", "broad", "class", "non-linear", "filter", "include", "bilateral", "non-local", "means", "other", "related", "filter", "filter", "can", "all", "express", "similar", "way", "First", "assign", "each", "value", "filter", "position", "some", "vector", "space", "replace", "every", "value", "weighted", "linear", "combination", "all", "value", "weight", "determine", "gaussian", "function", "distance", "between", "position", "value", "pixel", "color", "position", "-lrb-", "-rrb-", "coordinate", "describe", "gaussian", "blur", "position", "instead", "-lrb-", "-rrb-", "coordinate", "five-dimensional", "space-color", "volume", "describe", "bilateral", "filter", "we", "instead", "set", "position", "local", "patch", "color", "around", "associate", "pixel", "describe", "non-local", "means", "we", "describe", "monte-carlo", "kdtree", "sampling", "algorithm", "efficiently", "compute", "any", "filter", "can", "express", "way", "along", "GPU", "implementation", "technique", "we", "use", "algorithm", "implement", "accelerate", "bilateral", "filter", "respect", "full", "3d", "color", "distance", "accelerate", "non-local", "means", "single", "image", "volume", "unaligned", "burst", "image", "denoising", "fast", "adaptation", "non-local", "means", "geometry", "we", "have", "value", "filter", "each", "assign", "position", "d-dimensional", "space", "we", "space", "complexity", "-lrb-", "dn", "-rrb-", "we", "time", "complexity", "-lrb-", "dn", "log", "-rrb-", "whereas", "exist", "method", "typically", "either", "exponential", "quadratic", "n.", "cr", "category", "i.", "4.3", "-lsb-", "image", "processing", "computer", "Vision", "-rsb-", "enhancement?filtering", "i.", "3.5", "-lsb-", "Computer", "Graphics", "-rsb-", "computational", "geometry", "object", "modeling?geometric", "algorithm", "language", "system", "Keywords", "bilateral", "filter", "non-local", "means", "geometry", "filter", "denoising", "ACM", "Reference", "Format", "Adams", "a.", "Gelfand", "N.", "Dolson", "J.", "Levoy", "M.", "2009", "gaussian", "kd-tree", "fast", "high-dimensional", "filtering", "ACM", "Trans", "graph", "28", "Article", "21", "-lrb-", "August", "2009", "-rrb-", "12", "page", "dous", "10.1145", "1531326.1531327", "http://doi.acm.org/10.1145/1531326.1531327", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "fus", "rst", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "permissions@acm.org", "2009", "ACM", "0730-0301/2009", "03-art21", "10.00", "DOI", "10.1145", "1531326.1531327", "http://doi.acm.org/10.1145/1531326.1531327", "Jennifer", "Dolson", "Marc", "Levoy", "Stanford", "University", "Stanford", "University", "introduction", "recent", "year", "variety", "related", "non-linear", "filter", "have", "become", "important", "various", "task", "image", "processing", "computational", "photography", "geometry", "processing", "related", "field", "include", "bilateral", "filter", "non-local", "means", "filter", "various", "similar", "ad-hoc", "filter", "use", "particular", "application", "filter", "often", "highly", "computationally", "intensive", "we", "present", "framework", "which", "understand", "filter", "acceleration", "datum", "structure", "algorithm", "apply", "broadly", "across", "all", "they", "let", "we", "begin", "simple", "case", "bilateral", "filter", "recent", "method", "accelerate", "bilateral", "filter", "respect", "distance", "space", "luminance", "one", "method", "bilateral", "grid", "-lsb-", "Paris", "Durand", "2006", "-rsb-", "do", "embed", "image", "two", "dimensional", "manifold", "coarsely", "voxelize", "three", "dimensional", "spaceluminance", "volume", "perform", "3d", "gaussian", "blur", "sampling", "again", "along", "image", "manifold", "construct", "output", "shortcoming", "technique", "well", "other", "recent", "acceleration", "bilateral", "filter", "-lsb-", "Durand", "Dorsey", "2002", "-rsb-", "-lsb-", "Weiss", "2006", "-rsb-", "do", "respect", "distance", "chrominance", "result", "unwanted", "blur", "neighbouring", "isoluminant", "region", "-lrb-", "figure", "-rrb-", "one", "way", "address", "problem", "expand", "bilateral", "grid", "5d", "space-color", "volume", "describe", "-lsb-", "Paris", "Durand", "2009", "-rsb-", "however", "we", "argue", "section", "3.1", "memory", "require", "represent", "grid", "grow", "exponentially", "number", "dimension", "do", "time", "require", "each", "stage", "algorithm", "growth", "manageable", "filter", "size", "both", "space", "color", "large", "which", "turn", "permit", "grid", "coarse", "however", "filter", "small", "grid", "must", "fine", "make", "memory", "time", "requirement", "approach", "impractical", "bilateral", "filter", "can", "alternatively", "rephrase", "nearest", "neighbour", "search", "five", "dimension", "every", "-lrb-", "-rrb-", "point", "image", "we", "would", "like", "gather", "color", "from", "other", "nearby", "point", "suggest", "store", "cloud", "point", "represent", "image", "manifold", "kd-tree", "use", "approximate", "nearest", "neighbour", "query", "-lrb-", "describe", "-lsb-", "Arya", "et", "al.", "1998", "-rsb-", "-rrb-", "find", "nearby", "value", "unfortunately", "approach", "scale", "poorly", "filter", "size", "large", "filter", "each", "pixel", "may", "near", "every", "other", "pixel", "would", "preferable", "subsample", "set", "neighbour", "statistically", "efficient", "manner", "facilitate", "query", "we", "propose", "new", "type", "kd-tree", "which", "we", "term", "gaussian", "kd-tree", "describe", "section", "tree", "sparsely", "represent", "high-dimensional", "space", "value", "store", "point", "point", "cloud", "derive", "from", "reduce", "set", "pixel", "from", "original", "image", "so", "unlike", "bilateral", "grid", "we", "only", "ever", "store", "2d", "manifold", "regardless", "size", "dimensionality", "space", "which", "embedded", "tree", "support", "rapid", "montecarlo-sampled", "query", "probabilistically", "scatter", "gather", "from", "point", "use", "stratified", "weighted", "importance", "sampling", "query", "use", "implement", "embedding", "blur", "sampling", "space", "describe", "section", "do", "so", "computational", "complexity", "independent", "filter", "size", "linear", "dimensionality", "since", "gaussian", "kd-tree", "scale", "well", "dimension", "we", "need", "constrain", "ourselves", "three-dimensional", "color", "distance", "ability", "cheaply", "perform", "blur", "weight", "higher", "dimensional", "distance", "we", "can", "also", "accelerate", "non-local", "means", "-lsb-", "buade", "et", "al.", "2005", "-rsb-", "non-local", "means", "mix", "pixel", "value", "other", "pixel", "have", "similar", "local", "neighborhood", "equivalent", "gaussian", "blur", "2d", "manifold", "embed", "space", "much", "higher", "dimensionality", "non-local", "means", "usually", "make", "tractable", "limit", "only", "search", "similar", "neighborhood", "small", "local", "search", "window", "around", "each", "pixel", "we", "method", "fact", "slightly", "faster", "when", "search", "completely", "unbounded", "fewer", "dimension", "consider", "we", "discuss", "non-local", "means", "detail", "section", "3.2", "while", "non-local", "means", "increase", "number", "range", "dimension", "we", "can", "also", "increase", "number", "domain", "dimension", "include", "time", "section", "3.2", "we", "demonstrate", "fast", "non-local", "means", "denoise", "space-time", "volume", "non-local", "means", "able", "denoise", "dynamic", "scene", "average", "pixel", "value", "over", "time", "without", "require", "explicit", "motion", "model", "finally", "gaussian", "kd-tree", "do", "require", "any", "particular", "order", "structure", "value", "store", "value", "need", "lie", "grid", "we", "can", "mix", "they", "accord", "distance", "between", "any", "set", "associate", "vector", "we", "like", "we", "therefore", "need", "restrict", "ourselves", "image", "section", "3.3", "we", "apply", "non-local", "means", "noisy", "geometry", "we", "tree", "construction", "gaussian", "query", "algorithm", "dataparallel", "so", "we", "have", "also", "implement", "they", "graphic", "card", "use", "CUDA", "-lsb-", "Buck", "2007", "-rsb-", "significant", "speedup", "over", "CPU", "implementation", "implementation", "detail", "section", "2.4", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "21:2", "a.", "Adams", "et", "al.", "figure", "bilateral", "filter", "respect", "only", "distance", "luminance", "produce", "objectionable", "artifact", "left", "bilateral-filtered", "image", "some", "roof", "tile", "against", "sky", "respect", "distance", "luminance", "only", "note", "bleeding", "blue", "sky", "similarly", "bright", "roof", "tile", "-lrb-", "inset", "-rrb-", "right", "image", "filter", "use", "full", "3d", "color", "distance", "Input", "filter", "output", "Range", "Range", "Range", "domain", "Splat", "domain", "Blur", "domain", "slice", "Figure", "filter", "respect", "distance", "both", "domain", "range", "can", "do", "embed", "input", "signal", "higher", "dimensional", "domain-range", "space", "-lrb-", "splat", "-rrb-", "perform", "gaussian", "filter", "space", "-lrb-", "blur", "-rrb-", "finally", "sampling", "space", "along", "original", "embedded", "manifold", "-lrb-", "slice", "-rrb-", "Color", "bilateral", "filter", "require", "five", "dimensional", "space", "range", "dimension", "domain", "dimension", "y.", "non-local", "means", "conceptually", "same", "require", "many", "more", "range", "dimension", "we", "represent", "high-dimensional", "space", "sparsely", "use", "point", "store", "gaussian", "kd-tree", "-lrb-", "see", "Figure", "-rrb-", "gaussian", "kd-tree", "filtering", "most", "generally", "describe", "replace", "each", "value", "set", "size", "linear", "combination", "all", "other", "value", "ij", "we", "assume", "value", "represent", "homogeneous", "coordinate", "homogeneous", "coordinate", "filter", "along", "other", "make", "usual", "division", "sum", "weight", "unnecessary", "weight", "ij", "commonly", "compute", "associate", "each", "value", "position", "some", "other", "space", "weight", "give", "function", "distance", "between", "two", "position", "-lrb-", "-rrb-", "example", "when", "perform", "gaussian", "blur", "image", "value", "pixel", "color", "have", "-lrb-", "-rrb-", "coordinate", "associate", "they", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "weight", "give", "gaussian", "function", "distance", "between", "two", "position", "standard", "devation", "when", "perform", "bilateral", "filter", "weight", "further", "reduce", "gaussian", "function", "distance", "color", "space", "spatial", "standard", "devation", "color", "space", "standard", "deviation", "joint", "bilateral", "filter", "-lrb-", "describe", "-lsb-", "Eisemann", "Durand", "2004", "-rsb-", "-lsb-", "Petschnigg", "et", "al.", "2004", "-rsb-", "-rrb-", "instead", "use", "color", "distance", "from", "some", "other", "image", "extend", "include", "color", "distance", "term", "equation", "can", "more", "generally", "express", "formulation", "first", "propose", "-lsb-", "d.barash", "2002", "-rsb-", "pixel", "value", "now", "associate", "position", "five-dimensional", "space", "whose", "axis", "-lrb-", "-rrb-", "scale", "inverse", "standard", "deviation", "filter", "respective", "dimension", "we", "free", "scale", "position", "arbitrarily", "so", "without", "loss", "generality", "we", "gaussian", "kernel", "always", "have", "standard", "deviation", "one", "-lrb-", "absent", "equation", "-rrb-", "we", "can", "transform", "arbitrary", "elliptical", "ball", "linear", "transform", "position", "vector", "non-local", "means", "-lrb-", "describe", "-lsb-", "Buades", "et", "al.", "2005", "-rsb-", "-rrb-", "which", "average", "pixel", "other", "have", "similar", "local", "neighborhood", "can", "also", "express", "equation", "equal", "neighborhood", "around", "pixel", "i.", "non-local", "means", "can", "also", "adapt", "geometry", "use", "similar", "formulation", "-lrb-", "section", "3.3", "-rrb-", "give", "arbitrary", "set", "-lrb-", "-rrb-", "size", "dimension", "lesser", "dimension", "naive", "computation", "equation", "would", "take", "-lrb-", "-rrb-", "time", "every", "value", "interact", "every", "other", "value", "-lrb-", "example", "when", "blur", "image", "filter", "large", "image", "-rrb-", "equation", "type", "discrete", "Gauss", "transform", "which", "can", "accelerate", "use", "Improved", "fast", "Gauss", "Transform", "-lsb-", "Yang", "et", "al.", "2003", "-rsb-", "Improved", "fast", "Gauss", "transform", "group", "vector", "cluster", "radius", "proportional", "standard", "deviation", "desire", "Gaussian", "compute", "Taylor", "series", "approximation", "result", "each", "cluster", "center", "effective", "tool", "very", "large", "radius", "blur", "few", "cluster", "need", "unfortunately", "standard", "deviation", "commonly", "use", "filter", "small", "enough", "few", "datum", "point", "per", "cluster", "little", "benefit", "derive", "from", "clustering", "we", "find", "when", "apply", "bilateral", "filter", "Improved", "fast", "Gauss", "Transform", "fact", "slower", "than", "naive", "filter", "implementation", "typical", "parameter", "setting", "we", "instead", "accelerate", "computation", "equation", "three", "way", "firstly", "interaction", "further", "than", "three", "standard", "deviation", "apart", "can", "safely", "ignore", "-lrb-", "weight", "become", "very", "small", "-rrb-", "make", "collision", "detection", "problem", "sphere", "d-dimensional", "space", "suggest", "place", "point", "kd-tree", "-lrb-", "grid", "small", "-rrb-", "detail", "we", "tree", "construction", "section", "2.1", "secondly", "equation", "replace", "each", "value", "sum", "over", "many", "value", "sum", "can", "importance", "sample", "avoid", "have", "consider", "every", "interaction", "between", "some", "detail", "section", "2.2", "thirdly", "gaussian", "filter", "can", "accelerate", "compute", "filter", "lower", "resolution", "interpolate", "result", "we", "con", "struct", "reduce", "set", "only", "position", "value", "downsample", "use", "gaussian", "kernel", "size", "blur", "smaller", "set", "gaussian", "filter", "size", "upsample", "original", "position", "gaussian", "kernel", "size", "long", "we", "point", "sample", "space", "densely", "enough", "equivalent", "single", "gaussian", "blur", "size", "we", "consider", "sampling", "dense", "enough", "when", "maximum", "spacing", "between", "datum", "point", "reduce", "space", "work", "-lsb-", "Chen", "et", "al.", "2007", "-rsb-", "three", "stage", "term", "grid", "construction", "low", "pass", "filter", "slice", "we", "refer", "they", "splatting", "blur", "slice", "-lrb-", "figure", "-rrb-", "we", "typically", "set", "scale", "so", "combined", "effect", "equivalent", "gaussian", "blur", "standard", "deviation", "one", "memory", "use", "concern", "we", "can", "omit", "blur", "stage", "achieve", "same", "effective", "filter", "increase", "allow", "more", "coarsely", "space", "point", "increase", "number", "sample", "require", "during", "Monte-Carlo", "splatting", "slice", "we", "derive", "we", "reduce", "set", "size", "during", "tree", "building", "describe", "below", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "gaussian", "kd-tree", "fast", "High-Dimensional", "Filtering", "21:3", "Figure", "we", "show", "comparison", "bilateral", "grid", "-lsb-", "Paris", "Durand", "2006", "-rsb-", "we", "gaussian", "kd-tree", "regardless", "signal", "-lrb-", "orange", "-rrb-", "bilateral", "grid", "store", "sample", "regular", "grid", "-lrb-", "blue", "point", "-rrb-", "number", "sample", "grow", "exponentially", "dimension", "gaussian", "kd-tree", "only", "store", "sample", "along", "signal", "which", "case", "bilateral", "filter", "color", "image", "2d", "manifold", "5d", "space-color", "volume", "we", "place", "sample", "centroid", "bound", "box", "-lrb-", "light", "blue", "-rrb-", "pixel", "lie", "within", "each", "leaf", "node", "-lrb-", "outline", "gray", "-rrb-", "filtering", "do", "scatter", "pixel", "value", "onto", "nearby", "sample", "-lrb-", "splat", "-rrb-", "gather", "each", "sample", "from", "nearby", "sample", "-lrb-", "blur", "-rrb-", "gather", "each", "pixel", "from", "nearby", "sample", "construct", "output", "-lrb-", "slice", "-rrb-", "each", "stage", "operate", "use", "importance-sampled", "query", "tree", "query", "simulate", "send", "number", "sample", "distribute", "gaussian", "cloud", "-lrb-", "show", "green", "-rrb-", "around", "query", "point", "down", "leaf", "tree", "so", "probability", "sample", "arrive", "particular", "leaf", "proportional", "integral", "Gaussian", "over", "leaf", "effective", "standard", "deviation", "entire", "blur", "square", "root", "sum", "square", "standard", "deviation", "gaussian", "cloud", "associate", "each", "stage", "2.1", "build", "tree", "we", "gaussian", "kd-tree", "store", "cloud", "point", "dimension", "one", "point", "per", "leaf", "design", "allow", "fast", "importancesampled", "query", "point", "-lrb-", "section", "2.2", "-rrb-", "each", "inner", "node", "tree", "represent", "d-dimensional", "rectangular", "cell", "which", "may", "extend", "infinity", "one", "more", "dimension", "inner", "node", "store", "dimension", "along", "which", "cut", "value", "cut", "dimension", "cut", "along", "bound", "node", "dimension", "min", "max", "pointer", "its", "child", "lef", "right", "Leaf", "node", "contain", "only", "dimensional", "point", "which", "lie", "somewhere", "within", "cell", "represent", "key", "difference", "between", "tree", "conventional", "kd-tree", "we", "store", "max", "min", "well", "cut", "maximum", "bind", "compute", "minimum", "cut", "value", "all", "ancestor", "which", "cut", "along", "same", "dimension", "have", "larger", "cut", "value", "minimum", "bind", "similarly", "maximum", "cut", "value", "all", "ancestor", "which", "cut", "along", "same", "dimension", "have", "smaller", "cut", "value", "see", "Figure", "comparison", "tree", "bilateral", "grid", "we", "now", "face", "task", "build", "gaussian", "kd-tree", "contain", "point", "cloud", "-lrb-", "blue", "point", "Figure", "-rrb-", "adequate", "density", "around", "region", "where", "we", "intend", "sample", "fortunately", "we", "know", "ahead", "time", "we", "only", "ever", "sample", "position", "use", "construct", "tree", "example", "when", "bilateral", "filter", "we", "construct", "tree", "use", "-lrb-", "-rrb-", "value", "every", "pixel", "scatter", "from", "gather", "those", "location", "five-dimensional", "space", "therefore", "we", "can", "ensure", "adequate", "density", "guarantee", "every", "position", "within", "point", "store", "leaf", "node", "goal", "when", "build", "kd-tree", "usually", "minimize", "expected", "time", "take", "query", "raytracing", "example", "mean", "can", "advantageous", "have", "highly", "unbalanced", "tree", "which", "carve", "off", "empty", "space", "commonly", "hit", "area", "early", "however", "we", "never", "sample", "unpopulated", "area", "so", "how", "we", "deal", "empty", "space", "irrelevant", "typical", "datum", "each", "we", "leaf", "node", "likely", "reach", "any", "other", "so", "tree", "should", "balance", "recursively", "turn", "list", "position", "tree", "we", "first", "compute", "bound", "box", "bound", "box", "have", "diagonal", "length", "less", "than", "we", "create", "leaf", "node", "associated", "point", "center", "bound", "box", "otherwise", "we", "split", "halfway", "along", "longest", "bound", "box", "dimension", "divide", "input", "list", "two", "continue", "recursively", "scheme", "descend", "cell", "have", "small", "diagonal", "quickly", "possible", "another", "common", "scheme", "generate", "balanced", "tree", "split", "median", "value", "along", "longest", "dimension", "we", "case", "uneven", "distribution", "point", "example", "those", "produce", "from", "image", "which", "mostly", "single", "color", "can", "fact", "cause", "produce", "unbalanced", "tree", "while", "have", "advantage", "place", "most", "commonly", "access", "leave", "closer", "root", "tree", "practice", "we", "find", "do", "improve", "performance", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "21:4", "a.", "Adams", "et", "al.", "2.2", "query", "tree", "query", "we", "gaussian", "tree", "design", "facilitate", "gather", "from", "-lrb-", "scatter", "-rrb-", "value", "around", "give", "query", "position", "purpose", "compute", "importance-sampled", "approximation", "equation", "Figure", "illustrate", "process", "query", "take", "input", "query", "position", "space", "standard", "deviation", "around", "position", "number", "sample", "return", "list", "most", "point", "corresponding", "weight", "number", "sample", "set", "infinity", "list", "return", "include", "all", "point", "within", "three", "standard", "deviation", "query", "weight", "proportional", "gaussian", "kernel", "give", "standard", "deviation", "-lrb-", "q?p", "-rrb-", "number", "sample", "set", "one", "list", "contain", "single", "leaf", "node", "probabilistically", "choose", "from", "all", "leaf", "node", "within", "three", "standard", "deviation", "query", "repeatedly", "ask", "single", "sample", "merge", "result", "list", "produce", "same", "result", "limit", "ask", "infinite", "number", "sample", "from", "single", "query", "we", "can", "think", "we", "sample", "cloud", "point", "normally", "distribute", "around", "query", "give", "standard", "deviation", "although", "we", "do", "explicitly", "represent", "they", "each", "inner", "node", "we", "compute", "expect", "number", "sample", "lie", "within", "left", "right", "child", "compute", "area", "Gaussian", "truncate", "min", "max", "lie", "either", "side", "cut", "Gaussian", "separable", "so", "decision", "already", "make", "node", "split", "other", "dimension", "irrelevant", "expect", "number", "sample", "split", "each", "way", "round", "down", "nearest", "integer", "many", "sample", "assign", "left", "right", "child", "respectively", "final", "sample", "omit", "rounding", "one", "probabilistically", "assign", "either", "left", "right", "child", "splitting", "scheme", "save", "work", "compare", "individually", "simulate", "every", "sample", "result", "runtime", "which", "sublinear", "number", "sample", "bound", "number", "cell", "overlap", "ping", "query", "also", "stratify", "sampling", "result", "less", "noise", "output", "fixed", "number", "sample", "we", "arrive", "give", "leaf", "node", "probability", "proportional", "integral", "Gaussian", "over", "corresponding", "cell", "correct", "weight", "however", "we", "tree", "store", "value", "point", "cell", "correct", "we", "keep", "track", "-lrb-", "unrounded", "-rrb-", "expect", "number", "sample", "reach", "leaf", "compute", "probability", "which", "we", "should", "have", "reach", "point", "evaluate", "Gaussian", "return", "weight", "which", "latter", "divide", "former", "weighted", "importance", "sampling", "describe", "-lsb-", "Bekaert", "et", "al.", "2000", "-rsb-", "context", "radiosity", "correction", "allow", "we", "use", "piecewise", "quadratic", "approximation", "gaussian", "-lrb-", "give", "convolution", "three", "identical", "rect", "filter", "-rrb-", "while", "descend", "tree", "its", "integral", "easier", "compute", "than", "Gaussian", "see", "Algorithm", "relevant", "snippet", "C++", "code", "2.3", "Complexity", "analysis", "recall", "we", "d-dimensional", "datum", "point", "reduce", "during", "tree", "building", "we", "use", "sample", "when", "query", "tree", "we", "filter", "datum", "set", "first", "construct", "we", "gaussian", "kdtree", "tree", "construction", "must", "process", "-lrb-", "-rrb-", "node", "each", "level", "tree", "do", "-lrb-", "-rrb-", "work", "per", "node", "we", "splitting", "scheme", "balance", "tree", "so", "we", "can", "expect", "depth", "-lrb-", "log", "-rrb-", "tree", "construction", "therefore", "take", "-lrb-", "nd", "log", "-rrb-", "time", "we", "initialize", "leaf", "node", "have", "value", "zero", "do", "gaussian", "query", "sample", "each", "input", "datum", "point", "scatter", "value", "tree", "gaussian", "query", "have", "runtime", "bound", "-lrb-", "-lrb-", "log", "-rrb-", "-rrb-", "so", "stage", "take", "-lrb-", "sn", "-lrb-", "log", "-rrb-", "-rrb-", "time", "next", "we", "blur", "gaussian", "query", "each", "leaf", "node", "which", "gather", "nearby", "value", "cost", "-lrb-", "sm", "-lrb-", "log", "-rrb-", "-rrb-", "finally", "we", "slice", "gaussian", "query", "each", "input", "position", "cost", "-lrb-", "sn", "-lrb-", "log", "-rrb-", "-rrb-", "all", "result", "total", "complexity", "-lrb-", "-lrb-", "-lrb-", "-rrb-", "log", "sd", "-rrb-", "-rrb-", "recall", "sampling", "constant", "-lrb-", "typically", "256", "-rrb-", "result", "simplify", "expression", "-lrb-", "dn", "log", "-rrb-", "give", "earlier", "important", "two", "feature", "bind", "neither", "exponential", "-lrb-", "grid", "technique", "-rrb-", "nor", "quadratic", "-lrb-", "naive", "technique", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "gaussian", "kd-tree", "fast", "High-Dimensional", "Filtering", "21:5", "Figure", "timing", "memory", "use", "difference", "from", "naive", "implementation", "respectively", "various", "implementation", "bilateral", "filter", "all", "filter", "be", "run", "10", "megapixel", "image", "use", "color", "space", "standard", "deviation", "first", "graph", "show", "run", "time", "naive", "implementation", "grow", "large", "filter", "size", "grow", "its", "run", "time", "proportional", "filter", "size", "square", "run", "time", "bilateral", "grid", "-lrb-", "its", "memory", "use", "-rrb-", "grow", "large", "filter", "size", "shrink", "both", "inversely", "proportional", "filter", "size", "square", "gaussian", "kd-tree", "have", "run", "time", "independent", "filter", "size", "third", "graph", "show", "3d", "bilateral", "grid", "do", "compute", "color", "bilateral", "filter", "gaussian", "kd-tree", "compute", "something", "similar", "exactly", "same", "-lrb-", "describe", "below", "-rrb-", "5d", "bilateral", "grid", "almost", "exactly", "compute", "color", "bilateral", "filter", "2.4", "GPU", "Implementation", "once", "tree", "build", "all", "stage", "we", "algorithm", "data-parallel", "across", "query", "mind", "we", "implement", "algorithm", "CUDA", "-lsb-", "Buck", "2007", "-rsb-", "run", "NVIDIA", "GeForce", "GTX", "260", "we", "observe", "typical", "speedup", "10x", "over", "we", "single-threaded", "CPU", "implementation", "run", "Intel", "core", "duo", "e6400", "2.13", "GHz", "few", "interesting", "issue", "relate", "run", "algorithm", "GPU", "firstly", "recursion", "query", "method", "algorithm", "possible", "GPU", "which", "have", "function", "call", "stack", "we", "convert", "recursive", "code", "iterative", "code", "store", "argument", "pend", "call", "query", "method", "share", "memory", "each", "thread", "block", "take", "work", "from", "structure", "when", "idle", "work", "represent", "leaf", "node", "thread", "either", "scatter", "memory", "-lrb-", "splat", "-rrb-", "gather", "-lrb-", "blur", "slice", "-rrb-", "use", "atomic", "float", "point", "add", "memory", "either", "case", "work", "represent", "inner", "node", "thread", "walk", "sample", "down", "tree", "until", "reach", "leaf", "node", "diverge", "over", "split", "latter", "case", "thread", "continue", "work", "smaller", "two", "result", "task", "place", "other", "back", "pend", "work", "structure", "although", "each", "thread", "initially", "responsible", "its", "own", "query", "sharing", "pend", "work", "allow", "load", "balancing", "between", "thread", "block", "pend", "work", "structure", "fill", "thread", "revert", "independently", "simulate", "each", "sample", "case", "single", "sample", "algorithm", "become", "tail-recursive", "can", "convert", "iteration", "without", "use", "extra", "space", "secondly", "build", "kd-tree", "GPU", "difficult", "have", "be", "subject", "recent", "research", "-lrb-", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "-rrb-", "stage", "we", "again", "mimic", "recursive", "structure", "CPU", "algorithm", "use", "explicit", "pend", "work", "queue", "store", "global", "graphic", "memory", "we", "algorithm", "build", "tree", "stage", "breadth-first", "manner", "use", "pair", "queue", "contain", "build", "job", "single", "build", "job", "array", "point", "pointer", "parent", "node", "which", "result", "subtree", "should", "attach", "initial", "few", "large", "build", "job", "CPU", "run", "algorithm", "recursively", "use", "GPU", "kernel", "accelerate", "task", "bound", "box", "computation", "sort", "datum", "over", "pivot", "once", "enough", "build", "job", "parallelize", "across", "they", "effectively", "GPU", "take", "over", "each", "stage", "all", "job", "from", "first", "queue", "process", "create", "same", "number", "node", "new", "job", "create", "build", "any", "child", "place", "second", "queue", "between", "stage", "queue", "swap", "we", "parallelize", "build", "job", "over", "thread", "block", "rather", "than", "thread", "treat", "each", "thread", "block", "simd", "unit", "which", "each", "thread", "concern", "itself", "single", "dimension", "final", "phase", "after", "construction", "each", "node", "parallel", "walk", "up", "tree", "root", "calculate", "min", "max", "graphic", "card", "typically", "have", "less", "memory", "than", "host", "system", "so", "may", "able", "fit", "all", "vector", "memory", "tree", "building", "even", "final", "tree", "only", "use", "-lrb-", "md", "-rrb-", "memory", "overcome", "we", "build", "tree", "use", "large", "random", "subset", "datum", "we", "perform", "two-phase", "query", "include", "vector", "be", "initially", "select", "first", "we", "parallelize", "across", "input", "vector", "send", "each", "leaf", "node", "contain", "we", "parallelize", "across", "leaf", "node", "process", "vector", "arrive", "each", "locally", "extend", "tree", "necessary", "initial", "random", "subset", "select", "cover", "space", "well", "we", "typically", "see", "only", "small", "growth", "tree", "datum", "set", "too", "large", "fit", "host", "memory", "we", "can", "pick", "some", "position", "dimension", "large", "extent", "subdivide", "datum", "overlap", "block", "process", "each", "block", "individually", "typically", "dimension", "largest", "extent", "those", "represent", "spatial", "coordinate", "make", "block", "easy", "application", "we", "have", "describe", "high-speed", "low-memory", "way", "compute", "filter", "set", "value", "-lrb-", "equation", "-rrb-", "every", "value", "replace", "weighted", "linear", "combination", "all", "other", "value", "weight", "give", "gaussian", "function", "distance", "between", "arbitrary", "vector", "associate", "each", "value", "very", "general", "method", "which", "we", "now", "apply", "three", "particular", "problem", "each", "which", "have", "be", "solve", "its", "own", "separate", "way", "past", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "21:6", "a.", "Adams", "et", "al.", "Figure", "different", "method", "compute", "bilateral", "filter", "produce", "different", "result", "filter", "have", "spatial", "standard", "deviation", "16", "pixel", "color", "space", "standard", "deviation", "-lrb-", "-rrb-", "com8", "pute", "use", "naive", "algorithm", "-lrb-", "-rrb-", "compute", "use", "5d", "bilateral", "grid", "result", "nearly", "identical", "-lrb-", "-rrb-", "compute", "use", "gaussian", "kd-tree", "artifact", "from", "random", "sampling", "visible", "some", "place", "image", "result", "very", "slightly", "more", "aggressive", "preserve", "edge", "than", "naive", "can", "see", "amplify", "difference", "image", "bottom", "left", "-lrb-", "-rrb-", "compute", "use", "3d", "bilateral", "grid", "work", "perfectly", "uniformly", "brown", "head", "display", "unwanted", "blur", "around", "boxing", "glove", "where", "strong", "chrominance", "boundary", "unwanted", "color", "transfer", "show", "amplify", "difference", "image", "bottom", "right", "3.1", "Bilateral", "image", "filter", "bilateral", "filter", "first", "propose", "work", "-lsb-", "Aurich", "Weule", "1995", "-rsb-", "-lsb-", "Tomasi", "Manduchi", "1998", "-rsb-", "-lsb-", "Smith", "Brady", "1997", "-rsb-", "non-linear", "filter", "replace", "each", "pixel", "value", "weighted", "average", "all", "pixel", "value", "weight", "respect", "distance", "both", "position", "color", "small", "spatial", "extent", "effective", "way", "denoise", "large", "spatial", "extent", "use", "decomposition", "base", "detail", "layer", "-lsb-", "Durand", "Dorsey", "2002", "-rsb-", "accelerate", "filter", "use", "subsample", "conjunction", "piecewise", "linear", "approximation", "spatial", "domain", "-lsb-", "Paris", "Durand", "2006", "-rsb-", "introduce", "idea", "express", "filter", "linear", "filter", "higher", "dimensional", "space", "explicitly", "represent", "filter", "higher", "dimensional", "datum", "structure", "-lsb-", "Chen", "et", "al.", "2007", "-rsb-", "accelerate", "filter", "same", "way", "treat", "three-dimensional", "bilateral", "grid", "also", "apply", "grid", "related", "problem", "-lsb-", "Weiss", "2006", "-rsb-", "take", "different", "approach", "accelerate", "filter", "maintain", "partial", "histogram", "during", "scan", "image", "which", "make", "cheap", "compute", "local", "histogram", "any", "one", "pixel", "fly", "from", "which", "bilateral", "filter", "can", "approximate", "-lsb-", "Eisemann", "Durand", "2004", "-rsb-", "-lsb-", "Petschnigg", "et", "al.", "2004", "-rsb-", "introduce", "idea", "cross", "joint", "bilateral", "filter", "where", "image", "can", "filter", "respect", "color", "distance", "different", "image", "bilateral", "grid", "equivalent", "decouple", "position", "image", "manifold", "volume", "from", "value", "store", "along", "most", "common", "implementation", "bilateral", "filter", "directly", "evaluate", "appropriate", "weighted", "sum", "each", "pixel", "run", "faster", "than", "-lrb-", "-rrb-", "imply", "equation", "only", "consider", "neighbour", "pixel", "within", "some", "small", "number", "spatial", "standard", "deviation", "approach", "fine", "small", "spatial", "standard", "deviation", "run", "time", "scale", "square", "spatial", "standard", "deviation", "thus", "process", "10", "megapixel", "image", "use", "spatial", "standard", "deviation", "more", "than", "16", "pixel", "take", "hour", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "while", "grid-based", "acceleration", "have", "superior", "scale", "filter", "size", "have", "disadvantage", "only", "respect", "distance", "luminance", "rather", "than", "full", "color", "distance", "-lrb-", "figure", "-rrb-", "fortunately", "human", "eye", "more", "sensitive", "luminance", "variation", "than", "chrominance", "variation", "demosaicing", "algorithm", "exploit", "so", "most", "photograph", "full", "resolution", "have", "locally", "constant", "chrominance", "when", "spatial", "standard", "deviation", "small", "enough", "condition", "hold", "large", "enough", "naive", "algorithm", "run", "slowly", "3d", "bilateral", "grid", "perform", "well", "-lrb-", "see", "Figure", "-rrb-", "one", "way", "respect", "full", "color", "distance", "extend", "bilateral", "grid", "five", "dimension", "represent", "two", "spatial", "three", "color", "dimension", "image", "describe", "-lsb-", "Paris", "Durand", "2009", "-rsb-", "we", "implement", "grid", "use", "tent", "filter", "splat", "slice", "Gaussian", "blur", "filter", "width", "design", "so", "combined", "effect", "three", "approximate", "gaussian", "blur", "standard", "deviation", "one", "while", "result", "very", "close", "naive", "bilateral", "filter", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "memory", "usage", "prohibitive", "small", "filter", "size", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "sample", "grid", "place", "proportionally", "filter", "size", "Runtime", "proportional", "total", "size", "grid", "blur", "stage", "must", "process", "every", "grid", "point", "so", "computational", "cost", "also", "prohibitive", "small", "filter", "size", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "furthermore", "run", "time", "memory", "use", "both", "scale", "exponentially", "so", "grid", "generalize", "poorly", "higher", "dimensional", "filter", "gaussian", "kd-tree", "we", "now", "apply", "gaussian", "kd-tree", "describe", "section", "task", "value", "vector", "-lrb-", "homogeneous", "-rrb-", "pixel", "color", "position", "vector", "location", "-lrb-", "-rrb-", "space", "scale", "inverse", "respective", "standard", "deviation", "after", "perform", "some", "exploratory", "experiment", "we", "settle", "32", "16", "sample", "standard", "devation", "11", "11", "11", "splat", "blur", "slice", "respectively", "we", "do", "use", "we", "faster", "GPU", "implementation", "experiment", "so", "we", "can", "provide", "fair", "comparison", "against", "other", "method", "we", "can", "see", "from", "Figure", "-lrb-", "-rrb-", "memory", "use", "initially", "bound", "drop", "gradually", "higher", "spatial", "standard", "deviation", "space", "more", "coarsely", "sample", "timing", "result", "Figure", "-lrb-", "-rrb-", "show", "method", "respect", "color", "distance", "we", "perform", "best", "moderate", "standard", "deviation", "effect", "further", "illustrate", "Figure", "which", "show", "output", "produce", "various", "technique", "Figure", "-lrb-", "-rrb-", "show", "we", "what", "we", "compute", "quite", "bilateral", "filter", "difference", "relate", "sparsity", "we", "sampling", "consider", "bilateral", "filter", "hard", "edge", "between", "black", "region", "white", "region", "all", "sample", "we", "tree", "either", "black", "white", "pixel", "single", "large", "gaussian", "blur", "range-domain", "space", "may", "allow", "some", "energy", "transfer", "between", "two", "slightly", "gray", "either", "side", "boundary", "however", "each", "stage", "we", "algorithm", "represent", "smaller", "blur", "possible", "energy", "cross", "boundary", "during", "any", "stage", "leave", "input", "unchanged", "instead", "be", "line", "gray", "pixel", "along", "boundary", "serve", "step", "stone", "combined", "effect", "three", "stage", "could", "transfer", "energy", "between", "black", "white", "pixel", "via", "those", "gray", "pixel", "we", "version", "bilateral", "filter", "therefore", "respect", "hard", "boundary", "slightly", "more", "than", "soft", "one", "which", "may", "fact", "benefit", "most", "application", "behaviour", "undesirable", "one", "can", "set", "which", "force", "-lrb-", "i.e.", "we", "allocate", "one", "leaf", "node", "per", "input", "pixel", "-rrb-", "set", "so", "full", "blur", "happen", "during", "blur", "stage", "only", "parameter", "typical", "RMS", "difference", "between", "we", "output", "naive", "output", "drop", "0.002", "half", "quantization", "limit", "however", "under", "setting", "more", "sample", "require", "splat", "slice", "reduce", "performance", "conclusion", "graph", "tell", "mixed", "story", "we", "recommend", "use", "naive", "approach", "small", "spatial", "standard", "deviation", "when", "accuracy", "important", "when", "locally-constant", "chrominance", "assumption", "hold", "across", "filter", "size", "desire", "three-dimensional", "bilateral", "grid", "best", "option", "very", "large", "filter", "five", "dimensional", "grid", "superior", "moderate", "filter", "size", "spatial", "standard", "deviation", "between", "two", "ten", "pixel", "gaussian", "kd-tree", "perform", "best", "appear", "tipping", "point", "which", "grid", "method", "comparable", "tree", "we", "scale", "higher", "follow", "section", "we", "begin", "see", "result", "much", "more", "difficult", "obtain", "exist", "method", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "gaussian", "kd-tree", "fast", "High-Dimensional", "Filtering", "21:7", "figure", "non-local", "means", "denoise", "without", "remove", "detail", "-lrb-", "-rrb-", "top", "we", "show", "crop", "noisy", "input", "below", "further", "crop", "portion", "dog?s", "head", "-lrb-", "-rrb-", "same", "crop", "output", "non-local", "means", "implement", "use", "we", "gaussian", "kd-tree", "patch", "reduce", "pca", "25", "dimension", "use", "filter", "standard", "deviation", "patch", "space", "0.2", "spatial", "term", "mix", "dog?s", "head", "far", "away", "grass", "turn", "greenish", "-lrb-", "-rrb-", "next", "we", "add", "spatial", "term", "standard", "deviation", "10", "pixel", "prevent", "mixing", "expand", "patch", "space", "standard", "deviation", "0.3", "produce", "better", "result", "-lrb-", "-rrb-", "finally", "we", "show", "result", "bilateral", "filter", "remove", "equivalent", "amount", "noise", "bilateral", "filter", "produce", "inferior", "result", "non-local", "means", "some", "detail", "have", "be", "lose", "yet", "chrominance", "noise", "remain", "furthermore", "we", "algorithm", "scale", "linearly", "dimension", "non-local", "means", "significantly", "more", "expensive", "compute", "3.2", "image", "denoise", "nonlocal", "Means", "now", "we", "can", "use", "three-dimensional", "color", "distance", "accelerate", "bilateral", "filter", "natural", "ask", "what", "other", "dimension", "we", "could", "add", "position", "vector", "one", "could", "include", "local", "gradient", "well", "output", "any", "set", "local", "filter", "one", "add", "dimension", "position", "way", "become", "more", "specific", "about", "what", "constitute", "good", "match", "between", "two", "pixel", "desirable", "simultaneously", "extend", "spatial", "extent", "filter", "search", "similar", "pixel", "over", "wider", "area", "limit", "expansion", "non-local", "means", "filter", "though", "effective", "filter", "give", "purpose", "may", "lie", "anywhere", "along", "continuum", "between", "bilateral", "non-local", "means", "non-local", "means", "first", "propose", "-lsb-", "Buades", "et", "al.", "2005", "-rsb-", "average", "pixel", "other", "pixel", "whose", "local", "neighborhood", "contain", "similar", "image", "feature", "non-local", "means", "evaluate", "equation", "set", "-lrb-", "homogeneous", "-rrb-", "color", "pixel", "set", "window", "pixel", "value", "around", "pixel", "i.", "non-local", "means", "thus", "very", "effective", "self-similar", "image", "image", "need", "contain", "explicitly", "repeat", "element", "self-similar", "example", "every", "pixel", "along", "straight", "edge", "between", "two", "flat", "region", "have", "similar", "local", "neighborhood", "every", "other", "pixel", "along", "edge", "non-local", "means", "particularly", "effective", "denoise", "without", "remove", "detail", "because", "make", "smoothness", "assumption", "its", "image", "model", "non-local", "means", "however", "intractably", "slow", "its", "basic", "form", "every", "image", "patch", "must", "compare", "every", "other", "patch", "result", "complexity", "-lrb-", "-rrb-", "pixel", "patch", "simplest", "way", "ameliorate", "reduce", "search", "small", "local", "search", "window", "more", "sophisticated", "approach", "-lsb-", "Brox", "et", "al.", "2008", "-rsb-", "have", "focus", "accelerate", "patch", "search", "over", "entire", "domain", "cluster", "patch", "tree", "structure", "various", "kind", "when", "apply", "non-local", "means", "gaussian", "kd-tree", "can", "view", "member", "family", "technique", "discuss", "above", "gridded", "approach", "work", "here", "due", "exponential", "memory", "use", "computational", "complexity", "respect", "dimension", "gaussian", "kd-tree", "can", "use", "accelerate", "non-local", "means", "exactly", "same", "way", "accelerate", "bilateral", "filter", "use", "same", "kd-tree", "implementation", "do", "we", "construct", "position", "vector", "out", "patch", "around", "each", "pixel", "input", "rather", "than", "-lrb-", "-rrb-", "vector", "use", "bilateral", "filter", "patch", "large", "memory", "limit", "may", "difficult", "explicitly", "construct", "store", "all", "they", "can", "instead", "gather", "from", "input", "image", "need", "during", "splat", "slice", "dimensionality", "above", "around", "50", "example", "when", "use", "large", "patch", "gaussian", "kd-tree", "begin", "exhibit", "poor", "sampling", "behavior", "time", "any", "give", "sample", "have", "reach", "leaf", "node", "have", "be", "split", "over", "log", "different", "partition", "log", "many", "dimension", "over", "which", "splitting", "do", "chance", "point", "store", "cell", "be", "close", "query", "point", "become", "low", "ameliorate", "preprocess", "we", "perform", "pca", "over", "set", "patch", "compute", "set", "filter", "best", "capture", "variance", "patch", "pca", "help", "even", "we", "do", "use", "reduce", "dimensionality", "transformation", "decorrelate", "dimension", "order", "they", "from", "most", "least", "variance", "across", "datum", "set", "allow", "kd-tree", "split", "dimension", "largest", "variance", "first", "which", "now", "axis-aligned", "once", "query", "make", "down", "leaf", "node", "dimension", "have", "yet", "be", "split", "over", "those", "lowest", "variation", "over", "datum", "set", "so", "much", "more", "likely", "query", "point", "close", "point", "store", "leaf", "node", "practice", "also", "advantageous", "simply", "drop", "dimension", "small", "eigenvalue", "speed", "up", "algorithm", "without", "noticeably", "change", "result", "very", "noisy", "scene", "-lrb-", "top", "Figure", "-rrb-", "fact", "improve", "result", "slightly", "denoise", "position", "vector", "result", "we", "use", "we", "algorithm", "apply", "non-local", "means", "several", "type", "datum", "Figure", "show", "we", "algorithm", "use", "generate", "comparison", "between", "non-local", "means", "non-local", "means", "spatial", "term", "add", "bilateral", "filter", "Figure", "we", "show", "result", "volume", "datum", "set", "bacterium", "produce", "cryo-electron", "tomography", "-lsb-", "Amat", "et", "al.", "2008", "-rsb-", "volume", "typically", "very", "noisy", "because", "bombard", "specimen", "large", "number", "electron", "tend", "alter", "they", "mean", "few", "electron", "must", "use", "limit", "signal-to-noise", "ratio", "obtainable", "non-local", "means", "able", "robustly", "use", "nearby", "similar", "information", "improve", "image", "easiest", "way", "acquire", "similar", "information", "digital", "camera", "take", "second", "noisy", "photograph", "same", "scene", "entire", "burst", "shot", "property", "make", "nonlocal", "means", "excellent", "denoise", "from", "burst", "unaligned", "shot", "which", "may", "contain", "object", "deform", "change", "appearance", "exist", "method", "denoise", "from", "multiple", "shot", "video", "either", "globally", "align", "average", "-lrb-", "work", "-lsb-", "Telleen", "et", "al.", "2007", "-rsb-", "-lsb-", "Adams", "et", "al.", "2008", "-rsb-", "-rrb-", "search", "explicit", "block", "match", "-lrb-", "-lsb-", "Avanaki", "2006", "-rsb-", "-rrb-", "method", "fairly", "brittle", "more", "robust", "approach", "work", "-lsb-", "Bennett", "McMillan", "2005", "-rsb-", "which", "average", "either", "space", "time", "appropriate", "do", "denoise", "move", "textured", "object", "-lsb-", "Buades", "et", "al.", "2008", "-rsb-", "find", "apply", "non-local", "means", "volume", "produce", "better", "output", "than", "explicit", "search", "match", "block", "pixel", "trajectory", "Figure", "show", "result", "from", "apply", "non-local", "means", "two", "burst", "run", "time", "we", "implementation", "non-local", "means", "typically", "spend", "half", "perform", "patch", "pca", "-lrb-", "which", "implement", "stack", "convolution", "accelerate", "GPU", "-rrb-", "half", "compute", "denoising", "time", "each", "portion", "typically", "under", "one", "minute", "per", "megapixel", "16", "dimension", "regardless", "size", "search", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "21:8", "a.", "Adams", "et", "al.", "Figure", "one", "slice", "input", "-lrb-", "left", "-rrb-", "output", "-lrb-", "right", "-rrb-", "nonlocal", "means", "apply", "500", "500", "240", "volume", "datum", "set", "gather", "use", "cryo-electron", "tomography", "-lsb-", "Amat", "et", "al.", "2008", "-rsb-", "Patches", "be", "voxel", "subvolume", "reduce", "most", "important", "16", "dimension", "pca", "spatial", "standard", "deviation", "10", "pixel", "patch", "space", "standard", "deviation", "0.1", "result", "volume", "easier", "biologist", "analyze", "than", "input", "Figure", "denoising", "use", "non-local", "means", "burst", "image", "able", "average", "information", "across", "frame", "without", "compute", "any", "global", "alignment", "optical", "flow", "top", "burst", "16", "shot", "man", "look", "around", "wave", "toy", "denoise", "use", "nonlocal", "means", "21", "21", "patch", "reduce", "16", "dimension", "pca", "spatial", "standard", "deviation", "10", "patch", "standard", "deviation", "0.23", "eighth", "frame", "from", "burst", "before", "after", "denoise", "show", "bottom", "noisy", "burst", "10", "shot", "dog", "walk", "through", "foliage", "fifth", "frame", "show", "enlarged", "deform", "textured", "scene", "typical", "amount", "noise", "from", "point-and-shoot", "camera", "non-local", "means", "perform", "well", "remove", "noise", "-lrb-", "see", "example", "dog?s", "nose", "-rrb-", "although", "remove", "some", "fine", "detail", "fur", "patch", "size", "11", "11", "again", "reduce", "16", "dimension", "spatial", "standard", "deviation", "30", "patch", "standard", "deviation", "0.1", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "gaussian", "kd-tree", "fast", "High-Dimensional", "Filtering", "21:9", "Figure", "10", "non-local", "means", "geometry", "smoothing", "leave", "dragon", "model", "corrupt", "gaussian", "noise", "1/2", "mean", "edge", "length", "middle", "smooth", "base", "layer", "produce", "laplacian", "smoothing", "noisy", "mesh", "Right", "non-local", "means", "result", "mesh", "contain", "300k", "vertex", "take", "under", "minute", "perform", "denoising", "3.3", "Geometry", "Filtering", "Due", "success", "3d", "range", "acquisition", "technique", "denoising", "mesh", "point", "cloud", "active", "research", "area", "geometry", "processing", "goal", "same", "image", "denoising", "remove", "noise", "while", "best", "preserve", "underlying", "signal", "which", "case", "come", "set", "3d", "point", "-lrb-", "potentially", "mesh", "connectivity", "-rrb-", "sample", "from", "some", "surface", "isotropic", "geometry", "denoising", "method", "-lsb-", "Taubin", "1995", "-rsb-", "perform", "same", "amount", "smooth", "irrespective", "whether", "sharp", "feature", "edge", "corner", "present", "input", "which", "result", "feature", "appear", "rounded-off", "result", "recently", "several", "approach", "feature-preserving", "denoising", "have", "be", "propose", "base", "geometry", "diffusion", "-lsb-", "desbrun", "et", "al.", "1999", "-rsb-", "projection", "-lsb-", "Fleischman", "et", "al.", "2005", "-rsb-", "bilateral", "filter", "-lsb-", "Jones", "et", "al.", "2003", "-rsb-", "-lsb-", "Fleishman", "et", "al.", "2003", "-rsb-", "its", "extension", "non-local", "means", "-lsb-", "Yoshizawa", "et", "al.", "2006", "-rsb-", "section", "we", "show", "since", "gaussian", "kd-tree", "do", "place", "any", "structural", "constraint", "input", "datum", "can", "use", "filter", "geometry", "refer", "once", "again", "equation", "which", "state", "produce", "output", "value", "point", "generalize", "bilateral", "filter", "average", "together", "set", "value", "weight", "gaussian", "function", "distance", "between", "each", "point", "main", "difficulty", "adapt", "bilateral", "filter", "framework", "from", "image", "domain", "3d", "geometry", "general", "we", "input", "set", "3d", "point", "coordinate", "-lrb-", "-rrb-", "describe", "surface", "which", "do", "come", "parameterize", "over", "some", "regularly", "sample", "domain", "therefore", "unlike", "image", "natural", "decomposition", "input", "position", "-lrb-", "-rrb-", "value", "-lrb-", "-rrb-", "require", "equation", "two", "approach", "decompose", "set", "3d", "point", "spatial", "signal", "domain", "bilateral", "filter", "mesh", "have", "be", "propose", "recently", "-lsb-", "Jones", "et", "al.", "2003", "-rsb-", "compute", "filter", "coordinate", "each", "mesh", "vertex", "weighted", "sum", "its", "projection", "onto", "mesh", "face", "within", "point?s", "neighborhood", "case", "position", "equation", "centroid", "neighbor", "triangle", "value", "projection", "alternative", "method", "propose", "-lsb-", "Fleishman", "et", "al.", "2003", "-rsb-", "which", "use", "tangent", "plane", "each", "vertex", "build", "local", "parametrization", "geometry", "each", "neighbor", "vertex", "projection", "onto", "tangent", "plane", "come", "position", "height", "above", "tangent", "plane", "become", "value", "filter", "vertex", "move", "along", "its", "normal", "average", "height", "compute", "bilateral", "filter", "approach", "-lsb-", "Fleishman", "et", "al.", "2003", "-rsb-", "have", "be", "extend", "non-local", "means", "-lsb-", "Yoshizawa", "et", "al.", "2006", "-rsb-", "add", "geometric", "descriptor", "each", "vertex", "mesh", "above", "approach", "solve", "problem", "separate", "3d", "point", "coordinate", "spatial", "datum", "component", "represent", "neighbor", "each", "vertex", "its", "own", "local", "coordinate", "system", "however", "two", "problem", "use", "decomposition", "-lsb-", "Jones", "et", "al.", "2003", "-rsb-", "-lsb-", "Fleishman", "et", "al.", "2003", "-rsb-", "equation", "first", "since", "local", "projection", "use", "each", "value", "sum", "produce", "output", "value", "depend", "both", "coordinate", "vertex", "vertex", "which", "do", "give", "we", "one-to-one", "mapping", "between", "value", "position", "require", "efficiently", "compute", "blur", "second", "problem", "parameterization", "only", "make", "sense", "locally", "around", "each", "vertex", "since", "use", "tangent", "plane", "approximation", "geometry", "non-local", "means", "denoise", "we", "need", "average", "value", "potentially", "far", "apart", "space", "long", "local", "geometry", "look", "similar", "example", "scale", "front", "back", "dragon", "Figure", "10", "however", "projection", "point", "back", "mesh", "onto", "local", "frame", "point", "front", "can", "very", "far", "away", "from", "especially", "surface", "orientation", "different", "even", "local", "geometry", "similar", "we", "would", "prefer", "global", "notion", "value", "make", "sense", "across", "whole", "mesh", "Computing", "Global", "Positions", "value", "produce", "globally", "meaningful", "value", "we", "can", "average", "across", "all", "point", "mesh", "we", "treat", "feature-preserving", "mesh", "smoothing", "problem", "add", "back", "lose", "detail", "smooth", "base", "layer", "approach", "often", "use", "mesh", "editing", "-lsb-", "sorkine", "et", "al.", "2004", "-rsb-", "where", "smooth", "base", "layer", "use", "produce", "large-scale", "geometric", "deformation", "fine", "detail", "add", "back", "offset", "from", "deform", "geometry", "let", "input", "mesh", "let", "...", "vertex", "position", "vertex", "normal", "compute", "average", "face", "normal", "face", "incident", "vertex", "we", "apply", "laplacian", "smoothing", "produce", "smooth", "base", "layer", "vertex", "position", "normal", "laplacian", "smoothing", "successfully", "remove", "noise", "from", "mesh", "smooth", "across", "sharp", "feature", "difference", "between", "vertex", "coordinate", "give", "we", "noisy", "detail", "layer", "result", "detail", "vector", "translation", "invariant", "however", "still", "dependent", "surface", "orientation", "achieve", "invariance", "rigid", "transformation", "we", "express", "each", "detail", "vector", "principal", "coordinate", "frame", "vertex", "m.", "each", "vertex", "smooth", "base", "layer", "we", "compute", "coordinate", "frame", "-lrb-", "-rrb-", "where", "direction", "minimum", "maximum", "curvature", "vector", "compute", "smooth", "base", "layer", "so", "corrupt", "noise", "final", "offset", "vector", "each", "vertex", "compute", "projection", "principal", "curvature", "frame", "which", "express", "homogeneous", "coordinate", "give", "value", "vector", "each", "vertex", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "21:10", "a.", "Adams", "et", "al.", "Figure", "11", "left", "carve", "box", "model", "corrupt", "gaussian", "noise", "1/4", "mean", "edge", "length", "next", "smooth", "base", "layer", "produce", "laplacian", "smoothing", "next", "output", "non-local", "means", "standard", "deviation", "spin", "image", "space", "0.05", "take", "under", "minute", "denoise", "700k", "vertex", "mesh", "we", "algorithm", "finally", "closeup", "detail", "produce", "non-local", "means", "-lrb-", "top", "-rrb-", "bilateral", "filter", "produce", "equivalent", "smoothness", "-lrb-", "bottom", "-rrb-", "while", "bilateral", "filter", "still", "keep", "some", "edge", "information", "more", "detail", "visible", "non-local", "means", "result", "-lrb-", "-rrb-", "give", "we", "set", "value", "which", "meaningful", "globally", "can", "average", "across", "entire", "input", "use", "regular", "vector", "addition", "second", "component", "non-local", "means", "denoise", "position", "value", "equation", "which", "should", "relate", "some", "measure", "neighborhood", "similarity", "we", "neighborhood", "descriptor", "should", "robust", "noise", "invariant", "rigid", "transformation", "represent", "vector", "we", "use", "well-known", "spin", "image", "descriptor", "-lsb-", "Johnson", "Hebert", "1999", "-rsb-", "which", "orientationinvariant", "histogram", "cylindrical", "coordinate", "point", "within", "give", "neighborhood", "point", "normal", "spin", "value", "-lrb-", "-rrb-", "point", "neighborhood", "define", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "build", "spin", "image", "surface", "patch", "around", "we", "quantize", "pair", "-lrb-", "-rrb-", "set", "bin", "since", "spin", "image", "most", "sensitive", "orientation", "surface", "normal", "we", "use", "normal", "from", "base", "layer", "point", "coordinate", "from", "original", "mesh", "form", "spin", "image", "normal", "robust", "rest", "computation", "relatively", "robust", "noise", "due", "binning", "perform", "compute", "spin", "image", "we", "use", "bin", "value", "10", "bin", "value", "bin", "size", "equal", "sample", "spacing", "mesh", "recommend", "-lsb-", "Johnson", "Hebert", "1999", "-rsb-", "give", "we", "50-dimensional", "position", "vector", "once", "value", "position", "compute", "we", "blur", "use", "gaussian", "kd-tree", "produce", "smooth", "detail", "vector", "which", "add", "back", "offset", "base", "layer", "produce", "final", "denoised", "result", "result", "we", "apply", "we", "non-local", "means", "denoise", "algorithm", "several", "example", "mesh", "corrupt", "gaussian", "noise", "all", "example", "we", "use", "20", "iteration", "laplacian", "smoothing", "produce", "base", "mesh", "smooth", "detail", "layer", "filter", "standard", "deviation", "0.05", "spin", "image", "space", "Figure", "10", "show", "result", "apply", "non-local", "means", "smooth", "dragon", "model", "corrupt", "gaussian", "noise", "denoising", "particularly", "effective", "recover", "self-similar", "area", "mesh", "scale", "back", "ridge", "dragon", "Figure", "11", "we", "apply", "non-local", "means", "noisy", "model", "many", "sharp", "feature", "fine", "detail", "Notice", "we", "able", "maintain", "sharp", "edge", "carving", "box", "well", "recover", "fine", "detail", "petal", "model", "have", "many", "planar", "area", "so", "also", "particularly", "suitable", "algorithm", "-lsb-", "Jones", "et", "al.", "2003", "-rsb-", "which", "use", "local", "planar", "approximation", "right", "Figure", "11", "we", "show", "result", "apply", "bilateral", "smoothing", "produce", "equivalent", "amount", "noise", "reduction", "flat", "area", "while", "bilateral", "smoothing", "preserve", "edge", "better", "than", "laplacian", "smoothing", "use", "produce", "base", "layer", "non-local", "means", "able", "recover", "more", "detail", "petal", "section", "we", "demonstrate", "gaussian", "kd-tree", "can", "use", "non-local", "means", "smoothing", "geometry", "we", "method", "rely", "decompose", "input", "base", "detail", "layer", "decomposition", "have", "also", "be", "address", "context", "mesh", "parameterization", "-lsb-", "Sheffer", "et", "al.", "2006", "-rsb-", "we", "expect", "variety", "parametrization", "decomposition", "approach", "can", "use", "we", "framework", "addition", "investigate", "different", "geometry", "descriptor", "context", "non-local", "means", "denoise", "promising", "area", "future", "work", "finally", "we", "expect", "similar", "method", "can", "apply", "point", "cloud", "denoising", "conclusion", "future", "work", "we", "have", "describe", "novel", "method", "compute", "broad", "class", "non-linear", "filter", "which", "can", "describe", "equation", "base", "weighted", "importance", "sampling", "modify", "kd-tree", "class", "filter", "include", "bilateral", "filter", "joint", "bilateral", "filter", "non-local", "means", "filter", "related", "filter", "which", "value", "average", "other", "value", "consider", "nearby", "some", "high-dimensional", "space", "bilateral", "filter", "we", "compare", "method", "5d", "extension", "bilateral", "grid", "-lsb-", "Paris", "Durand", "2006", "-rsb-", "find", "which", "method", "superior", "depend", "filter", "size", "use", "higher", "dimensional", "filter", "non-local", "means", "we", "tree-based", "filter", "exhibit", "excellent", "performance", "its", "runtime", "memory", "use", "both", "scale", "linearly", "dimension", "we", "method", "require", "particular", "structure", "input", "so", "we", "also", "apply", "task", "denoise", "geometry", "produce", "novel", "non-local", "means", "filter", "mesh", "several", "issue", "remain", "address", "future", "work", "firstly", "we", "tree", "building", "take", "significant", "fraction", "we", "total", "runtime", "so", "we", "use", "very", "simple", "splitting", "scheme", "possible", "more", "sophisticated", "building", "algorithm", "could", "improve", "runtime", "later", "stage", "enough", "justify", "its", "cost", "secondly", "case", "value", "many", "more", "than", "log", "-lrb-", "-rrb-", "dimension", "splitting", "take", "place", "we", "tree", "do", "adequately", "constrain", "sample?s", "location", "before", "reach", "leaf", "many", "sample", "return", "very", "small", "weight", "attach", "work", "we", "solve", "throw", "away", "least", "important", "dimension", "pca", "may", "other", "tree", "structure", "still", "amenable", "weighted", "importance", "sampling", "while", "more", "strongly", "constrain", "sample", "location", "may", "also", "beneficial", "store", "value", "leaf", "cell", "rather", "than", "point", "somewhere", "within", "they", "would", "improve", "complexity", "algorithm", "remove", "distance", "evaluation", "currently", "require", "compute", "correct", "probability", "leaf", "node", "make", "importance", "sampling", "exact", "rather", "than", "weighted", "would", "compute", "different", "function", "value", "one", "far", "more", "dependent", "specific", "way", "which", "tree", "build", "finally", "tree", "traversal", "extremely", "irregular", "algorithm", "speedup", "we", "observe", "from", "we", "GPU", "implementation", "significantly", "less", "than", "theoretically", "possible", "more", "intelligent", "software", "caching", "portion", "tree", "other", "datum", "structure", "may", "speed", "up", "further", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "gaussian", "kd-tree", "fast", "High-Dimensional", "Filtering", "21:11", "acknowledgment", "work", "support", "Reed-Hodgson", "Stanford", "Graduate", "Fellowship", "NDSEG", "Graduate", "Fellowship", "from", "United", "States", "Department", "Defense", "NSF", "Graduate", "Fellowship", "from", "National", "Science", "Foundation", "thanks", "also", "Justin", "Talbot", "Leonidas", "Guibas", "Jeremy", "Sugerman", "fruitful", "discussion", "advice", "Hao", "Li", "provide", "we", "mesh", "datum", "also", "we", "human", "canine", "figure", "subject", "reference", "dam", "a.", "elfand", "N.", "ULLI", "K.", "2008", "Viewfinder", "alignment", "Computer", "Graphics", "Forum", "-lrb-", "Proc", "eurographic", "-rrb-", "27", "597", "606", "mat", "F.", "OUSSAVI", "F.", "OMOLLI", "L.", "LIDAN", "G.", "OWN", "ING", "K.", "OROWITZ", "M.", "2008", "Markov", "random", "field", "base", "automatic", "image", "alignment", "electron", "tomography", "Journal", "Structural", "Biology", "-lrb-", "March", "-rrb-", "260", "275", "rya", "S.", "OUNT", "D.", "ETANYAHU", "N.", "S.", "ilverman", "R.", "a.", "1998", "optimal", "algorithm", "approximate", "nearest", "neighbor", "search", "Journal", "ACM", "45", "URICH", "V.", "EULE", "J.", "1995", "non-linear", "gaussian", "filter", "perform", "edge", "preserving", "diffusion", "mustererkennung", "1995", "17", "DAGM-Symposium", "Springer-Verlag", "London", "UK", "538", "545", "VANAKI", "A.", "N.", "2006", "spatiotemporal", "edge-preserving", "denoising", "method", "high-quality", "video", "signal", "processing", "Information", "Technology", "2006", "IEEE", "International", "Symposium", "-lrb-", "Aug.", "-rrb-", "157", "161", "ekaert", "P.", "BERT", "M.", "ILLEMS", "Y.", "D.", "2000", "weighted", "importance", "sampling", "technique", "monte", "carlo", "radiosity", "Proceedings", "Eurographics", "Workshop", "Rendering", "Techniques", "2000", "Springer-Verlag", "London", "UK", "35", "46", "ennett", "E.", "P.", "ILLAN", "L.", "2005", "Video", "enhancement", "use", "per-pixel", "virtual", "exposure", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "05", "-rrb-", "rox", "T.", "LEINSCHMIDT", "O.", "REMERS", "D.", "2008", "efficient", "nonlocal", "means", "denoising", "textural", "pattern", "image", "processing", "IEEE", "transaction", "17", "-lrb-", "July", "-rrb-", "1083", "1092", "uade", "a.", "oll", "B.", "orel", "j.-m", "2005", "non-local", "algorithm", "image", "denoising", "Proc", "cvpr", "05.", "vol", "60", "65", "vol", "uade", "a.", "oll", "B.", "orel", "j.-m", "2008", "nonlocal", "image", "movie", "denoising", "International", "Journal", "Computer", "Vision", "76", "123", "139", "uck", "i.", "2007", "Gpu", "computing", "program", "massively", "parallel", "processor", "CGO", "07", "Proceedings", "International", "Symposium", "Code", "Generation", "Optimization", "IEEE", "Computer", "Society", "Washington", "DC", "USA", "17", "hen", "J.", "ari", "S.", "URAND", "F.", "2007", "real-time", "edgeaware", "image", "processing", "bilateral", "grid", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "07", "-rrb-", "D.B", "ARASH", "2002", "fundamental", "relationship", "between", "bilateral", "filter", "adaptive", "smoothing", "nonlinear", "diffusion", "equation", "IEEE", "transaction", "Pattern", "analysis", "machine", "Intelligence", "24", "844", "847", "esbrun", "m.", "eyer", "m.", "chroder", "P.", "arr", "a.", "1999", "implicit", "fairing", "irregular", "mesh", "use", "diffusion", "curvature", "flow", "Proc", "SIGGRAPH", "99", "urand", "F.", "ORSEY", "J.", "2002", "fast", "bilateral", "filter", "display", "high-dynamic-range", "image", "Proc", "SIGGRAPH", "02", "isemann", "E.", "URAND", "F.", "2004", "flash", "photography", "enhancement", "via", "intrinsic", "relighting", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "04", "-rrb-", "leischman", "S.", "OHEN", "D.", "ILVA", "C.", "2005", "robust", "move", "least-square", "fitting", "sharp", "feature", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "05", "-rrb-", "LEISHMAN", "S.", "RORI", "I.", "ohen", "D.", "2003", "bilateral", "mesh", "denoising", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "03", "-rrb-", "ohnson", "a.", "ebert", "m.", "1999", "use", "spin", "image", "efficient", "object", "recognition", "cluttered", "3d", "scene", "PAMI", "21", "ONES", "T.", "URAND", "F.", "ESBRUN", "M.", "2003", "Nonitertive", "feature-preserving", "mesh", "smoothing", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "03", "-rrb-", "24", "UMAR", "N.", "HANG", "L.", "AYAR", "S.", "K.", "2008", "what", "good", "nearest", "neighbor", "algorithm", "find", "similar", "patch", "image", "Proc", "eccv", "08", "364", "378", "ari", "S.", "URAND", "F.", "2006", "fast", "approximation", "bilateral", "filter", "use", "signal", "processing", "approach", "Proc", "eccv", "06", "ari", "S.", "URAND", "F.", "2009", "fast", "approximation", "bilateral", "filter", "use", "signal", "processing", "approach", "International", "Journal", "Computer", "Vision", "81", "24", "52", "ark", "S.", "W.", "INSEN", "L.", "REYLOS", "O.", "WENS", "J.", "D.", "AMANN", "B.", "2006", "discrete", "sibson", "interpolation", "IEEE", "transaction", "visualization", "computer", "graphic", "12", "-lrb-", "mar.", "apr.", "-rrb-", "243", "253", "etschnigg", "G.", "zeliskus", "R.", "GRAWALA", "M.", "OHEN", "M.", "OPPE", "H.", "oyama", "K.", "2004", "Digital", "photography", "flash", "no-flash", "image", "pair", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "04", "-rrb-", "heffer", "a.", "raun", "E.", "ose", "K.", "2006", "mesh", "Parameterization", "method", "application", "now", "Publishers", "mith", "S.", "RADY", "J.", "M.", "1997", "Susan", "new", "approach", "low", "level", "image", "processing", "International", "Journal", "Computer", "Vision", "23", "45", "78", "orkine", "O.", "OHEN", "D.", "IPMAN", "Y.", "SSL", "C.", "PETER", "EIDEL", "H.", "LEXA", "M.", "2004", "laplacian", "surface", "editing", "Proc", "sgp", "AUBIN", "G.", "1995", "signal", "processing", "approach", "fair", "surface", "design", "Proc", "SIGGRAPH", "95", "elleen", "J.", "ullivan", "a.", "ee", "J.", "ang", "O.", "UNAWAR", "DANE", "P.", "OLLINS", "I.", "AVIS", "J.", "2007", "synthetic", "shutter", "speed", "imaging", "Computer", "Graphics", "Forum", "-lrb-", "Proc", "eurographic", "-rrb-", "26", "591", "598", "omasus", "C.", "anduchus", "R.", "1998", "bilateral", "filter", "gray", "color", "image", "Proc", "iccv", "98", "839", "EISS", "B.", "2006", "fast", "median", "bilateral", "filter", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "06", "-rrb-", "ang", "C.", "URAISWAMI", "R.", "UMEROV", "N.", "A.", "AVIS", "L.", "2003", "improve", "fast", "gauss", "transform", "efficient", "kernel", "density", "estimation", "Proc", "iccv", "03", "664", "671", "vol", ".1", "oshizawa", "S.", "ELYAEV", "a.", "eidel", "h.-p", "2006", "smooth", "example", "mesh", "denoising", "average", "similarity-based", "weight", "IEEE", "shape", "Modeling", "International", "HOU", "K.", "OU", "Q.", "ang", "R.", "UO", "B.", "2008", "real-time", "kd-tree", "construction", "graphic", "hardware", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "Asia", "08", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009", "21:12", "a.", "Adams", "et", "al.", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "21", "publication", "date", "August", "2009" ],
  "content" : "\n  \n    a4a47bc96d74385241245c68c3a8687c9b86685f5a4cfc13ac6acec3ac565c00\n    owa\n    10.1145/1531326.1531327\n    Name identification was not possible. \n  \n  \n    \n      \n        Gaussian KD-Trees for Fast High-Dimensional Filtering\n      \n      Andrew Adams Natasha Gelfand Stanford University Nokia Research\n      \n        \n        Figure 1: The Gaussian kd-tree accelerates a broad class of non-linear filters, including the bilateral (left), non-local means (middle), and a novel non-local means for geometry (right).\n      \n      We propose a method for accelerating a broad class of non-linear filters that includes the bilateral, non-local means, and other related filters. These filters can all be expressed in a similar way: First, assign each value to be filtered a position in some vector space. Then, replace every value with a weighted linear combination of all values, with weights determined by a Gaussian function of distance between the positions. If the values are pixel colors and the positions are (x, y) coordinates, this describes a Gaussian blur. If the positions are instead (x, y, r, g, b) coordinates in a five-dimensional space-color volume, this describes a bilateral filter. If we instead set the positions to local patches of color around the associated pixel, this describes non-local means. We describe a Monte-Carlo kdtree sampling algorithm that efficiently computes any filter that can be expressed in this way, along with a GPU implementation of this technique. We use this algorithm to implement an accelerated bilateral filter that respects full 3D color distance; accelerated non-local means on single images, volumes, and unaligned bursts of images for denoising; and a fast adaptation of non-local means to geometry. If we have n values to filter, and each is assigned a position in a d-dimensional space, then our space complexity is O(dn) and our time complexity is O(dn log n), whereas existing methods are typically either exponential in d or quadratic in n. CR Categories: I.4.3 [Image Processing and Computer Vision]: Enhancement?Filtering I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling?Geometric algorithms, languages, and systems Keywords: bilateral filter, non-local means, geometry filtering,\n      denoising ACM Reference Format Adams, A., Gelfand, N., Dolson, J., Levoy, M. 2009. Gaussian KD-Trees for Fast High-Dimensional Filtering. ACM Trans. Graph. 28, 3, Article 21 (August 2009), 12 pages. DOI = 10.1145/1531326.1531327 http://doi.acm.org/10.1145/1531326.1531327. Copyright Notice Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the fi rst page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2009 ACM 0730-0301/2009/03-ART21 $10.00 DOI 10.1145/1531326.1531327 http://doi.acm.org/10.1145/1531326.1531327\n      Jennifer Dolson Marc Levoy Stanford University Stanford University\n    \n    \n      \n        1 Introduction\n      \n      In recent years, a variety of related non-linear filters have become important for various tasks in image processing, computational photography, geometry processing, and related fields. These include the bilateral filter, the non-local means filter, and various similar ad-hoc filters used for particular applications. Such filters are often highly computationally intensive. We present a framework with which to understand such filters, and an acceleration data structure and algorithm that applies broadly across all of them.  Let us begin with the simple case of a bilateral filter. Recent methods for accelerating the bilateral filter respect distance in space and in luminance. One such method, the bilateral grid [Paris and Durand 2006], does this by embedding the image as a two dimensional manifold in a coarsely voxelized three dimensional spaceluminance volume, performing a 3D Gaussian blur, and then sampling again along the image manifold to construct the output. A shortcoming of this technique, as well as other recent accelerations of the bilateral filter by [Durand and Dorsey 2002] and [Weiss 2006], is that they do not respect distance in chrominance, resulting in unwanted blurring of neighbouring isoluminant regions (Figure 2). One way to address this problem is to expand the bilateral grid to a 5D space-color volume, as described in [Paris and Durand 2009]. However, as we argue in Section 3.1, the memory required to represent the grid grows exponentially with the number of dimensions, as does the time required by each stage of the algorithm. This growth is manageable if the filter size in both space and color is large, which in turn permits the grid to be coarse. However, if the filter is small the grid must be fine, making the memory and time requirements of this approach impractical. Bilateral filtering can alternatively be rephrased as a nearest neighbour search in five dimensions. For every (x, y, r, g, b) point in the image, we would like to gather colors from other nearby points. This suggests storing the cloud of points representing the image manifold in a kd-tree, and using approximate nearest neighbour queries (as described by [Arya et al. 1998]) to find nearby values. Unfortunately this approach scales poorly with filter size. For a large filter each pixel may be near to every other pixel. It would be preferable to subsample this set of neighbours in a statistically efficient manner. To facilitate such queries, we propose a new type of kd-tree, which we term a Gaussian kd-tree, described in Section 2. The tree sparsely represents the high-dimensional space as values stored at points. This point cloud is derived from a reduced set of the pixels from the original image, so unlike the bilateral grid, we only ever store a 2D manifold, regardless of the size and dimensionality of the space in which it is embedded. The tree supports rapid MonteCarlo-sampled queries to probabilistically scatter to or gather from the points, using stratified weighted importance sampling. These queries are used to implement the embedding, blurring, and sampling of the space as described in Section 2, and they do so at a computational complexity independent of the filter size and linear in the dimensionality. Since the Gaussian kd-tree scales well with dimension, we need not constrain ourselves to three-dimensional color distances. With the ability to cheaply perform blurs weighted by higher dimensional distances, we can also accelerate non-local means [Buades et al. 2005]. Non-local means mixes pixel values with other pixels that have similar local neighborhoods, and is equivalent to a Gaussian blur on a 2D manifold embedded in a space of much higher dimensionality. Non-local means is usually made tractable by limiting it to only search for similar neighborhoods in a small local search window around each pixel. Our method is in fact slightly faster when the search is completely unbounded, as there are fewer dimensions to consider. We discuss non-local means in detail in Section 3.2. While non-local means increases the number of range dimensions, we can also increase the number of domain dimensions to include time. In Section 3.2, we demonstrate fast non-local means for denoising space-time volumes. Non-local means is able to denoise dynamic scenes by averaging pixel values over time without requiring an explicit motion model. Finally, the Gaussian kd-tree does not require any particular ordering or structure to the values it stores. The values need not lie on a grid, and we can mix them according to distances between any set of associated vectors we like. We therefore need not restrict ourselves to images. In Section 3.3 we apply non-local means to noisy geometry. Our tree construction and Gaussian query algorithms are dataparallel, and so we have also implemented them on a graphics card using CUDA [Buck 2007] for a significant speedup over the CPU implementation. Implementation details are in Section 2.4.\n      ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n      \n        \n        \n      \n      21:2 ? A. Adams et al.\n      \n        \n        Figure 2: Bilateral filtering respecting only distance in luminance produces objectionable artifacts. On the left is a bilateral-filtered image of some roof tiles against sky respecting distance in luminance only. Note the bleeding of the blue sky into the similarly bright roof tiles (inset). On the right is the image filtered using full 3D color distance.\n      \n      Input Filtered Output\n      \n        \n        \n        \n        \n        \n      \n      Range Range Range Domain Splat Domain Blur Domain Slice\n      \n        Figure 3: Filtering that respects distance in both domain and range can be done by embedding the input signal in a higher dimensional domain-range space (splatting), performing a Gaussian filter in that space (blurring), and finally sampling the space along the original embedded manifold (slicing). Color bilateral filtering requires a five dimensional space, with range dimensions r, g, b, and domain dimensions x and y. Non-local means is conceptually the same, but requires many more range dimensions. We represent the high-dimensional space sparsely using points stored in a Gaussian kd-tree (see Figure 4 ).\n      \n      \n        2 The Gaussian KD-Tree\n        Filtering is most generally described by replacing each value v i in a set of size n with a linear combination of all other values v j :\n        \n          1\n          n v i = w ij ? v j j=1\n        \n        We assume that values are represented by homogeneous coordinates, and the homogeneous coordinate is filtered along with the others. This makes the usual division by the sum of the weights unnecessary. Weights w ij are commonly computed by associating each value v i with a position p i in some other space, with the weight then given by a function of distance between the two positions: n\n        \n          2\n          v i = f (|p i ? p j |) ? v j j=1\n        \n        For example, when performing a Gaussian blur on an image, values are pixel colors, and have (x, y) coordinates associated with them (p i = (x i , y i ) T ). The weights are given by a Gaussian function of the distance between two such positions, with standard devation ?: n\n        \n          3\n          v i = e ?|p i ?p j | 2 /2? 2 ? v j j=1\n        \n        When performing a bilateral filter, that weight is further reduced by a Gaussian function of distance in color space, with spatial standard devation ? p and color space standard deviation ? c : n\n        \n          4\n          v i = e ?|p i ?p j | 2 /2? p 2 ? e ?|v i ?v j | 2 /2? c 2 ? v j j=1\n        \n        A joint bilateral filter (described by [Eisemann and Durand 2004] and [Petschnigg et al. 2004]) instead uses color distance from some other image. By extending p i and p j to include the color distance term, Equation 4 can be more generally expressed as: n\n        \n          5\n          v i = e ?|p i ?p j | 2 /2 ? v j j=1\n        \n        In this formulation, first proposed by [D.Barash 2002], pixel values v i are now associated with positions p i in a five-dimensional  space whose axes are (x, y, r, g, b), scaled by the inverse of the standard deviations of the filter in the respective dimensions. We are free to scale the positions arbitrarily, so without loss of generality our Gaussian kernel always has standard deviation of one (? is absent in Equation 5). We can transform it to an arbitrary elliptical ball with a linear transform of the position vectors. Non-local means (described by [Buades et al. 2005]), which averages pixels with others that have a similar local neighborhood, can also be expressed as Equation 5 with p i equal to a neighborhood around pixel i. Non-local means can also be adapted to geometry using a similar formulation (Section 3.3). Given an arbitrary set of (v i , p i ) of size n, with p i of dimension d, and v i of lesser dimension, a naive computation of Equation 5 would take O(n 2 d) time, as every value interacts with every other value (for example when blurring an image with a filter as large as the image). Equation 5 is a type of discrete Gauss transform, which can be accelerated using the Improved Fast Gauss Transform of [Yang et al. 2003]. The Improved Fast Gauss Transform groups vectors p i into clusters of radius proportional to the standard deviation of the desired Gaussian, and computes Taylor series approximations of the result at each cluster center. It is an effective tool for very large radius blurs, as few clusters are needed. Unfortunately the standard deviations commonly used in filtering are small enough that there are few data points per cluster, and little benefit is derived from the clustering. We find that when applied to bilateral filtering, the Improved Fast Gauss Transform is in fact slower than a naive filter implementation for typical parameter settings. We instead accelerate computation of Equation 5 in three ways. Firstly, interactions further than three standard deviations apart can be safely ignored (as the weights become very small) making this a collision detection problem for spheres in d-dimensional space. This suggests placing the points in a kd-tree (or a grid if d is small). Details of our tree construction are in Section 2.1. Secondly, Equation 5 replaces each value with a sum over many values. This sum can be importance sampled to avoid having to consider every interaction between v i and some v j . Details of this are in Section 2.2. Thirdly, Gaussian filtering can be accelerated by computing the filter at a lower resolution and then interpolating the result. We con- struct a reduced set with only m positions and values, downsample to it using a Gaussian kernel of size ? s , blur the smaller set with a Gaussian filter of size ? b , then upsample to the original positions with a Gaussian kernel of size ? s . As long as our m points sample the space densely enough, this will be equivalent to a single Gaussian blur of size 2? s 2 + ? b 2 . We consider the sampling dense enough when the maximum spacing between data points in the reduced space is ? s . In the work of [Chen et al. 2007], these three stages are termed grid construction, low pass filtering, and slicing. We refer to them as splatting, blurring, and slicing ( Figure 3 ). We typically set ? b = 3? s , and scale ? b and ? s so that their combined effect is equivalent to a Gaussian blur of standard deviation one. If memory use is a concern, we can omit the blurring stage and achieve the same effective filter by increasing ? s . This allows for more coarsely spaced points, but increases the number of samples required during the Monte-Carlo splatting and slicing. We derive our reduced set of size m during tree building, described below.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        Gaussian KD-Trees for Fast High-Dimensional Filtering ? 21:3\n        \n          \n          Figure 4: We show a comparison of the bilateral grid of [Paris and Durand 2006] to our Gaussian kd-tree. Regardless of the signal (in orange), the bilateral grid stores samples on a regular grid (the blue points). The number of samples grows exponentially with dimension. The Gaussian kd-tree only stores samples along the signal, which in the case of a bilateral filter of a color image is a 2D manifold in a 5D space-color volume. We place these samples at the centroids of the bounding boxes (in light blue) of the pixels that lie within each leaf node (outlined in gray). Filtering is done by scattering pixel values onto nearby samples (splatting), gathering at each sample from nearby samples (blurring), and then gathering at each pixel from nearby samples to construct the output (slicing). Each of these stages operates using an importance-sampled query of the tree. Such a query simulates sending a number of samples, distributed in a Gaussian cloud (shown in green) around the query point down to the leaves of the tree, so that the probability of a sample arriving at a particular leaf is proportional to the integral of the Gaussian over that leaf. The effective standard deviation of the entire blur is the square root of the sum of the squares of the standard deviations of the Gaussian clouds associated with each stage.\n        \n      \n      \n        2.1 Building the tree\n        Our Gaussian kd-tree stores a cloud of m points in d dimensions, one point per leaf, and is designed to allow for fast importancesampled queries of these points (Section 2.2). Each inner node of the tree ? represents a d-dimensional rectangular cell, which may extend to infinity in one or more dimensions. An inner node stores a dimension ? d along which it cuts, and value ? cut on that dimension to cut along, the bounds of the node in that dimension ? min and ? max , and pointers to its children ? lef t and ? right . Leaf nodes contain only a d dimensional point, which lies somewhere within the cell they represent. The key difference between this tree and a conventional kd-tree is that we store ? max and ? min as well as ? cut . The maximum bound is computed as the minimum cut value of all ancestors which cut along the same dimension and have a larger cut value. The minimum bound is similarly the maximum cut value of all ancestors which cut along the same dimension and have a smaller cut value. See Figure 4 for a comparison of the tree to a bilateral grid. We are now faced with the task of building a Gaussian kd-tree containing a point cloud (the blue points in Figure 4 ) with adequate density around the regions where we intend to sample. Fortunately we know ahead of time that we will only ever sample at the positions used to construct the tree. For example when bilateral filtering, we will construct the tree using the (x, y, r, g, b) values of every pixel, and then scatter from and gather to those locations in five-dimensional space. Therefore, we can ensure adequate density by guarantee that every position p i is within ? s /2 of a point stored at a leaf node. The goal when building a kd-tree is usually to minimize the expected time taken by a query. In raytracing, for example, this means it can be advantageous to have a highly unbalanced tree which carves off empty space and commonly hit areas early. However, we never sample in unpopulated areas, so how we deal with empty space is irrelevant, and for typical data each of our leaf nodes is as likely to be reached as any other, so the tree should be balanced. To recursively turn a list of positions p i into a tree, we first compute their bounding box. If the bounding box has diagonal length less than ? s we create a leaf node, and an associated point at the center of the bounding box. Otherwise, we split halfway along the longest bounding box dimension, divide the input list into two, and continue recursively. This scheme descends to cells that have a small diagonal as quickly as possible. Another common scheme for generating balanced trees is to split on the median value along the longest dimension. In our case, an uneven distribution of points, for example those produced from an image which is mostly a single color, can in fact cause this to produce an unbalanced tree. While this has the advantage of placing the most commonly accessed leaves closer to the root of the tree, in practice we found that it did not improve performance.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        21:4 ? A. Adams et al.\n      \n      \n        2.2 Querying the tree\n        A query into our Gaussian tree is designed to facilitate gathers from (or scatters to) values around a given query position, for the purpose of computing an importance-sampled approximation of Equation 5. Figure 4 illustrates the process. A query takes as input a query position q in the space, a standard deviation ? around that position, and a number of samples s, and returns a list of at most s points p i and corresponding weights w i . If the number of samples is set to infinity, the list returned will include all points within three standard deviations of the query, with weights proportional to a Gaussian kernel of the given standard deviation (w i = e ?|q?p i | 2 /2? ). If the number of samples is set to one, the list will contain a single leaf node, probabilistically chosen from all leaf nodes within three standard deviations of the query, such that repeatedly asking for a single sample and merging the resulting lists will produce the same result in the limit as asking for an infinite number of samples from a single query. We can think of our samples as a cloud of points normally distributed around the query with the given standard deviation, although we do not explicitly represent them as such. At each inner node ? we compute the expected number of samples that lie within the left and right child by computing the area of the Gaussian, truncated to with ? min and ? max , that lies on either side of ? cut . The Gaussian is separable, so decisions already made by nodes that split in other dimensions are irrelevant. The expected number of samples that split each way are rounded down to the nearest integer, and that many samples are assigned to the left or right child respectively. The final sample omitted by the rounding, if there is one, is probabilistically assigned to either the left or the right child. This splitting scheme saves work compared to individually simulating every sample, resulting in a runtime which is sublinear in the number of samples, and bounded by the number of cells overlap-\n        \n        ping a query. It also stratifies the sampling, resulting in less noise in the output for a fixed number of samples. We arrive at a given leaf node with a probability proportional to the integral of the Gaussian over the corresponding cell. This is not the correct weight, however, as our tree stores values at points, not cells. To correct for this, we keep track of the (unrounded) expected number of samples to reach this leaf, compute the probability with which we should have reached this point by evaluating the Gaussian at it, and return a weight which is the latter divided by the former. This is weighted importance sampling, as described by [Bekaert et al. 2000] in the context of radiosity. This correction allows us to use a piecewise quadratic approximation to the Gaussian (given by the convolution of three identical rect filters) while descending the tree, as its integral is easier to compute than that of a Gaussian. See Algorithm 1 for the relevant snippets of C++ code.\n      \n      \n        2.3 Complexity Analysis\n        Recall that we start with n d-dimensional data points, reduced to m during tree building, and that we use s samples when querying the tree. We filter the data set by first constructing our Gaussian kdtree. Tree construction must process O(n) nodes at each level of the tree, doing O(d) work per node. Our splitting scheme balances  the tree, so we can expect a depth of O(log m). Tree construction therefore takes O(nd log m) time. We then initialize the leaf nodes to have a value of zero, and do a Gaussian query with s samples for each of the n input data points to scatter values into the tree. A Gaussian query has a runtime bounded by O(s(log m + d)), so this stage takes O(sn(log m + d)) time. Next we blur with a Gaussian query at each leaf node which gathers nearby values, and costs O(sm(log m + d)), and finally we slice with a Gaussian query at each input position for a cost of O(sn(log m + d)). This all results in a total complexity of O(n((s + d) log m + sd)). Recall that m < n and s is a sampling constant (typically 4 ? s ? 256). This results in the simplified expression O(dn log n) given earlier. The important two features of this bound are that it is neither exponential in d (as are grid techniques) nor is it quadratic in n (as is the naive technique).\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        Gaussian KD-Trees for Fast High-Dimensional Filtering ? 21:5\n        \n          \n          Figure 5: Timing, memory use, and difference from a naive implementation respectively for the various implementations of the bilateral filter. All filters were run on a 10 megapixel image using a color space standard deviation of 1 . The first graph shows that the running time of 8 the naive implementation grows large as the filter size grows, as its run time is proportional to the filter size squared. The running time of the bilateral grid (and its memory use) grow large as the filter size shrinks, as both are inversely proportional to the filter size squared. The Gaussian kd-tree has running time independent of filter size. The third graph shows that the 3D bilateral grid does not compute the color bilateral filter, the Gaussian kd-tree computes something similar but not exactly the same (described below), and the 5D bilateral grid almost exactly computes the color bilateral filter.\n        \n      \n      \n        2.4 GPU Implementation\n        Once the tree is built, all stages of our algorithm are data-parallel across queries. With this in mind we implemented the algorithm in CUDA [Buck 2007] and ran it on an NVIDIA GeForce GTX 260. We observed a typical speedup of 10x over our single-threaded CPU implementation running on an Intel Core 2 Duo E6400 at 2.13 GHz. There are a few interesting issues related to running the algorithm on the GPU. Firstly, the recursion of the query method in Algorithm 1 is not possible on the GPU, which has no function call stack. We convert the recursive code to iterative code by storing the arguments to pending calls to the query method in shared memory. Each thread in a block takes work from this structure when idle. If the work represents a leaf node, the thread either scatters to memory (for splatting), or gathers (for blurring or slicing), using atomic floating point adds to memory in either case. If the work represents an inner node the thread walks the samples down the tree until they reach a leaf node or diverge over a split. In the latter case, the thread continues working on the smaller of the two resulting tasks, and places the other back into the pending work structure. Although each thread is initially responsible for its own query, the sharing of pending work allows for load balancing between the threads in a block. If the pending work structure fills, threads revert to independently simulating each sample. For the case of a single sample, Algorithm 1 becomes tail-recursive, and can be converted to iteration without using extra space.  Secondly, building a kd-tree on the GPU is difficult, and has been the subject of recent research (such as [Zhou et al. 2008]). For this stage we again mimic the recursive structure of the CPU algorithm, using explicit pending work queues stored in global graphics memory. Our algorithm builds the tree in stages in a breadth-first manner using a pair of queues containing build jobs. A single build job is an array of points and a pointer to a parent node to which the resulting subtree should be attached. For the initial few large build jobs, the CPU runs the algorithm recursively, using GPU kernels to accelerate the tasks of bounding box computation and sorting data over a pivot. Once there are enough build jobs to parallelize across them effectively, the GPU takes over. In each stage all the jobs from the first queue are processed, creating the same number of nodes, and the new jobs created to build any children are placed on the second queue. In between stages the queues are swapped. We parallelize build jobs over thread blocks rather than threads, treating each thread block as a SIMD unit, in which each thread concerns itself with a single dimension. In a final phase after construction, each node ? in parallel walks up the tree to the root to calculate ? min and ? max . The graphics card typically has less memory than the host system, so it may not be able to fit all n vectors in memory for tree building, even if the final tree only uses O(md) memory. To overcome this, we build the tree using a large random subset of the data. We then perform a two-phase query to include the vectors that were not initially selected. First we parallelize across input vectors and send each to the leaf node that contains it. Then we parallelize across leaf nodes, and process the vectors that arrived at each to locally extend the tree if necessary. If the initial random subset selected covers the space well, we will typically see only a small growth of the tree. If the data set is too large to fit into host memory, we can pick some of the position dimensions with large extent and subdivide the data into overlapping blocks, processing each block individually. Typically the dimensions with largest extent will be those representing spatial coordinates, making blocking easy.\n      \n      \n        3 Applications\n        We have described a high-speed, low-memory way to compute a filtering of a set of values (Equation 5), such that every value is replaced with a weighted linear combination of all other values, with  the weights given by a Gaussian function of the distance between arbitrary vectors associated with each value. This is a very general method, which we will now apply to three particular problems, each of which has been solved in its own separate way in the past.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        21:6 ? A. Adams et al.\n        \n          \n          Figure 6: Different methods of computing the bilateral filter produce different results. This filter had a spatial standard deviation of 16 pixels and a color space standard deviation of 1 . (a) Com8 puted using the naive algorithm. (b) Computed using a 5D bilateral grid. The result is nearly identical. (c) Computed using a Gaussian kd-tree. Artifacts from the random sampling are visible in some places in the image, and the result is very slightly more aggressive in preserving edges than the naive, as can be seen in the amplified difference image at bottom left. (d) Computed using the 3D bilateral grid. It works perfectly on the uniformly brown head, but displays unwanted blurring around the boxing gloves where there is a strong chrominance boundary. The unwanted color transfer is shown in the amplified difference image on the bottom right.\n        \n      \n      \n        3.1 Bilateral Image Filtering\n        The bilateral filter, first proposed in the work of [Aurich and Weule 1995], [Tomasi and Manduchi 1998], and [Smith and Brady 1997], is a non-linear filter that replaces each pixel value with a weighted average of all pixel values, with weights respecting distance in both position and color. With small spatial extent it is an effective way to denoise, and with large spatial extent it is used for decomposition into base and detail layers. [Durand and Dorsey 2002] accelerated  the filter by using subsampling in conjunction with piecewise linear approximation in the spatial domain. [Paris and Durand 2006] then introduced the idea of expressing the filter as a linear filter in a higher dimensional space, by explicitly representing the filter in a higher dimensional data structure. [Chen et al. 2007] accelerates the filter in the same way by treating it as a three-dimensional bilateral grid, and also applies that grid to related problems. [Weiss 2006] takes a different approach, and accelerates the filter by maintaining partial histograms during a scan of the image, which makes it cheap to compute a local histogram at any one pixel on the fly, from which a bilateral filter can be approximated. [Eisemann and Durand 2004] and [Petschnigg et al. 2004] introduced the idea of the cross or joint bilateral filter, where an image can be filtered with respect to color distances in a different image. In the bilateral grid, this is equivalent to decoupling the position of the image manifold in the volume from the values stored along it. The most common implementation of a bilateral filter directly evaluates the appropriate weighted sum at each pixel. It runs faster than the O(n 2 ) implied by Equation 5 by only considering neighbouring pixels within some small number of spatial standard deviations. This approach is fine for small spatial standard deviations, but running time scales with the square of the spatial standard deviation; thus, processing a 10 megapixel image using a spatial standard deviation of more than 16 pixels takes hours ( Figure 5(a) ). While the grid-based accelerations have superior scaling with filter size, they have the disadvantage of only respecting distance in luminance, rather than full color distance ( Figure 2 ). Fortunately, human eyes are more sensitive to luminance variation than chrominance variation, and demosaicing algorithms exploit this, so that most photographs at full resolution have locally constant chrominance. When the spatial standard deviation is small enough for this condition to hold, but large enough for a naive algorithm to run slowly, a 3D bilateral grid performs well (see Figure 5 ). One way to respect full color distance is to extend the bilateral grid to five dimensions, representing the two spatial and three color dimensions in an image, as described by [Paris and Durand 2009]. We implemented such a grid, using tent filters for splatting and slicing, and a Gaussian for blurring, with filter widths designed so that the combined effect of the three is an approximate Gaussian blur of standard deviation one. While the results are very close to the naive bilateral filter ( Figure 5(c) ), the memory usage is prohibitive for small filter sizes ( Figure 5(b) ), as samples in the grid are placed proportionally to the filter size. Runtime is proportional to the total size of the grid, as the blur stage must process every grid point, and so the computational cost is also prohibitive for small filter sizes ( Figure 5(a) ). Furthermore, running time and memory use both scale exponentially with d, so the grid generalizes poorly to higher dimensional filters. The Gaussian kd-tree We now apply the Gaussian kd-tree described in Section 2 to this task. The value vectors v i are the (homogeneous) pixel colors, and the position vectors p i are their locations in (x, y, r, g, b) space, scaled by the inverse of the respective standard deviations. After performing some exploratory experiments, we ? settled ? on 8, 32, and ? 16 samples with standard devations of 1/ 11, 3/ 11, and 1/ 11, for splatting, blurring, and slicing respectively. We did not use our faster GPU implementation for these experiments, so that we can provide a fair comparison against the other methods. We can see from Figure 5(b) that the memory use is initially bounded, and then drops gradually with higher spatial standard deviations as the space is more coarsely sampled. The timing results in Figure 5(a) show that, of the methods that respect color distance, we perform the best at moderate standard deviations. This effect is further illustrated in Figure 6 , which shows the outputs produced by the various techniques. Figure 5(c) shows us that what we compute is not quite the bilateral filter. The difference is related to the sparsity of our sampling. Consider a bilateral filter of a hard edge between a black region and a white region. All the samples in our tree are either of black or white pixels. A single large Gaussian blur in range-domain space may allow for some energy transfer between the two, slightly graying either side of the boundary. However, each stage of our algorithm represents a smaller blur, and it is possible for no energy to cross the boundary during any stage, leaving the input unchanged. If instead there were a line of gray pixels along the boundary to serve as a stepping stone, then the combined effect of the three stages could transfer energy between black and white pixels via those gray pixels. Our version of the bilateral filter therefore respects hard boundaries slightly more than soft ones, which may in fact be a benefit in most applications. If this behaviour is undesirable, one can set ? s = 0, which forces n = m (i.e. we allocate one leaf node per input pixel), and then set ? b = 1, so that the full blur happens during the blur stage only. With these parameters, the typical RMS difference between our output and the naive output drops to 0.002, or half of the quantization limit. However, under these settings more samples are required for splatting or slicing, reducing performance. Conclusion The graphs tell a mixed story. We recommend using the naive approach for small spatial standard deviations when accuracy is important. When a locally-constant chrominance assumption holds across the filter size desired, the three-dimensional bilateral grid is the best option. For very large filters, the five- dimensional grid is superior. For moderate filter sizes, with spatial standard deviations between two and ten pixels, the Gaussian kd-tree performs the best. d = 5 appears to be a tipping point, at which grid methods are comparable to the tree. As we scale d higher in the following sections, we begin to see results much more difficult to obtain with existing methods.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        Gaussian KD-Trees for Fast High-Dimensional Filtering ? 21:7\n        \n          \n          Figure 7: Non-local means denoises without removing detail. (a) At the top we show a crop of the noisy input. Below it is a further crop of a portion of the dog?s head. (b) The same crops of the output of non-local means, implemented using our Gaussian kd-tree, with 9 ? 9 patches, reduced with PCA to 25 dimensions, using a filter with standard deviation in patch space of 0.2, and no spatial term. It mixes the dog?s head with far away grass, turning it greenish. (c) Next we add a spatial term with standard deviation of 10 pixels to prevent such mixing, and expand the patch space standard deviation to 0.3, producing a better result. (d) Finally, we show the result of a bilateral filter that removes an equivalent amount of noise. The bilateral filter produces an inferior result to non-local means. Some detail has been lost, yet chrominance noise remains. Furthermore, as our algorithm scales linearly with dimension, non-local means is not significantly more expensive to compute.\n        \n      \n      \n        3.2 Image Denoising with Nonlocal Means\n        Now that we can use three-dimensional color distances in an accelerated bilateral filter, it is natural to ask what other dimensions we could add to the position vectors. One could include local gradients as well, or the output of any set of local filters. As one adds dimensions to the position, and in this way becomes more specific about what constitutes a good match between two pixels, it is desirable to simultaneously extend the spatial extent of the filter, to search for similar pixels over a wider area. The limit of this expansion is the non-local means filter, though an effective filter for a given purpose may lie anywhere along the continuum between the bilateral and non-local means.  Non-local means, first proposed by [Buades et al. 2005], averages pixels with other pixels whose local neighborhoods contain similar image features. That is, non-local means evaluates Equation 5 with v i set to the (homogeneous) color of pixel i and p i set to a window of pixel values around pixel i. Non-local means is thus very effective for self-similar images. An image need not contain explicitly repeated elements to be self-similar. For example, every pixel along a straight edge between two flat regions has a similar local neighborhood to every other pixel along that edge. Non-local means is particularly effective at denoising without removing detail because it makes no smoothness assumptions in its image model. Non-local means, however, is intractably slow in its basic form, as every image patch must be compared with every other patch, resulting in a complexity of O(f 2 n 2 ) for n pixels and f ?f patches. The simplest way to ameliorate this is to reduce the search to a small local search window. More sophisticated approaches, such as [Brox et al. 2008] have focused on accelerating the patch search over the entire domain, by clustering the patches in a tree structures of various kinds. When applied to non-local means, the Gaussian kd-tree can be viewed as a member of this family of techniques. As discussed above, gridded approaches will not work here, due to the exponential memory use and computational complexity with respect to dimension. The Gaussian kd-tree can be used to accelerate non-local means in exactly the same way it accelerates bilateral filtering, using the same kd-tree implementation. To do this, we construct the position vectors p i out of patches around each pixel in the input, rather than the (r, g, b, x, y) vectors used for bilateral filtering. If the patches are large and memory is limited it may be difficult to explicitly construct and store all of them, and they can instead be gathered from the input image as needed during splatting and slicing. At dimensionalities above around 50, for example when using large patches, the Gaussian kd-tree begins to exhibit poor sampling behavior. By the time any given sample has reached a leaf node, it has been split over log m different partitions. If d log m there are many dimensions over which no splitting was done, and the chance of the point stored in the cell being close to the query point becomes low. To ameliorate this, as a preprocess we perform PCA over the set of patches to compute a set of filters that best capture the variance in a patch. PCA helps even if we do not use it to reduce dimensionality, as the transformation decorrelates the dimensions, and orders them from most to least variance across the data set. This allows kd-tree to split on dimensions with the largest variance first, which are now axis-aligned. Once a query makes it down to a leaf node, the dimensions that have not yet been split over are those with the lowest variation over the data set, so it is much more likely that the query point is close to the point stored in the leaf node. In practice, it is also advantageous to simply drop the dimensions with small eigenvalues. This speeds up the algorithm without noticeably changing the results. For very noisy scenes (such as the top of Figure 9 ) it in fact improved the results, as it slightly denoises the position vectors. Results We use our algorithm to apply non-local means to several types of data. Figure 7 shows our algorithm used to generate a comparison between non-local means, non-local means with a spatial term added, and bilateral filtering. In Figure 8 we show results on a volume data set of a bacteria produced by cryo-electron tomography by [Amat et al. 2008]. Such volumes are typically very noisy, because bombarding specimens with large numbers of electrons tends to alter them, meaning few electrons must be used, limiting the signal-to-noise ratio obtainable. Non-local means is able to robustly use nearby similar information to improve an image. The easiest way to acquire similar information on a digital camera is to take a second noisy photograph of the same scene, or an entire burst of shots. This property makes nonlocal means excellent for denoising from a burst of unaligned shots, which may contain objects that deform or change their appearance. Existing methods for denoising from multiple shots or videos either globally align and average (such as the work of [Telleen et al. 2007] and [Adams et al. 2008]) or search for explicit block matches (such as [Avanaki 2006]). These methods are fairly brittle. A more robust approach is the work of [Bennett and McMillan 2005] which averages in either space or time, as appropriate, but does not denoise moving textured objects. [Buades et al. 2008] finds that applying non-local means to the volume produces better output than explicit searches for matching blocks or pixel trajectories. Figure 9 shows results from applying non-local means to such two such bursts. The running time for our implementation of non-local means is typically spent half performing the patch PCA (which is implemented as a stack of convolutions accelerated on the GPU), and half computing the denoising. The time for each portion is typically under one minute per megapixel at 16 dimensions, regardless of the size of the search.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        21:8 ? A. Adams et al.\n        \n          \n          Figure 8: One slice of the input (left) and output (right) of nonlocal means applied to a 500 ? 500 ? 240 volume data set gathered using cryo-electron tomography [Amat et al. 2008]. Patches were 5 ? 5 ? 5 voxel subvolumes reduced to the most important 16 dimensions with PCA. The spatial standard deviation was 10 pixels, and the patch space standard deviation was 0.1. The resulting volume is easier for biologists to analyze than the input.\n        \n        \n          \n          Figure 9: Denoising using non-local means on a burst of images is able to average information across frames without computing any global alignment or optical flow. On the top is a burst of 16 shots of a man looking around and waving a toy. This is denoised using nonlocal means with 21 ? 21 patches reduced to 16 dimensions with PCA. The spatial standard deviation was 10 and the patch standard deviation was 0.23. The eighth frame from the burst, before and after denoising, is shown. At the bottom is a noisy burst of 10 shots of a dog walking through foliage, with the fifth frame shown enlarged. This is a deforming textured scene with the typical amount of noise from a point-and-shoot camera. Non-local means performs well at removing the noise (see for example the dog?s nose), although it removes some fine details in the fur. The patch size was 11 ? 11 again reduced to 16 dimensions, the spatial standard deviation was 30 and the patch standard deviation was 0.1.\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        Gaussian KD-Trees for Fast High-Dimensional Filtering ? 21:9\n        \n          \n          Figure 10: Non-local means for geometry smoothing. Left: the dragon model corrupted by Gaussian noise with ? = 1/2 mean edge length Middle: smooth base layer produced by Laplacian smoothing of the noisy mesh; Right: non-local means result. This mesh contains 300K vertices and it took under a minute to perform the denoising.\n        \n      \n      \n        3.3 Geometry Filtering\n        Due to the success of 3D range acquisition techniques, denoising of meshes and point clouds is an active research area in geometry processing. The goal is the same as in image denoising, to remove noise while best preserving the underlying signal, which in this case comes as a set of 3d points (potentially with mesh connectivity) sampled from some surface. Isotropic geometry denoising methods, such as [Taubin 1995], perform the same amount of smoothing irrespective of whether sharp features such as edges and corners are present in the input, which results in these features appearing rounded-off in the result. Recently, several approaches for feature-preserving denoising have been proposed based on geometry diffusion [Desbrun et al. 1999], projections [Fleischman et al. 2005], the bilateral filter [Jones et al. 2003] [Fleishman et al. 2003], and its extension to non-local means [Yoshizawa et al. 2006]. In this section, we will show that, since the Gaussian kd-tree does not place any structural constraints on input data, it can be used for filtering of geometry. Refer once again to Equation 5, which states that to produce an output value v ? i at a point p i , a generalized bilateral filter averages together a set of values v j weighted by a Gaussian function of the distance between p i and each point p j . The main difficulty in adapting this bilateral filtering framework from the image domain to 3d geometry is that, in general, our input is a set of 3d point coordinates (x i , y i , z i ) describing a surface, which does not come parameterized over some regularly sampled domain. Therefore, unlike for images, there is no natural decomposition of the input into positions (p i ?s) and values (v i ?s), as required for Equation 5. Two approaches to decompose a set of 3d points into the spatial and signal domains for bilateral filtering of meshes have been proposed recently. [Jones et al. 2003] computes the filtered coordinates of each mesh vertex as a weighted sum of its projections onto the mesh faces within the point?s neighborhood. In this case, the positions in Equation 5 are the centroids of the neighboring triangles, and the values are the projections. And alternative method was proposed by [Fleishman et al. 2003], which uses tangent planes at each vertex to build a local parametrization of the geometry. For each neighboring vertex, the projection onto the tangent plane be comes the position, and the height above the tangent plane becomes the value. The filtered vertex is then moved along its normal by the averaged height computed by the bilateral filter. The approach of [Fleishman et al. 2003] has been extended to non-local means in [Yoshizawa et al. 2006] by adding a geometric descriptor to each vertex in the mesh. The above approaches solve the problem of separating 3d point coordinates into the spatial and data components by representing the neighbors of each vertex in its own local coordinate system. However, there are two problems in using the decompositions of [Jones et al. 2003] and [Fleishman et al. 2003] in Equation 5. First, since local projections are used, each value v j in the sum to produce the output value v i depends both on coordinates of vertex i and vertex j, which does not give us a one-to-one mapping between values and positions required for efficiently computing the blur. The second problem is that the parameterizations only make sense locally around each vertex since they use tangent plane approximations of the geometry. For non-local means denoising, we need to average values that are potentially far apart in space, as long as the local geometry looks similar, for example the scales on the front and back of the dragon in Figure 10 . However, the projection of a point j on the back of the mesh onto the local frame of a point i on the front can be very far away from i, especially if surface orientation at i and j are different, even if local geometry is similar. We would prefer a global notion of value that makes sense across the whole mesh. Computing Global Positions and Values To produce a globally meaningful value that we can average across all points on the mesh, we will treat feature-preserving mesh smoothing as a problem of adding back lost detail to a smooth base layer. This approach is often used in mesh editing [Sorkine et al. 2004], where a smooth base layer is used to produce large-scale geometric deformations, and fine detail is then added back as offsets from the deformed geometry. Let M be the input mesh, let x i , i = 1 . . . n be the vertex positions, and n i be the vertex normals computed by averaging the face normals for faces incident on vertex i. We apply Laplacian smoothing to M to produce the smooth base layer M  ? with vertex positions x i and normals n i . Laplacian smoothing successfully removes the noise from the mesh, but will smooth across sharp features. The difference between the vertex coordinates of M and M  ? gives us the noisy detail layer, d i = x i ? x i . The resulting detail vectors are translation invariant, however they are still dependent on the surface orientation at x i . To achieve invariance to rigid transformations, we express each detail vector d i in the principal coordinate frame of the vertex i of M.  ? That is, for each vertex on the smoothed base layer, we compute the coordinate frame ( n i , k  ? 1 i , k  ? i 2 ), where k  ? i 1 , k  ? i 2 are the directions of minimum and maximum curvature. These vectors are computed on the smoothed base layer, so they are not corrupted by noise. The final offset vector for each vertex is computed as the projection of d i into the principal curvature frame, which is then expressed in homogeneous coordinates to give the value vector for each vertex:\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        21:10 ? A. Adams et al.\n        \n          \n          Figure 11: On the left is a carved box model corrupted by Gaussian noise with ? = 1/4 mean edge length. Next is the smooth base layer produced by Laplacian smoothing. Next is the output of non-local means with standard deviation in spin image space on 0.05. It took under a minute to denoise this 700K vertex mesh with our algorithm. Finally a closeup of the detail produced by non-local means (top) and a bilateral filter that produces equivalent smoothness (bottom). While the bilateral filter still keeps some edge information, more detail is visible in the non-local means result.\n        \n        \n          6\n          v i = ( d i , n i , d i , k  ? 1 i , d i , k  ? 2 i , 1)\n        \n        This gives us the set of n values v i , which are meaningful globally and can be averaged across the entire input using the regular vector addition. The second component of the non-local means denoising is the position values in Equation 5, which should be related to some measure of neighborhood similarity. Our neighborhood descriptor should be robust to noise, invariant to rigid transformations, and represented as a vector in R n . We use the well-known spin image descriptors [Johnson and Hebert 1999], which are orientationinvariant histograms of cylindrical coordinates of points within a given neighborhood. For a point x i with normal n i , the spin value (?, ?) of a point x j in the neighborhood of x i is defined as:\n        \n          7\n          (?, ?) = ( ||x j ? x i || 2 ? n i , x j ? x i 2 , n i , x j ? x i )\n        \n        To build a spin image of a surface patch around x i , we quantize the pairs (?, ?) into a set of bins. Since the spin images are most sensitive to the orientation of the surface normal, we use the normals n i from the base layer and the point coordinates from the original mesh to form the spin images. If the normals are robust, the rest of the computation is relatively robust to noise due to the binning that is performed to compute the spin image. We use 5 bins for the values of ? and 10 bins for the values of ? with the bin size equal to the sample spacing of the mesh as recommended in [Johnson and Hebert 1999]. This gives us 50-dimensional position vectors p i . Once the values are positions are computed, we blur using the Gaussian kd-tree to produce the smoothed detail vectors, which are then added back as offsets to the base layer to produce the final denoised result.  Results We apply our non-local means denoising algorithm to several examples of meshes corrupted by Gaussian noise. In all examples, we use 20 iterations of Laplacian smoothing to produce the base mesh, and smooth the detail layer with the filter of standard deviation 0.05 in spin image space. Figure 10 shows the results of applying non-local means smoothing to a dragon model corrupted by Gaussian noise. The denoising is particularly effective at recovering self-similar areas of the mesh such as the scales and the back ridge of the dragon. In Figure 11 we apply non-local means to a noisy model with many sharp features and fine detail. Notice that we are able to maintain sharp edges of the carvings on the box, as well as recover the fine detail in the petals. This model has many planar areas, so it is also particularly suitable for the algorithm of [Jones et al. 2003], which uses local planar approximations. On the right of Figure 11 we show the results of applying bilateral smoothing to produce equivalent amount of noise reduction in the flat areas. While bilateral smoothing preserves edges better than Laplacian smoothing used to produce the base layer, non-local means is able to recover more detail in the petals. In this section, we demonstrated that the Gaussian kd-tree can be used for non-local means smoothing of geometry. Our method relies on decomposing the input into a base and a detail layer. Such decompositions have also been addressed in the context of mesh parameterizations [Sheffer et al. 2006], and we expect that a variety of parametrization and decomposition approaches can be used in our framework. In addition, investigating different geometry descriptors in the context of non-local means denoising is a promising area of future work. Finally, we expect that a similar method can be applied to point cloud denoising.\n      \n      \n        4 Conclusion and Future Work\n        We have described a novel method for computing the broad class of non-linear filters which can be described by Equation 5, based on weighted importance sampling of a modified kd-tree. This class of filters includes bilateral filters, joint bilateral filters, non-local means filters, and related filters in which values are averaged with other values that are considered nearby in some high-dimensional space. For bilateral filtering, we compare this method to a 5D extension of the bilateral grid of [Paris and Durand 2006], and find that which method is superior depends on the filter size used. For higher dimensional filters, such as non-local means, our tree-based filter exhibits excellent performance, as its runtime and memory use both scale linearly with dimension. Our method requires no particular structure to the input, so we also apply it to the task of denoising  geometry to produce a novel non-local means filter for meshes. Several issues remain to be addressed in future work. Firstly, our tree building takes a significant fraction of our total runtime, and so we use a very simple splitting scheme. It is possible that a more sophisticated building algorithm could improve the runtime of later stages enough to justify its cost. Secondly, in cases with n values and many more than log(n) dimensions, the splitting that takes place in our tree does not adequately constrain a sample?s location before it reaches a leaf, and many samples are returned with very small weights attached. In this work, we solved this by throwing away the least important dimensions with PCA, but it may be that other tree structures are still amenable to weighted importance sampling while more strongly constraining sample locations. It may also be beneficial to store values at leaf cells, rather than at a point somewhere within them. This would improve the complexity of the algorithm by removing the distance evaluation currently required to compute the correct probabilities at the leaf nodes, and making the importance sampling exact rather than weighted, but it would compute a different function of the values one far more dependent on the specific way in which the tree was built. Finally, tree traversal is an extremely irregular algorithm, and the speedup we observed from our GPU implementation is significantly less than theoretically possible. More intelligent software caching of portions of the tree and other data structures may speed this up further.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        Gaussian KD-Trees for Fast High-Dimensional Filtering ? 21:11\n      \n      \n        Acknowledgments\n        This work was supported by a Reed-Hodgson Stanford Graduate Fellowship, an NDSEG Graduate Fellowship from the United States Department of Defense, and an NSF Graduate Fellowship from the National Science Foundation. Thanks also to Justin Talbot, Leonidas Guibas, and Jeremy Sugerman for fruitful discussion and advice, to Hao Li for providing us with mesh data, and also to our human and canine figure subjects.\n      \n      \n        References\n        \n          A DAMS , A., G ELFAND , N., AND P ULLI , K. 2008. Viewfinder alignment. Computer Graphics Forum (Proc. Eurographics) 27, 2, 597?606.\n          A MAT , F., M OUSSAVI , F., C OMOLLI , L., E LIDAN , G., D OWN ING , K., AND H OROWITZ , M. 2008. Markov random field based automatic image alignment for electron tomography. Journal of Structural Biology (March), 260?275.\n          A RYA , S., M OUNT , D., N ETANYAHU , N. S., S ILVERMAN , R., AND W U , A. 1998. An optimal algorithm for approximate nearest neighbor searching. Journal of the ACM 45, 6.\n          A URICH , V., AND W EULE , J. 1995. Non-linear gaussian filters performing edge preserving diffusion. In Mustererkennung 1995, 17. DAGM-Symposium, Springer-Verlag, London, UK, 538?545.\n          A VANAKI , A. N. 2006. A spatiotemporal edge-preserving denoising method for high-quality video. Signal Processing and Information Technology, 2006 IEEE International Symposium on (Aug.), 157?161.\n          B EKAERT , P., S BERT , M., AND W ILLEMS , Y. D. 2000. Weighted importance sampling techniques for monte carlo radiosity. In Proceedings of the Eurographics Workshop on Rendering Techniques 2000, Springer-Verlag, London, UK, 35?46.\n          B ENNETT , E. P., AND M C M ILLAN , L. 2005. Video enhancement using per-pixel virtual exposures. ACM Transactions on Graphics (Proc. SIGGRAPH 05).\n          B ROX , T., K LEINSCHMIDT , O., AND C REMERS , D. 2008. Efficient nonlocal means for denoising of textural patterns. Image Processing, IEEE Transactions on 17, 7 (July), 1083?1092.\n          B UADES , A., C OLL , B., AND M OREL , J.-M. 2005. A non-local algorithm for image denoising. In Proc. CVPR 05., vol. 2, 60?65 vol. 2.\n          B UADES , A., C OLL , B., AND M OREL , J.-M. 2008. Nonlocal image and movie denoising. International Journal of Computer Vision 76, 2, 123?139.\n          B UCK , I. 2007. Gpu computing: Programming a massively parallel processor. In CGO ?07: Proceedings of the International Symposium on Code Generation and Optimization, IEEE Computer Society, Washington, DC, USA, 17.\n          C HEN , J., P ARIS , S., AND D URAND , F. 2007. Real-time edgeaware image processing with the bilateral grid. ACM Transactions on Graphics (Proc. SIGGRAPH 07).\n          D.B ARASH . 2002. A fundamental relationship between bilateral filtering, adaptive smoothing and the nonlinear diffusion equation. IEEE Transactions on Pattern Analysis and Machine Intelligence 24, 6, 844?847.\n          D ESBRUN , M., M EYER , M., S CHRODER , P., AND B ARR , A. 1999. Implicit fairing of irregular meshes using diffusion and curvature flow. Proc. SIGGRAPH 99.\n          D URAND , F., AND D ORSEY , J. 2002. Fast bilateral filtering for the display of high-dynamic-range images. Proc. SIGGRAPH 02.\n          E ISEMANN , E., AND D URAND , F. 2004. Flash photography enhancement via intrinsic relighting. ACM Transactions on Graphics (Proc. SIGGRAPH 04).\n          F LEISCHMAN , S., C OHEN -O R , D., AND S ILVA , C. 2005. Robust moving least-squares fitting with sharp features. ACM Transactions on Graphics (Proc. SIGGRAPH 05).\n          F LEISHMAN , S., D RORI , I., AND C OHEN -O R , D. 2003. Bilateral mesh denoising. ACM Transactions on Graphics (Proc. SIGGRAPH 03).\n          J OHNSON , A., AND H EBERT , M. 1999. Using spin images for efficient object recognition in cluttered 3D scenes. PAMI 21.\n          J ONES , T., D URAND , F., AND D ESBRUN , M. 2003. Nonitertive, feature-preserving mesh smoothing. ACM Transactions on Graphics (Proc. SIGGRAPH 03) 24, 3.\n          K UMAR , N., Z HANG , L., AND N AYAR , S. K. 2008. What is a good nearest neighbors algorithm for finding similar patches in images? Proc. ECCV 08, 364?378.\n          P ARIS , S., AND D URAND , F. 2006. A fast approximation of the bilateral filter using a signal processing approach. In Proc. ECCV 06.\n          P ARIS , S., AND D URAND , F. 2009. A fast approximation of the bilateral filter using a signal processing approach. International Journal of Computer Vision 81, 24?52.\n          P ARK , S. W., L INSEN , L., K REYLOS , O., O WENS , J. D., AND H AMANN , B. 2006. Discrete sibson interpolation. IEEE Transactions on Visualization and Computer Graphics 12, 2 (Mar./ Apr.), 243?253.\n          P ETSCHNIGG , G., S ZELISKI , R., A GRAWALA , M., C OHEN , M., H OPPE , H., AND T OYAMA , K. 2004. Digital photography with flash and no-flash image pairs. ACM Transactions on Graphics (Proc. SIGGRAPH 04).\n          S HEFFER , A., P RAUN , E., AND R OSE , K. 2006. Mesh Parameterization Methods and Their Applications. Now Publishers.\n          S MITH , S., AND B RADY , J. M. 1997. Susan:a new approach to low level image processing. International Journal of Computer Vision 23, 45?78.\n          S ORKINE , O., C OHEN OR , D., L IPMAN , Y., R SSL , C., PETER S EIDEL , H., AND A LEXA , M. 2004. Laplacian surface editing. Proc. SGP.\n          T AUBIN , G. 1995. A signal processing approach to fair surface design. Proc. SIGGRAPH 95.\n          T ELLEEN , J., S ULLIVAN , A., Y EE , J., W ANG , O., G UNAWAR DANE , P., C OLLINS , I., AND D AVIS , J. 2007. Synthetic shutter speed imaging. Computer Graphics Forum (Proc. Eurographics) 26, 3, 591?598.\n          T OMASI , C., AND M ANDUCHI , R. 1998. Bilateral filtering for gray and color images. Proc. ICCV 98 0, 839.\n          W EISS , B. 2006. Fast median and bilateral filtering. ACM Transactions on Graphics (Proc. SIGGRAPH 06).\n          Y ANG , C., D URAISWAMI , R., G UMEROV , N. A., AND D AVIS , L. 2003. Improved fast gauss transform and efficient kernel density estimation. Proc. ICCV 03, 664?671 vol.1.\n          Y OSHIZAWA , S., B ELYAEV , A., AND S EIDEL , H.-P. 2006. Smoothing by example: mesh denoising by averaging with similarity-based weights. IEEE Shape Modeling International.\n          Z HOU , K., H OU , Q., W ANG , R., AND G UO , B. 2008. Real-time kd-tree construction on graphics hardware. ACM Transactions on Graphics (Proc. SIGGRAPH Asia 08).\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n        21:12 ? A. Adams et al.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 21, Publication date: August 2009.\n      \n    \n  ",
  "resources" : [ ]
}