{
  "uri" : "sig2008-a34-ben-chen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008/a34-ben-chen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Variational Harmonic Maps for Space Deformation",
    "published" : "2009",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Mirela-Ben-Chen",
      "name" : "Mirela",
      "surname" : "Ben-Chen"
    }, {
      "uri" : "http://drinventor/Ofir-Weber",
      "name" : "Ofir",
      "surname" : "Weber"
    }, {
      "uri" : "http://drinventor/Craig-Gotsman",
      "name" : "Craig",
      "surname" : "Gotsman"
    } ]
  },
  "bagOfWords" : [ "73c1065c6e33b168145c75b344507a04beea46d6f86a5afa4c959ef6d008ddf8", "ouh", "http://dx.doi.org/10.1145/1576246.1531340", "name", "identification", "possible", "Variational", "Harmonic", "Maps", "Space", "Deformation", "Mirela", "Ben-Chen", "Ofir", "Weber", "Craig", "Gotsman", "Technion", "Israel", "Institute", "Technology", "space", "deformation", "mapping", "from", "source", "region", "target", "region", "within", "euclidean", "space", "which", "best", "satisfy", "some", "userspecified", "constraint", "can", "use", "deform", "shape", "embed", "ambient", "space", "represent", "various", "form", "polygon", "mesh", "point", "cloud", "volumetric", "datum", "space", "deformation", "method", "useful", "should", "possess", "some", "natural", "property", "e.g.", "detail", "preservation", "smoothness", "intuitive", "control", "harmonic", "map", "from", "domain", "mapping", "whose", "component", "harmonic", "function", "harmonic", "mapping", "smooth", "regular", "component", "couple", "some", "special", "way", "mapping", "can", "detail-preserving", "make", "natural", "choice", "space", "deformation", "application", "challenge", "find", "harmonic", "mapping", "domain", "which", "satisfy", "constraint", "specify", "user", "yet", "also", "detail-preserving", "intuitive", "control", "we", "generate", "harmonic", "mapping", "linear", "combination", "set", "harmonic", "basis", "function", "which", "have", "closed-form", "expression", "when", "source", "region", "boundary", "piecewise", "linear", "do", "define", "energy", "functional", "mapping", "minimize", "within", "linear", "span", "basis", "function", "result", "mapping", "harmonic", "natural", "``", "as-rigid-as-possible", "''", "deformation", "source", "region", "unlike", "other", "space", "deformation", "method", "we", "approach", "do", "require", "explicit", "discretization", "domain", "show", "much", "more", "efficient", "yet", "generate", "comparable", "deformation", "state-ofthe-art", "method", "we", "describe", "optimization", "algorithm", "minimize", "deformation", "energy", "which", "robust", "provably", "convergent", "easy", "implement", "cr", "category", "i.", "3.5", "-lsb-", "Computer", "Graphics", "-rsb-", "computational", "geometry", "Object", "Modeling", "Keywords", "space", "deformation", "harmonic", "map", "shape", "editing", "introduction", "space", "deformation", "method", "deform", "ambient", "space", "which", "shape", "embedded", "instead", "explicitly", "deform", "shape", "itself", "method", "have", "become", "popular", "recent", "year", "-lsb-", "Huang", "et", "al.", "2006", "Lipman", "et", "al.", "2007b", "Joshi", "et", "al.", "2007", "Lipman", "et", "al.", "2008", "Sumner", "et", "al.", "2007", "Botsch", "et", "al.", "2007", "-rsb-", "several", "reason", "first", "more", "general", "than", "explicit", "deformation", "space", "deformation", "can", "apply", "any", "shape", "representation", "whether", "polygonal", "mesh", "point", "cloud", "volumetric", "datum", "________________________", "ACM", "Reference", "Format", "Ben-Chen", "M.", "Weber", "O.", "Gotsman", "C.", "2009", "Variational", "Harmonic", "Maps", "Space", "Deformation", "ACM", "Trans", "graph", "28", "Article", "34", "-lrb-", "August", "2009", "-rrb-", "11", "page", "dous", "10.1145", "1531326.1531340", "http://doi.acm.org/10.1145/1531326.1531340", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "fus", "rst", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "permissions@acm.org", "2009", "ACM", "0730-0301/2009", "03-art34", "10.00", "DOI", "10.1145", "1531326.1531340", "http://doi.acm.org/10.1145/1531326.1531340", "figure", "beast", "model", "enclose", "its", "cage", "-lrb-", "left", "-rrb-", "its", "deformation", "use", "variational", "harmonic", "map", "-lrb-", "right", "-rrb-", "second", "deform", "ambient", "space", "computational", "complexity", "deformation", "decouple", "from", "complexity", "shape", "hence", "even", "extremely", "complex", "shape", "can", "deform", "interactive", "rate", "some", "space", "deformation", "method", "-lsb-", "Lipman", "et", "al.", "2007b", "Joshi", "et", "al.", "2007", "Lipman", "et", "al.", "2008", "-rsb-", "``", "cage-based", "''", "method", "give", "``", "source", "cage", "''", "manipulate", "user", "create", "``", "target", "cage", "''", "base", "source", "target", "cage", "mapping", "source", "cage", "define", "mapping", "function", "have", "closed-form", "expression", "deformation", "method", "become", "accurate", "efficient", "other", "hand", "manipulate", "cage", "tedious", "time-consuming", "task", "more", "user-friendly", "natural", "deformation", "method", "direct", "manipulation", "user", "position", "small", "number", "``", "control", "point", "''", "inside", "domain", "manipulate", "they", "instead", "cage", "method", "-lsb-", "Huang", "et", "al.", "2006", "Sumner", "et", "al.", "2007", "Botsch", "et", "al.", "2007", "-rsb-", "define", "space", "deformation", "domain", "which", "coarser", "than", "input", "shape", "solve", "optimization", "problem", "find", "parameter", "deformation", "give", "user", "'s", "constraint", "optimization", "problem", "generally", "non-linear", "robustness", "efficiency", "algorithm", "depend", "critically", "formulation", "deformation", "optimization", "method", "use", "we", "propose", "use", "harmonic", "map", "source", "region", "underlie", "deformation", "model", "since", "harmonic", "function", "smooth", "regular", "use", "wide", "range", "application", "from", "parameterization", "-lsb-", "floater", "Hormann", "2005", "-rsb-", "remeshing", "-lsb-", "Dong", "et", "al.", "2005", "-rsb-", "space", "deformation", "-lsb-", "Joshi", "et", "al.", "2007", "Lipman", "et", "al.", "2008", "-rsb-", "we", "generate", "harmonic", "map", "domain", "linear", "combination", "harmonic", "basis", "function", "special", "case", "domain", "polyhedron", "basis", "function", "first", "second", "derivative", "have", "closed-form", "expression", "harmonic", "map", "use", "expression", "we", "allow", "user", "place", "position", "orientation", "constraint", "arbitrary", "location", "inside", "domain", "define", "energy", "functional", "which", "depend", "also", "constraint", "define", "additional", "``", "rigidity", "line", "''", "semi-automatic", "way", "result", "deformation", "natural", "``", "as-rigid-as-possible", "''", "deformation", "shape", "respect", "specify", "constraint", "worth", "note", "we", "harmonic", "basis", "function", "variant", "``", "Green", "coordinate", "''", "Lipman", "et", "al.", "-lsb-", "2008", "-rsb-", "-lrb-", "Weber", "et", "al.", "-lsb-", "2009", "-rsb-", "-rrb-", "however", "we", "give", "simpler", "expression", "they", "also", "provide", "first", "second", "derivative", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "34:2", "M.", "Ben-Chen", "et", "al.", "1.1", "contribution", "we", "main", "contribution", "robust", "very", "efficient", "space", "deformation", "method", "which", "provide", "some", "advantage", "over", "exist", "method", "first", "user", "manipulate", "set", "position", "orientation", "constraint", "instead", "directly", "manipulate", "``", "source", "cage", "''", "hence", "we", "method", "more", "intuitive", "easy", "control", "second", "we", "have", "closed-form", "expression", "linear", "combination", "basis", "function", "deformation", "continuous", "domain", "thus", "do", "require", "voxelization", "input", "domain", "some", "other", "method", "do", "finally", "since", "we", "have", "closed-form", "expression", "also", "gradient", "deformation", "we", "optimization", "procedure", "may", "base", "alternate", "least-square", "``", "local/global", "''", "algorithm", "which", "until", "now", "applicable", "only", "discrete", "mesh-based", "setting", "optimization", "method", "extremely", "efficient", "its", "computational", "complexity", "dominate", "matrix-vector", "multiplication", "use", "pre-computed", "matrix", "thus", "may", "also", "easily", "implement", "GPU", "addition", "quite", "simple", "implement", "guarantee", "converge", "1.2", "previous", "work", "shape", "deformation", "one", "most", "active", "research", "subject", "computer", "graphic", "thorough", "review", "all", "recent", "work", "outside", "scope", "paper", "we", "shall", "thus", "concentrate", "space", "deformation", "method", "most", "relevant", "we", "work", "general", "method", "can", "classify", "two", "major", "group", "``", "cagebased", "''", "deformation", "direct", "manipulation", "deformation", "``", "cage-based", "''", "deformation", "user", "specify", "boundary", "relevant", "region", "space", "source", "``", "cage", "''", "which", "contain", "input", "shape", "cage", "typically", "piecewise-linear", "close", "surface", "user", "manipulate", "vertex", "cage", "generate", "target", "cage", "deformation", "define", "relationship", "between", "two", "cage", "cage-based", "method", "closely", "related", "barycentric", "coordinate", "typically", "deformation", "define", "linear", "combination", "vertex", "target", "cage", "set", "barycentric", "coordinate", "function", "define", "input", "cage", "since", "barycentric", "coordinate", "function", "depend", "only", "source", "cage", "can", "pre-computed", "make", "very", "efficient", "method", "deformation", "require", "only", "matrix-vector", "multiplication", "one", "first", "method", "-lsb-", "Huang", "et", "al.", "2006", "-rsb-", "use", "mean-value", "coordinate", "-lsb-", "Floater", "et", "al.", "2005", "Ju", "et", "al.", "2005", "-rsb-", "coordinate", "function", "unfortunately", "mean-value", "coordinate", "guarantee", "positive", "inside", "domain", "unless", "convex", "cause", "severe", "artifact", "result", "deformation", "later", "method", "-lsb-", "Joshi", "et", "al.", "2007", "-rsb-", "suggest", "use", "harmonic", "coordinate", "instead", "guarantee", "positive", "inside", "domain", "however", "harmonic", "coordinate", "solution", "Dirichlet", "problem", "boundary", "domain", "do", "have", "closed", "form", "expression", "thus", "compute", "coordinate", "easy", "recently", "Lipman", "et", "al.", "-lsb-", "2008", "-rsb-", "show", "how", "define", "two", "set", "coordinate", "function", "Green", "coordinate", "which", "have", "closed-form", "expression", "result", "detail-preserving", "mapping", "later", "Weber", "et", "al.", "-lsb-", "2009", "-rsb-", "show", "coordinate", "twodimension", "special", "case", "complex-valued", "barycentric", "coordinate", "may", "derive", "from", "celebrated", "Cauchy", "integral", "theorem", "call", "they", "cauchy-green", "coordinate", "all", "cage-based", "method", "have", "common", "disadvantage", "detailed", "deformation", "possible", "only", "relatively", "complex", "cage", "cage", "even", "few", "hundred", "face", "extremely", "hard", "manipulate", "order", "generate", "satisfying", "result", "overcome", "problem", "Weber", "et", "al.", "-lsb-", "2009", "-rsb-", "propose", "something", "similar", "spirit", "we", "method", "use", "complex", "Cauchy-Green", "coordinate", "conformal", "basis", "function", "find", "new", "cage", "location", "solve", "optimization", "problem", "derive", "from", "position", "constraint", "supply", "user", "although", "method", "quite", "effective", "complex", "conformal", "formulation", "apply", "only", "planar", "deformation", "we", "method", "can", "consider", "generalization", "Weber", "et", "al.", "-lsb-", "2009", "-rsb-", "three", "dimension", "general", "major", "difference", "between", "two", "method", "we", "use", "harmonic", "mapping", "basis", "function", "instead", "conformal", "function", "since", "complex", "holomorphic", "function", "-lrb-", "which", "two", "dimension", "generate", "conformal", "map", "-rrb-", "do", "have", "simple", "generalization", "three", "dimension", "result", "order", "achieve", "detail-preservation", "we", "need", "solve", "non-linear", "minimization", "problem", "whereas", "Weber", "et", "al.", "-lsb-", "2009", "-rsb-", "optimization", "require", "solution", "linear", "system", "worth", "note", "all", "previous", "method", "-lsb-", "Joshi", "et", "al.", "2007", "Lipman", "et", "al.", "2008", "Weber", "et", "al.", "2009", "-rsb-", "use", "harmonic", "map", "some", "sort", "underlie", "deformation", "function", "harmonic", "coordinate", "use", "independent", "harmonic", "function", "each", "coordinate", "thus", "able", "enforce", "exact", "interpolation", "target", "cage", "however", "both", "hard", "compute", "cause", "serious", "shearing", "effect", "cauchy-green", "coordinate", "two", "dimension", "-lsb-", "Lipman", "et", "al.", "2008", "Weber", "et", "al.", "2009", "-rsb-", "enforce", "conformal", "map", "harmonic", "map", "whose", "two", "component", "have", "orthogonal", "gradient", "equal", "norm", "Green", "coordinate", "three", "dimension", "use", "vertex", "target", "cage", "its", "normal", "coefficient", "linear", "combination", "harmonic", "basis", "function", "from", "point", "view", "we", "framework", "generalization", "all", "those", "coordinate", "we", "seek", "harmonic", "map", "instead", "predefine", "relationship", "between", "its", "component", "relationship", "derive", "implicitly", "minimize", "energy", "functional", "two", "other", "recent", "space-deformation", "method", "which", "solve", "nonlinear", "optimization", "problem", "give", "positional", "constraint", "those", "Sumner", "et", "al.", "-lsb-", "2007", "-rsb-", "Botsch", "et", "al.", "-lsb-", "2007", "-rsb-", "Sumner", "et", "al", "-lsb-", "2007", "-rsb-", "deformation", "define", "use", "deformation", "graph", "which", "automatically", "compute", "from", "input", "shape", "affine", "transformation", "associate", "each", "node", "deformation", "graph", "which", "describe", "transformation", "node", "undergo", "transformation", "variable", "energy", "function", "which", "force", "they", "rigid", "have", "smooth", "behavior", "minimize", "energy", "combine", "position", "constraint", "impose", "user", "generate", "deformation", "parameter", "deformation", "graph", "deformation", "point", "ambient", "space", "compute", "from", "transformation", "node", "deformation", "graph", "which", "close", "euclidean", "distance", "point", "two", "disadvantage", "method", "compare", "ours", "first", "deformation", "graph", "cage", "sense", "deformation", "function", "compute", "base", "euclidean", "distance", "cause", "artifact", "when", "deform", "shape", "which", "have", "piece", "which", "close", "each", "other", "euclidean", "distance", "far", "apart", "geodesic", "distance", "example", "finger", "hand", "addition", "smoothness", "deformation", "enforce", "discretely", "require", "neighbor", "face", "deformation", "graph", "have", "similar", "transformation", "we", "setting", "we", "have", "closed-form", "expression", "second", "derivative", "deformation", "we", "require", "vanish", "boundary", "domain", "hence", "regularization", "term", "energy", "more", "robust", "similar", "method", "Botsch", "et", "al.", "-lsb-", "2007", "-rsb-", "where", "deformation", "define", "voxelization", "input", "region", "here", "deformation", "also", "compute", "solve", "non-linear", "optimization", "problem", "use", "multi-grid", "framework", "method", "suffer", "from", "some", "aliasing", "effect", "due", "discretization", "addition", "its", "implementation", "somewhat", "involve", "comparison", "result", "we", "method", "method", "Sumner", "et", "al.", "Botsch", "et", "al.", "present", "section", "other", "direct", "surface", "manipulation", "technique", "exist", "those", "Sorkine", "et", "al.", "-lsb-", "2004", "-rsb-", "Lipman", "et", "al.", "-lsb-", "2005", "-rsb-", "sorkine", "alexa", "-lsb-", "2007", "-rsb-", "mention", "only", "few", "however", "method", "work", "directly", "surface", "manifold", "mesh", "somewhat", "limited", "can", "apply", "other", "shape", "representation", "polygon", "soup", "point", "cloud", "we", "formulation", "deformation", "mapping", "base", "Green", "'s", "third", "identity", "which", "relate", "value", "harmonic", "function", "boundary", "region", "its", "value", "inside", "region", "closely", "related", "both", "Green", "coordinate", "define", "Lipman", "et", "al.", "-lsb-", "2008", "-rsb-", "common", "method", "solve", "boundaryvalue", "problem", "know", "Boundary", "element", "method", "''", "BEM", "-lsb-", "Kythe", "1995", "-rsb-", "BEM", "have", "be", "use", "example", "Martin", "et", "al.", "-lsb-", "2008", "-rsb-", "discretize", "harmonic", "basis", "function", "polyhedral", "finite", "element", "despite", "common", "mathematical", "machinery", "we", "approach", "somewhat", "different", "from", "both", "method", "BEM", "framework", "one", "seek", "harmonic", "function", "domain", "have", "some", "give", "boundary", "value", "whereas", "we", "seek", "harmonic", "map", "which", "minimize", "give", "functional", "Green", "coordinate", "setting", "boundary", "mapping", "function", "set", "``", "target", "cage", "''", "its", "normal", "vector", "where", "we", "set", "boundary", "mapping", "function", "variable", "optimization", "problem", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "Variational", "Harmonic", "Maps", "Space", "Deformation", "34:3", "1.3", "Method", "Overview", "before", "diving", "underlie", "mathematics", "we", "present", "brief", "overview", "we", "deformation", "method", "input", "polyhedral", "cage", "enclose", "some", "region", "interest", "set", "position", "orientation", "constraint", "number", "point", "within", "cage", "output", "harmonic", "deformation", "mapping", "which", "map", "every", "point", "input", "cage", "some", "point", "explain", "next", "section", "deformation", "mapping", "uniquely", "define", "two", "function", "define", "vertex", "face", "cage", "respectively", "order", "find", "we", "pose", "optimization", "problem", "where", "discrete", "value", "variable", "goal", "optimization", "problem", "minimize", "energy", "functional", "which", "require", "detail", "preservation", "smoothness", "while", "enforce", "user", "'s", "constraint", "discrete", "setting", "we", "method", "somewhat", "similar", "solve", "location", "vertex", "target", "cage", "use", "Green", "coordinate", "-lsb-", "Lipman", "et", "al.", "2008", "-rsb-", "deformation", "method", "thus", "function", "analogous", "vertex", "location", "target", "cage", "analogous", "normal", "face", "however", "important", "difference", "we", "setup", "function", "independent", "whereas", "Green", "coordinate", "setup", "-lrb-", "normal", "face", "target", "cage", "-rrb-", "uniquely", "define", "-lrb-", "vertex", "target", "cage", "-rrb-", "hence", "we", "have", "more", "degree", "freedom", "larger", "space", "possible", "deformation", "rest", "paper", "organize", "follow", "follow", "section", "we", "define", "deformation", "mapping", "first", "consider", "general", "-lrb-", "continuous", "-rrb-", "domain", "cage", "specialize", "case", "where", "cage", "polyhedron", "we", "proceed", "define", "energy", "functional", "pose", "optimization", "problem", "section", "we", "discuss", "we", "optimization", "procedure", "its", "convergence", "property", "experimental", "result", "comparison", "state-of-the-art", "method", "present", "section", "we", "conclude", "discussion", "some", "future", "research", "direction", "section", "Variational", "Harmonic", "Maps", "give", "input", "domain", "region", "space", "which", "we", "shape", "lie", "we", "consider", "all", "possible", "harmonic", "mapping", "domain", "within", "large", "space", "possible", "deformation", "we", "choose", "harmonic", "map", "which", "both", "satisfy", "user", "'s", "constraint", "preserve", "detail", "much", "possible", "we", "begin", "describe", "we", "deformation", "mapping", "first", "general", "domain", "domain", "piecewise-linear", "-lrb-", "polyhedral", "-rrb-", "boundary", "once", "deformation", "mapping", "establish", "we", "discuss", "energy", "functional", "2.1", "harmonic", "map", "from", "Boundary", "function", "let", "open", "region", "smooth", "boundary", "let", "continuous", "function", "from", "example", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "we", "say", "harmonic", "map", "each", "its", "component", "harmonic", "function", "from", "R.", "specifically", "three", "dimension", "harmonic", "map", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "laplacian", "operator", "-lrb-", "-rrb-", "since", "laplacian", "linear", "operator", "harmonic", "mapping", "form", "linear", "subspace", "function", "from", "we", "would", "like", "select", "mapping", "from", "linear", "space", "which", "both", "satisfy", "user", "'s", "constraint", "detail-preserving", "however", "use", "current", "formulation", "obvious", "how", "find", "mapping", "fortunately", "all", "harmonic", "map", "can", "generate", "integrate", "two", "smooth", "map", "define", "??", "-lrb-", "boundary", "-rrb-", "two", "special", "function", "formalize", "follow", "theorem", "Theorem", "mapping", "harmonic", "mapping", "only", "exist", "two", "mapping", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "da", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "da", "where", "-lrb-", "-rrb-", "fundamental", "solution", "Laplace", "equation", "-lrb-", "-rrb-", "unit", "normal", "direction", "surface", "??", "point", "q.", "Proof", "let", "we", "concentrate", "case", "-lrb-", "-rrb-", "-lrb-", "p-q", "-rrb-", "straightforward", "see", "define", "-lrb-", "-rrb-", "harmonic", "mapping", "take", "derivative", "relative", "under", "integral", "sign", "let", "we", "consider", "second", "integral", "mapping", "define", "hence", "do", "depend", "p.", "so", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "solution", "Laplace", "equation", "hence", "harmonic", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "similarly", "first", "integral", "define", "boundary", "do", "depend", "p.", "so", "we", "have", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "so", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "since", "harmonic", "all", "its", "partial", "derivative", "harmonic", "function", "addition", "normal", "surface", "do", "depend", "so", "its", "dot", "product", "just", "linear", "combination", "harmonic", "function", "which", "again", "harmonic", "function", "opposite", "direction", "due", "Green", "'s", "third", "identity", "which", "guarantee", "any", "harmonic", "scalar", "function", "satisfy", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "da", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "da", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "34:4", "M.", "Ben-Chen", "et", "al.", "any", "point", "true", "all", "component", "f.", "hence", "take", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "jacobian", "complete", "proof", "we", "now", "use", "eq", "-lrb-", "-rrb-", "define", "we", "deformation", "mapping", "continuous", "deformation", "mapping", "fundamental", "solution", "-lrb-", "-rrb-", "Laplace", "equation", "have", "closed-form", "expression", "any", "dimension", "we", "define", "follow", "two", "scalar", "kernel", "function", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "give", "two", "smooth", "mapping", "we", "define", "deformation", "mapping", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "da", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "da", "way", "we", "able", "represent", "any", "point", "domain", "boundary", "integral", "kernel", "function", "b.", "Theorem", "deformation", "mapping", "span", "linear", "space", "all", "harmonic", "mapping", "through", "mapping", "since", "do", "depend", "we", "can", "also", "obtain", "expression", "partial", "derivative", "mapping", "example", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "??", "-lrb-", "-rrb-", "da", "-lrb-", "-rrb-", "??", "-lrb-", "-rrb-", "da", "similar", "expression", "may", "derive", "any", "partial", "higher", "order", "derivative", "f.", "note", "both", "deformation", "mapping", "its", "derivative", "linear", "b.", "use", "deformation", "mapping", "its", "derivative", "we", "later", "define", "energy", "functional", "-lrb-", "-rrb-", "final", "deformation", "point", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "arg", "min", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "before", "define", "energy", "functional", "we", "first", "show", "how", "deformation", "mapping", "can", "simplify", "special", "case", "source", "region", "polyhedral", "discrete", "deformation", "mapping", "most", "general", "setup", "domain", "boundary", "mapping", "can", "arbitrary", "however", "deformation", "application", "usually", "bind", "piecewise", "linear", "surface", "mean", "deform", "shape", "contain", "d-dimensional", "polyhedron", "addition", "we", "would", "like", "restrict", "specific", "type", "so", "we", "can", "find", "closed", "expression", "integral", "face", "cage", "derivative", "note", "restricted", "specific", "family", "function", "one", "direction", "Theorem", "true", "anymore", "we", "can", "generate", "all", "harmonic", "mapping", "use", "-lrb-", "-rrb-", "anymore", "when", "choose", "family", "belong", "we", "have", "make", "sure", "identity", "mapping", "-lrb-", "-rrb-", "more", "generally", "any", "affine", "mapping", "-lrb-", "-rrb-", "ap", "-lrb-", "where", "d?d", "matrix", "vector", "-rrb-", "still", "obtainable", "-lrb-", "-rrb-", "case", "we", "should", "use", "-lrb-", "-rrb-", "aq", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "hence", "piecewise-linear", "cage", "can", "restricted", "piecewise-linear", "since", "piecewise-linear", "surface", "have", "piecewiseconstant", "normal", "can", "restricted", "piecewise-constant", "simplest", "family", "b.", "course", "one", "could", "use", "higher", "degree", "polynomial", "expression", "integral", "more", "complicated", "we", "discuss", "now", "specifically", "three-dimensional", "case", "region", "bound", "triangle", "mesh", "-lrb-", "-rrb-", "vertex", "its", "face", "mention", "arbitrary", "mapping", "anymore", "piecewise-linear", "map", "define", "value", "vertex", "-lcb-", "-rcb-", "piecewise", "constant", "map", "define", "value", "face", "-lcb-", "-rcb-", "case", "we", "deformation", "map", "become", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "da", "-lrb-", "-rrb-", "da", "here", "-lrb-", "-rrb-", "piecewise", "linear", "interpolation", "value", "vertex", "triangle", "-lrb-", "-rrb-", "F.", "precisely", "equation", "consider", "Lipman", "et", "al", "-lsb-", "2008", "-rsb-", "analytic", "solution", "integral", "be", "give", "however", "we", "prefer", "use", "different", "expression", "which", "be", "develop", "context", "boundary", "element", "method", "Urago", "-lsb-", "2000", "-rsb-", "expression", "have", "somewhat", "geometric", "interpretation", "derivative", "easier", "compute", "analytic", "solution", "integral", "allow", "we", "express", "use", "two", "set", "scalar", "function", "-lcb-", "-lrb-", "-rrb-", "-rcb-", "-lcb-", "-lrb-", "-rrb-", "-rcb-", "use", "function", "deformation", "map", "can", "express", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "expression", "gradient", "vector", "hessian", "matrix", "give", "Appendix", "A.", "Figure", "show", "example", "deformation", "give", "specific", "mapping", "S.", "give", "point", "we", "can", "write", "its", "deformation", "mapping", "matrix", "notation", "follow", "Figure", "deformation", "range-scanned", "model", "-lrb-", "polygon", "soup", "-rrb-", "use", "we", "harmonic", "mapping", "-lrb-", "right", "-rrb-", "source", "model", "enclose", "its", "cage", "-lrb-", "leave", "-rrb-", "deformed", "model", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "where", "number", "vertex", "number", "face", "row", "vector", "whose", "entry", "-lrb-", "-rrb-", "row", "vector", "whose", "entry", "-lrb-", "-rrb-", "matrix", "whose", "i-th", "row", "similarly", "transpose", "Jacobian", "deformation", "point", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "where", "matrix", "whose", "i-th", "column", "gradient", "-lrb-", "-rrb-", "similarly", "hessian", "deformation", "point", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "hessian", "contain", "value", "which", "only", "independent", "due", "symmetry", "hessian", "addition", "since", "harmonic", "zz", "xx", "yy", "so", "actually", "only", "linearly", "independent", "value", "hessian", "five", "value", "present", "first", "column", "-lrb-", "-rrb-", "second", "third", "column", "hold", "relevant", "hessian", "value", "w.", "matrix", "whose", "i-th", "column", "hold", "respective", "five", "value", "from", "hessian", "-lrb-", "-rrb-", "similarly", "many", "case", "shape", "deform", "accompany", "normal", "vector", "example", "point", "cloud", "which", "have", "normal", "associate", "every", "point", "triangulate", "mesh", "which", "contain", "normal", "original", "surface", "case", "we", "would", "like", "deform", "normal", "well", "shape", "we", "can", "do", "deform", "plane", "which", "orthogonal", "normal", "vector", "point", "give", "two", "vector", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "which", "span", "plane", "orthogonal", "-lrb-", "-rrb-", "we", "have", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "where", "span", "deform", "plane", "plug", "back", "expression", "jacobian", "matrix", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "similarly", "hence", "we", "can", "pre-compute", "relevant", "matrix", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "Variational", "Harmonic", "Maps", "Space", "Deformation", "34:5", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "where", "matrix", "whose", "th", "column", "hold", "dot", "product", "??", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "same", "equip", "deformation", "mapping", "its", "first", "second", "derivative", "we", "can", "proceed", "define", "we", "energy", "functional", "show", "how", "use", "find", "mapping", "2.2", "energy", "functional", "we", "energy", "functional", "similar", "functional", "which", "be", "use", "previously", "As-Rigid-As-Possible", "deformation", "application", "-lsb-", "sorkine", "Alexa", "2007", "Sumner", "et", "al", "2007", "Botsch", "et", "al", "2007", "-rsb-", "attempt", "satisfy", "constraint", "specify", "user", "addition", "balance", "detail", "preservation", "smoothness", "user", "constraint", "we", "deformation", "mapping", "define", "everywhere", "user", "can", "choose", "set", "point", "set", "point", "specify", "target", "position", "-lrb-", "-rrb-", "Jacobians", "-lrb-", "-rrb-", "jacobian", "constraint", "can", "use", "prescribe", "orientation", "point", "any", "other", "affine", "transform", "point", "example", "Figure", "we", "have", "prescribe", "set", "position", "constraint", "jacobian", "constraint", "marked", "location", "require", "its", "affine", "transform", "small", "scale", "allow", "we", "easily", "generate", "muscle", "``", "bulge", "''", "effect", "see", "figure", "position", "jacobian", "constraint", "hard", "constraint", "we", "optimization", "process", "detail", "vs.", "volume", "preservation", "well", "know", "detail", "shape", "point", "space", "preserve", "during", "deformation", "local", "transformation", "point", "undergo", "close", "rigid", "fact", "have", "be", "use", "many", "as-rigid-as-possible", "deformation", "method", "-lsb-", "Botsch", "et", "al.", "2007", "Sumner", "et", "al.", "2007", "Sorkine", "Alexa", "2007", "-rsb-", "however", "recently", "Lipman", "et", "al.", "-lsb-", "2007a", "-rsb-", "have", "show", "detail", "preservation", "might", "come", "expense", "volume", "preservation", "fact", "order", "preserve", "volume", "Lipman", "et", "al.", "-lsb-", "2007a", "-rsb-", "scale", "transformation", "accord", "local", "curvature", "information", "hence", "require", "Jacobians", "all", "point", "domain", "rotation", "necessarily", "give", "desire", "effect", "might", "result", "volume", "loss", "however", "as-rigid-as-possible", "deformation", "reasonable", "assume", "point", "medial", "axis", "domain", "which", "very", "sparse", "subset", "domain", "itself", "undergo", "only", "rotation", "example", "consider", "Figure", "figure", "illustrate", "character", "deformation", "bar", "upside-down", "``", "''", "shape", "similar", "deformation", "Figure", "deformation", "almost", "volume", "preserving", "its", "relative", "change", "volume", "0.04", "figure", "color-code", "determinant", "condition", "number", "Jacobian", "deformation", "vertical", "slice", "through", "shape", "determinant", "indicate", "local", "change", "volume", "condition", "number", "-lrb-", "max", "min", "-rrb-", "indicate", "amount", "nonuniform", "scale", "evident", "figure", "volume", "top", "bar", "increase", "volume", "bottom", "bar", "decrease", "medial", "axis", "bar", "only", "bent", "volume", "near", "remain", "constant", "addition", "condition", "number", "closest", "near", "medial", "axis", "which", "indicate", "transformation", "area", "close", "rotation", "we", "setting", "local", "transformation", "point", "simply", "jacobian", "matrix", "since", "we", "can", "prescribe", "Jacobians", "deformation", "any", "location", "we", "choose", "we", "prescribe", "Jacobians", "medial", "axis", "close", "possible", "rotation", "way", "we", "do", "not", "need", "compute", "desire", "transformation", "boundary", "domain", "imply", "from", "smoothness", "deformation", "value", "rotation", "know", "advance", "compute", "part", "optimization", "process", "hence", "we", "would", "like", "minimize", "follow", "rigidity", "energy", "min", "-lrb-", "-rrb-", "rigid", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "rigidity", "energy", "where", "-lrb-", "-rrb-", "medial", "axis", "domain", "norm", "frobenius", "matrix", "norm", "Jacobian", "linear", "variable", "hence", "we", "know", "which", "rotation", "-lrb-", "-rrb-", "each", "point", "should", "undergo", "minimize", "rigid", "would", "simple", "matter", "minimize", "quadratic", "energy", "course", "-lrb-", "-rrb-", "know", "advance", "hence", "optimization", "process", "non-linear", "smoothness", "local", "transformation", "point", "govern", "Jacobian", "mapping", "smooth", "deformation", "have", "similar", "transformation", "nearby", "point", "hence", "small", "second", "derivative", "so", "enforce", "smoothness", "we", "require", "Frobenius", "norm", "hessian", "matrix", "each", "deformation", "mapping", "component", "small", "possible", "minimize", "follow", "energy", "min", "smooth", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "energy", "can", "simplify", "use", "follow", "observation", "we", "mapping", "harmonic", "hence", "all", "partial", "higher", "derivative", "all", "its", "component", "also", "harmonic", "accord", "maximum", "principle", "harmonic", "function", "domain", "achieve", "its", "extremum", "boundary", "domain", "hence", "we", "minimize", "second", "derivative", "boundary", "domain", "also", "bound", "inside", "domain", "result", "we", "may", "use", "follow", "smoothness", "energy", "min", "smooth", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ds", "Smoothness", "Energy", "energy", "give", "point", "choose", "user", "target", "position", "target", "jacobians", "respectively", "we", "would", "like", "solve", "follow", "optimization", "problem", "min", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ds", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "continuous", "optimization", "Problem", "where", "norm", "Frobenius", "norm", "-lrb-", "-rrb-", "unknown", "matrix", "define", "every", "point", "medial", "axis", "discrete", "energy", "minimize", "energy", "functional", "its", "current", "form", "difficult", "because", "non-linearity", "rotation", "constraint", "because", "we", "do", "have", "closed-form", "expression", "neither", "medial", "axis", "nor", "integral", "instead", "we", "convert", "integral", "sum", "finite", "sample", "follow", "smoothness", "energy", "we", "sample", "boundary", "surface", "point", "rigidity", "energy", "we", "approximate", "medial", "axis", "sample", "point", "set", "rigidity", "line", "line", "can", "acquire", "from", "skeleton", "deform", "shape", "available", "can", "prescribe", "manually", "user", "can", "compute", "use", "skeleton", "extraction", "algorithm", "Au", "et", "al.", "-lsb-", "2008", "-rsb-", "once", "line", "give", "we", "sample", "they", "anchor", "point", "sampling", "d/l", "point", "each", "rigidity", "line", "since", "we", "require", "smoothness", "sufficient", "anchor", "point", "sparsely", "distribute", "so", "can", "relatively", "small", "assumption", "sparse", "set", "rigidity", "constraint", "enough", "when", "deformation", "smooth", "have", "be", "use", "successfully", "other", "deformation", "method", "-lsb-", "Weber", "et", "al.", "2007", "Sorkine", "Cohen-Or", "2004", "-rsb-", "consequently", "we", "only", "have", "unknown", "rotation", "matrix", "solve", "set", "optimization", "problem", "become", "min", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "p1", "-rrb-", "Discrete", "Optimization", "Problem", "Figure", "show", "comparison", "result", "use", "different", "number", "anchor", "point", "rigidity", "constraint", "location", "anchor", "point", "be", "compute", "use", "skeleton", "extraction", "algorithm", "Au", "et", "al.", "-lsb-", "2008", "-rsb-", "evident", "from", "figure", "increase", "number", "anchor", "beyond", "give", "point", "do", "significantly", "improve", "result", "Figure", "Generating", "realistic", "muscle", "``", "bulge", "''", "effect", "place", "single", "jacobian", "constraint", "near", "marked", "area", "require", "scale", "addition", "jacobian", "constraint", "we", "have", "also", "place", "position", "constraint", "cause", "hand", "rotate", "Figure", "character", "Jacobian", "deformation", "within", "one", "slice", "through", "vertical", "bar", "model", "bent", "``", "''", "shape", "-lrb-", "left", "-rrb-", "color-coding", "condition", "number", "-lrb-", "right", "-rrb-", "color-coding", "determinant", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "34:6", "M.", "Ben-Chen", "et", "al.", "Figure", "deformation", "use", "different", "number", "anchor", "point", "leg", "armadillo", "model", "-lrb-", "left", "-rrb-", "deform", "bent", "position", "use", "specify", "number", "anchor", "point", "top", "bottom", "row", "show", "different", "view", "same", "deform", "shape", "source", "pose", "show", "five", "user", "constraint", "red", "sphere", "positional", "constraint", "black", "cylinder", "orientation", "constraint", "Figure", "show", "two", "deformation", "``", "armadillo", "''", "model", "addition", "figure", "show", "setup", "deformation", "cage", "original", "pose", "anchor", "point", "constraint", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "deformation", "armadillo", "model", "-lrb-", "-rrb-", "Cage", "anchor", "location", "-lrb-", "-rrb-", "original", "pose", "constraint", "-lrb-", "-rrb-", "deformed", "pose", "-lrb-", "-rrb-", "another", "deform", "pose", "from", "two", "different", "viewpoint", "follow", "section", "we", "describe", "we", "optimization", "scheme", "minimize", "deformation", "energy", "optimization", "solve", "optimization", "problem", "-lrb-", "p1", "-rrb-", "we", "use", "follow", "observation", "variable", "know", "-lrb-", "p1", "-rrb-", "simple", "linear", "least-square", "problem", "linear", "equality", "constraint", "which", "have", "closed-form", "global", "minimum", "other", "hand", "know", "optimal", "rotation", "matrix", "those", "which", "closest", "Frobenius", "norm", "Jacobians", "deformation", "map", "also", "have", "closed-form", "solution", "solution", "variant", "well-known", "Procrustes", "problem", "obtain", "use", "singular", "value", "decomposition", "-lrb-", "svd", "-rrb-", "hence", "we", "can", "solve", "-lrb-", "p1", "-rrb-", "use", "alternate", "least", "square", "method", "``", "local/global", "''", "algorithm", "-lsb-", "Liu", "et", "al", "2008", "Sorkine", "Alexa", "2007", "-rsb-", "``", "local", "''", "step", "we", "keep", "fix", "solve", "many", "small", "independent", "local", "problem", "while", "``", "global", "''", "step", "we", "keep", "fix", "solve", "one", "global", "linear", "system", "we", "repeat", "two", "step", "until", "convergence", "convergence", "robustness", "point", "out", "previous", "work", "-lsb-", "Liu", "et", "al", "2008", "Sorkine", "Alexa", "2007", "-rsb-", "``", "local/global", "''", "algorithm", "guarantee", "converge", "because", "each", "step", "must", "reduce", "energy", "general", "convergence", "rate", "depend", "initial", "configuration", "however", "since", "number", "variable", "relatively", "small", "number", "anchor", "jacobian", "computation", "usually", "smaller", "than", "complexity", "cage", "``", "local/global", "''", "algorithm", "robust", "enough", "converge", "good", "solution", "from", "arbitrary", "initial", "configuration", "arbitrary", "we", "mean", "Jacobians", "initialize", "random", "matrix", "figure", "show", "result", "deformation", "after", "various", "number", "iteration", "start", "from", "arbitrary", "configuration", "addition", "show", "graph", "value", "energy", "functional", "vs.", "iteration", "number", "use", "different", "initial", "configuration", "can", "see", "from", "graph", "we", "method", "always", "converge", "same", "solution", "matter", "which", "initial", "configuration", "use", "interactive", "modeling", "environment", "initial", "configuration", "can", "take", "from", "value", "previous", "frame", "case", "small", "number", "iteration", "``", "local/global", "''", "algorithm", "usually", "enough", "achieve", "convergence", "initial", "configuration", "we", "use", "all", "example", "paper", "except", "one", "figure", "section", "we", "provide", "some", "more", "deformation", "example", "timing", "require", "generate", "they", "let", "we", "now", "turn", "more", "detailed", "description", "minimization", "process", "implementation", "detail", "use", "``", "local/global", "''", "approach", "deformation", "algorithm", "relatively", "simple", "implement", "boil", "down", "three", "step", "preprocessing", "step", "during", "which", "some", "matrix", "pre-computed", "later", "use", "optimization", "step", "where", "we", "iterate", "``", "local/global", "''", "step", "find", "value", "finally", "deformation", "step", "during", "which", "value", "combine", "user", "'s", "constraint", "generate", "final", "mapping", "input", "shape", "step", "implement", "series", "matrix", "operation", "matrix", "which", "``", "stack", "''", "matrix", "derivative", "avoid", "clutter", "notation", "we", "redefine", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "term", "single", "matrix", "follow", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "each", "matrix", "represent", "concatenation", "matrix", "from", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "respectively", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "addition", "matrix", "size", "matrix", "size", "-lrb-", "where", "number", "vertex", "face", "respectively", "-rrb-", "matrix", "whose", "first", "row", "last", "row", "now", "we", "can", "convert", "optimization", "problem", "matrix", "notation", "use", "expression", "min", "-lrb-", "-rrb-", "jz", "hz", "Dz", "jz", "where", "-lrb-", "-rrb-", "...", "-lrb-", "-rrb-", "...", "-lrb-", "-rrb-", "...", "-lrb-", "-rrb-", "...", "stack", "deformation", "Jacobian", "hessian", "matrix", "respective", "point", "-lrb-", "position", "constraint", "orientation", "constraint", "anchor", "point", "hessian", "sample", "point", "boundary", "domain", "-rrb-", "...", "...", "...", "right", "hand", "side", "linear", "equation", "user", "'s", "position", "orientation", "constraint", "unknown", "rotation", "matrix", "anchor", "point", "energy", "can", "now", "write", "az", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "constant", "determine", "relative", "weight", "smoothness", "constraint", "vs.", "rigidity", "constraint", "we", "experiment", "we", "take", "matrix", "norm", "infinity", "norm", "maximal", "norm", "row", "matrix", "user", "specify", "parameter", "which", "can", "use", "control", "stiffness", "deformation", "we", "take", "0.01", "all", "we", "experiment", "return", "optimization", "problem", "know", "minimum", "give", "opt", "-lrb-", "-rrb-", "since", "most", "column", "multiply", "zero", "right", "hand", "side", "we", "can", "truncate", "its", "last", "5k", "column", "follow", "opt", "trunc", "trunc", "-lrb-", "-rrb-", "trunc", "where", "ttrunc", "include", "only", "first", "3d", "column", "we", "enforce", "user", "'s", "constraint", "remove", "+3", "variable", "from", "problem", "compute", "value", "from", "remain", "variable", "use", "equation", "opt", "-lrb-", "-rrb-", "can", "do", "course", "only", "number", "hard", "constraint", "less", "than", "number", "degree", "freedom", "problem", "m.", "however", "relatively", "complicated", "deformation", "can", "generate", "small", "number", "position", "orientation", "constraint", "result", "system", "type", "opt", "where", "compute", "from", "partial", "matrix", "during", "optimization", "procedure", "we", "need", "re-compute", "current", "jacobian", "matrix", "hence", "we", "get", "new", "jb", "addition", "once", "non-linear", "iteration", "have", "converge", "we", "need", "compute", "new", "location", "deform", "shape", "new", "location", "point", "...", "give", "...", "...", "opt", "...", "opt", "opt", "...", "matrix", "pre-computed", "before", "interactive", "deformation", "begin", "thus", "we", "have", "lay", "out", "all", "building", "block", "we", "algorithm", "which", "can", "state", "follow", "pre-processing", "compute", "matrix", "give", "location", "user", "'s", "constraint", "anchor", "point", "hessian", "sample", "boundary", "input", "shape", "optimization", "Select", "initial", "solution", "set", "global", "repeat", "until", "convergence", "follow", "two", "step", "local", "normalize", "-lrb-", "global", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "Variational", "Harmonic", "Maps", "Space", "Deformation", "34:7", "figure", "``", "local/global", "''", "optimization", "scheme", "robust", "enough", "converge", "good", "solution", "from", "any", "arbitrary", "initial", "configuration", "-lrb-", "leave", "right", "-rrb-", "deform", "shape", "after", "17", "200", "iteration", "start", "from", "arbitrary", "initial", "configuration", "graph", "show", "value", "energy", "functional", "vs.", "number", "iteration", "start", "from", "different", "random", "start", "point", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "34:8", "M.", "Ben-Chen", "et", "al.", "global", "local", "step", "``", "normalization", "''", "matrix", "Global", "do", "compute", "SVD", "each", "matrix", "usv", "replace", "uv", "up", "change", "sign", "last", "column", "have", "negative", "determinant", "additional", "benefit", "local", "step", "since", "Jacobians", "negative", "determinant", "allow", "optimization", "process", "tend", "find", "minimum", "which", "do", "not", "contain", "foldover", "course", "since", "might", "override", "global", "step", "occurrence", "foldover", "depend", "user", "'s", "constraint", "we", "experience", "reasonable", "set", "constraint", "foldover", "likely", "appear", "we", "detect", "convergence", "measure", "amount", "change", "global", "between", "two", "consecutive", "iteration", "which", "equivalent", "change", "rigidity", "energy", "would", "better", "measure", "change", "total", "energy", "however", "more", "computationally", "expensive", "computational", "complexity", "each", "iteration", "complexity", "compute", "svd", "operation", "matrix-vector", "multiplication", "which", "-lrb-", "-lrb-", "+3", "-rrb-", "-rrb-", "detailed", "performance", "timing", "provide", "next", "section", "note", "computational", "complexity", "both", "local", "global", "shape", "do", "depend", "complexity", "deform", "shape", "nor", "complexity", "cage", "deformation", "opt", "last", "global", "compute", "optimization", "step", "deform", "location", "give", "...", "opt", "algorithm", "can", "sum", "up", "few", "line", "pseudo-code", "outline", "algorithm", "pre-process", "step", "require", "only", "vector", "matrix", "operation", "set", "up", "matrix", "multiply", "they", "hence", "use", "any", "efficient", "linear", "algebra", "package", "implementation", "relatively", "straightforward", "we", "provide", "runtime", "all", "step", "algorithm", "various", "3d", "model", "next", "section", "precompute", "while", "-lrb-", "err", "threshold", "-rrb-", "do", "js_prev", "j", "j", "normalize_jacobians", "-lrb-", "j", "-rrb-", "j", "-lsb-", "constraint", "j", "-rsb-", "err", "norm", "-lrb-", "js_prev", "j", "-rrb-", "end", "new_positions", "-lsb-", "constraint", "j", "-rsb-", "algorithm", "pseudo-code", "deformation", "algorithm", "experimental", "result", "we", "implement", "we", "Variational", "Harmonic", "Map", "-lrb-", "vhm", "-rrb-", "deformation", "system", "plugin", "maya", "commercial", "modeling", "animation", "system", "optimization", "deformation", "step", "VHM", "include", "two", "building", "block", "SVD", "computation", "matrix", "dense", "matrix-vector", "multiply", "dense", "matrix-vector", "multiply", "operation", "``", "embarrassingly", "parallel", "''", "sense", "compose", "many", "independent", "operation", "-lrb-", "multiply", "one", "row", "one", "column", "-rrb-", "which", "can", "perform", "parallel", "we", "have", "exploit", "implement", "computation", "equation", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "GPU", "we", "use", "nvidia?s", "CUDA", "programming", "language", "BLAS", "library", "Nvidia", "Quadro", "FX", "5800", "graphic", "card", "figure", "1-3", "6-14", "accompany", "video", "demonstrate", "application", "VHM", "different", "deformation", "scenario", "section", "we", "first", "compare", "VHM", "two", "other", "state-of-the-art", "deformation", "method", "discuss", "some", "its", "property", "comparison", "we", "compare", "performance", "VHM", "two", "state-of-the-art", "deformation", "method", "``", "embed", "deformation", "''", "-lrb-", "ED", "-rrb-", "Sumner", "et", "al.", "-lsb-", "2007", "-rsb-", "``", "adaptive", "rigid", "cell", "''", "-lrb-", "ARC", "-rrb-", "Botsch", "et", "al.", "-lsb-", "2007", "-rsb-", "we", "compare", "method", "three", "deformation", "scenario", "synthetic", "model", "one", "deformation", "beast", "model", "measure", "overall", "appearance", "deform", "shape", "detail", "preservation", "change", "total", "volume", "shape", "Software", "kindly", "provide", "respective", "author", "before", "start", "comparison", "we", "should", "state", "upfront", "some", "disadvantage", "VHM", "its", "biggest", "downside", "compare", "ED", "ARC", "additional", "shape", "deform", "user", "must", "also", "supply", "cage", "bound", "domain", "set", "``", "rigidity", "line", "''", "although", "generate", "rigidity", "line", "relatively", "painless", "-lrb-", "e.g.", "use", "skeleton", "extraction", "algorithm", "-lsb-", "Au", "et", "al.", "2008", "-rsb-", "-rrb-", "create", "cage", "trivial", "problem", "mostly", "understate", "exist", "cage-based", "deformation", "method", "respect", "method", "which", "automatically", "generate", "underlying", "space", "representation", "deformation", "graph", "ED", "voxelization", "ARC", "have", "advantage", "other", "hand", "we", "believe", "benefit", "have", "cage", "closed", "form", "expression", "deformation", "faster", "optimization", "separation", "unrelated", "part", "shape", "outweigh", "hassle", "generate", "cage", "Figure", "show", "comparison", "between", "VHM", "ED", "ARC", "``", "bar", "''", "shape", "three", "different", "deformation", "VHM", "ED", "method", "we", "use", "same", "constraint", "ARC", "we", "achieve", "deformation", "through", "interactive", "manipulation", "result", "show", "ARC", "after", "final", "rbf", "interpolation", "step", "VHM", "ARC", "ED", "Figure", "comparison", "we", "deformation", "method", "vhm", "arc", "ed", "three", "deformation", "``", "bar", "''", "model", "Figure", "setup", "use", "comparison", "Figure", "-lrb-", "top", "from", "leave", "right", "-rrb-", "VHM", "cage", "anchor", "arc", "cell", "-lrb-", "320", "-rrb-", "ed", "deformation", "graph", "-lrb-", "187", "vertex", "-rrb-", "-lrb-", "bottom", "-rrb-", "VHM", "ARC", "ED", "constraint", "Figure", "show", "setup", "we", "use", "deformation", "Figure", "Figure", "10", "show", "comparison", "setup", "deformation", "beast", "model", "model", "be", "interactively", "deform", "reach", "require", "pose", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "Variational", "Harmonic", "Maps", "Space", "Deformation", "34:9", "VHM", "ARC", "ED", "Figure", "10", "comparison", "we", "method", "-lrb-", "vhm", "-rrb-", "arc", "ed", "deformation", "``", "beast", "''", "model", "setup", "use", "deformation", "small", "image", "-lrb-", "top", "-rrb-", "VHM", "cage", "anchor", "arc", "cell", "-lrb-", "2148", "-rrb-", "ed", "deformation", "graph", "-lrb-", "300", "vertex", "-rrb-", "-lrb-", "bottom", "-rrb-", "VHM", "ARC", "ED", "constraint", "Figure", "11", "deformation", "tetrahedral", "mesh", "model", "hand", "one", "finger", "easily", "move", "without", "influence", "nearby", "finger", "even", "though", "close", "euclidean", "distance", "compare", "detail", "preservation", "different", "model", "we", "compute", "rigidity", "distortion", "triangle", "deform", "mesh", "which", "define", "similarly", "Liu", "et", "al.", "-lsb-", "2008", "-rsb-", "rigid", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "area", "source", "triangle", "singular", "value", "Jacobian", "transformation", "transform", "source", "planar", "triangle", "deform", "planar", "triangle", "ideally", "we", "would", "like", "compare", "singular", "value", "Jacobian", "3d", "transformation", "since", "other", "two", "method", "we", "do", "have", "access", "actual", "deformation", "function", "rather", "only", "end", "result", "unfortunately", "easily", "do", "addition", "we", "compare", "change", "total", "volume", "deform", "shape", "volume", "vol", "new", "vol", "orig", "vol", "orig", "comparison", "error", "give", "Table", "can", "see", "from", "figure", "10", "Table", "result", "VHM", "comparable", "those", "ARC", "however", "VHM", "considerably", "more", "efficient", "-lrb-", "show", "Table", "-rrb-", "also", "simpler", "implement", "when", "compare", "ED", "we", "method", "somewhat", "better", "both", "visual", "quality", "result", "Figure", "show", "ed", "method", "have", "some", "noise", "issue", "volume", "preservation", "locality", "deformation", "Figure", "11", "demonstrate", "VHM", "have", "local", "effect", "only", "region", "geodesically", "close", "manipulate", "region", "modify", "oppose", "unrelated", "region", "which", "happen", "close", "euclidean", "distance", "index", "finger", "hand", "may", "move", "without", "influence", "other", "finger", "rigid", "volume", "Model", "VHM", "ARC", "ED", "VHM", "ARC", "ED", "0.050", "0.035", "0.049", "0.086", "0.078", "0.143", "0.069", "0.070", "0.078", "0.177", "0.116", "0.226", "0.046", "0.043", "0.053", "0.069", "0.082", "0.118", "beast", "0.022", "0.013", "0.018", "0.063", "0.025", "0.119", "Model", "VHM", "ARC", "ED", "VHM", "ARC", "ED", "0.050", "0.035", "0.049", "0.086", "0.078", "0.143", "0.069", "0.070", "0.078", "0.177", "0.116", "0.226", "0.046", "0.043", "0.053", "0.069", "0.082", "0.118", "beast", "0.022", "0.013", "0.018", "0.063", "0.025", "0.119", "Table", "comparison", "rigidity", "error", "volume", "change", "deformation", "method", "Figure", "12", "-lrb-", "leave", "-rrb-", "two", "as-similar-as-possible", "deformation", "beast", "model", "note", "exaggerated", "hand", "foot", "-lrb-", "right", "-rrb-", "another", "asap", "deformation", "color", "coding", "condition", "number", "Jacobian", "deformation", "sample", "input", "cage", "graph", "show", "histogram", "value", "as-similar-as-possible", "deformation", "one", "benefit", "we", "``", "local/global", "''", "optimization", "scheme", "constraint", "jacobian", "matrix", "anchor", "point", "can", "easily", "change", "from", "rigidity", "constraint", "other", "type", "constraint", "simply", "modify", "local", "step", "optimization", "algorithm", "example", "do", "previous", "``", "local/global", "''", "base", "method", "-lsb-", "Liu", "et", "al.", "2008", "-rsb-", "we", "can", "replace", "rigidity", "constraint", "similarity", "constraint", "require", "jacobian", "matrix", "anchor", "point", "similarity", "transform", "local", "step", "modify", "replace", "``", "normalization", "''", "step", "jacobian", "matrix", "follow", "procedure", "compute", "SVD", "each", "matrix", "usv", "replace", "US", "new", "where", "new", "diagonal", "matrix", "whose", "entry", "average", "diagonal", "entry", "deformation", "asrigid-as-possible", "anymore", "introduce", "uniform", "scale", "however", "can", "see", "Figure", "12", "accompany", "video", "interesting", "exaggeration", "effect", "can", "generate", "way", "some", "application", "one", "might", "require", "deformation", "quasi-conformal", "mean", "condition", "number", "Jacobian", "deformation", "bound", "case", "assimilar-as-possible", "approach", "more", "appropriate", "than", "asrigid-as-possible", "approach", "Figure", "12", "show", "color-code", "condition", "number", "Jacobian", "sample", "point", "inside", "cage", "beast", "model", "show", "deformation", "addition", "figure", "show", "histogram", "value", "evident", "from", "figure", "condition", "number", "smaller", "than", "3.5", "which", "indicate", "deformation", "quasi-conformal", "quasiconformal", "factor", "similar", "Green", "coordinate", "-lsb-", "Lipman", "et", "al.", "2008", "-rsb-", "cage", "oppose", "direct", "manipulation", "method", "-lsb-", "Botsch", "et", "al.", "2007", "Sumner", "et", "al.", "2007", "-rsb-", "which", "build", "underlie", "representation", "automatically", "cage", "base", "method", "-lsb-", "Lipman", "et", "al.", "2008", "-rsb-", "usually", "rely", "manually", "model", "cage", "we", "also", "use", "manually", "model", "cage", "since", "we", "approach", "cage", "only", "mathematical", "tool", "visible", "user", "important", "check", "how", "sensitive", "deformation", "cage", "use", "specifically", "we", "would", "like", "verify", "two", "reasonable", "cage", "result", "similar", "deformation", "when", "user", "constraint", "identical", "investigate", "we", "implement", "straightforward", "algorithm", "generate", "simple", "cage", "uniform", "decomposition", "space", "follow", "merge", "neighbor", "co-planar", "face", "cage", "would", "somewhat", "hard", "manipulate", "manually", "since", "we", "method", "user", "do", "manipulate", "cage", "directly", "issue", "we", "apply", "algorithm", "``", "beast", "''", "model", "from", "Figure", "use", "manually", "build", "automatic", "cage", "we", "deform", "model", "interactively", "Figure", "13", "show", "two", "cage", "deformation", "result", "from", "they", "evident", "from", "figure", "deformation", "induce", "two", "cage", "very", "similar", "indicate", "we", "method", "very", "sensitive", "precise", "cage", "use", "non-articulated", "shape", "some", "object", "plate-like", "object", "do", "have", "obvious", "skeleton", "case", "we", "method", "can", "still", "apply", "place", "anchor", "medial", "surface", "instead", "medial", "axis", "Figure", "14", "show", "two", "deformation", "``", "bumpy", "plane", "''", "model", "use", "different", "anchor", "configuration", "both", "case", "anchor", "be", "place", "medial", "surface", "model", "exact", "placement", "different", "figure", "show", "result", "deformation", "very", "similar", "indicate", "we", "method", "very", "sensitive", "exact", "location", "anchor", "medial", "surface", "figure", "also", "show", "comparison", "result", "deformation", "same", "model", "use", "arc", "method", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "34:10", "M.", "Ben-Chen", "et", "al.", "Figure", "13", "two", "deformation", "use", "manually", "build", "cage", "-lrb-", "left", "-rrb-", "automatic", "cage", "-lrb-", "right", "-rrb-", "vhm", "vhm", "arc", "figure", "14", "deformation", "plate", "like", "object", "use", "two", "different", "anchor", "configuration", "medial", "surface", "-lrb-", "left", "middle", "-rrb-", "deformation", "use", "arc", "same", "model", "-lrb-", "right", "-rrb-", "efficiency", "Table", "provide", "model", "statistics", "deformation", "time", "millisecond", "we", "example", "deformation", "timing", "break", "down", "time", "one", "optimization", "iteration", "-lrb-", "label", "``", "solve", "''", "-rrb-", "time", "matrix-vector", "multiply", "which", "generate", "deformation", "-lrb-", "label", "``", "def", "''", "-rrb-", "preprocessing", "time", "all", "model", "less", "than", "minute", "clear", "from", "table", "we", "solve", "time", "considerably", "faster", "than", "those", "report", "arc", "-lsb-", "Botsch", "et", "al.", "2007", "-rsb-", "ed", "-lsb-", "Sumner", "et", "al.", "2007", "-rsb-", "which", "be", "run", "machine", "spec", "similar", "ours", "example", "solve", "step", "ED", "Giraffe", "model", "require", "120", "msec", "use", "six", "Gauss-Newton", "iteration", "use", "arc", "method", "solve", "step", "model", "50,000", "vertex", "require", "330", "msec", "single", "Newton", "iteration", "larger", "model", "79,000", "vertex", "solve", "step", "VHM", "require", "only", "12", "msec", "VHM", "solve", "include", "GPU", "optimization", "-lrb-", "global", "part", "``", "local/global", "''", "algorithm", "-rrb-", "whereas", "other", "method", "implement", "CPU", "however", "ARC", "ED", "optimization", "algorithm", "base", "Gauss-Newton", "iteration", "use", "large", "sparse", "matrix", "algorithm", "considerably", "harder", "parallelize", "than", "dense", "matrix-vector", "multiply", "which", "can", "implement", "use", "off-the-shelf", "CUDA", "code", "hence", "one", "compare", "best", "possible", "implementation", "method", "ours", "have", "distinct", "advantage", "deformation", "time", "also", "very", "fast", "10", "msec", "170,000", "vertex", "armadillo", "model", "Model", "Verts", "Ancrs", "Iters", "Cage", "Solve", "Def", "Tot", "face", "-lrb-", "m", "-rrb-", "-lrb-", "m", "-rrb-", "-lrb-", "m", "-rrb-", "bar", "32,908", "208", "15", "0.27", "1.84", "5.89", "Tet", "28,796", "288", "28", "0.43", "2.27", "6.14", "hand", "Giraffe", "79,226", "204", "27", "33", "0.37", "3.08", "15.29", "beast", "32,311", "226", "50", "10", "0.53", "2.60", "7.90", "arma", "28,829", "68", "26", "0.27", "1.87", "8.89", "leg", "arma", "173,101", "250", "88", "13", "0.69", "10.60", "19.57", "Solve", "Def", "Tot", "-lrb-", "m", "-rrb-", "-lrb-", "m", "-rrb-", "-lrb-", "m", "-rrb-", "15", "0.27", "1.84", "5.89", "0.43", "2.27", "6.14", "33", "0.37", "3.08", "15.29", "10", "0.53", "2.60", "7.90", "26", "0.27", "1.87", "8.89", "Cage", "face", "bar", "32,908", "208", "Tet", "28,796", "288", "28", "hand", "Giraffe", "79,226", "204", "27", "beast", "32,311", "226", "50", "arma", "28,829", "68", "leg", "arma", "173,101", "250", "88", "13", "0.69", "10.60", "19.57", "Table", "Performance", "measure", "msec", "Intel", "2.67", "GHz", "i7", "machine", "-lrb-", "use", "single", "thread", "-rrb-", "4gb", "RAM", "``", "solve", "''", "time", "one", "optimization", "iteration", "``", "def", "''", "time", "matrix", "multiply", "deformation", "step", "``", "iter", "''", "average", "number", "iteration", "typical", "deformation", "require", "converge", "conclusion", "discussion", "we", "have", "propose", "new", "space", "deformation", "method", "-lrb-", "Variational", "Harmonic", "mapping", "VHM", "-rrb-", "whose", "underlie", "mathematical", "model", "harmonic", "mapping", "use", "mapping", "its", "derivative", "we", "define", "energy", "function", "whose", "minimization", "allow", "user", "deform", "shape", "use", "small", "number", "position", "orientation", "constraint", "we", "show", "how", "minimize", "energy", "use", "very", "efficient", "iterative", "``", "local/global", "''", "algorithm", "demonstrate", "result", "deformation", "close", "as-rigidas-possible", "deformation", "its", "quality", "comparable", "state-of-theart", "space", "deformation", "method", "while", "be", "considerably", "faster", "future", "we", "hope", "further", "explore", "variational", "harmonic", "mapping", "setting", "other", "than", "deformation", "due", "similarity", "boundary", "element", "method", "-lrb-", "bem", "-rrb-", "-lsb-", "Kythe", "1995", "-rsb-", "we", "method", "might", "also", "effective", "find", "solution", "different", "interpolation", "problem", "moreover", "we", "would", "like", "investigate", "theoretical", "property", "we", "deformation", "its", "relation", "quaternionic", "analytic", "function", "acknowledgment", "we", "would", "like", "thank", "Robert", "Sumner", "Mario", "Botsch", "Oscar", "KinChung", "Au", "Daniel", "Cohen-Or", "Amit", "Mano", "supply", "we", "software", "implementation", "Robert", "Sumner", "Mark", "Pauly", "giraffe", "model", "Autodesk", "beast", "model", "AIM@SHAPE", "project", "armadillo", "hand", "model", "NVIDIA", "donation", "Quadro", "graphic", "card", "work", "partially", "support", "Israel-Niedersachsen", "-lrb-", "Volkswagen", "Foundation", "-rrb-", "grant", "#zn", "2046", "Israel", "Ministry", "Science", "fund", "Promotion", "Research", "Technion", "reference", "O.", "K.-C.", "aus", "c.-l.", "hu", "h.-k.", "ohen", "D.", "ee", "t.-y", "2008", "Skeleton", "extraction", "mesh", "contraction", "ACM", "Trans", "graph", "27", "1-10", "otsch", "M.", "auly", "M.", "ICKE", "M.", "ross", "M.", "2007", "adaptive", "space", "deformation", "base", "rigid", "cell", "Computer", "Graphics", "Forum", "26", "339-347", "ong", "S.", "IRCHER", "S.", "ARLAND", "M.", "2005", "harmonic", "function", "quadrilateral", "remeshing", "arbitrary", "manifold", "Computer", "aid", "Geometric", "Design", "22", "392-423", "loater", "M.S.", "G.", "EIMERS", "M.", "2005", "mean", "value", "coordinate", "3d", "Computer", "aid", "Geometric", "Design", "22", "623", "631", "loater", "M.", "S.", "ORMANN", "K.", "2005", "surface", "parameterization", "tutorial", "survey", "advance", "multiresolution", "geometric", "modeling", "157-186", "uang", "J.", "hus", "X.", "IU", "X.", "HOU", "K.", "EI", "L.-Y.", "ENG", "S.-H.", "ao", "H.", "UO", "B.", "hum", "h.-y", "2006", "subspace", "gradient", "domain", "mesh", "deformation", "ACM", "Trans", "graph", "25", "11261134", "OSHI", "P.", "EYER", "M.", "OSE", "T.", "REEN", "B.", "ANOCKI", "T.", "2007", "harmonic", "coordinate", "character", "articulation", "ACM", "Trans", "graph", "26", "71", "T.", "chaefer", "S.", "ARREN", "J.", "2005", "mean", "value", "coordinate", "closed", "triangular", "mesh", "ACM", "Trans", "graph", "24", "561-566", "YTHE", "K.", "P.", "1995", "introduction", "Boundary", "element", "method", "crc", "Press", "ipman", "Y.", "OHEN", "D.", "AL", "R.", "EVIN", "D.", "2007", "volume", "shape", "preservation", "via", "move", "frame", "manipulation", "ACM", "Trans", "graph", "26", "ipman", "Y.", "OPF", "J.", "OHEN", "D.", "EVIN", "D.", "2007", "GPU", "assist", "positive", "mean", "value", "coordinate", "mesh", "deformation", "Proc", "Symposium", "Geometry", "Processing", "117-123", "ipman", "Y.", "EVIN", "D.", "ohen", "D.", "2008", "Green", "coordinate", "ACM", "Trans", "graph", "27", "1-10", "ipman", "Y.", "orkine", "O.", "EVIN", "D.", "ohen", "D.", "2005", "linear", "rotation-invariant", "coordinate", "mesh", "ACM", "Trans", "graph", "24", "479-487", "iu", "L.", "HANG", "L.", "Y.", "OTSMAN", "C.", "ORTLER", "S.J.", "local/global", "approach", "mesh", "parameterization", "2008", "Computer", "Graphics", "Forum", "27", "1495-1504", "artin", "S.", "AUFMANN", "P.", "OTSCH", "M.", "ICKE", "M.", "ross", "M.", "Polyhedral", "finite", "element", "use", "harmonic", "basis", "function", "2008", "Computer", "Graphics", "Forum", "27", "1521-1529", "orkine", "O.", "LEXA", "M.", "2007", "as-rigid-as-possible", "surface", "modeling", "Proc", "Symposium", "Geometry", "Processing", "109116", "orkine", "O.", "ohen", "D.", "2004", "least-square", "mesh", "Proc", "shape", "Modeling", "International", "191-199", "orkine", "O.", "OHEN", "D.", "IPMAN", "Y.", "LEXA", "M.", "SSL", "C.", "EIDEL", "H.", "2004", "laplacian", "surface", "editing", "Proc", "Symposium", "Geometry", "Processing", "175-184", "umner", "R.", "W.", "chmid", "J.", "auly", "M.", "2007", "embed", "deformation", "shape", "manipulation", "ACM", "Trans", "graph", "26", "80", "RAGO", "M.", "2000", "Analytical", "integral", "fundamental", "solution", "three-dimensional", "Laplace", "equation", "gradient", "Trans", "Japan", "Soc", "Mech", "Eng", "66", "642", "254-261", "eber", "O.", "orkine", "O.", "IPMAN", "Y.", "OTSMAN", "C.", "2007", "context-aware", "skeletal", "shape", "deformation", "Computer", "Graphics", "Forum", "26", "265-274", "eber", "O.", "EN", "hen", "M.", "OTSMAN", "C.", "2009", "complex", "barycentric", "coordinate", "application", "planar", "shape", "deformation", "Computer", "Graphics", "Forum", "28", "587-597", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009", "Variational", "Harmonic", "Maps", "Space", "Deformation", "34:11", "appendix", "mapping", "mapping", "define", "vertex", "face", "mesh", "respectively", "so", "we", "must", "provide", "each", "face", "scalar", "value", "each", "vertex", "scalar", "value", "value", "determine", "sum", "value", "face", "neighbor", "v.", "give", "point", "face", "-lrb-", "-rrb-", "we", "define", "tetrahedron", "span", "four", "point", "Figure", "15", "-lrb-", "log", "-rrb-", "-lrb-", "-rrb-", "tetrahedron", "??", "sign", "solid", "angle", "point", "subtend", "face", "vol", "its", "signed", "volume", "normalize", "outward", "point", "normal", "area", "face", "t.", "follow", "Urago", "-lsb-", "2000", "-rsb-", "we", "obtain", "-lrb-", "-rrb-", "vol", "-lrb-", "-rrb-", "gradient", "again", "follow", "Urago", "-lsb-", "2000", "-rsb-", "take", "derivative", "??", "??", "-lrb-", "-rrb-", "Hessians", "derive", "hessian", "matrix", "we", "need", "jacobian", "matrix", "gradient", "vector", "??", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-rrb-", "-lsb-", "-rsb-", "??", "where", "give", "vector", "-lsb-", "-rsb-", "skew", "symmetric", "matrix", "any", "vector", "-lsb-", "-rsb-", "v?w", "finally", "hessian", "matrix", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "15", "notation", "definition", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "derivative", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "34", "publication", "date", "August", "2009" ],
  "content" : "\n  \n    73c1065c6e33b168145c75b344507a04beea46d6f86a5afa4c959ef6d008ddf8\n    ouh\n    http://dx.doi.org/10.1145/1576246.1531340\n    Name identification was not possible. \n  \n  \n    \n      \n        Variational Harmonic Maps for Space Deformation\n      \n      Mirela Ben-Chen Ofir Weber Craig Gotsman Technion ? Israel Institute of Technology\n      A space deformation is a mapping from a source region to a target region within Euclidean space, which best satisfies some userspecified constraints. It can be used to deform shapes embedded in the ambient space and represented in various forms ? polygon meshes, point clouds or volumetric data. For a space deformation method to be useful, it should possess some natural properties: e.g. detail preservation, smoothness and intuitive control. A harmonic map from a domain ? ? R d to R d is a mapping whose d components are harmonic functions. Harmonic mappings are smooth and regular, and if their components are coupled in some special way, the mapping can be detail-preserving, making it a natural choice for space deformation applications. The challenge is to find a harmonic mapping of the domain, which will satisfy constraints specified by the user, yet also be detail-preserving, and intuitive to control. We generate harmonic mappings as a linear combination of a set of harmonic basis functions, which have a closed-form expression when the source region boundary is piecewise linear. This is done by defining an energy functional of the mapping, and minimizing it within the linear span of these basis functions. The resulting mapping is harmonic, and a natural \"As-Rigid-As-Possible\" deformation of the source region. Unlike other space deformation methods, our approach does not require an explicit discretization of the domain. It is shown to be much more efficient, yet generate comparable deformations to state-ofthe-art methods. We describe an optimization algorithm to minimize the deformation energy, which is robust, provably convergent, and easy to implement.\n      CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling Keywords: Space deformation, harmonic maps, shape editing\n    \n    \n      \n        1 Introduction\n      \n      Space deformation methods deform the ambient space in which a shape is embedded, instead of explicitly deforming the shape itself. Such methods have become popular in recent years [Huang et al. 2006; Lipman et al. 2007b; Joshi et al. 2007, Lipman et al. 2008; Sumner et al. 2007; Botsch et al. 2007], for several reasons. First, they are more general than explicit deformation ? space deformation can be applied to any shape representation, whether it is a polygonal mesh, a point cloud or volumetric data. ________________________\n      \n        ACM Reference Format\n      \n      Ben-Chen, M., Weber, O., Gotsman, C. 2009. Variational Harmonic Maps for Space Deformation. ACM Trans. Graph. 28, 3, Article 34 (August 2009), 11 pages. DOI = 10.1145/1531326.1531340 http://doi.acm.org/10.1145/1531326.1531340.\n      \n        Copyright Notice\n      \n      Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the fi rst page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2009 ACM 0730-0301/2009/03-ART34 $10.00 DOI 10.1145/1531326.1531340 http://doi.acm.org/10.1145/1531326.1531340\n      \n        \n        Figure 1: The Beast model enclosed in its cage (left) and its deformation using a variational harmonic map (right)\n      \n      Second, by deforming the ambient space, the computational complexity of the deformation is decoupled from the complexity of the shape, hence even extremely complex shapes can be deformed at interactive rates. Some space deformation methods [Lipman et al. 2007b; Joshi et al. 2007; Lipman et al. 2008] are \"cage-based\". In these methods, a given \"source cage\" is manipulated by the user to create a \"target cage\". Then, based on the source and target cages, a mapping of the source cage is defined. If the mapping function has a closed-form expression, the deformation method becomes accurate and efficient. On the other hand, manipulating a cage is a tedious and time-consuming task. A more user-friendly and natural deformation method is direct manipulation ? the user positions a small number of \"control points\" inside the domain, and manipulates them instead of the cage. Such methods [Huang et al. 2006; Sumner et al. 2007; Botsch et al. 2007] define the space deformation on a domain which is coarser than the input shape, and solve an optimization problem to find the parameters of the deformation, given the user's constraints. As this optimization problem is generally non-linear, the robustness and efficiency of these algorithms depend critically on the formulation of the deformation, and the optimization method used.  We propose to use harmonic maps of the source region as the underlying deformation model. Since harmonic functions are smooth and regular, they are used for a wide range of applications, from parameterization [Floater and Hormann 2005] and remeshing [Dong et al. 2005] to space deformations [Joshi et al. 2007; Lipman et al. 2008]. We generate harmonic maps on the domain as a linear combination of harmonic basis functions. In the special case that the domain is a polyhedron, these basis functions, and their first and second derivatives, will have closed-form expressions, as will the harmonic maps. Using these expressions, we allow the user to place position and orientation constraints at arbitrary locations inside the domain and define an energy functional which depends also on these constraints. By defining additional \"rigidity lines\" in a semi-automatic way, the resulting deformation is a natural \"As-Rigid-As-Possible\" deformation of the shape, respecting the specified constraints. It is worth noting that our harmonic basis functions are a variant of the \"Green coordinates\" of Lipman et al. [2008] (and Weber et al. [2009]), however, we give simpler expressions for them, and also provide their first and second derivatives.\n      ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n      34:2 ? M. Ben-Chen et al.\n      \n        1.1 Contribution\n        Our main contribution is a robust and very efficient space deformation method, which provides some advantages over existing methods. First, the user manipulates a set of position and orientation constraints, instead of directly manipulating the \"source cage\", hence our method is more intuitive and easy to control. Second, we have a closed-form expression a linear combination of basis functions for the deformation of a continuous domain, thus do not require a voxelization of the input domain, as some other methods do. And finally, since we have closed-form expressions also for the gradients of the deformation, our optimization procedure may be based on an alternating least-squares \"local/global\" algorithm, which, until now, was applicable only in discrete mesh-based settings. This optimization method is extremely efficient, as its computational complexity is dominated by matrix-vector multiplications using pre-computed matrices, thus may also be easily implemented on the GPU. In addition, it is quite simple to implement, and guaranteed to converge.\n      \n      \n        1.2 Previous Work\n        Shape deformation is one of the most active research subjects in computer graphics, and a thorough review of all the recent work is outside the scope of this paper. We shall thus concentrate on the space deformation methods most relevant to our work. In general, these methods can be classified into two major groups ? \"cagebased\" deformation, and direct manipulation deformation.  In \"cage-based\" deformation, the user specifies the boundary of a relevant region of space ? the source \"cage\" ? which contains the input shape. The cage is typically a piecewise-linear closed surface. The user then manipulates the vertices of this cage to generate a target cage and the deformation is defined by the relationship between these two cages. Cage-based methods are closely related to barycentric coordinates, as typically the deformation is defined as a linear combination of the vertices of the target cage with a set of barycentric coordinate functions defined on the input cage. Since these barycentric coordinate functions depend only on the source cage, they can be pre-computed making for a very efficient method, as the deformation then requires only a matrix-vector multiplication. One of the first such methods [Huang et al. 2006] used mean-value coordinates [Floater et al. 2005; Ju et al. 2005] as the coordinate functions. Unfortunately, mean-value coordinates are not guaranteed to be positive inside the domain unless it is convex. This causes severe artifacts in the resulting deformation. Later methods [Joshi et al. 2007] suggested using harmonic coordinates instead, as these are guaranteed to be positive inside the domain. However, harmonic coordinates are the solution of a Dirichlet problem on the boundary of the domain, and they do not have a closed form expression. Thus, computing these coordinates is not easy. Recently, Lipman et al. [2008] showed how to define two sets of coordinate functions ? Green coordinates, which have closed-form expressions, and result in detail-preserving mappings. Later, Weber et al. [2009] showed that these coordinates in twodimensions are a special case of complex-valued barycentric coordinates, and may be derived from the celebrated Cauchy integral theorem. They called them Cauchy-Green coordinates. All the cage-based methods have a common disadvantage ? detailed deformations are possible only with relatively complex cages, and such cages ? even with a few hundred faces ? are extremely hard to manipulate in order to generate a satisfying result. To overcome this problem, Weber et al. [2009] proposed something similar in spirit to our method: use the complex Cauchy-Green coordinates as conformal basis functions, and find the new cage location by solving an optimization problem derived from position constraints supplied by the user. Although their method is quite effective, the complex conformal formulation applies only to planar deformation. Our method can be considered as a generalization of Weber et al. [2009] to three dimensions, and R d in general. But there is a major difference between the two methods. We use harmonic mappings as basis functions instead of conformal functions, since complex holomorphic functions (which in two dimensions generate conformal maps) do not have a simple generalization to three dimensions. As a result, in order to achieve detail-preservation, we need to solve a non-linear minimization problem, whereas in Weber et al. [2009] the optimization required the solution of a linear system. It is worth noting that all previous methods [Joshi et al. 2007; Lipman et al. 2008; Weber et al. 2009] use harmonic maps of some sort as their underlying deformation function. Harmonic coordinates use independent harmonic functions for each coordinate, thus are able to enforce an exact interpolation of the target cage. However, this is both hard to compute, and causes serious shearing effects. Cauchy-Green coordinates in two dimensions [Lipman et al. 2008; Weber et al. 2009] enforce conformal maps ? harmonic maps, whose two components have orthogonal gradients with equal norm. Green coordinates in three dimensions use the vertices of the target cage and its normals as the coefficients of a linear combination of the harmonic basis functions. From this point of view, our framework is a generalization of all those coordinates ? we seek a harmonic map, but instead of predefining the relationship between its components, the relationship is derived implicitly by minimizing an energy functional. Two other recent space-deformation methods which solve a nonlinear optimization problem given positional constraints are those of Sumner et al. [2007] and Botsch et al. [2007]. In Sumner et al [2007], the deformation is defined using a deformation graph, which is automatically computed from the input shape. An affine transformation is associated with each node in the deformation graph, which describes the transformation this node undergoes. These transformations are the variables of an energy function ? which forces them to be rigid and have a smooth behavior. Minimizing this energy, combined with the position constraints imposed by the user, generates the deformation parameters of the deformation graph. The deformation of a point in the ambient space is then computed from the transformations of nodes in the deformation graph, which are close in Euclidean distance to this point. There are two disadvantages of this method compared to ours ? first, the deformation graph is not a cage, in the sense that the deformation function is computed based on Euclidean distances. This causes artifacts when deforming a shape which has pieces which are close to each other in Euclidean distance, but far apart in geodesic distance, for example, fingers of a hand. In addition, the smoothness of the deformation is enforced discretely, by requiring neighboring faces of the deformation graph to have similar transformations. In our setting, we have a closed-form expression for the second derivatives of the deformation, and we require these to vanish on the boundary of the domain, hence the regularization term of the energy is more robust. A similar method is that of Botsch et al. [2007], where the deformation is defined on a voxelization of the input region. Here the deformation is also computed by solving a non-linear optimization problem using a multi-grid framework. This method suffers from some aliasing effects due to the discretization, and in addition its implementation is somewhat involved. Comparisons of the results of our method with the methods of Sumner et al. and Botsch et al. will be presented in the Section 4. Other direct surface manipulation techniques exist, such as such as those of Sorkine et al. [2004], Lipman et al. [2005] and Sorkine and Alexa [2007], to mention only a few. However, as these methods work directly on the surface of a manifold mesh, they are somewhat limited, and cannot be applied to other shape representations, such as polygon soups or point clouds. Our formulation of the deformation mapping is based on Green's third identity, which relates the values of a harmonic function on the boundary of a region to its values inside the region. This is closely related both to the Green coordinates defined by Lipman et al. [2008], and to a common method for solving boundaryvalue problems known as the ?Boundary Element Method\" or BEM [Kythe 1995]. BEM has been used, for example, by Martin et al. [2008] to discretize harmonic basis functions for polyhedral finite elements. Despite the common mathematical machinery, our approach is somewhat different from both these methods. In the BEM framework, one seeks a harmonic function on the domain having some given boundary values, whereas we seek a harmonic map which minimizes a given functional. In the Green coordinates setting, the boundary mapping functions are set to be the \"target cage\" and its normal vectors, where as in our setting the boundary mapping functions are variables in an optimization problem.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        Variational Harmonic Maps for Space Deformation ? 34:3\n      \n      \n        1.3 Method Overview\n        Before diving into the underlying mathematics, we present a brief overview of our deformation method. The input is a polyhedral cage enclosing some region of interest, and a set of position and orientation constraints on a number of points within the cage. The output is a harmonic deformation mapping f, which maps every point in the input cage to some point in R 3 .  As will be explained in the next section, the deformation mapping is uniquely defined by two functions, a and b, defined on the vertices and faces of the cage, respectively. In order to find a and b, we pose an optimization problem where the discrete values of a and b are the variables. The goal of the optimization problem is to minimize an energy functional which requires detail preservation and smoothness, while enforcing the user's constraints. In the discrete setting, our method is somewhat similar to solving for the locations of the vertices of the target cage, using the Green coordinates [Lipman et al. 2008] deformation method. Thus, the function a is analogous to the vertex locations of the target cage, and b is analogous to the normals to the faces. However, there is an important difference ? in our setup, the functions a and b are independent, whereas in the Green Coordinates setup, b (the normals to the faces of the target cage) are uniquely defined by a (the vertices of the target cage). Hence, we have more degrees of freedom, and a larger space of possible deformations. The rest of the paper is organized as follows. In the following section we define the deformation mapping, first considering a general (continuous) domain in R d as the cage, and then specializing it to the case where the cage is a polyhedron. We proceed by defining the energy functional, and posing the optimization problem. In Section 3 we discuss our optimization procedure, and its convergence properties. Experimental results and comparisons with state-of-the-art methods are presented in Section 4. We conclude with a discussion and some future research directions in Section 5.\n      \n      \n        2 Variational Harmonic Maps\n        Given the input domain ? the region of space in which our shape lies, we consider all possible harmonic mappings of this domain.  Within this large space of possible deformations, we will choose the harmonic map which both satisfies the user's constraints, and preserves detail as much as possible. We begin by describing our deformation mapping, first for a general domain, and then for a domain with a piecewise-linear (polyhedral) boundary. Once the deformation mapping is established, we will discuss the energy functional.\n      \n      \n        2.1 Harmonic Maps from Boundary Functions\n        Let ? be an open region of R d with a smooth boundary S, and let f be a continuous function from ? to R d . For example, for d = 3, f = (u(x,y,z), v(x,y,z), w(x,y,z)). We say that f is a harmonic map if each of its d components are harmonic functions from ? to R. Specifically, in three dimensions, f is a harmonic map if: ? p = ( x , y , z ) ? ? , ? 2 u ( p ) = 0, ? 2 v ( p ) = 0, ? 2 w ( p ) = 0 where ? 2 is the Laplacian operator: ? 2 u ( x , y , z ) = ? 2 u + ? 2 u + ? 2 u ? x 2 ? y 2 ? z 2 Since the Laplacian is a linear operator, harmonic mappings form a linear subspace of functions from R d to R d . We would like to select a mapping from this linear space, which both satisfies the user's constraints and is detail-preserving. However, using the current formulation, it is not obvious how to find such a mapping. Fortunately, all harmonic maps on ? can be generated by integrating two smooth maps defined on S=??, (the boundary of ?) with two special functions. This is formalized in the following theorem. Theorem: The mapping f : ? ? R d is a harmonic mapping if and only if there exist two C 2 mappings a and b: a,b: S ? R d such that\n        \n          1\n          f ( p ) = ? a ( q )( ? G ( q , p ) ? n ? ( q )) dA ? ? b ( q ) G ( q , p ) dA q ? S q ? S\n        \n        where G(p,q) is the fundamental solution of the Laplace equation in R d and n ?( q ) is the unit normal direction to the surface S=?? at the point q.  Proof: Let us concentrate on the case d = 3. Then G(p,q) = 1/(4?|p-q|). It is straightforward to see that f as defined in (1) is a harmonic mapping by taking the derivative relative to p under the integral sign. Let us consider the second integral ? the mapping b is defined on S, hence does not depend on p. So: ? 2 ( b ( q ) G ( q , p ) ) = b ( q ) ? 2 G ( q , p ) G is a solution to the Laplace equation, hence harmonic: ? 2 ( b ( q ) G ( q , p ) ) = 0 . Similarly, for the first integral ? a is defined on the boundary and does not depend on p. So, we have: ? 2 ( a ( q )( ? G ( q , p ) ? n ? ( q )) ) = a ( q ) ? 2 ( ? G ( q , p ) ? n ? ( q ) ) = a ( q ) ? 2 ( G x n x + G y n y + G z n z ) where G x = ?G/?x, and so on, and n ?( q ) =(n x ,n y ,n z ). Since G is harmonic, all its partial derivatives G x , G y and G z are harmonic functions. In addition, the normal to the surface does not depend on p, so its dot product with ?G is just a linear combination of harmonic functions, which is again a harmonic function. The opposite direction is due to Green's third identity, which guarantees that any harmonic scalar function u satisfies:\n        \n          2\n          u ( p ) = ? u ( q )( ? G ( q , p ) ? n ? ( q )) dA ? ? ( ? u ( q ) ? n ? ( q )) G ( q , p ) dA q ? S q ? S\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        34:4 ? M. Ben-Chen et al.\n        for any point p ? ?. This is true for all the d components of f. Hence, taking a ( q ) = f ( q ) b ( q ) = J f ( q ) ? n ? ( q ) where J f (q) is the Jacobian of f at q, completes the proof. ? We will now use Eq. (1) to define our deformation mapping.\n        The continuous deformation mapping. The fundamental solution G(q,p) to the Laplace equation has a closed-form expression for any dimension d. We define the following two scalar kernel functions: ? ? , ? ? : ( S ? ? ) ? R ? ? ( q , p ) = G ( q , p ) ? ? ( q , p ) = ? G ( q , p ) ? n ? ( q ) Given two smooth mappings a,b : S ? R d , we define the deformation mapping f: ? ? R d to be f a , b ( p ) = ? a ( q ) ? ? ( q , p ) dA ? ? b ( q ) ? ? ( q , p ) dA q ? S q ? S In this way we are able to represent f a,b at any point of the domain as boundary integrals of the kernel functions with a and b. By the Theorem, the deformation mapping spans the linear space of all harmonic mappings on ?, through the mappings a and b on S. Since a and b do not depend on p, we can also obtain expressions for the partial derivatives of the mapping. For example: ? f a ? , b x ( p ) = q ? ? S a ( q ) ?? ? ( ? q x , p ) dA ? q ? ? S b ( q ) ?? ? ( ? q x , p ) dA Similar expressions may be derived for any partial or higher order derivatives of f. Note that both the deformation mapping, and its derivatives, are linear in a and b. Using the deformation mapping and its derivatives, we will later define an energy functional E(f a,b ) and the final deformation of a point p ? ? will be f a ', b ' ( p ) where ( a ', b ') = arg min( E ( f a , b )) Before defining the energy functional, we first show how the deformation mapping can be simplified in the special case that the source region is polyhedral.  The discrete deformation mapping. In the most general setup, the domain ?, and the boundary mappings a and b, can be arbitrary. However, deformation applications usually bound ? with a piecewise linear surface ? meaning the deformed shape is contained in a d-dimensional polyhedron. In addition, we would like to restrict a and b to be of specific types, so that we can find closed expressions for the integrals of ? ? and ? ? on the faces of the cage, and for their derivatives. Note, that if a and b are restricted to a specific family of functions, one direction of the Theorem is not true anymore, and we cannot generate all harmonic mappings on ? using (1) anymore. When choosing the families that a and b belong to, we have to make sure the identity mapping f(p) = p, and, more generally, any affine mapping f(p) = Ap + T (where A is an d?d matrix, and T is a vector), are still obtainable by (1). In this case we should use: a ( q ) = Aq + T b ( q ) = A ? n ? ( q ) Hence, for a piecewise-linear cage, a can be restricted to be piecewise-linear on S. Since a piecewise-linear surface has piecewiseconstant normals, b can be restricted to be piecewise-constant. These are the simplest families for a and b. Of course, one could use higher degree polynomials, but then the expressions for the integrals of ? ? and ? ? will be more complicated. We will discuss now specifically the three-dimensional case for a region ? bounded by a triangle mesh S = (V, F), V are the vertices of S and F are its faces. As mentioned, a and b are not arbitrary mappings anymore ? a is the piecewise-linear map on S defined by values at the vertices {a v ? R 3 | v ? V}, and b is the piecewise constant map defined by values at the faces {b t ? R 3 | t ? F}. In this case, our deformation map becomes: f a , b ( p ) = ? ? a ( q ) ? ? ( q , p ) dA ? ? ? b t ? ? ( q , p ) dA t ? F q ? t t ? F q ? t Here, a(q) is the piecewise linear interpolation of the values a i , a j , a k on the vertices of the triangle t = (i,j,k) ? F. Precisely this equation was considered by Lipman et al [2008], and the analytic solutions of the integrals were given. However, we prefer to use different expressions, which were developed in the context of boundary element methods by Urago [2000]. These expressions have a somewhat geometric interpretation, and their derivatives are easier to compute. The analytic solutions of the integrals allow us to express f using two sets of scalar functions { ? v ( p ) : ? ? R | v ? V}, and { ? t ( p ) : ? ? R | t ? F}. Using these functions, the deformation map can be expressed as: f a , b ( p ) = ? a v ? v ( p ) + ? b t ? t ( p ) v ? V t ? F The expressions for ? v and ? t , their gradient vectors and Hessian matrices are given in Appendix A. Figure 2 shows an example of such a deformation, given specific mappings a and b on S. Given a point p, we can write its deformation mapping in matrix notation as follows:\n        \n          \n          Figure 2 : Deformation of a range-scanned model (polygon soup) using our harmonic mapping. (Right) Source model enclosed in its cage. (Left) Deformed model.\n        \n        \n          3\n          ( f a , b ( p ) ) 1 ? 3 = ( ? 1 ? n ? 1 ? m ) ? ? ? b a n ? 3 ? ? ?\n        \n        where n is the number of vertices, m is the number of faces, ? is the row vector whose entries are ? i (p), ? is the row vector whose entries are ? i (p), a is the matrix whose i-th row is a i , and similarly for b . The transpose of the Jacobian of the deformation at the point p is:\n        \n          4\n          ( J f ( p ) ) T 3 ? 3 = ( ( G ? ) 3 ? n ( G ? ) 3 ? m ) ? ? ? b a n ? ? 3 ? ? ?\n        \n        where G ? is a matrix whose i-th column is the gradient of ? i (p), and similarly for G ? . The Hessian of the deformation at the point p is:\n        \n          5\n          ( H f ( p ) ) 5 ? 3 = ( ( H ? ) 5 ? n ( H ? ) 5 ? m ) ? ? ? b a n ? ? 3 ? ? ?\n        \n        If p = (x,y,z), and f a,b (p) = (u(x,y,z),v(x,y,z),w(x,y,z)), then the Hessian of u contains 9 values, of which only 6 are independent, due to the symmetry of the Hessian. In addition, since u is harmonic, u zz =-u xx -u yy so there are actually only 5 linearly independent values in the Hessian. These five values are present in the first column of H f (p). The second and third columns hold the relevant  Hessian values of v and w. H ? is a matrix whose i-th column holds the respective five values from the Hessian of ? i (p), and similarly for H ? . In many cases, the shape to be deformed is accompanied by normal vectors. For example, a point cloud which has a normal associated with every point, or a triangulated mesh which contains the normals of the original surface. In these cases, we would like to deform the normals as well as the shape. We can do this by deforming the plane which is orthogonal to the normal vector at the point p ? ?. Given two vectors n 1 (p) and n 2 (p), which span the plane orthogonal to n ?( p ) , we have: f a , b ( n ? ( p ) ) = n 1 ? n 2 = ( J f ( p ) n 1 ( p ) ) ? ( J f ( p ) n 2 ( p ) ) where 1 and 2 span the deformed plane. Plugging this back into the expression for the Jacobian matrix in (4): n 1 T ( p ) = n 1 T ( p ) ( G ? G ? ) ? ? ? a b ? ? ? and similarly for n 2 . Hence, we can pre-compute the relevant matrices:\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        Variational Harmonic Maps for Space Deformation ? 34:5\n        \n          6\n          ? ? ? n n 1 2 T T ( ( p p ) ) ? ? ? 2 ? 3 = ( ( N ? ) 2 ? n ( N ? ) 2 ? m ) ? ? ? b a n ? ? 3 ? ? ? where N ? is a matrix whose i -th column holds the dot product of ?? i ( p ) with n 1 ( p ) and n 2 ( p ), and the same for N ? .\n        \n        Equipped with the deformation mapping and its first and second derivatives, we can proceed to define our energy functional, and show how to use it to find the mappings a and b .\n      \n      \n        2.2 The Energy Functional\n        Our energy functional is similar to functionals which were used previously in ?As-Rigid-As-Possible? deformation applications [Sorkine and Alexa 2007; Sumner et al 2007; Botsch et al 2007]. It attempts to satisfy the constraints specified by the user and, in addition, balance detail preservation with smoothness.  User constraints. As our deformation mapping f is defined everywhere in ?, the user can choose a set of r points q i ? ?, and a set of s points t i ? ?, and specify their target positions f ( q i ) = f i , and their Jacobians J f ( t i ) = g i . The Jacobian constraints can be used to prescribe the orientation of the points t i , or any other affine transform on these points. For example, in Figure 3 we have prescribed a set of position constraints, and a Jacobian constraint in the marked location, requiring its affine transform to be a small scale. This allowed us to easily generate the muscle \"bulge\" effect seen in the figure. The position and Jacobian constraints are hard constraints in our optimization process. Detail vs. volume preservation. It is well known that the details of a shape at a point in space are preserved during a deformation if the local transformation that point undergoes is close to rigid. This fact has been used in many As-Rigid-As-Possible deformation methods [Botsch et al. 2007; Sumner et al. 2007; Sorkine and Alexa 2007]. However, recently Lipman et al. [2007a], have shown that detail preservation might come at the expense of volume preservation. In fact, in order to preserve the volume, Lipman et al. [2007a] scaled the transformations, according to local curvature information. Hence, requiring the Jacobians of all the points in the domain to be rotations, will not necessarily give the desired effect, and might result in volume loss. However, in an As-Rigid-As-Possible deformation, it is reasonable to assume that the points on the medial axis of the domain, which is a very sparse subset of the domain itself, undergo only rotations. For example, consider Figure 4 . The figure illustrates the character of the deformation of a bar to an upside-down \"U\" shape, similar to the deformations in Figure 8 . This deformation is almost volume preserving, as its relative change in volume is 0.04. The figure color-codes the determinant and condition number of the Jacobian of the deformation on a vertical slice through the shape. The determinant indicates the local change in volume, and the condition number (? max /? min ) indicates the amount of nonuniform scale. As evident in the figure, the volume on the top of the bar increases, the volume on the bottom the bar decreases, but the medial axis of the bar is only bent ? the volume near it remains constant. In addition, the condition number is closest to 1 near the medial axis, which indicates that the transformations in this area are close to rotations. In our setting, the local transformation of a point p is simply the Jacobian matrix of f a,b at p . Since we can prescribe the Jacobians of the deformation in any location we choose, we prescribe the Jacobians of the medial axis to be as close as possible to rotations. This way we don't need to compute the desired transformations on the boundary of the domain, as they will be implied from the smoothness of the deformation. The values of these rotations are not known in advance, and will be computed as part of the optimization process. Hence, we would like to minimize the following rigidity energy: 2 a , min b , R ( ? ) E Rigid ( f a , b ) = ? J f ( p ) ? R ( p ) F d ? p ? M ( ? ) s . t . ? p ? M ( ? ) R ( p ) T R ( p ) = I The Rigidity Energy where M (?) is the medial axis of the domain and the norm is the Frobenius matrix norm. The Jacobian is linear in the variables a and b , hence if we knew which rotations R ( p ) each point should undergo, minimizing E Rigid would be a simple matter of minimizing a quadratic energy. Of course, R ( p ) are not known in advance, hence the optimization process is non-linear. Smoothness. The local transformation of a point p ? ? is governed by the Jacobian of the mapping f at p . A smooth deformation will have similar transformations for nearby points, and hence a small second derivative. So, to enforce smoothness, we require the Frobenius norm of the Hessian matrix of each of the deformation mapping components to be as small as possible, by minimizing the following energy: 2 min a , b E Smooth ( f a , b ) = ? H f ( p ) F d ? p ? ? This energy can be simplified using the following observation. Our mapping is harmonic, and hence all the partial and higher derivatives of all its components are also harmonic. According to the maximum principle, a harmonic function on a domain achieves its extremum on the boundary of the domain. Hence, if we minimize the second derivatives on the boundary of the domain, they will also be bounded inside the domain. As a result, we may use the following smoothness energy: 2 min a , b E Smooth ( f a , b ) = ? H f ( p ) F ds p ? S The Smoothness Energy The energy. Given the points q i and t i chosen by the user, and their target positions f i and target Jacobians g i respectively, we would like to solve the following optimization problem: a , min b , R ( p ) E ( f a , b ) = ? J f ( p ) ? R ( p ) 2 F d ? + ? 2 ? H f ( p ) 2 F ds p ? M ( ? ) p ? S s . t . ? i = 1.. r , f a , b ( q i ) = f i , ? i = 1.. s , J f ( t i ) = g i ? p ? M ( ? ), R ( p ) T R ( p ) = I The Continuous Optimization Problem where the norms are Frobenius norms, and R(p) are unknown 3?3 matrices defined on every point p on the medial axis of ?. The discrete energy. Minimizing the energy functional in its current form is difficult, because of the non-linearity of the rotation constraints, and because we do not have closed-form expressions neither for the medial axis, nor for the integrals. Instead, we convert the integrals to a sum of finite samples, as follows. For the smoothness energy, we sample the boundary surface S at k points w i . For the rigidity energy we approximate the medial axis, by sample points on a set of rigidity lines. These lines can be acquired from a skeleton of the deformed shape if it is available, can be prescribed manually by the user, or can be computed using a skeleton extraction algorithm, such as that of Au et al. [2008]. Once l such lines are given, we sample them at d anchor points m i , by sampling d/l points on each rigidity line. Since we require smoothness, it is sufficient for the anchor points to be sparsely distributed, so d can be relatively small. The assumption that a sparse set of rigidity constraints is enough when the deformation is smooth has been used successfully in other deformation methods [Weber et al. 2007; Sorkine and Cohen-Or 2004]. Consequently, we only have d unknown rotation matrices R i to solve for. In this setting the optimization problem becomes: a min , b , R i E ( f a , b ) = ? i d = 1 J f ( m i ) ? R i 2 F + ? 2 ? i = k 1 H f ( w i ) 2 F s . t . ? i = 1.. r , f a , b ( q i ) = f i , ? i = 1.. s , J f ( t i ) = g i ? i = 1.. d , R i T R i = I (P1): The Discrete Optimization Problem  Figure 5 shows a comparison of results using a different number of anchor points for the rigidity constraints. The locations of the anchor points were computed using the skeleton extraction algorithm by Au et al. [2008]. As is evident from the figure, increasing the number of anchors beyond a given point does not significantly improve the results.\n        \n          \n          Figure 3: Generating a realistic muscle \"bulge\" effect by placing a single Jacobian constraint near the marked area, and requiring it to scale. In addition to the Jacobian constraints, we have also placed position constraints causing the hand to rotate.\n        \n        \n          \n          \n          Figure 4: The character of the Jacobian of the deformation within one slice through a vertical bar model, bent to a \"U\" shape. (left) Color-coding of the condition number. (right) Color-coding of the determinant.\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        34:6 ? M. Ben-Chen et al.\n        \n          \n          Figure 5: Deformation using a different number of anchor points.\n        \n        The leg of the armadillo model (left) was deformed to a bent position, using the specified number of anchor points. The top and bottom rows show different views of the same deformed shape. The source pose shows the five user constraints ? red spheres are positional constraints, and black cylinders are orientation constraints.\n         Figure 6 shows two deformations of the \"Armadillo\" model. In addition, the figure shows the setup for the deformation ? the cage, the original pose, the anchor points and the constraints.\n        (a)\n        (b)\n        (c)\n        (d)\n        (e)\n        \n          \n          Figure 6: Deformations of the Armadillo model (a) Cage and anchor locations (b) Original pose and constraints (c) Deformed pose (d,e) Another deformed pose from two different viewpoints\n        \n        In the following section we describe our optimization scheme for minimizing the deformation energy.\n      \n      \n        3 Optimization\n        To solve the optimization problem (P1) we use the following observation. If the variables R i are known, then (P1) is a simple linear least-squares problem with linear equality constraints, which has a closed-form global minimum. On the other hand, if a and b are known, then the optimal rotation matrices R i ? those which are closest in Frobenius norm to the Jacobians of the deformation map at m i also have a closed-form solution. This solution is a variant of the well-known ?Procrustes problem?, obtained using Singular Value Decomposition (SVD). Hence, we can solve (P1) using the alternating least squares method, or \"local/global\" algorithm [Liu et al 2008; Sorkine and Alexa 2007]. In the \"local\" step, we keep a and b fixed, and solve many small and independent local problems for the R i , while in the \"global\" step, we keep R i fixed and solve one global linear system for a and b. We repeat these two steps until convergence.  Convergence and robustness. As was pointed out in previous works [Liu et al 2008; Sorkine and Alexa 2007], the \"local/global\" algorithm is guaranteed to converge, because each step must reduce the energy. In general, the convergence rate depends on the initial configuration. However, since the number of variables is relatively small ? the number of anchors for the Jacobian computation is usually smaller than the complexity of the cage ? the \"local/global\" algorithm is robust enough to converge to a good solution from an arbitrary initial configuration. By ?arbitrary? we mean that the Jacobians are initialized to be random 3?3 matrices.  Figure 7 shows the resulting deformation after various numbers of iterations, starting from an arbitrary configuration. In addition, it shows graphs of the value of the energy functional vs. the iteration number using different initial configurations. As can be seen from the graph, our method always converged to the same solution, no matter which initial configuration was used. In an interactive modeling environment, the initial configuration can be taken from the values of a,b and R i in the previous frame. In this case, a small number of iterations of the \"local/global\" algorithm are usually enough to achieve convergence. This is the initial configuration we used for all the examples in the paper, except the ones in Figure 7 . In Section 4 we provide some more deformation examples, with the timings required to generate them. Let us now turn to a more detailed description of the minimization process. Implementation details. Using the \"local/global\" approach, the deformation algorithm is relatively simple to implement, and boils down to three steps ? the preprocessing step, during which some matrices are pre-computed for later use, the optimization step, where we iterate the \"local/global\" steps to find the values of R i , and, finally, the deformation step, during which the values of R i are combined with the user's constraints to generate the final mapping of the input shape. These steps are implemented as a series of matrix operations, on matrices which are \"stacked\" matrices of ?, ? and their derivatives. To avoid clutter in the notation, we redefine (3), (4) and (5) in terms of single matrices as follows: f a , b ( p ) = D p z , J f ( p ) = J p z , H f ( p ) = H p z where each matrix represents a concatenation of matrices from (3), (4) and (5) respectively: D p = [?, ?], J p = [G ? , G ? ], H p = [H ? , H ? ]. In addition, a is a matrix of size n?3, and b is a matrix of size m?3 (where n and m are the number of vertices and faces respectively). z is the matrix whose first n rows are a, and last m rows are b. Now we can convert the optimization problem to matrix notation using these expressions: min z , R ? E ( f z ) = Jz ? ? R ? 2 F + ? 2 Hz ? 2 F s . t . Dz ? = f ? , Jz = g ? ? i = 1.. d , R i T R i = I where: D ? r ? ( n + m ) = ? ? ? ? D D ... q q 1 r ? ? ? ? J 3 s ? ( n + m ) = ? ? ? ? J J ... t t 1 s ? ? ? ? J ? 3 d ? ( n + m ) = ? ? ? ? J J ... m m d 1 ? ? ? ? H ? 5 k ? ( n + m ) = ? ? ? ? H H ... w w k 1 ? ? ? ? are stacks of deformation, Jacobian and Hessian matrices for the respective points (r position constraints, s orientation constraints, d anchor points and k Hessian sample points on the boundary of the domain), and: f ? r ? 3 = ? ? ? ? ... f f 1 r ? ? ? ? g ? 3 s ? 3 = ? ? ? ? g g ... 1 s ? ? ? ? R ? 3 d ? 3 = ? ? ? ? R R ... d 1 ? ? ? ? are the right hand sides of the linear equations ? the user's position and orientation constraints, and the unknown rotation matrices R i at the anchor points. The energy can now be written as: E = Az ? ? ? ? R 0 ? ? ? ? 2 F , A (3 d + 5 k ) ? ( n + m ) = ? ? ? ? J H ? ? ? ? ? The constant ? determines the relative weight of the smoothness constraints vs. the rigidity constraints. In our experiments, we took ? to be: ? = ? d | J ? | ? | H ? | ? . The matrix norms are infinity norms ? the maximal L 1 norms of the rows of the matrix, and ? is a user specified parameter, which can be used to control the stiffness of the deformation. We took ? to be 0.01 in all of our experiments. Returning to the optimization problem, if R ? is known, then the minimum of E is given by: z opt = A + ? ? ? R 0 ? 5 3 k d ? ? 3 3 ? ? ? , A + = ( A T A ) ? 1 A T Since most of the columns of A + are multiplied by zero on the right hand side, we can truncate its last 5k columns as follows: z opt = A trunc + R ? , A trunc + = ( A T A ) ? 1 A trunc T where A Ttrunc includes only the first 3d columns of A T . We enforce the user's constraints by removing r+3s variables from the problem, and computing their value from the remaining variables using the equations: ? ? ? D J ? ? ? ? z opt = h ? , h ? ( r + 3 s ) ? 3 = ? ? ? g f ? ? ? ? ? This can be done, of course, only if the number of hard constraints is less than the number of degrees of freedom in the problem ? n+m. However, relatively complicated deformations can be generated with a small number of position and orientation constraints. The resulting system is of the type: z opt = B ? ? ? R h ? ? ? ? ? where B is computed from partial matrices of A. During the optimization procedure, we need to re-compute the current Jacobian matrices. Hence, we get: R ? new = C ? ? ? R h ? ? ? ? ? , C = JB ? In addition, once the non-linear iteration has converged, we need to compute the new location of the deformed shape. The new location of the points x 1 ,x 2 ,...,x a are given by: ? ? ? ? x ... x a 1 ? ? ? ? = ? ? ? ? D D ... x x a 1 ? ? ? ? z opt = ? ? ? ? D D ... x x a 1 ? ? ? ? B ? ? ? R ? h opt ? ? ? ? = F ? ? ? R ? h opt ? ? ? ? , F = ? ? ? ? D D ... x x 1 a ? ? ? ? B The matrices C and F are pre-computed before the interactive deformation begins. Thus, we have laid out all the building blocks for our algorithm, which can be stated as follows: Pre-processing. Compute the matrices C and F, given the locations of the user's constraints, the anchor points, the Hessian samples on the boundary and the input shape. Optimization. Select an initial solution z, R ? , and set R ? Global = R ? . Repeat until convergence the following two steps: 1. R ? Local = normalize( R ? Global )\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        Variational Harmonic Maps for Space Deformation ? 34:7\n        \n          \n          Figure 7: The \"local/global\" optimization scheme is robust enough to converge to a good solution from any arbitrary initial configuration. (Left to right) the deformed shape after 1, 3, 17 and 200 iterations, starting from an arbitrary initial configuration. The graphs show the value of the energy functional vs. the number of iterations, starting from different random starting points.\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        34:8 ? M. Ben-Chen et al.\n        \n          7\n          2. R ? Global = C ? ? ? R ? h ? ? ? ?\n        \n        In the local step, the \"normalization\" of the matrices R ? Global is done by computing the SVD for each matrix R i =USV T , and replacing it with UV T , up to a change of sign in the last column of U, if it has a negative determinant. An additional benefit of this local step, is that since Jacobians with negative determinant are not allowed, the optimization process tends to find a minimum which doesn't contain foldovers. Of course, since this might be overridden by the global step, the occurrence of foldovers depends on the user's constraints. In our experience, for a reasonable set of constraints, foldovers are not likely to appear.  We detect convergence by measuring the amount of change in R ? Global between two consecutive iterations, which is equivalent to the change in the rigidity energy. It would be better to measure the change in the total energy, however this is more computationally expensive. The computational complexity of each iteration is the complexity of computing d SVD operations, and a matrix-vector multiplication which is O(d(r+3s+d)). Detailed performance timings are provided in the next section. Note that the computational complexity of both the local and the global shape do not depend on the complexity of the deformed shape, nor on the complexity of the cage. Deformation. If R ? opt is the last R ? Global computed in the optimization step, then the deformed locations are given by:\n        \n          8\n          ? ? ? ... x 1 ? ? ? = F ? ? ? R ? h ? ? ? ?\n        \n        \n          8\n          ? x a ? opt\n        \n        The algorithm can be summed up in a few lines of pseudo-code, outlined in Algorithm 1. The pre-process step requires only vector and matrix operations to set up the matrices, and multiply them. Hence, using any efficient linear algebra package, the implementation is relatively straightforward. We provide runtimes of all the steps of the algorithm, for various 3D models, in the next section. Precompute C,F While (err > threshold) do Js_prev = Js Js = normalize_jacobians(Js) Js = C*[constraints;Js] err = norm(Js_prev ? Js) end new_positions = F*[constraints;Js]\n        Algorithm 1 : Pseudo-code of the deformation algorithm\n      \n      \n        4 Experimental Results\n        We implemented our ?Variational Harmonic Map? (VHM) deformation system as a plugin to the Maya ? commercial modeling and animation system. The optimization and deformation step of VHM include two building blocks ? SVD computations of 3?3 matrices, and dense matrix-vector multiply. Dense matrix-vector multiply operations are \"embarrassingly parallel\" in the sense that they are composed of many independent operations (multiplying one row by one column), which can be performed in parallel. We have exploited this by implementing the computation of Equations (7) and (8) on the GPU. We used Nvidia?s CUDA programming language with the BLAS library, on an Nvidia Quadro FX 5800 graphics card. Figures 1-3, 6-14 and the accompanying  video demonstrate the application of VHM to different deformation scenarios. In this section we will first compare VHM to two other state-of-the-art deformation methods, and then discuss some of its properties. Comparison. We compared the performance of VHM to two state-of-the-art deformation methods: \"Embedded Deformation\" (ED) of Sumner et al. [2007] and \"Adaptive Rigid Cells\" (ARC) of Botsch et al. [2007]. We compared these methods on three deformation scenarios of a synthetic model, and on one deformation of the beast model ? measured by the overall appearance of the deformed shape, the detail preservation and the change in the total volume of the shape. Software was kindly provided by the respective authors. Before starting the comparison we should state upfront some disadvantages of VHM. Its biggest downside, compared to ED and ARC, is that in additional to the shape to be deformed, the user must also supply a cage bounding the domain, and a set of \"rigidity lines\". Although generating the rigidity lines is relatively painless (e.g. using a skeleton extraction algorithm such as [Au et al. 2008]), creating a cage is not a trivial problem, and this is mostly understated in existing cage-based deformation methods. In this respect, methods which automatically generate the underlying space representation ? the deformation graph for ED and the voxelization for ARC, have an advantage. On the other hand, we believe the benefits of having a cage ? a closed form expression for the deformation, faster optimization and separation of unrelated parts of the shape ? outweigh the hassle of generating such a cage.  Figure 8 shows a comparison between VHM, ED and ARC for the \"bar\" shape, with three different deformations. For VHM and ED methods, we used the same constraints. For ARC, we achieved the deformation through interactive manipulation. The results shown for ARC are after the final RBF interpolation step.\n        A B C\n        \n          \n        \n        VHM ARC ED\n        \n          Figure 8: Comparison of our deformation method ? VHM with ARC and ED on three deformations of the \"bar\" model.\n          \n        \n        \n          Figure 9: The setup used for the comparisons in Figure 8 . (top,\n        \n        from left to right) VHM cage and anchors, ARC cells (320) and ED deformation graph (187 vertices). (bottom) The VHM, ARC and ED constraints.\n         Figure 9 shows the setup we used for the deformations in Figure 8 . Figure 10 shows the comparison and setup for the deformation of the beast model. The models were interactively deformed to reach the required pose.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        Variational Harmonic Maps for Space Deformation ? 34:9\n        VHM\n        ARC\n        ED\n        \n          \n          Figure 10: Comparison of our method (VHM) with ARC and ED on a deformation of the \"Beast\" model, and the setup used for the deformation. Small images: (top) VHM cage and anchors, ARC\n        \n        cells (2148) and ED deformation graph (300 vertices), (bottom) the VHM, ARC and ED constraints.\n        \n          \n          Figure 11: Deformation of a tetrahedral mesh model of a hand. One finger is easily moved without influencing the nearby finger, even though it is close in Euclidean distance.\n        \n        To compare the detail preservation of the different models, we computed the rigidity distortion of the triangles of the deformed mesh, which is defined similarly to Liu et al. [2008] as: m m E Rigid = ? t = 1 A t ? ? ? ( ? 1, t ? 1 ) 2 + ( ? 2, t ? 1 ) 2 ? ? ? ? t = 1 A t where A t is the area of the source triangle, and ? 1,t and ? 2,t are the singular values of the Jacobian of the 2?2 transformation, that transforms the source planar triangle to the deformed planar triangle. Ideally, we would like to compare the singular values of the Jacobian of the 3D transformation, but since for the other two methods we do not have access to the actual deformation function, rather only the end result, this is, unfortunately, not easily done. In addition, we compared the change in the total volume of the deformed shape as: E volume = vol new ? vol orig vol orig The comparison of these errors is given in Table 1 . As can be seen from Figures 8 and 10, and Table 1 , the results of VHM are comparable to those of ARC, however VHM is considerably more efficient (as is shown in Table 2 ), and also simpler to implement. When compared to ED, our method is somewhat better, both in the visual quality of the results ? Figure 8 shows that the ED method has some noise issues and in volume preservation. Locality of the deformation. Figure 11 demonstrates that VHM has a local effect, and only regions geodesically close to the manipulated regions are modified, as opposed to unrelated regions which happen to be close in Euclidean distance ? the index finger of the hand may be moved without influencing the other fingers.\n        E rigid E volume\n        \n          \n            \n              \n                \n                   Model\n                   VHM\n                   ARC\n                   ED\n                   VHM\n                   ARC\n                   ED\n                \n              \n              \n                \n                   A\n                   0.050\n                   0.035\n                   0.049\n                   0.086\n                   0.078\n                   0.143\n                \n                \n                   B\n                   0.069\n                   0.070\n                   0.078\n                   0.177\n                   0.116\n                   0.226\n                \n                \n                   C\n                   0.046\n                   0.043\n                   0.053\n                   0.069\n                   0.082\n                   0.118\n                \n                \n                   Beast\n                   0.022\n                   0.013\n                   0.018\n                   0.063\n                   0.025\n                   0.119\n                \n              \n            \n          \n          Model VHM ARC ED VHM ARC ED A 0.050 0.035 0.049 0.086 0.078 0.143 B 0.069 0.070 0.078 0.177 0.116 0.226 C 0.046 0.043 0.053 0.069 0.082 0.118 Beast 0.022 0.013 0.018 0.063 0.025 0.119\n          Table 1: Comparison of the rigidity error and volume change of the deformation methods.\n        \n        \n          \n          Figure 12: (left) Two As-Similar-As-Possible deformations of the\n        \n        Beast model. Note the exaggerated hands and feet.(right) Another ASAP deformation, and the color coding of the condition number of the Jacobian of the deformation, sampled on the input cage. The graph shows the histogram of these values.\n        As-Similar-As-Possible deformations. One of the benefits of our \"local/global\" optimization scheme is that the constraints on the Jacobian matrices of the anchor points can be easily changed from rigidity constraints to other types of constraints, simply by modifying the local step in the optimization algorithm. For example, as was done in previous \"local/global\" based methods, such as [Liu et al. 2008], we can replace the rigidity constraints with similarity constraints by requiring the Jacobian matrices of the anchor points to be similarity transforms. The local step is modified by replacing the \"normalization\" step of the Jacobian matrices with the following procedure: Compute the SVD for each matrix R i =USV T , and replace it with US new V T , where S new is a diagonal matrix, whose entries are the average of the diagonal entries of S. Such a deformation will not be AsRigid-As-Possible anymore, as it introduces uniform scale. However, as can be seen in Figure 12 and in the accompanying video, interesting exaggeration effects can be generated this way. For some applications, one might require the deformation to be quasi-conformal, meaning that the condition number of the Jacobian of the deformation is bounded. In these cases, the AsSimilar-As-Possible approach is more appropriate than the AsRigid-As-Possible approach. Figure 12 shows the color-coding of the condition number of the Jacobian, for sampled points inside the cage of the Beast model, for the shown deformation. In addition, the figure shows the histogram of these values. As is evident from the figure, the condition numbers are smaller than 3.5, which indicates that this deformation is quasi-conformal, with a quasiconformal factor similar to the that of the Green coordinates [Lipman et al. 2008]. The cage. As opposed to direct manipulation methods [Botsch et al. 2007, Sumner et al. 2007], which build the underlying representation automatically, cage based methods such as [Lipman et al. 2008] usually rely on a manually modeled cage. We also use manually modeled cages, but since in our approach the cages are only a mathematical tool, and are not visible to the user, it is important to check how sensitive the deformation is to the cage used. Specifically, we would like to verify that two reasonable cages result in similar deformations, when the user constraints are identical. To investigate this, we implemented a straightforward algorithm to generate a simple cage by uniform decomposition of space, followed by merging neighboring co-planar faces. Such cages would be somewhat hard to manipulate manually, but since in our method the user does not manipulate the cage directly, this is not an issue. We applied this algorithm to the \"Beast\" model from Figure 1 , and using the manually built and automatic cages, we deformed the model interactively. Figure 13 shows the two cages, and the deformations resulting from them. As is evident from the figure, the deformations induced by the two cages are very similar, indicating that our method is not very sensitive to the precise cage used. Non-articulated shapes. Some objects, such as plate-like objects, do not have an obvious skeleton. In these cases, our method can still be applied by placing the anchors on the medial surface instead of on the medial axis. Figure 14 shows two deformation of a \"Bumpy plane\" model, using different anchors configurations. In both cases, the anchors were placed on the medial surface of the model, but their exact placement was different. As the figure shows, the resulting deformations are very similar, indicating that our method is not very sensitive to the exact locations of the anchors on the medial surface. The figure also shows the comparison of the results to the deformation of the same model using the ARC method.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        34:10 ? M. Ben-Chen et al.\n        \n          \n          Figure 13: Two deformations using a manually built cage (left), and an automatic cage (right)\n        \n        VHM\n        VHM\n        ARC\n        \n          \n          Figure 14: Deformation of a plate like object, using two different anchor configurations on the medial surface (left and middle). Deformation using ARC of the same model (right)\n        \n        Efficiency. Table 2 provides the model statistics and the deformation times in milliseconds for our examples. The deformation timing is broken down into the time for one optimization iteration (labeled \"Solve\") and the time for the matrix-vector multiply which generates the deformation (labeled \"Def\"). The preprocessing time for all the models was less than a minute. It is clear from the table that our solve times are considerably faster than those reported for ARC [Botsch et al. 2007] and ED [Sumner et al. 2007], which were run on machines with spec similar to ours. For example, the solve step of ED for the Giraffe model requires 120 msecs, using six Gauss-Newton iterations. Using the ARC method, the solve step for a model with 50,000 vertices requires 330 msecs for a single Newton iteration. For a larger model of 79,000 vertices, the solve step of VHM requires only 12 msecs. The VHM solve includes GPU optimization (for the global part of the \"local/global\" algorithm), whereas the other methods are implemented on the CPU. However, the ARC and ED optimization algorithms are based on Gauss-Newton iterations using a large sparse matrix. Such algorithms are considerably harder to parallelize than dense matrix-vector multiplies, which can be implemented using off-the-shelf CUDA code. Hence, if one is to compare the best possible implementation of the methods, ours has a distinct advantage. The deformation times are also very fast, with 10 msecs for the 170,000 vertex Armadillo model.\n        Model Verts\n        Ancrs Iters\n        \n          \n            \n              \n                \n                  \n                  \n                   Cage\n                  \n                  \n                   Solve\n                   Def\n                   Tot\n                \n              \n              \n                \n                  \n                  \n                   faces\n                  \n                  \n                   (ms)\n                   (ms)\n                   (ms)\n                \n                \n                   Bar\n                   32,908\n                   208\n                   6\n                   15\n                   0.27\n                   1.84\n                   5.89\n                \n                \n                   Tet\n                   28,796\n                   288\n                   28\n                   9\n                   0.43\n                   2.27\n                   6.14\n                \n                \n                   Hand\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                \n                \n                   Giraffe\n                   79,226\n                   204\n                   27\n                   33\n                   0.37\n                   3.08\n                   15.29\n                \n                \n                   Beast\n                   32,311\n                   226\n                   50\n                   10\n                   0.53\n                   2.60\n                   7.90\n                \n                \n                   Arma\n                   28,829\n                   68\n                   6\n                   26\n                   0.27\n                   1.87\n                   8.89\n                \n                \n                   leg\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                \n                \n                   Arma\n                   173,101\n                   250\n                   88\n                   13\n                   0.69\n                   10.60\n                   19.57\n                \n              \n            \n          \n          Solve Def Tot (ms) (ms) (ms) 15 0.27 1.84 5.89 9 0.43 2.27 6.14\n          33 0.37 3.08 15.29 10 0.53 2.60 7.90 26 0.27 1.87 8.89\n          Cage faces Bar 32,908 208 6 Tet 28,796 288 28 Hand Giraffe 79,226 204 27 Beast 32,311 226 50 Arma 28,829 68 6 leg Arma 173,101 250 88\n          13 0.69 10.60 19.57\n          Table 2: Performance measured in msecs on an Intel 2.67GHz i7 machine (using a single thread) with 4GB of RAM. \"Solve\" time for one optimization iteration, \"Def\" time for the matrix multiply in the deformation step. \"Iters\" average number of iterations a typical deformation requires to converge.\n        \n      \n      \n        5 Conclusions and Discussion\n        We have proposed a new space deformation method (?Variational Harmonic Mapping? ? VHM) whose underlying mathematical model is a harmonic mapping. Using this mapping and its derivatives, we defined an energy function whose minimization allows the user to deform the shape using a small number of position and orientation constraints. We showed how to minimize the energy using a very efficient iterative \"local/global\" algorithm and demonstrated that the resulting deformation is close to an As-RigidAs-Possible deformation. Its quality is comparable to state-of-theart space deformation methods, while being considerably faster. In the future we hope to further explore variational harmonic mappings in settings other than deformation. Due to the similarity to boundary element methods (BEM) [Kythe 1995], our method might also be effective in finding solutions to different interpolation problems. Moreover, we would like to investigate the theoretical properties of our deformation, and its relation to quaternionic analytic functions.\n      \n      \n        Acknowledgments\n        We would like to thank Robert Sumner, Mario Botsch, Oscar KinChung Au, Daniel Cohen-Or and Amit Mano for supplying us with their software implementations, Robert Sumner and Mark Pauly for the giraffe model, Autodesk for the Beast model, the AIM@SHAPE project for the Armadillo and hand models, and NVIDIA for the donation of the Quadro graphics card. This work was partially supported by Israel-Niedersachsen (Volkswagen Foundation) grant #ZN2046, the Israel Ministry of Science and the Fund for the Promotion of Research at the Technion.\n      \n      \n        References\n        \n          A U , O. K.-C., T AI , C.-L., C HU , H.-K., C OHEN -O R , D., AND L EE , T.-Y. 2008. Skeleton extraction by mesh contraction. ACM Trans. Graph. 27, 3, 1-10.\n          B OTSCH , M., P AULY , M., W ICKE , M., AND G ROSS , M. 2007. Adaptive space deformations based on rigid cells. Computer Graphics Forum 26, 3, 339-347.\n          D ONG , S., K IRCHER , S., AND G ARLAND , M. 2005. Harmonic functions for quadrilateral remeshing of arbitrary manifolds. Computer Aided Geometric Design 22, 5, 392-423.\n          F LOATER , M.S., K ?S , G., AND R EIMERS , M. 2005. Mean value coordinates in 3D. Computer Aided Geometric Design 22, 7, 623?631.\n          F LOATER , M. S. AND H ORMANN , K. 2005. Surface parameterization: A tutorial and survey. Advances in Multiresolution for Geometric Modeling 157-186.\n          H UANG , J., S HI , X., L IU , X., Z HOU , K., W EI , L.-Y., T ENG , S.-H., B AO , H., G UO , B., AND S HUM , H.-Y. 2006. Subspace gradient domain mesh deformation. ACM Trans. Graph. 25, 3, 11261134.\n          J OSHI , P., M EYER , M., D E R OSE , T., G REEN , B., AND S ANOCKI , T. 2007. Harmonic coordinates for character articulation. ACM Trans. Graph. 26, 3, 71.\n          J U , T., S CHAEFER , S., AND W ARREN , J. 2005. Mean value coordinates for closed triangular meshes. ACM Trans. Graph. 24, 3, 561-566.\n          K YTHE , K., P. 1995. An Introduction to Boundary Element Methods. CRC Press.\n          L IPMAN , Y., C OHEN -O R , D., G AL , R., AND L EVIN , D. 2007. Volume and shape preservation via moving frame manipulation. ACM Trans. Graph. 26, 1, 5.\n          L IPMAN , Y., K OPF , J., C OHEN -O R , D., AND L EVIN , D. 2007. GPU assisted positive mean value coordinates for mesh deformations. In Proc. Symposium on Geometry Processing, 117-123.\n          L IPMAN , Y., L EVIN , D., AND C OHEN -O R , D. 2008. Green coordinates. ACM Trans. Graph. 27, 3, 1-10.\n          L IPMAN , Y., S ORKINE , O., L EVIN , D., AND C OHEN -O R , D. 2005. Linear rotation-invariant coordinates for meshes. ACM Trans. Graph. 24, 3, 479-487.\n          L IU , L., Z HANG , L., X U , Y., G OTSMAN , C., AND G ORTLER , S.J. A local/global approach to mesh parameterization. 2008. Computer Graphics Forum 27, 5, 1495-1504.\n          M ARTIN , S., K AUFMANN , P., B OTSCH , M., W ICKE , M., AND G ROSS , M. Polyhedral finite elements using harmonic basis functions. 2008. Computer Graphics Forum 27, 5, 1521-1529.\n          S ORKINE , O. AND A LEXA , M. 2007. As-rigid-as-possible surface modeling. In Proc. Symposium on Geometry Processing, 109116.\n          S ORKINE , O., AND C OHEN -O R , D. 2004. Least-squares meshes. In Proc. of Shape Modeling International, 191-199.\n          S ORKINE , O., C OHEN -O R , D., L IPMAN , Y., A LEXA , M., R ?SSL , C., AND S EIDEL , H. 2004. Laplacian surface editing. In Proc. Symposium on Geometry Processing, 175-184.\n          S UMNER , R. W., S CHMID , J., AND P AULY , M. 2007. Embedded deformation for shape manipulation. ACM Trans. Graph. 26, 3, 80.\n          U RAGO , M. 2000. Analytical integrals of fundamental solution of three-dimensional Laplace equation and their gradients. In Trans. of the Japan Soc. of Mech. Eng. 66, 642, 254-261.\n          W EBER , O., S ORKINE , O., L IPMAN , Y., AND G OTSMAN , C. 2007. Context-aware skeletal shape deformation. Computer Graphics Forum 26, 3, 265-274.\n          W EBER , O., B EN -C HEN , M., AND G OTSMAN , C. 2009. Complex barycentric coordinates with applications to planar shape deformation. Computer Graphics Forum 28, 2, 587-597.\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n        Variational Harmonic Maps for Space Deformation ? 34:11\n      \n      \n        Appendix A\n        The mappings ? and ? . The mappings ? and ? are defined on the vertices and faces of the mesh, respectively, so we must provide for each face a scalar value ? t and for each vertex a scalar value ? v . The values of ? v are determined as a sum of values on the faces neighboring v. Given a point p ? ?, and a face t = (u,v,w) ?F, we define a tetrahedron T spanned by these four points, as in Figure 15 . N t u e v = e e v v T d v t R v t = e w + e u v e v J v t w C C v v t t = = 2 4 ? ? 1 ( d R v t v t + log d ? ? ? ? v t 1 R R )( v v t t R + ? v t ? d d v v t t d ? ? ? ? v t ) p P t = N t ? ? d i t C i t ? ? t N t i ? t On this tetrahedron, 4?? t is the signed solid angle at the point p, subtended by the face t, and vol t is its signed volume. N t is the normalized outward pointing normal of t, and A t is the area of the face t. Following Urago [2000] we obtain: ? t = ? ? i ? t C i t ( J i t ? N t ) ? A 3 t ? t vol t ? v = t ? ? N ( v ) 2 1 A t P t ? J v t The gradients. Again following Urago [2000], and taking the derivative of ? v : ?? t = ? P t ?? v = t ? ? N ( v ) 2 1 A t P t ? d v t The Hessians. To derive the Hessian matrices for ? t and ? v we need the Jacobian matrix of P t , and the gradient vector of ? t . These are: ?? t = ? 3 J v t i C v t i ( e v i + 1 ? 1 + e v i + 2 ? 1 ) i = 1 J ( P t = ( u , v , w ) ) = ? ? ? ? ? ( ( ( e e e u u v + + + e e e w v w ) ) ) C C C w t u v t t ? ? ? ? ? 3 x 3 T ? ? ? ? ? d d d w u v t t t ? ? ? ? ? 3 x 3 [ N t ] ? T + ?? T t N t where, given a vector v , [v] ? is the skew symmetric matrix, such that for any vector w, [v] ? w = v?w. Finally the Hessian matrices of ? v and ? t are: H ( ? t ) = ? J ( P t ) H ( ? v ) = ? t ? ? N ( v ) 2 1 A t ? ? d v t ? ? ? J ( P t )\n        \n          Figure 15: Notations for the definitions of ? v (p), ? t (p) and their derivatives.\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 34, Publication date: August 2009.\n      \n    \n  ",
  "resources" : [ ]
}