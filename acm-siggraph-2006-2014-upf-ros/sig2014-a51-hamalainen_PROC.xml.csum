{
  "uri" : "sig2014-a51-hamalainen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2014/a51-hamalainen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Online Motion Synthesis Using Sequential Monte Carlo",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "however", "we", "current", "computer", "up", "12", "logical", "core", "we", "have", "achieve", "decent", "75-80", "core", "utilization", "access", "sampler", "synchronize", "which", "mean", "we", "implementation", "optimal", "massively", "parallel", "computing", "we", "threading", "use", "pool", "worker", "thread", "which", "each", "obtain", "sample", "from", "sampler", "simulate", "physics", "forward", "compute", "-lrb-", "-rrb-", "store", "computed", "value", "sampler", "make", "simulation", "more", "robust", "get", "maximum", "available", "force", "fudge", "factor", "correct", "each", "body", "part", "delicate", "difficult", "solve", "we", "use", "fudgefree", "patch", "from", "official", "ODE", "issue", "tracker", "instead", "add", "motor", "limit", "constraint", "row", "LCP", "formulation", "cause", "instability", "ODE", "have", "solve", "introduce", "hand-tuned", "fudge", "factor", "scale", "force", "secondly", "ode", "implement", "joint", "motor", "limit", "way", "might", "cause", "too", "much", "force", "apply", "when", "motor", "move", "away", "from", "limit", "simulation", "fully", "causal", "sampler", "sometimes", "forget", "choose", "control", "strategy", "before", "have", "be", "completely", "execute", "ensure", "run", "two", "simulation", "different", "thread", "same", "control", "parameter", "achieve", "exactly", "same", "motion", "we", "have", "solve", "issue", "remove", "non-deterministic", "optimization", "store", "random", "number", "generator", "seed", "thread", "context", "level" ],
  "content" : "However, with our current computers with up to 12 logical cores, we have achieved a decent 75-80% core utilization. Access to the sampler is synchronized, which means that our implementation is not optimal for massively parallel computing. Our threading uses a pool of worker threads, which each obtain a sample from the sampler, simulate the physics forward, compute f (S) and store the computed value to the sampler. This makes the simulation more robust. Getting  the maximum available force and the fudge factor correct for each body part is delicate and difficult, and to solve this we used a fudgefree patch from the official ODE issue tracker that instead adds the motor limits as constraint rows in the LCP formulation. This causes instability, and ODE has solved this by introducing a hand-tuned fudge factor that scales the force. Secondly, ODE implements joint motor limits in a way that might cause too much force to be applied when the motor is moving away from the limit. If the simulation is not fully causal, the sampler sometimes forgets a chosen control strategy before it has been completely executed. This ensures that running two simulations in different threads with the same control parameters achieve exactly the same motion. We have solved these issues by removing the non-deterministic optimizations and by storing the random number generator seed on a threading context level.",
  "resources" : [ ]
}