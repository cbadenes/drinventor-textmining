{
  "uri" : "sig2012a-a160-chen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2012a/a160-chen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Depth-Presorted Triangle Lists",
    "published" : "2012",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ge-Chen",
      "name" : "Ge",
      "surname" : "Chen"
    }, {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Lei-Yang",
      "name" : "Lei",
      "surname" : "Yang"
    }, {
      "uri" : "http://drinventor/Liang-Hu",
      "name" : "Liang",
      "surname" : "Hu"
    } ]
  },
  "bagOfWords" : [ "base", "test", "plane", "simple", "run-time", "procedure", "use", "give", "viewpoint", "select", "subsequence", "triangle", "rasterization", "since", "only", "transparent", "component", "object", "translucency", "effect", "must", "preprocess", "increase", "run-time", "memory", "significant", "limitation", "either", "within", "extended", "sequence", "each", "triangle", "pair", "half-space", "result", "depth-sorted", "rendering", "original", "input", "triangle", "relative", "viewpoint", "finally", "CPU", "intervention", "result", "guarantee", "exact", "here", "we", "focus", "method", "we", "believe", "most", "related", "ours", "most", "well-known", "approach", "render", "depth-sorted", "static", "geometry", "BSP", "tree", "-lsb-", "Fuchs", "et", "al.", "1980", "Paterson", "Yao", "1989", "-rsb-", "root", "node", "represent", "entirety", "space", "each", "subtree", "represent", "fraction", "parent?s", "space", "reside", "one", "two", "halfspace", "most", "general", "technique", "operate", "pixel", "level", "New", "hardware", "capability", "have", "recently", "enable", "use", "dynamic", "link", "list", "collect", "fragment", "blend", "they", "order", "-lsb-", "Yang", "et", "al.", "2010", "-rsb-", "instead", "count", "number", "fragment", "first", "rasterization", "pass", "store", "they", "individual", "array", "during", "second", "pass", "-lsb-", "dx10", "SDK", "2010", "-rsb-", "before", "composit", "they", "parallel", "-lsb-", "patney", "et", "al.", "2010", "-rsb-", "many", "modification", "render", "pipeline", "have", "be", "propose", "support", "variation", "a-buffer", "algorithm", "exact", "amount", "memory", "need", "fix", "common", "approach", "limit", "maximum", "number", "fragment", "per", "pixel", "-lsb-", "Jouppi", "Chang", "1999", "Myers", "Bavoil", "2007a", "Bavoil", "et", "al.", "2007", "Liu", "et", "al.", "2009", "Huang", "et", "al.", "2010", "Salvi", "et", "al.", "2011", "-rsb-", "which", "case", "some", "heuristic", "must", "use", "merge", "evict", "overflow", "fragment", "another", "method", "avoid", "need", "sorting", "stochastic", "transparency", "-lsb-", "Enderton", "et", "al.", "2010", "Laine", "Karras", "2011", "-rsb-", "refreshing", "new", "take", "screen-door", "transparency", "-lsb-", "Foley", "et", "al.", "1990", "Mulder", "et", "al.", "1998", "-rsb-", "case", "figure", "-lrb-", "back-face", "culling", "-rrb-", "triangle", "never", "occlude", "other", "triangle", "since", "triangle", "half-space", "behind", "each", "they", "we", "seek", "topological", "sort", "occlusion", "graph", "i.e.", "order", "which", "back-edges", "-lsb-", "skiena", "2008", "-rsb-", "-lrb-", "edge", "adjacent", "irrelevant", "iteration", "have", "be", "omit", "-rrb-", "remedy", "two", "back-edge", "point", "node", "often", "suffice", "move", "immediately", "before", "note", "cycle", "two", "node", "do", "exist", "since", "self-intersecting", "triangle", "assume", "have", "back-edge", "point", "set", "node", "well", "forward-edge", "arrive", "from", "distinct", "node", "lie", "between", "do", "produce", "valid", "cut", "plane", "plane", "form", "use", "all", "possible", "combination", "vertex", "from", "one", "region", "edge", "from", "other", "region", "option", "geometry", "shader", "-lrb-", "g", "-rrb-", "4d", "plane", "vector", "keep", "32-bit", "4-channel", "texture", "index", "triangle", "id", "total", "memory", "ratio", "report", "ratio", "total", "memory", "use", "standard", "triangle", "list", "duplicated", "triangle", "other", "hand", "more", "extreme", "scenario", "where", "semi-transparent", "object", "dominate", "have", "50", "primitive", "count", "slowdown", "more", "significant", "1.5" ],
  "content" : "Based on these test planes, a simple run-time procedure uses the given viewpoint to select a subsequence of triangles for rasterization. Since only the transparent components of objects with translucency effects must be preprocessed, the increase in run-time memory is not a significant limitation either. Within the extended sequence, each triangle is paired with a half-space. The result is a depth-sorted rendering of the original input triangles, relative to the viewpoint. Finally, there is no CPU intervention and results are guaranteed to be exact. Here, we focus on the methods we believe are most related to ours. The most well-known approach for rendering depth-sorted static geometry is the BSP tree [Fuchs et al. 1980; Paterson and Yao 1989]. The root node represents the entirety of space, and each subtree represents the fraction of the parent?s space that reside in one of the two halfspaces. The most general techniques operate at the pixel level. New hardware capabilities have recently enabled the use dynamic linked lists to collect fragments and blend them in order [Yang et al. 2010], or instead to count the number of fragments in a first rasterization pass and store them into individual arrays during a second pass [ DX10 SDK 2010 ], before compositing them in parallel [Patney et al. 2010]. Many modifications to the rendering pipeline have been proposed that support variations of the A-buffer. The algorithms are exact and the amount of memory needed is fixed. A common approach is to limit the maximum number of fragments per pixel [Jouppi and Chang 1999; Myers and Bavoil 2007a,b; Bavoil et al. 2007; Liu et al. 2009; Huang et al. 2010; Salvi et al. 2011], in which case some heuristic must be used to merge or evict overflowing fragments. Another method that avoids the need for sorting is stochastic transparency [Enderton et al. 2010; Laine and Karras 2011], a refreshing new take on screen-door transparency [Foley et al. 1990; Mulder et al. 1998]. In the case of figure 2 (with back-face culling), triangles C D E never occlude other triangles, since there are no triangles in the half-space behind each of them. We seek a topological sort of the occlusion graph, i.e., an ordering in which there are no back-edges [Skiena 2008]. (Edges that are not adjacent to x are irrelevant to this iteration and have been omitted.) To remedy the two back-edges pointing to the b ? nodes, it often suffices to move x immediately before b 1 . Note that cycles of two nodes do not exist since there are no self-intersecting triangles. Assume x has back-edges pointing to a set of nodes b ? , as well as forward-edges arriving from n distinct nodes f ? that lie between x and b 1 . If that does not produce a valid cutting plane, then planes are formed using all possible combinations of vertices from one region and edges from the other region. Option 3: Geometry shader (GS) The 4D plane vectors are kept in a 32-bit 4-channel texture indexed by triangle ID. The total memory ratio is reported as a ratio to the total memory used by a standard triangle list with no duplicated triangles. On the other hand, in a more extreme scenario where the semi-transparent objects start to dominate by having 50% of the primitive count, the slowdown is a more significant 1.5?.",
  "resources" : [ ]
}