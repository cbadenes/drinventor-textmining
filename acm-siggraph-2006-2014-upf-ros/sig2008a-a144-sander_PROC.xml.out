{
  "uri" : "sig2008a-a144-sander_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a144-sander_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Efficient Traversal of Mesh Edges using Adjacency Primitives",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Eden-Chlamtac",
      "name" : "Eden",
      "surname" : "Chlamtac"
    }, {
      "uri" : "http://drinventor/Hugues-Hoppe",
      "name" : "Hugues",
      "surname" : "Hoppe"
    } ]
  },
  "bagOfWords" : [ "we", "present", "scheme", "efficient", "traversal", "mesh", "edge", "build", "adjacency", "primitive", "programmable", "geometry", "shader", "introduce", "recent", "graphic", "hardware", "particular", "current", "gpus", "include", "vertex", "cache", "al", "low", "reuse", "post-shaded", "vertex", "among", "several", "adjacent", "triangle", "thereby", "achieve", "significant", "reduction", "both", "memory", "bandwidth", "vertex", "shader", "computation", "note", "regular", "mesh", "region", "all", "edge", "face", "can", "cover", "introduce", "primitive", "only", "half", "triangle", "i.e.", "all", "face", "point", "same", "direction", "-lrb-", "figure", "2b", "-rrb-", "each", "one", "assign", "face", "point", "opposite", "direction", "particular", "we", "show", "select", "minimum", "number", "primitive", "cover", "all", "edge", "reduce", "minimum", "vertex", "cover", "problem", "assign", "remain", "face", "primitive", "reduce", "two", "bipartite", "matching", "problem", "moreover", "derive", "good", "lower", "bind", "number", "cover", "face", "we", "able", "show", "practical", "triangle", "mesh", "approximate", "solution", "within", "few", "percent", "optimal", "have", "determine", "set", "triangles-with-adjacency", "we", "optimize", "order", "maximize", "vertex", "cache", "reuse", "because", "order", "efficiency", "depend", "cache", "size", "we", "provide", "two", "order", "algorithm", "slower", "careful", "scheme", "assume", "prior", "knowledge", "cache", "size", "faster", "scheme", "can", "run", "load", "time", "base", "specific", "hardware", "optimize", "traversal", "mesh", "edge", "GPU", "relatively", "unexplored", "area", "however", "technique", "require", "splitting", "mesh", "vertex", "preprocess", "result", "mesh", "time", "large", "original", "test", "base", "either", "triangle", "orientation", "silhouette", "per-edge", "order", "vertex", "index", "note", "local", "branch", "lead", "inefficient", "simd", "processing", "contrast", "we", "scheme", "generate", "roughly", "half", "many", "primitive", "moreover", "most", "primitive", "process", "all", "adjacent", "edge", "result", "excellent", "simd", "utilization", "we", "describe", "we", "processing", "pipeline", "next", "three", "section", "use", "follow", "notation", "each", "triangle", "form", "three", "vertex", "-lcb-", "-rcb-", "define", "three", "edge", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "show", "Figure", "3a", "two", "undirected", "graph", "can", "associate", "mesh", "primal", "graph", "-lrb-", "-rrb-", "have", "same", "vertex", "edge", "dual", "graph", "-lrb-", "-rrb-", "other", "hand", "have", "one", "vertex", "each", "triangle", "equivalent", "find", "minimum", "vertex", "cover", "dual", "graph", "-lrb-", "-rrb-", "mesh", "boundary", "we", "find", "minimal", "vertex", "cover", "reduce", "graph", "-lrb-", "-rrb-", "-lrb-", "i.e.", "all", "boundary", "vertex", "remove", "show", "Figure", "3b", "-rrb-", "return", "although", "we", "could", "use", "any", "they", "we", "purpose", "we", "implementation", "base", "method", "Grosso", "et", "al.", "-lsb-", "2007", "-rsb-", "excellent", "maximum", "clique", "approximation", "heuristic", "which", "related", "minimum", "vertex", "cover", "follow", "minimum", "vertex", "cover", "graph", "-lrb-", "-rrb-", "only", "maximum", "clique", "complement", "graph", "-lrb-", "-rrb-", "where", "set", "all", "edge", "algorithm", "Grosso", "et", "al.", "iterate", "between", "two", "step", "perturbation", "tabu", "search", "each", "iteration", "maximal", "clique", "end", "new", "maximal", "clique", "first", "perturbation", "set", "add", "random", "vertex", "correct", "remove", "from", "all", "vertex", "adjacent", "v.", "next", "tabu", "search", "successively", "grow", "until", "maximal", "again", "while", "also", "attempt", "translate", "away", "from", "long", "share", "least", "one", "vertex", "end", "iteration", "replace", "cardinality", "larger", "fortunately", "possible", "apply", "stochastic", "algorithm", "we", "vertex", "cover", "problem", "without", "have", "explicitly", "construct", "complement", "set", "which", "would", "have", "quadratic", "complexity", "we", "first", "modify", "algorithm", "Grosso", "et", "al.", "negate", "all", "edge", "test", "construct", "maximal", "independent", "set", "we", "minimal", "vertex", "cover", "simply", "complement", "intermediate", "result", "we", "find", "stochastic", "algorithm", "produce", "excellent", "minimal", "cover", "wide", "variety", "input", "graph", "produce", "from", "triangle", "mesh", "quantify", "quality", "result", "we", "develop", "efficient", "algorithm", "provide", "good", "lower", "bind", "emphasize", "bind", "only", "use", "evaluation", "purpose", "necessary", "part", "we", "processing", "pipeline", "we", "describe", "appendix", "use", "lower", "bind", "we", "determine", "cover", "typically", "within", "2-3", "optimal", "-lrb-", "see", "Table", "-rrb-", "have", "create", "triangle-with-adjacency", "primitive", "centered", "each", "cover", "face", "we", "assign", "uncovered", "face", "adjacent", "face", "within", "primitive", "simplify", "runtime", "traversal", "we", "assume", "assign", "face", "first", "adjacent", "face", "-lcb-", "-rcb-", "within", "primitive", "-lrb-", "see", "Figure", "-rrb-", "two", "way", "duplicate", "index", "we", "can", "use", "they", "distinguish", "between", "boundary", "edge", "edge", "have", "already", "be", "cover", "recall", "processing", "edge", "require", "access", "both", "its", "adjacent", "triangle", "primitive", "one", "they", "degenerate", "chain", "restriction", "satisfy", "every", "connected", "component", "cover", "face", "have", "least", "one", "face", "either", "adjacent", "mesh", "boundary", "match", "uncovered", "face", "constrain", "acceptable", "matching", "we", "prove", "nonetheless", "always", "possible", "find", "perfect", "restricted", "matching", "formally", "give", "minimal", "cover", "dual", "graph", "-lrb-", "include", "all", "dual", "vertex", "correspond", "boundary", "face", "-rrb-", "we", "must", "match", "each", "remain", "vertex", "vertex", "C.", "Finding", "unrestricted", "matching", "from", "easy", "let", "-lrb-", "-rrb-", "denote", "degree", "vertex", "we", "consider", "bipartite", "graph", "-lrb-", "-lcb-", "-rcb-", "-lrb-", "-rrb-", "-rrb-", "where", "-lrb-", "-rrb-", "subset", "edge", "between", "we", "see", "-lrb-", "-rrb-", "all", "-lrb-", "since", "cover", "all", "its", "three", "neighbor", "must", "-rrb-", "-lrb-", "-rrb-", "all", "-lrb-", "triangle", "have", "most", "three", "neighbor", "-rrb-", "follow", "satisfy", "marriage", "condition", "which", "any", "subset", "its", "neighbor", "-lrb-", "-rrb-", "we", "have", "-lrb-", "-rrb-", "thus", "hall?s", "theorem", "-lsb-", "hall", "1935", "-rsb-", "guarantee", "existence", "matching", "from", "C.", "express", "condition", "restricted", "matching", "denote", "-lcb-", "-rcb-", "partition", "connected", "component", "subgraph", "induce", "c.", "each", "we", "must", "ensure", "least", "one", "follow", "two", "condition", "hold", "some", "correspond", "mesh", "boundary", "triangle", "some", "match", "i.e.", "have", "assign", "face", "proof", "follow", "lemma", "-lrb-", "illustrate", "Figure", "-rrb-", "describe", "construction", "algorithm", "restricted", "matching", "we", "have", "see", "always", "exist", "some", "unrestricted", "perfect", "matching", "from", "-lrb-", "figure", "5a", "-rrb-", "we", "must", "find", "matching", "also", "cover", "least", "one", "face", "each", "component", "do", "contain", "boundary", "face", "let", "-lcb-", "-rcb-", "denote", "set", "component", "let", "we", "collapse", "moment", "each", "single", "vertex", "merge", "repeat", "edge", "any", "subset", "non-boundary", "component", "its", "neighbor", "-lrb-", "-rrb-", "we", "must", "show", "-lrb-", "-rrb-", "indeed", "let", "-lrb-", "-rrb-", "set", "dual", "edge", "from", "-lrb-", "-rrb-", "before", "merge", "note", "each", "must", "have", "least", "three", "edge", "go", "-lrb-", "since", "minimality", "cover", "corresponding", "bound", "region", "primal", "surround", "face", "-rrb-", "moreover", "every", "have", "degree", "-lrb-", "originally", "every", "have", "degree", "though", "some", "its", "edge", "might", "participate", "-lrb-", "-rrb-", "-rrb-", "therefore", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "thus", "hall?s", "theorem", "exist", "matching", "from", "-lrb-", "figure", "5b", "-rrb-", "form", "disjoint", "collection", "cycle", "path", "-lrb-", "because", "every", "vertex", "graph", "have", "degree", "-rrb-", "let", "vertex", "participate", "match", "-lrb-", "star", "Figure", "-rrb-", "path", "alternate", "between", "which", "end", "vertex", "which", "participate", "-lrb-", "figure", "5d", "-rrb-", "let", "set", "edge", "all", "alternate", "path", "-lrb-", "note", "disjoint", "-rrb-", "now", "take", "flip", "membership", "all", "edge", "alternate", "path", "produce", "new", "perfect", "matching", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "Figure", "5e", "-rrb-", "clearly", "match", "also", "cover", "all", "C.", "let", "we", "verify", "every", "participate", "matching", "since", "completely", "match", "every", "must", "contain", "some", "vertex", "match", "also", "match", "participate", "regardless", "whether", "alternate", "path", "go", "through", "flip", "otherwise", "initial", "vertex", "alternate", "path", "thus", "participate", "once", "path", "flip", "find", "bipartite", "matching", "we", "use", "algorithm", "Hopcroft", "Karp", "-lsb-", "1973", "-rsb-", "implement", "Rothberg", "-lsb-", "1985", "-rsb-", "time", "complexity", "algorithm", "-lrb-", "-rrb-", "which", "simply", "-lrb-", "1.5", "-rrb-", "size", "input", "mesh", "several", "method", "optimize", "traversal", "index", "triangle", "mesh", "maximize", "runtime", "efficiency", "GPU", "vertex", "cache", "we", "focus", "here", "method", "most", "related", "we", "approach", "refer", "reader", "Chhugani", "Kumar", "-lsb-", "2007", "-rsb-", "more", "complete", "survey", "hoppe", "-lsb-", "1999", "-rsb-", "show", "efficacy", "FIFO", "cache", "build", "successive", "triangle", "strip", "greedily", "optimize", "length", "Chhugani", "Kumar", "-lsb-", "2007", "-rsb-", "further", "improve", "cache", "efficiency", "approach", "partition", "mesh", "triangle", "adjacent", "chain", "split", "chain", "strip", "use", "dynamic", "programming", "Sander", "et", "al.", "-lsb-", "2007", "-rsb-", "develop", "fast", "algorithm", "do", "require", "mesh", "adjacency", "have", "linear", "complexity", "independent", "cache", "size", "therefore", "suitable", "load-time", "optimization", "triangle", "buffer", "we", "contribution", "optimize", "traversal", "triangle", "primitive", "adjacency", "create", "describe", "previous", "two", "section", "because", "each", "adjacency", "primitive", "involve", "larger", "stencil", "up", "vertex", "naive", "application", "previous", "reordering", "method", "give", "poor", "result", "-lrb-", "we", "arbitrarily", "select", "-lsb-", "Lin", "Yu", "2006", "-rsb-", "representative", "off-the-shelf", "method", "-rrb-", "we", "choose", "extend", "two", "prior", "method", "namely", "-lsb-", "Lin", "Yu", "2006", "-rsb-", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "because", "strategy", "emit", "all", "unvisited", "primitive", "adjacent", "central", "vertex", "can", "generalize", "other", "primitive", "type", "result", "we", "denote", "we", "extension", "two", "method", "careful", "fast", "scheme", "respectively", "careful", "scheme", "base", "extend", "-lsb-", "Lin", "Yu", "2006", "-rsb-", "algorithm", "Lin", "Yu", "proceeds", "iteratively", "select", "central", "vertex", "emit", "all", "its", "adjacent", "unvisited", "face", "vertex", "selection", "algorithm", "consider", "position", "vertex", "cache", "number", "unvisited", "face", "number", "cache", "miss", "would", "result", "we", "modify", "cost", "analysis", "consider", "ring", "adjacency", "primitive", "reference", "candidate", "central", "vertex", "regular", "mesh", "region", "primitive", "show", "Figure", "6a", "we", "also", "modify", "algorithm", "emit", "adjacent", "primitive", "order", "minimize", "result", "number", "cache", "miss", "fast", "scheme", "base", "extend", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "algorithm", "Sander", "et", "al.", "consider", "fewer", "candidate", "next", "central", "vertex", "process", "make", "conservative", "assumption", "unvisited", "adjacent", "face", "may", "cause", "two", "additional", "cache", "miss", "adjacency", "primitive", "conservative", "bind", "must", "raise", "five", "cache", "miss", "per", "primitive", "therefore", "obtain", "good", "result", "we", "find", "necessary", "emit", "only", "primitive", "whose", "cover", "face", "immediately", "adjacent", "central", "vertex", "i.e.", "only", "up", "adjacency", "primitive", "regular", "mesh", "region", "show", "Figure", "6b", "scheme", "take", "only", "fraction", "second", "run", "even", "large", "mesh", "-lrb-", "Table", "-rrb-", "can", "use", "quickly", "specialize", "primitive", "order", "cache", "size", "give", "graphic", "system", "note", "cover", "assignment", "can", "still", "obtain", "preprocessing", "stage", "since", "unaffected", "cache", "size", "Table", "show", "result", "we", "traversal", "construction", "assortment", "practical", "mesh", "c/b", "column", "represent", "ratio", "between", "cover", "result", "-lrb-", "-rrb-", "we", "compute", "lower", "bind", "result", "-lrb-", "-rrb-", "remarkably", "c/b", "indicate", "Grosso", "et", "al.", "-lsb-", "2007", "-rsb-", "can", "find", "cover", "solution", "only", "worse", "than", "lower", "bind", "therefore", "most", "worse", "than", "optimal", "practice", "both", "cover", "assignment", "step", "can", "perform", "efficiently", "-lrb-", "seconds", "small", "model", "minute", "large", "model", "-rrb-", "note", "pre-processing", "algorithm", "therefore", "time-critical", "show", "later", "application", "excellent", "cover", "assignment", "result", "translate", "significant", "speedup", "practical", "render", "scenario", "Figure", "plot", "cache", "efficiency", "function", "cache", "size", "efficiency", "denote", "cm/v", "give", "number", "cache", "miss", "divide", "number", "vertex", "lower", "value", "better", "optimal", "minimum", "value", "give", "each", "vertex", "must", "process", "least", "once", "note", "substantial", "reduction", "number", "cache", "miss", "per", "vertex", "both", "we", "careful", "fast", "scheme", "compare", "order", "produce", "representative", "prior", "algorithm", "design", "triangle", "primitive", "without", "adjacency", "show", "Table", "fast", "scheme", "order", "magnitude", "faster", "than", "careful", "scheme", "like", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "its", "processing", "time", "independent", "cache", "size", "figure", "show", "visualization", "result", "mesh", "from", "Table", "spatial", "distribution", "cache", "efficiency", "convey", "color", "each", "mesh", "vertex", "accord", "its", "total", "number", "cache", "miss", "color", "white", "correspond", "optimal", "single", "cache", "miss", "per", "vertex", "darker", "shades", "gray", "indicate", "progressively", "more", "cache", "miss", "per", "vertex", "we", "demonstrate", "practical", "advantage", "we", "efficient", "edgeprocess", "traversal", "three", "application", "-lrb-", "see", "Figure", "-rrb-", "Shadow", "volume", "mesh", "render", "shadow", "volume", "screen-space", "stencil", "buffer", "-lsb-", "Heidmann", "1991", "-rsb-", "shadow", "volume", "form", "within", "geometry", "shader", "displace", "triangle", "form", "front", "cap", "rear", "cap", "-lrb-", "depend", "whether", "face", "light", "-rrb-", "extrude", "silhouette", "edge", "-lrb-", "respect", "light", "-rrb-", "form", "quadrilateral", "span", "cap", "baseline", "we", "use", "sample", "program", "shadowvolume10", "DirectX", "10", "SDK", "modify", "use", "we", "optimize", "set", "cover", "primitive", "-lrb-", "figure", "8a", "-rrb-", "note", "we", "geometry", "shader", "output", "triangle", "strip", "rather", "than", "independent", "triangle", "-lrb-", "figure", "10", "-rrb-", "result", "small", "speed", "improvement", "10", "20", "apply", "all", "measurement", "Line", "illustration", "many", "render", "technique", "enhance", "object", "appearance", "emphasize", "silhouette", "other", "important", "contour", "e.g.", "-lsb-", "Gooch", "Gooch", "2001", "DeCarlo", "et", "al.", "2003", "-rsb-", "geometry", "shader", "silhouette", "rendering", "some", "sense", "ideal", "scenario", "highlight", "efficiency", "GPU", "edge-processing", "because", "output", "silhouette", "often", "have", "sub-linear", "complexity", "we", "develop", "simple", "prototype", "render", "both", "silhouette", "sharp", "feature", "-lrb-", "figure", "8b", "-rrb-", "again", "we", "use", "baseline", "basic", "approach", "process", "all", "face", "triangle", "adjacency", "follow", "framework", "from", "dx10", "shadow", "volume", "sample", "since", "we", "use", "small", "quadrilateral", "render", "primitive", "we", "can", "control", "thickness", "line", "well", "render", "mesh", "triangle", "white", "hidden", "line", "removal", "all", "single", "render", "pass", "approach", "have", "similarity", "shadow", "volume", "mesh", "also", "split", "front", "part", "rear", "part", "silhouette", "edge", "-lrb-", "respect", "motion", "-rrb-", "extrude", "form", "quadrilateral", "previous", "application", "we", "compare", "against", "traditional", "approach", "process", "all", "triangle", "adjacency", "result", "motion", "volume", "render", "par", "tial", "transparency", "use", "geometry", "shader", "program", "can", "all", "do", "single", "render", "pass", "-lrb-", "figure", "8c", "-rrb-", "shadow", "volume", "application", "we", "output", "triangle", "strip", "since", "extruded", "quadrilateral", "share", "vertex", "emit", "triangle", "face", "-lrb-", "figure", "10", "-rrb-", "quantitative", "speedup", "we", "measure", "performance", "speedup", "factor", "use", "we", "approach", "against", "baseline", "method", "outline", "above", "each", "application", "measurement", "be", "perform", "both", "NVIDIA", "GeForce", "8800GTX", "AMD", "ATI", "Radeon", "hd2900", "simulate", "more", "realistic", "graphic", "scene", "measurement", "use", "multiple", "instance", "model", "factor", "out", "overhead", "due", "frame", "setup", "other", "element", "scene", "through", "experimentation", "we", "observe", "best", "result", "we", "application", "AMD", "NVIDIA", "card", "when", "set", "vertex", "cache", "parameter", "12", "24", "vertex", "respectively", "any", "rate", "result", "we", "report", "be", "significantly", "affect", "cache", "size", "parameter", "we", "geometry-shader-bound", "prototype", "application", "which", "just", "use", "Gouraud", "shade", "vertex", "program", "may", "overly", "simple", "we", "have", "verify", "more", "expensive", "vertex", "program", "do", "give", "rise", "greater", "speedup", "speedup", "produce", "use", "we", "approach", "report", "Table", "since", "we", "process", "just", "over", "half", "number", "primitive", "speedup", "cover", "computation", "could", "reach", "close", "however", "practice", "do", "occur", "because", "each", "we", "geometry", "shader", "instance", "emit", "more", "datum", "general", "application", "result", "speedup", "between", "1.5", "2.0", "most", "input", "mesh", "other", "application", "many", "other", "application", "would", "also", "benefit", "from", "efficient", "edge", "traversal", "some", "notable", "example", "include", "fur", "rendering", "selective", "extrusion", "fin", "from", "edge", "near", "silhouette", "-lsb-", "Lengyel", "et", "al.", "2001", "-rsb-", "soft-shadow", "use", "penumbra", "wedge", "-lsb-", "assarsson", "akenine-m", "ller", "2003", "-rsb-", "beveled", "edge", "-lsb-", "bahnassus", "bahnassi", "2007", "-rsb-", "one", "final", "note", "set", "cover", "face", "can", "also", "use", "render", "wireframe", "model", "-lrb-", "without", "geometry", "shader", "i.e.", "mode", "d3d10", "fill", "wireframe", "-rrb-", "we", "notice", "speedup", "roughly", "70", "when", "use", "cover", "face", "rather", "than", "all", "face", "model", "naturally", "efficient", "100", "improvement", "can", "obtain", "create", "buffer", "line", "contain", "edge", "model", "however", "may", "practical", "value", "list", "cover", "face", "already", "available", "-lrb-", "e.g.", "one", "above", "application", "-rrb-", "since", "would", "consume", "any", "additional", "video", "memory", "dismiss", "alternative", "scheme", "we", "briefly", "summarize", "some", "other", "scheme", "we", "consider", "associate", "drawback", "each", "edge", "could", "process", "individually", "consider", "its", "pair", "adjacent", "face", "encode", "vertex", "e.g.", "index", "line-with-adjacency", "primitive", "however", "would", "result", "index", "buffer", "4e", "index", "edge", "about", "twice", "many", "we", "scheme", "also", "face", "processing", "could", "well", "load-balanced", "among", "primitive", "triangle-strip-with-adjacency", "primitive", "would", "appear", "promising", "way", "string", "together", "several", "triangle-with-adjacency", "primitive", "however", "even", "regular", "mesh", "region", "one", "can", "obtain", "regular", "covering", "mesh", "edge", "therefore", "branch", "would", "necessary", "geometry", "shader", "again", "degrading", "simd", "parallelism", "efficiency", "Limitations", "current", "gpus", "introduction", "any", "geometry", "shader", "slow", "down", "render", "pipeline", "therefore", "use", "we", "representation", "render", "just", "mesh", "face", "incur", "additional", "cost", "however", "most", "application", "perform", "edge", "processing", "bottleneck", "edge", "processing", "itself", "therefore", "mesh", "render", "time", "do", "significantly", "impact", "result", "timing", "number", "previous", "section", "take", "account", "we", "have", "design", "efficient", "representation", "process", "both", "edge", "face", "mesh", "GPU", "we", "optimize", "traversal", "representation", "provide", "two", "separate", "improvement", "over", "prior", "approach", "-lrb-", "-rrb-", "nearly", "two-fold", "reduction", "number", "adjacency", "primitive", "-lrb-", "-rrb-", "additional", "reduction", "vertex", "processing", "memory", "bandwidth", "due", "improve", "vertex", "caching", "optimization", "result", "substantial", "gain", "several", "real-time", "rendering", "method", "future", "hardware", "likely", "include", "larger", "primitive", "form", "surface", "patch", "define", "efficient", "traversal", "patch", "interesting", "area", "continue", "research", "Pedro", "Sander", "partly", "support", "Hong", "Kong", "RGC", "CERG", "grant", "619008", "page", "220", "234", "SSARSSON", "U.", "kenine", "OLLER", "t.", "2003", "geometrybased", "soft", "shadow", "volume", "algorithm", "use", "graphic", "hardware", "22", "-lrb-", "-rrb-", ":511", "520", "W.", "2007", "micro-beveled", "edge", "Charles", "River", "LYTHE", "D.", "2006", "direct3d", "10", "system", "25", "-lrb-", "-rrb-", ":724", "734", "rennan", "C.", "2002", "Shadow", "volume", "extrusion", "use", "vertex", "shader", "wordware", "ard", "D.", "ITCHELL", "J.", "2002", "non-photorealistic", "render", "pixel", "vertex", "shader", "ShaderX", "Vertex", "Pixel", "Shader", "Tips", "Tricks", "hhuganus", "J.", "UMAR", "S.", "2007", "geometry", "engine", "optimization", "cache", "friendly", "compress", "representation", "geometry", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "page", "16", "how", "M.", "M.", "1997", "optimize", "geometry", "compression", "realtime", "rendering", "IEEE", "visualization", "page", "347", "354", "arlo", "D.", "inkelstein", "a.", "usinkiewicz", "S.", "TELLA", "A.", "2003", "suggestive", "contour", "convey", "shape", "22", "-lrb-", "-rrb-", ":848", "855", "eering", "M.", "1995", "geometry", "compression", "page", "13", "20", "dmond", "J.", "OHNSON", "E.", "L.", "1973", "match", "Euler", "tour", "chinese", "postman", "mathematical", "programming", "5:88", "129", "stkowskus", "R.", "ITCHELL", "J.", "S.", "B.", "iang", "X.", "2002", "optimal", "decomposition", "polygonal", "model", "triangle", "strip", "Proceedings", "Symposium", "Computational", "Geometry", "page", "254", "263", "van", "F.", "kiena", "S.", "a.", "1996", "optimize", "triangle", "strip", "fast", "rendering", "page", "319", "326", "abow", "H.", "N.", "1974", "phd", "thesis", "Stanford", "University", "D.", "S.", "1977", "rectilinear", "Steiner", "OOCH", "B.", "A.", "2001", "a.", "K.", "Peters", "Ltd.", "rosso", "a.", "ocatellus", "M.", "ullan", "W.", "2007", "simple", "ingredient", "lead", "very", "efficient", "heuristic", "maximum", "clique", "problem", "Journal", "Heuristics", "on-line", "18", "t.", "1991", "real", "shadow", "real", "time", "ertzmann", "a.", "1999", "silhouette", "outline", "introduction", "3d", "Non-Photorealistic", "Rendering", "chapter", "ACM", "SIGGRAPH", "Course", "Notes", "OPPE", "H.", "1999", "optimization", "mesh", "locality", "transparent", "vertex", "caching", "Proceedings", "ACM", "SIGGRAPH", "99", "page", "269", "276", "ARYPIS", "G.", "UMAR", "V.", "1995", "engyel", "J.", "raun", "E.", "inkelstein", "a.", "oppe", "H.", "2001", "real-time", "fur", "over", "arbitrary", "surface", "page", "227", "232", "G.", "T.", "P.-Y", "2006", "IEEE", "transaction", "visualization", "computer", "graphic", "12", "-lrb-", "-rrb-", ":640", "648", "uire", "M.", "UGHES", "J.", "2004", "hardware-determined", "feature", "edge", "page", "35", "47", "othberg", "E.", "1985", "http://elib.zib.de/", "pub/packages/mathprog", "matching/weighted", "ander", "P.", "V.", "EHAB", "D.", "arczak", "J.", "2007", "fast", "triangle", "reordering", "vertex", "locality", "reduce", "overdraw", "ACM", "Trans", "ARIQ", "S.", "2007", "Fur", "-lrb-", "use", "shell", "fin", "-rrb-", "Technical", "Report", "WP-03021-001-v01", "NVIDIA", "Corp.", "R.", "C.", "1996", "interactive", "real-time", "12", "-lrb-", "-rrb-", ":283", "295", "iang", "X.", "ELD", "M.", "itchell", "J.", "S.", "B.", "1999", "fast", "effective", "stripification", "polygonal", "surface", "model", "page", "71", "78", "simple", "lower", "bind", "size", "we", "vertex", "cover", "obtain", "follow", "let", "-lrb-", "-rrb-", "denote", "degree", "vertex", "-lrb-", "either", "primal", "dual", "graph", "-rrb-", "-lrb-", "-rrb-", "every", "dual", "vertex", "since", "each", "triangle", "have", "most", "neighbor", "can", "tighten", "obtain", "lower", "bind", "number", "edge", "must", "cover", "twice", "intuition", "all", "odddegree", "vertex", "mesh", "must", "have", "least", "one", "adjacent", "edge", "cover", "twice", "moreover", "doubly", "cover", "edge", "must", "form", "path", "terminate", "only", "other", "odd-degree", "vertex", "formally", "consider", "vertex", "primal", "graph", "ring", "-lrb-", "-rrb-", "dual", "vertex", "surround", "-lrb-", "i.e.", "red", "cycle", "Figure", "3a", "-rrb-", "let", "-lrb-", "-rrb-", "denote", "number", "edge", "-lrb-", "-rrb-", "cover", "twice", "since", "cover", "one", "can", "show", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "let", "-lrb-", "-rrb-", "minimum", "subgraph", "-lrb-", "minimize", "-rrb-", "all", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "number", "edge", "cover", "twice", "must", "least", "argue", "before", "we", "obtain", "-lrb-", "-rrb-", "set", "edge", "which", "odd-degree", "vertex", "coincide", "set", "call", "join", "thus", "set", "minimum", "odd", "join", "where", "odd", "set", "odd-degree", "vertex", "have", "be", "show", "find", "minimum", "join", "can", "reduce", "minimum-weight", "perfect", "matching", "problem", "particular", "Edmonds", "Johnson", "-lsb-", "1973", "-rsb-", "have", "show", "minimum", "odd", "join", "equivalent", "minimum", "weight", "matching", "between", "odddegree", "vertex", "where", "weight", "attach", "any", "pair", "vertex", "odd", "exactly", "shortest-path", "distance", "dist", "-lrb-", "-rrb-", "we", "able", "greatly", "speed", "up", "computation", "note", "shortest", "path", "between", "two", "vertex", "odd", "cross", "two", "other", "vertex", "odd", "can", "contribute", "minimum-weight", "perfect", "matching", "we", "call", "path", "illegal", "often", "prune", "99", "search", "space", "verify", "validity", "optimization", "we", "prove", "follow", "lemma", "-lrb-", "actual", "proof", "necessary", "implementation", "either", "we", "algorithm", "lower", "bind", "-rrb-", "prove", "-lrb-", "-rrb-", "note", "contain", "cycle", "-lrb-", "removal", "preserve", "odd", "join", "-rrb-", "each", "tree", "we", "find", "legal", "path", "decomposition", "repeatedly", "perform", "following", "contract", "all", "uninterrupted", "path", "individual", "edge", "choose", "lowest", "leaf", "match", "its", "sibling", "remove", "connect", "path", "prove", "-lrb-", "-rrb-", "note", "any", "matching", "total", "length", "all", "shortest", "path", "minimal", "path", "must", "edge-disjoint", "we", "two", "crucial", "observation", "which", "follow", "from", "minimality", "both", "observation", "follow", "from", "same", "principle", "we", "have", "path", "between", "violate", "either", "observation", "observation", "-lrb-", "shorter", "than", "distinct", "shortest", "path", "intersect", "-rrb-", "we", "could", "construct", "strictly", "smaller", "odd", "join", "remove", "path", "take", "symmetric", "difference", "remain", "edge", "set", "we", "may", "assume", "contain", "minimum", "number", "tree", "among", "all", "minimum", "odd", "join", "suppose", "sake", "contradiction", "some", "vertex", "odd", "some", "tree", "connect", "legal", "path", "exist", "illegal", "shortest", "path", "contain", "two", "internal", "vertex", "odd", "we", "consider", "two", "case", "Case", "node", "same", "tree", "-lrb-", "possibly", "-rrb-", "-lrb-", "figure", "11a", "-rrb-", "let", "sub-path", "from", "let", "shortest", "tree", "path", "from", "y.", "minimality", "observation", "both", "path", "shortest", "path", "from", "y.", "case", "tree", "-lrb-", "figure", "11d", "-rrb-" ],
  "content" : "We present a scheme for efficient traversal of mesh edges that builds on the adjacency primitives and programmable geometry shaders introduced in recent graphics hardware. In particular, current GPUs include a vertex cache to al low reuse of post-shaded vertices among several adjacent triangles, thereby achieving significant reduction in both memory bandwidth and vertex shader computation. Note that, in regular mesh regions, all edges and faces can be covered by introducing primitives for only half of the triangles, i.e. all the faces ?pointing in the same direction? ( Figure 2b ), each one assigned to a face pointing in the opposite direction. In particular, we show that selecting a minimum number of primitives to cover all edges reduces to a minimum vertex cover problem, and that assigning the remaining faces to these primitives reduces to two bipartite matching problems. Moreover, by deriving a good lower bound on the number of cover faces, we are able to show that, for practical triangle meshes, the approximate solutions are within a few percent of optimal; 2. Having determined a set of triangles-with-adjacency, we optimize their ordering to maximize vertex cache reuse. Because ordering efficiency depends on cache size, we provide two ordering algorithms: a slower, careful scheme that assumes prior knowledge of the cache size, and a faster scheme that can be run at load time based on the specific hardware. Optimizing the traversal of mesh edges on the GPU is a relatively unexplored area. However, the technique requires splitting the mesh vertices in a preprocess, resulting in a mesh that is 6 times as large as the original. This test is based either on the triangle orientation at silhouettes, or on per-edge ordering of vertex indices. Note that such local branching leads to inefficient SIMD processing. In contrast, our scheme generates roughly half as many primitives, and moreover most of these primitives process all 3 of their adjacent edges, resulting in excellent SIMD utilization. We describe our processing pipeline in the next three sections using the following notation. Each triangle is formed by three vertices {v i , v j , v k } in V , and defines three edges: {v i , v j }, {v j , v k }, and {v k , v i }. As shown in Figure 3a , two undirected graphs can be associated with mesh M . The primal graph G(V, E) has the same vertices V and edges E. The dual graph G (V , E ), on the other hand, has one vertex in V for each triangle in T . This is equivalent to finding the minimum vertex cover C ? V in the dual graph G (V , E ). For meshes with boundaries, we find the minimal vertex cover C ? on the reduced graph G ? (V \\B , E ? ) (i.e., G with all boundary vertices removed, as shown in Figure 3b), and return C = C ? ? B . Although we could use any of them for our purposes, our implementation is based on the method of Grosso et al. [2007]. This is an excellent maximum clique approximation heuristic, which is related to the minimum vertex cover as follows: C is a minimum vertex cover for graph G (V , E ) if and only if C = V \\ C is a maximum clique on the complement graph G (V , E ), where E is the set of all edges not in E . The algorithm of Grosso et al. iterates between two steps: a perturbation and a tabu search. Each iteration starts with a maximal clique K, and ends with a new maximal clique K . First, the perturbation sets K =K, adds a random vertex v ? K , and corrects K by removing from it all vertices not adjacent to v. Next, the tabu search successively grows K until it is maximal again, while also attempting to translate it away from K as long as they share at least one vertex. At the end of the iteration, K is replaced by K if the cardinality of K is larger. Fortunately, it is possible to apply the stochastic algorithm to our vertex cover problem without having to explicitly construct the complement set E , which would have quadratic complexity. We first modify the algorithm of Grosso et al. by negating all the edge tests, to construct a maximal independent set I. Our minimal vertex cover C is simply the complement I of this intermediate result. We find that the stochastic algorithm produces excellent minimal covers C on a wide variety of input graphs produced from triangle meshes. To quantify the quality of these results, we develop an efficient algorithm that provides a good lower bound on |C|. To emphasize that this bound is only used for evaluation purposes, and is not a necessary part of our processing pipeline, we describe it in the appendix. Using this lower bound, we determine that the covers C are typically within 2-3% of optimal (see Table 1 ). Having created a triangle-with-adjacency primitive centered at each cover face, we assign the uncovered faces to adjacent faces within these primitives. And to simplify the runtime traversal, we assume that this assigned face is the first adjacent face {0, 1, 2} within the primitive (see Figure 4 ). There are two ways to duplicate the index, and we can use them to distinguish between boundary edges and edges that have already been covered. Recall that processing of an edge requires access to both its adjacent triangles, but in this primitive one of them is degenerate. This chain of restrictions is satisfied if every connected component of cover faces has at least one face that is either adjacent to the mesh boundary or is matched to an uncovered face. This constrains the acceptable matchings, but we will prove that nonetheless it is always possible to find such a perfect restricted matching. Formally, given the minimal cover C in the dual graph G (including all dual vertices corresponding to boundary faces), we must match each remaining vertex in C = V \\ C to a vertex in C. Finding an unrestricted matching from C to C is easy. Let d(v) denote the degree of vertex v. If we consider the bipartite graph G = ({C, C}, E (C, C)), where E (C, C) ? E is the subset of edges between C and C, we see that d G (v ) = 3 for all v ? C (since v is not in the cover, all its three neighbors must be), and d G (v ) ? 3 for all v ? C (a triangle has at most three neighbors). It follows that C satisfies the marriage condition, which is that for any subset C ? C and its neighbors ? G (C ) ? C, we have |? G (C )| ? |C |. Thus Hall?s theorem [Hall 1935] guarantees the existence of a matching M from C to C. To express the conditions on the restricted matching, denote by {C i } the partition into connected components of the subgraph of G induced on C. For each C i we must ensure that at least one of the following two conditions holds: 1. Some v ? C i corresponds to a mesh boundary triangle, or 2. Some v ? C i is matched to C, i.e. it has an assigned face. The proof of the following lemma (illustrated in Figure 5 ) describes a construction algorithm for the restricted matching. As we have seen, there always exists some unrestricted perfect matching M from C to C ( Figure 5a ). We must find a matching M that also covers at least one face in each component C i that does not contain a boundary face. Let A ? {C i } denote this set of components. Let us collapse for a moment each C i ? A to a single vertex, and merge repeated edges. That is, for any subset K ? A of non-boundary components, and its neighbors ?(K) ? C, we must show that |K| ? |?(K)|. Indeed, let E (K) be the set of dual edges from K to ?(K) before merging. Note that each C i ? A must have at least three edges in G going to C (since, by minimality of the cover C, the corresponding bounded region in the primal is surrounded by faces in C). Moreover, every u ? C has degree ? 3 (originally every u ? C had degree 3, though some of its edges might not participate in E (K)). Therefore 3|K| ? |E (K)| ? 3|?(K)|. Thus, by Hall?s theorem, there exists a matching N from A into C ( Figure 5b ). These form a disjoint collection of cycles and paths (because every vertex in this graph has degree ? 2). Let v ? C be a vertex participating in matching N but not in M (the star in Figure 5 ). Then there is a path alternating between C and C which starts at v and ends in a vertex u ? C which participates in M but not N (Figure 5d). Let P be the set of edges in all such alternating paths (note that they are disjoint). Now take M and flip the membership of all edges in the alternating paths, producing a new perfect matching M = (M \\ P ) ? (P \\ M ) ( Figure 5e ). Clearly, matching M also covers all of C. Let us verify that every C i ? A participates in this matching. Since A is completely matched by N , every C i must contain some vertex v that is matched by N . If it is also matched by M , then it will participate in M regardless of whether an alternating path going through it is flipped. Otherwise, it is the initial vertex in an alternating path, and thus will participate in M once this path is flipped. To find the bipartite matchings, we use the algorithm by Hopcroft and Karp [1973], as implemented by Rothberg [1985]. The time complexity of this algorithm is O(|E | |V |), which is simply O(n 1.5 ) on the size of the input mesh. Several methods optimize the traversal of indexed triangles in a mesh to maximize the runtime efficiency of a GPU vertex cache. We focus here on the methods that are most related to our approach, and refer the reader to Chhugani and Kumar [2007] for a more complete survey. Hoppe [1999] shows the efficacy of a FIFO cache, and builds successive triangle strips by greedily optimizing their lengths. Chhugani and Kumar [2007] further improve the cache efficiency; their approach partitions the mesh triangles into adjacent chains, and then splits the chains into strips using dynamic programming. Sander et al. [2007] develop a fast algorithm that does not require mesh adjacency, has linear complexity independent of cache size, and is therefore suitable for load-time optimization of triangle buffers. Our contribution is to optimize the traversal of triangle primitives with adjacency, created as described in the previous two sections. Because each adjacency primitive involves a larger stencil of up to 6 vertices, naive application of previous reordering methods gives poor results. (We arbitrarily selected [Lin and Yu 2006] as the representative ?off-the-shelf? method.) We chose to extend two of the prior methods, namely [Lin and Yu 2006] and [Sander et al. 2007], because their strategy of emitting all unvisited primitives adjacent to a central vertex can be generalized to other primitive types. In the results, we denote our extensions of these two methods as the ?careful? and ?fast? schemes, respectively. Careful scheme based on extending [Lin and Yu 2006] The algorithm of Lin and Yu proceeds by iteratively selecting a central vertex and emitting all its adjacent unvisited faces. The vertex selection algorithm considers the position of the vertex in the cache, the number of unvisited faces, and the number of cache misses that would result. We modify this cost analysis to consider the ring of adjacency primitives that reference the candidate central vertex. In a regular mesh region, there are 6 such primitives, as shown in Figure 6a. We also modify the algorithm to emit the adjacent primitives in the order that minimizes the resulting number of cache misses. Fast scheme based on extending [Sander et al. 2007] The algorithm of Sander et al. considers fewer candidates for the next central vertex to process, and makes the conservative assumption that unvisited adjacent faces may cause two additional cache misses. With adjacency primitives, this conservative bound must be raised to five cache misses per primitive. Therefore, to obtain good results, we found it necessary to emit only the primitives whose cover face is immediately adjacent to the central vertex; i.e. only up to 3 adjacency primitives in a regular mesh region, as shown in Figure 6b . As this scheme takes only a fraction of a second to run even on large meshes ( Table 1 ), it can be used to quickly specialize the primitive ordering to the cache size of a given graphics system. Note that the cover and assignment can still be obtained in a preprocessing stage, since they are unaffected by cache size. Table 1 shows the results of our traversal construction for an assortment of practical meshes. The C/B column represents the ratio between the cover results (C) and our computed lower bound results (B). Remarkably, C/B indicate that Grosso et al. [2007] can find cover solutions that are only 2?3% worse than the lower bound, and therefore at most 2?3% worse than optimal. In practice, both the cover and the assignment steps can be performed efficiently (in seconds for small models, and minutes for large models). Note that this is a pre-processing algorithm and therefore not time-critical. As shown later in the applications, the excellent cover and assignment results translate into significant speedups in practical rendering scenarios. Figure 9 plots the cache efficiency as a function of cache size. The efficiency, denoted CM/V, is given by the number of cache misses divided by the number of vertices. Lower values are better, and the optimal minimum value is 1, given that each vertex must be processed at least once. Note the substantial reduction in the number of cache misses per vertex for both our careful and fast schemes compared to the ordering produced by a representative prior algorithm designed for triangle primitives without adjacency. As shown in Table 1 , the fast scheme is orders of magnitude faster than the careful scheme, and like [Sander et al. 2007], its processing time is independent of the cache size. Figure 7 shows a visualization of the results on 4 meshes from Table 1 . The spatial distribution of cache efficiency is conveyed by coloring each mesh vertex according to its total number of cache misses. The color white corresponds to the optimal single cache miss per vertex. Darker shades of gray indicate progressively more cache misses per vertex. We demonstrate the practical advantages of our efficient edgeprocessing traversal with three applications (see Figure 8 ). Shadow volumes The mesh is rendered as a shadow volume into a screen-space stencil buffer [Heidmann 1991]. The shadow volume is formed within the geometry shader, by displacing triangles to form a front cap and a rear cap (depending on whether they face the light), and by extruding silhouette edges (with respect to the light) to form quadrilaterals spanning these caps. As a baseline, we used sample program ShadowVolume10 of the DirectX 10 SDK, and modified it to use our optimized set of cover primitives (Figure 8a). Note that our geometry shader outputs triangle strips rather than independent triangles ( Figure 10 ). This results in a small speed improvement of 10?20%, and was applied in all measurements. Line illustration Many rendering techniques enhance object appearance by emphasizing silhouettes or other important contours, e.g. [Gooch and Gooch 2001; DeCarlo et al. 2003]. With geometry shaders, silhouette rendering is in some sense an ideal scenario to highlight the efficiency of GPU edge-processing, because the output silhouette often has sub-linear complexity. We developed a simple prototype that renders both silhouettes and sharp features ( Figure 8b ). Again, we used as a baseline the basic approach of processing all faces as triangles with adjacency following the framework from the DX10 shadow volume sample. Since we use small quadrilaterals as the rendering primitive, we can control the thickness of the lines, as well as render the mesh triangles in white for hidden line removal, all in a single rendering pass. The approach has similarities to shadow volumes, in that the mesh is also split into a front part and a rear part, and silhouette edges (with respect to the motion) are extruded to form quadrilaterals. As in the previous applications, we compared against the traditional approach of processing all triangles with adjacency. The resulting motion volume is rendered with par- tial transparency. Using a geometry shader program, this can all be done in a single rendering pass ( Figure 8c ). As in the shadow volume application, we output triangle strips since the extruded quadrilaterals share vertices with the emitted triangle faces ( Figure 10 ). Quantitative speedups We measured performance speedup factors of using our approach against the baseline methods outlined above for each application. Measurements were performed on both an NVIDIA GeForce 8800GTX and an AMD ATI Radeon HD2900. To simulate a more realistic graphics scene, the measurements used multiple instances of the models to factor out overhead due to frame setup and other elements in the scene. Through experimentation, we observed best results for our applications on the AMD and NVIDIA cards when setting the vertex cache parameter to 12 and 24 vertices, respectively. At any rate, the results we report were not significantly affected by the cache size parameter. For our geometry-shader-bound prototype applications, which just use Gouraud shading, the vertex programs may be overly simple. We have verified that a more expensive vertex program does give rise to greater speedups. The speedups produced by using our approach are reported in Table 2 . Since we are processing just over half of the number of primitives, the speedup of the cover computation could reach close to 2?. However, in practice this does not occur because each of our geometry shader instances emit more data. In general, these applications results in speedups between 1.5? and 2.0? for most input meshes. Other applications Many other applications would also benefit from efficient edge traversal. Some notable examples include fur rendering by selective extrusion of fins from edges near the silhouette [Lengyel et al. 2001], soft-shadows using penumbra wedges [Assarsson and Akenine-M?ller 2003], and beveled edges [Bahnassi and Bahnassi 2007]. One final note is that the set of cover faces can also be used to render the wireframe of the model (without a geometry shader, i.e. with mode D3D10 FILL WIREFRAME). We noticed a speedup of roughly 70% when using the cover faces rather than all faces of the model. This is naturally not as efficient as the 100% improvement that can be obtained by creating a buffer of lines containing the edges of the model. However, it may be of practical value if the list of cover faces is already available (e.g., for one the above applications), since it would not consume any additional video memory. Dismissed alternative schemes We briefly summarize some other schemes that we considered and their associated drawbacks. Each edge could be processed individually by considering its pair of adjacent faces, encoded by 4 vertices, e.g. in an indexed line-with-adjacency primitive. However, this would result in an index buffer with 4e indices for e edges, about twice as many as in our scheme. Also, face processing could not be well load-balanced among these primitives. The triangle-strip-with-adjacency primitive would appear to be a promising way to string together several triangle-with-adjacency primitives. However, even on a regular mesh region, one cannot obtain a regular covering of the mesh edges. Therefore, branching would be necessary in the geometry shader, again degrading SIMD parallelism efficiency. Limitations In current GPUs, the introduction of any geometry shader slows down the rendering pipeline. Therefore using our representation to render just the mesh faces incurs additional cost. However, for most applications that perform edge processing, the bottleneck is in the edge processing itself, and therefore the mesh rendering time does not significantly impact the results. The timing numbers in the previous section take that into account. We have designed an efficient representation for processing both edges and faces of a mesh on a GPU. Our optimized traversal representation provides two separate improvements over prior approaches: (1) a nearly two-fold reduction in the number of adjacency primitives, and (2) additional reduction in vertex processing and memory bandwidth due to improved vertex caching. These optimizations result in substantial gains for several real-time rendering methods. Future hardware is likely to include larger primitives in the form of surface patches. Defining efficient traversals for such patches will be an interesting area of continuing research. Pedro Sander was partly supported by Hong Kong RGC CERG grant #619008. pages 220?234. A SSARSSON , U. and A KENINE -M OLLER  ? , T. 2003. A geometrybased soft shadow volume algorithm using graphics hardware. 22(3):511?520. , W. 2007. Micro-beveled edges. Charles River B LYTHE , D. 2006. The Direct3D 10 system. 25(3):724?\n        734. B RENNAN , C. 2002. Shadow volume extrusion using a vertex shader. In Wordware. C ARD , D. and M ITCHELL , J. 2002. Non-photorealistic rendering with pixel and vertex shaders. In ShaderX: Vertex and Pixel Shader Tips and Tricks. C HHUGANI , J. and K UMAR , S. 2007. Geometry engine optimization: cache friendly compressed representation of geometry. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), pages 9?16. C HOW , M. M. 1997. Optimized geometry compression for realtime rendering. In IEEE Visualization, pages 347?354. D E C ARLO , D., F INKELSTEIN , A., R USINKIEWICZ , S., and S AN TELLA , A. 2003. Suggestive contours for conveying shape. 22(3):848?855. D EERING , M. 1995. Geometry compression. In pages 13?20. E DMONDS , J. and J OHNSON , E. L. 1973. Matching, Euler tours and the Chinese postman. Mathematical Programming, 5:88? 129. E STKOWSKI , R., M ITCHELL , J. S. B., and X IANG , X. 2002. Optimal decomposition of polygonal models into triangle strips. In Proceedings of Symposium on Computational Geometry, pages 254?263. E VANS , F., S KIENA , S., and V , A. 1996. Optimizing triangle strips for fast rendering. In pages 319?326. G ABOW , H. N. 1974. PhD thesis, Stanford University. , D. S. 1977. The rectilinear Steiner G OOCH , B. and G , A. 2001. A. K. Peters, Ltd.\n        G ROSSO , A., L OCATELLI , M., and P ULLAN , W. 2007. Simple ingredients leading to very efficient heuristics for the maximum clique problem. Journal of Heuristics, on-line. 18:\n        H , T. 1991. Real shadows real time. H ERTZMANN , A. 1999. Silhouettes and outlines. In Introduction to 3D Non-Photorealistic Rendering, chapter 7. ACM SIGGRAPH Course Notes. H OPPE , H. 1999. Optimization of mesh locality for transparent vertex caching. In Proceedings of ACM SIGGRAPH 99, pages 269?276. K ARYPIS , G. and K UMAR , V. 1995. L ENGYEL , J., P RAUN , E., F INKELSTEIN , A., and H OPPE , H. 2001. Real-time fur over arbitrary surfaces. In pages 227?232. L IN , G. and Y U , T. P.-Y. 2006. IEEE Transactions on Visualization and Computer Graphics, 12(4):640?648. M C G UIRE , M. and H UGHES , J. 2004. Hardware-determined feature edges. In pages 35?47. R OTHBERG , E. 1985. http://elib.zib.de/ pub/Packages/mathprog/matching/weighted. S ANDER , P. V., N EHAB , D., and B ARCZAK , J. 2007. Fast triangle reordering for vertex locality and reduced overdraw. ACM Trans- T ARIQ , S. 2007. Fur (using shells and fins). Technical Report WP-03021-001-v01, NVIDIA Corp. , R. C. 1996. Interactive real-time 12(6):283?295. X IANG , X., H ELD , M., and M ITCHELL , J. S. B. 1999. Fast and effective stripification of polygonal surface models. pages 71?78. A simple lower bound on the size |C| of our vertex cover is obtained as follows. Let d(v) denote the degree of vertex v (in either the primal or the dual graph). Then, d(v ) ? 3 for every dual vertex v ? V since each triangle has at most 3 neighbors. This can be tightened by obtaining a lower bound on the number of edges that must be covered twice. The intuition is that all odddegree vertices in the mesh must have at least one adjacent edge that is covered twice, and moreover these doubly covered edges must form paths that terminate only at other odd-degree vertices. Formally, consider a vertex v in the primal graph, the ring R(v) of dual vertices surrounding v (i.e. a red cycle in Figure 3a ), and let t(v) denote the number of edges in R(v) that are covered twice. Since C is a cover, one can show that t(v) ? d(v) (mod 2). Let G  ? = (V, E)  ? be a minimum subgraph of G (minimizing | E|)  ? such that for all v ? V , d G  ? (v) ? d G (v) (mod 2). Then the number of edges covered twice by C must be at least | E|. ? Arguing as before, we obtain |C| ? (|E | + | E|)/3. ? A set of edges for which the odd-degree vertices coincide with a set T is called a T -join. Thus, the set E  ? is a minimum V odd -join, where V odd is the set of odd-degree vertices in G. It has been shown that finding a minimum T -join can be reduced to a minimum-weight perfect matching problem. In particular, Edmonds and Johnson [1973] have shown that the minimum V odd join is equivalent to a minimum weight matching between odddegree vertices, where the weight attached to any pair of vertices u, v ? V odd is exactly the shortest-path distance in G, dist G (u, v). We are able to greatly speed up this computation by noting that a shortest path between two vertices in V odd that crosses two other vertices in V odd cannot contribute to the minimum-weight perfect matching. We call such paths illegal. Often this prunes 99% of the search space. To verify the validity of this optimization, we prove the following lemma (the actual proof is not necessary for the implementation of either our algorithm, or the lower bound). To prove (1), note that G  ? contains no cycles (their removal preserves a V odd -join). For each such tree T , we find a legal path decomposition by repeatedly performing the following: Contract all uninterrupted paths in T to individual edges. Choose a lowest leaf and match it to its sibling, removing the connecting path in T . To prove (2), note that for any such matching, if the total length of all shortest paths is minimal, the paths must be edge-disjoint. We start with two crucial observations, which follow from the minimality of E:  ? Both observations follow from the same principle. If we had a path p ? between a and b that violates either Observation 1 or Observation 2 (that is, p ? is shorter than T a,b or is a distinct shortest path intersecting E),  ? we could construct a strictly smaller V odd -join by removing path T a,b and taking the symmetric difference of the remaining edge set and p ? . We may assume that G  ? contains the minimum number of trees among all minimum V odd -joins. Suppose for the sake of contradiction that for some vertices u, v ? V odd in some tree T connected by a legal T -path p, there exists an illegal shortest path p containing two internal vertices x, y ? V odd . We consider two cases: Case 1: Nodes x and y are in the same tree T (possibly T = T ) in G  ? ( Figure 11a ). Let p x,y be the sub-path of p from x to y, and let T x,y be the shortest tree path from x to y. By the minimality of p and Observation 1, both paths are shortest paths from x to y. Case 2: For trees T = T in G,  ? x ? T and y ? T (Figure 11d).",
  "resources" : [ ]
}