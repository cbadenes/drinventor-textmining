{
  "uri" : "sig2012a-a160-chen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2012a/a160-chen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Depth-Presorted Triangle Lists",
    "published" : "2012",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ge-Chen",
      "name" : "Ge",
      "surname" : "Chen"
    }, {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Lei-Yang",
      "name" : "Lei",
      "surname" : "Yang"
    }, {
      "uri" : "http://drinventor/Liang-Hu",
      "name" : "Liang",
      "surname" : "Hu"
    } ]
  },
  "bagOfWords" : [ "we", "present", "novel", "approach", "real-time", "rendering", "static", "3d", "model", "front-to-back", "back-to-front", "relative", "any", "viewpoint", "outside", "its", "bound", "volume", "select", "subsequence", "statically", "presort", "depth", "contain", "each", "input", "triangle", "exactly", "once", "work", "we", "present", "technique", "possess", "unique", "combination", "desirable", "property", "whereas", "most", "previous", "depth-sorting", "algorithm", "work", "seamlessly", "deformable", "geometry", "run-time", "we", "method", "assume", "static", "geometry", "view", "from", "outside", "model?s", "bound", "volume", "finally", "we", "preprocessing", "stage", "can", "take", "hour", "complete", "when", "run", "larger", "model", "result", "data-structure", "consume", "more", "memory", "than", "input", "scenario", "which", "we", "demonstrate", "result", "section", "relative", "order", "between", "object", "determine", "CPU", "we", "method", "ensure", "correct", "triangle", "order", "within", "each", "object", "end", "release", "cycle", "require", "model", "can", "preprocessed", "engine", "set", "up", "take", "advantage", "simplicity", "we", "run-time", "component", "large", "performance", "gain", "ensue", "we", "key", "insight", "space", "different", "triangle", "order", "result", "from", "depth-sort", "triangle", "model", "under", "each", "possible", "viewpoint", "constitute", "tiny", "fraction", "all", "triangle", "permutation", "moreover", "space", "depth-sorted", "order", "extremely", "redundant", "sense", "few", "modification", "same", "order", "valid", "large", "portion", "viewpoint", "space", "we", "explore", "insight", "following", "way", "during", "preprocessing", "stage", "we", "create", "extended", "sequence", "triangle", "-lrb-", "i.e.", "list", "contain", "one", "more", "instance", "each", "input", "triangle", "-rrb-", "view-dependent", "subsequence", "guarantee", "include", "each", "input", "triangle", "exactly", "once", "entire", "extended", "sequence", "send", "render", "GPU", "which", "point", "extremely", "simple", "efficient", "run-time", "procedure", "select", "those", "triangle", "which", "associate", "half-space", "contain", "viewpoint", "since", "run-time", "sorting", "only", "trivial", "run-time", "selection", "procedure", "we", "method", "run", "order", "magnitude", "faster", "than", "previous", "approach", "summary", "we", "contribution", "include", "fastest", "single-draw-call", "exact", "real-time", "depth-sorted", "rendering", "algorithm", "static", "model", "preprocessing", "algorithm", "create", "compact", "extended", "sequence", "triangle", "associate", "half-space", "contain", "depth-sorted", "subsequence", "relative", "all", "viewpoint", "three", "version", "run-time", "algorithm", "select", "subsequence", "associate", "give", "viewpoint", "all", "lead", "state-of-the-art", "run-time", "performance", "rest", "paper", "organize", "follow", "section", "we", "position", "we", "method", "context", "previous", "work", "section", "present", "two", "simple", "example", "helpful", "understand", "preprocess", "algorithm", "which", "describe", "section", "section", "provide", "relevant", "statistics", "specific", "we", "method", "well", "performance", "comparison", "against", "previous", "approach", "note", "many", "depth-sorting", "method", "can", "use", "render", "dynamic", "-lrb-", "even", "self-intersecting", "-rrb-", "geometry", "naturally", "when", "compare", "they", "against", "we", "approach", "we", "assume", "target", "application", "do", "require", "functionality", "each", "node", "BSP", "tree", "include", "half-space", "test", "BSP", "tree", "create", "during", "preprocessing", "stage", "much", "like", "we", "extended", "triangle", "list", "render", "from", "bsp", "tree", "traverse", "recursively", "run-time", "back-to-front", "rendering", "when", "visit", "node", "subtree", "represent", "half-space", "contain", "viewpoint", "visit", "last", "we", "method", "half-space", "instead", "use", "separate", "viewpoint", "which", "give", "individual", "triangle", "instance", "must", "draw", "from", "those", "which", "must", "ignore", "we", "method", "therefore", "better", "suit", "modern", "gpus", "where", "recursiveness", "pointer", "manipulation", "difficult", "otherwise", "inefficient", "accomplish", "early", "cpu-based", "approach", "also", "generate", "flat", "semi-flat", "datastructure", "Newell", "et", "al.", "-lsb-", "1972", "-rsb-", "Goad", "-lsb-", "1982", "-rsb-", "both", "describe", "automatic", "procedure", "sort", "triangle", "priority", "order", "give", "viewpoint", "Schumacker", "et", "al.", "-lsb-", "1969", "-rsb-", "propose", "method", "separate", "scene", "convex", "cluster", "during", "preprocessing", "we", "method", "leverage", "GPU", "hardware", "order", "render", "model", "use", "single", "draw", "call", "without", "require", "order", "computation", "run-time", "we", "method", "require", "single", "pass", "use", "constant", "memory", "significantly", "faster", "particularly", "when", "multiple", "sample", "per", "pixel", "use", "anti-aliasing", "-lrb-", "e.g.", "msaa", "-rrb-", "include", "rbuffer", "-lsb-", "wittenbrink", "2001", "-rsb-", "f-buffer", "-lsb-", "Mark", "Proudfoot", "2001", "-rsb-", "Delay", "Streams", "-lsb-", "Aila", "et", "al.", "2003", "-rsb-", "freepipe", "architecture", "-lsb-", "Liu", "et", "al.", "2010", "-rsb-", "we", "method", "run", "standard", "render", "pipeline", "another", "alternative", "render", "scene", "many", "time", "require", "maximum", "depth", "complexity", "each", "pass", "z-buffer", "use", "select", "next", "closest", "fragment", "-lsb-", "mamman", "1989", "Everitt", "2001", "Thibieroz", "2008", "-rsb-", "-lrb-", "much", "like", "selection", "sort", "-rrb-", "performance", "reason", "variation", "idea", "split", "scene", "piece", "presorted", "-lsb-", "Wexler", "et", "al.", "2005", "-rsb-", "peel", "multiple", "layer", "per", "pass", "-lsb-", "Liu", "et", "al.", "2006", "Bavoil", "Myers", "2008", "-rsb-", "exploit", "any", "order", "structure", "may", "already", "present", "-lsb-", "Carr", "et", "al.", "2008", "-rsb-", "we", "method", "simpler", "depend", "depth-complexity", "significantly", "faster", "many", "method", "rely", "approximation", "performance", "reason", "we", "method", "always", "produce", "noisefree", "rendering", "significantly", "faster", "finally", "context", "overdraw", "reduction", "some", "static", "order", "may", "succeed", "eliminate", "most", "overdraw", "-lsb-", "Nehab", "et", "al.", "2006", "Sander", "et", "al.", "2007", "-rsb-", "we", "begin", "present", "two", "simple", "example", "motivate", "we", "strategy", "build", "depth-presorted", "triangle", "list", "simplicity", "we", "show", "both", "example", "2d", "-lrb-", "see", "figure", "-rrb-", "triangle", "represent", "line", "segment", "arrow", "next", "each", "triangle", "represent", "normal", "direction", "consider", "non-convex", "model", "figure", "-lrb-", "top", "left", "-rrb-", "we", "show", "possible", "produce", "depth-sorted", "rendering", "model", "-lrb-", "include", "back-facing", "triangle", "-rrb-", "from", "any", "viewpoint", "use", "fix", "triangle", "order", "trick", "duplicate", "each", "triangle", "include", "additional", "instance", "opposite", "orientation", "augmented", "model", "newly", "instance", "back-facing", "triangle", "blue", "show", "figure", "-lrb-", "top", "right", "-rrb-", "although", "now", "twice", "many", "triangle", "original", "model", "back-face", "culling", "ensure", "hardware", "rasterize", "most", "one", "instance", "each", "triangle", "additional", "freedom", "award", "duplication", "allow", "we", "create", "triangle", "order", "we", "seek", "same", "token", "cde", "never", "occlude", "any", "triangle", "can", "add", "front", "list", "triangle", "have", "more", "complex", "occlusion", "relationship", "solve", "general", "case", "automatically", "we", "first", "construct", "graph", "capture", "all", "occlusion", "relationship", "occlusion", "graph", "show", "figure", "-lrb-", "bottom", "-rrb-", "order", "whenever", "direct", "graph", "acyclic", "-lrb-", "i.e.", "dag", "-rrb-", "case", "occlusion", "graph", "figure", "surprisingly", "possible", "construct", "order", "describe", "above", "many", "simple", "object", "unfortunately", "general", "case", "may", "cycle", "occlusion", "graph", "even", "back-face", "culling", "so", "topological", "sort", "can", "find", "simplest", "case", "show", "figure", "-lrb-", "left", "-rrb-", "corresponding", "occlusion", "graph", "contain", "cycle", "show", "underneath", "-lrb-", "we", "have", "omit", "back-facing", "triangle", "from", "graph", "isolate", "single", "cycle", "-rrb-", "key", "observation", "can", "only", "occlude", "viewpoint", "inside", "yellow", "region", "can", "only", "occlude", "viewpoint", "gray", "region", "furthermore", "region", "can", "separate", "cut", "plane", "-lrb-", "red", "dashed-line", "-rrb-", "thus", "we", "can", "solve", "cycle", "problem", "create", "extra", "copy", "show", "figure", "-lrb-", "bottom", "right", "-rrb-", "use", "cut", "plane", "select", "copy", "render", "depend", "which", "side", "current", "viewpoint", "lie", "section", "we", "describe", "algorithm", "automatically", "generate", "depth-presorted", "triangle", "list", "arbitrary", "input", "model", "while", "description", "we", "assume", "back-to-front", "order", "desire", "algorithm", "can", "trivially", "adjust", "create", "front-to-back", "order", "since", "we", "method", "focus", "static", "model", "we", "assume", "intersect", "triangle", "have", "be", "split", "prior", "invocation", "we", "preprocess", "algorithm", "so", "input", "list", "contain", "intersect", "triangle", "moreover", "we", "assume", "way", "depth-sort", "triangle", "from", "any", "viewpoint", "other", "word", "we", "assume", "single-viewpoint", "visibility", "cycle", "input", "model", "self-intersection", "which", "common", "production", "model", "must", "anyway", "eliminate", "when", "render", "transparency", "additional", "preprocessing", "can", "break", "cycle", "splitting", "triangle", "when", "need", "example", "section", "3.1", "we", "create", "back-facing", "duplicate", "each", "input", "triangle", "order", "relax", "occlusion", "restriction", "we", "compute", "occlusion", "graph", "generate", "preliminary", "order", "graph", "have", "cycle", "topological", "sort", "completely", "solve", "problem", "-lsb-", "skiena", "2008", "-rsb-", "when", "cycle", "good", "preliminary", "order", "one", "minimize", "number", "back-edge", "find", "optimal", "preliminary", "order", "equivalent", "solve", "minimum", "feedback", "arc-set", "problem", "which", "np-complete", "-lsb-", "karp", "1972", "-rsb-", "fortunately", "correctness", "we", "algorithm", "do", "depend", "optimality", "therefore", "we", "use", "fast", "heuristic", "detail", "section", "4.2", "final", "most", "important", "preprocess", "stage", "deal", "backedge", "preliminary", "order", "do", "so", "we", "scan", "order", "from", "finish", "duplicate", "triangle", "associate", "they", "halfspace", "whenever", "we", "find", "back-edge", "step", "follow", "along", "line", "example", "section", "3.2", "describe", "below", "each", "iteration", "we", "process", "graph", "node", "move", "along", "preliminary", "order", "from", "finish", "node", "send", "back-edge", "can", "safely", "ignore", "all", "back-edge", "must", "deal", "example", "guide", "we", "through", "algorithm", "here", "move", "along", "list", "from", "right", "left", "current", "iteration", "reach", "yellow", "node", "back-edge", "-lrb-", "red", "-rrb-", "must", "eliminate", "work", "whenever", "triangle", "between", "edge", "point", "x.", "plane", "must", "set", "viewpoint", "from", "which", "occlude", "contain", "one", "half-space", "whereas", "set", "viewpoint", "from", "which", "occlude", "contain", "other", "half-space", "algorithm", "find", "plane", "-lrb-", "when", "exist", "-rrb-", "give", "section", "4.1.1", "we", "can", "duplicate", "follow", "we", "annotate", "right", "copy", "half-space", "test", "so", "run-time", "algorithm", "describe", "section", "only", "render", "copy", "viewpoint", "correct", "half-space", "left", "copy", "do", "need", "annotated", "plane", "use", "z-buffering", "depth-test", "less", "ensure", "fragment", "generate", "left", "copy", "shaded", "store", "only", "right", "copy", "skip", "-lrb-", "recall", "back-to-front", "render", "proceeds", "from", "right", "leave", "-rrb-", "fact", "allow", "we", "avoid", "deal", "multiple", "half-space", "test", "most", "practical", "case", "Whenever", "we", "can", "find", "completely", "separate", "viewpoint", "associate", "edge", "from", "those", "associate", "edge", "from", "clear", "we", "can", "move", "next", "offend", "node", "thus", "duplicate", "may", "introduce", "graph", "new", "back-edge", "emanate", "from", "subset", "show", "below", "case", "we", "proceed", "next", "iteration", "postpone", "handling", "new", "back-edge", "iteration", "analyze", "node", "from", "which", "emanate", "-lrb-", "example", "-rrb-", "we", "note", "earlier", "general", "only", "right", "copy", "assign", "half-space", "test", "z-buffer", "deal", "left", "copy", "therefore", "we", "traverse", "list", "from", "right", "left", "each", "node", "copy", "process", "only", "once", "assign", "most", "one", "plane", "important", "notice", "long", "we", "manage", "separate", "least", "one", "edge", "between", "from", "least", "one", "edge", "between", "we", "have", "make", "progress", "since", "number", "finite", "algorithm", "terminate", "we", "focus", "three", "node", "graph", "current", "node", "right-most", "node", "which", "send", "back-edge", "right-most", "node", "between", "send", "forward-edge", "we", "further", "assume", "exist", "path", "from", "so", "cycle", "graph", "-lrb-", "otherwise", "we", "could", "simply", "move", "right", "-rrb-", "viewpoint", "edge", "-lrb-", "-rrb-", "can", "separate", "from", "viewpoint", "edge", "-lrb-", "-rrb-", "we", "duplicate", "usual", "viewpoint", "edge", "-lrb-", "-rrb-", "can", "separate", "from", "those", "edge", "-lrb-", "-rrb-", "we", "duplicate", "instead", "finally", "viewpoint", "edge", "-lrb-", "-rrb-", "can", "separate", "from", "those", "edge", "-lrb-", "-rrb-", "we", "duplicate", "node", "configuration", "show", "below", "least", "one", "separation", "must", "possible", "otherwise", "would", "viewpoint", "from", "which", "entire", "cycle", "visible", "would", "preclude", "existence", "depth-sorted", "triangle", "order", "viewpoint", "contradict", "we", "assumption", "therefore", "complete", "proof", "note", "we", "follow", "strategy", "duplicate", "move", "right", "possible", "may", "have", "other", "back-edge", "require", "further", "duplication", "case", "additional", "plane", "have", "associate", "right", "copy", "b.", "fortunately", "must", "relatively", "rare", "since", "we", "have", "never", "observe", "practice", "let", "we", "begin", "few", "definition", "we", "associate", "occlusion", "region", "i?j", "each", "edge", "from", "node", "node", "define", "set", "viewpoint", "from", "whence", "occludes", "j.", "thus", "from", "viewpoint", "outside", "i?j", "edge", "do", "exist", "similarly", "we", "associate", "each", "node", "-lrb-", "i.e.", "each", "triangle", "instance", "-rrb-", "render", "region", "represent", "set", "viewpoint", "from", "which", "render", "node", "duplicated", "render", "region", "new", "node", "cumulatively", "restricted", "associate", "half-space", "can", "therefore", "become", "rather", "small", "therefore", "each", "edge", "relevant", "only", "inside", "reduce", "occlusion", "region", "definition", "hand", "we", "can", "define", "problem", "find", "appropriate", "cut", "plane", "p.", "let", "current", "node", "be", "analyze", "we", "want", "duplicate", "place", "new", "copy", "left", "we", "hope", "find", "plane", "partition", "edge", "among", "two", "instance", "back-edge", "go", "new", "-lrb-", "left", "-rrb-", "instance", "forward-edge", "remain", "current", "-lrb-", "right", "-rrb-", "instance", "since", "ideal", "plane", "may", "exist", "we", "greedily", "look", "good", "alternative", "we", "we", "search", "separate", "back-edge", "region", "from", "empty", "forward-edge", "region", "-lrb-", "plane", "itself", "do", "job", "-rrb-", "we", "try", "progressively", "add", "forward-edge", "region", "set", "we", "can", "find", "separate", "plane", "between", "-lrb-", "-rrb-", "otherwise", "we", "set", "consider", "add", "occlusion", "region", "next", "forward-edge", "when", "we", "do", "consider", "all", "forward-edge", "-lrb-", "order", "efficiency", "-rrb-", "we", "assign", "last", "successful", "separate", "plane", "orig", "-lrb-", "-rrb-", "inal", "move", "edge", "account", "final", "region", "its", "new", "copy", "address", "when", "time", "come", "duplicate", "require", "subset", "show", "section", "4.1", "fact", "always", "possible", "separate", "least", "one", "from", "least", "one", "x?b", "we", "can", "rely", "fall-back", "procedure", "ensure", "termination", "algorithm", "section", "we", "detail", "geometric", "operation", "use", "efficiently", "compute", "ultimately", "cut", "plane", "separate", "they", "computation", "involve", "convex-hull", "half-space", "intersection", "linear-programming", "perform", "use", "qhull", "-lsb-", "Barber", "et", "al.", "1996", "-rsb-", "lp_solve", "-lsb-", "berkelaar", "et", "al.", "2004", "-rsb-", "library", "intersection", "viewpoint", "region", "determine", "reduce", "occlusion", "region", "i?j", "amount", "find", "intersection", "between", "three", "convex", "region", "do", "so", "we", "form", "intersection", "between", "all", "half-space", "define", "each", "i?j", "since", "intersection", "often", "empty", "optimization", "avoid", "costly", "half-space", "intersection", "we", "first", "check", "all", "vertex", "either", "outside", "one", "plane", "bound", "i?j", "so", "intersection", "empty", "Union", "viewpoint", "region", "we", "conservatively", "approximate", "-lrb-", "-rrb-", "each", "region", "convex-hull", "note", "do", "compromise", "find", "ideal", "cut", "plane", "since", "any", "plane", "-lrb-", "-rrb-", "separate", "from", "also", "separate", "convex-hull", "-lrb-", "-rrb-", "cut", "plane", "give", "convex-hull", "we", "use", "linear", "programming", "determine", "whether", "intersect", "so", "cut", "plane", "can", "separate", "they", "algorithm", "proceeds", "without", "-lrb-", "-rrb-", "update", "otherwise", "we", "check", "any", "bound", "plane", "two", "region", "suitable", "cut", "plane", "-lrb-", "i.e.", "all", "vertex", "other", "region", "lie", "opposite", "side", "plane", "-rrb-", "least", "one", "plane", "necessarily", "separate", "two", "convex-hull", "become", "candidate", "plane", "practice", "we", "find", "generate", "single", "depth-presorted", "triangle", "list", "entire", "range", "viewpoint", "require", "far", "too", "many", "triangle", "duplication", "lead", "list", "many", "time", "many", "triangle", "input", "model", "divide", "space", "viewpoint", "small", "number", "partition", "create", "independent", "depth-presorted", "triangle", "list", "each", "partition", "we", "get", "much", "better", "trade-off", "between", "total", "memory", "usage", "run-time", "performance", "-lrb-", "see", "result", "section", "-rrb-", "divide", "space", "view", "point", "partition", "we", "first", "enclose", "model", "bound", "polyhedron", "give", "number", "face", "-lrb-", "we", "have", "experiment", "16", "64", "-rrb-", "each", "partition", "define", "one", "polyhedron", "face", "boundary", "neighbor", "partition", "figure", "limit", "set", "valid", "viewpoint", "lie", "outside", "bound", "polyhedron", "we", "further", "reduce", "number", "constraint", "occlusion", "graph", "only", "further", "modification", "when", "compute", "depth-presorted", "triangle", "list", "each", "partition", "all", "render", "region", "further", "restricted", "corresponding", "partition", "we", "experiment", "different", "orientation", "polyhedron", "obtain", "very", "similar", "result", "depth-presorted", "list", "each", "partition", "can", "compute", "simultaneously", "leverage", "parallelism", "multi-core", "cpus", "list", "concatenate", "index", "buffer", "multiple", "segment", "run-time", "we", "issue", "draw", "call", "render", "segment", "index", "buffer", "correspond", "partition", "contain", "current", "viewpoint", "thus", "CPU", "perform", "coarse-level", "viewpoint", "selection", "-lrb-", "which", "trivial", "-rrb-", "GPU", "complete", "fine-level", "triangle", "selection", "describe", "below", "task", "run-time", "select", "those", "triangle", "from", "depthpresorted", "list", "pass", "half-space", "test", "recall", "each", "triangle", "annotated", "test", "plane", "-lrb-", "4d", "vector", "store", "plane", "equation", "-rrb-", "decide", "whether", "render", "triangle", "from", "viewpoint", "xyz", "we", "use", "single", "dot", "product", "which", "extremely", "efficient", "modern", "gpus", "triangle", "associated", "test", "plane", "we", "use", "-lsb-", "-rsb-", "which", "cause", "test", "always", "succeed", "test", "can", "implement", "either", "vertex", "geometry", "fragment", "shader", "programmable", "pipeline", "stage", "although", "each", "alternative", "have", "advantage", "disadvantage", "depend", "application", "render", "configuration", "-lrb-", "see", "section", "-rrb-", "we", "favor", "fragment", "shader", "test", "option", "fragment", "shader", "-lrb-", "f", "-rrb-", "4d", "plane", "vector", "keep", "32-bit", "4-channel", "texture", "index", "triangle", "id", "-lrb-", "although", "practice", "need", "have", "arise", "would", "simple", "encode", "entire", "linked-list", "test-plane", "texture", "-rrb-", "f", "issue", "lookup", "perform", "dot", "product", "since", "one", "dot", "product", "test", "perform", "per", "triangle", "fragment", "method", "may", "suffer", "pixelbound", "scene", "fortunately", "test", "inexpensive", "texture", "access", "coherent", "option", "Vertex", "shader", "-lrb-", "VS", "-rrb-", "4d", "plane", "vector", "send", "vertex", "attribute", "when", "dot", "product", "test", "fail", "v", "move", "vertex", "viewpoint", "position", "so", "get", "cull", "near", "plane", "otherwise", "apply", "standard", "vertex", "transformation", "since", "all", "three", "vertex", "each", "triangle", "perform", "same", "exact", "test", "result", "consistent", "drawback", "approach", "triangle", "can", "longer", "share", "vertex", "which", "may", "impact", "vertex", "bind", "scene", "g", "emit", "only", "triangle", "pass", "dot", "product", "test", "section", "we", "discuss", "performance", "memory", "consumption", "we", "approach", "all", "experiment", "be", "conduct", "Intel", "xeon", "2.27", "GHz", "E5520", "CPU", "12gb", "RAM", "AMD", "Radeon", "HD", "6970", "GPU", "we", "use", "model", "resolution", "range", "from", "1,000", "100,000", "triangle", "which", "we", "believe", "representative", "resolution", "depth", "complexity", "most", "static", "model", "find", "game", "all", "rendering", "use", "alpha", "blend", "proper", "semitransparency", "when", "render", "back-to-front", "figure", "runtime", "performance", "result", "figure", "average", "over", "256", "viewpoint", "around", "model", "report", "ratio", "relative", "baseline", "standard", "rendering", "measure", "directly", "clock", "tick", "baseline", "render", "all", "input", "triangle", "order", "optimize", "vertex-cache", "locality", "-lrb-", "completely", "disregard", "depth-sorting", "-rrb-", "example", "render", "depth-sorted", "model", "we", "method", "twice", "expensive", "baseline", "rendering", "we", "report", "performance", "ratio", "two", "segment", "partitioning", "figure", "show", "effect", "increase", "number", "viewpoint", "partition", "average", "number", "triangle", "per", "segment", "-lrb-", "i.e", "actually", "process", "draw-call", "run-time", "-rrb-", "well", "total", "memory", "consumption", "average", "draw", "call", "size", "report", "ratio", "number", "triangle", "input", "triangle", "list", "calculation", "assume", "each", "vertex", "contain", "position", "normal", "texture", "coordinate", "note", "although", "increase", "number", "partition", "increase", "memory", "consumption", "reduce", "average", "segment", "size", "important", "note", "total", "memory", "increase", "only", "happen", "transparent", "part", "model", "have", "any", "transparency", "effect", "all", "furthermore", "vast", "majority", "memory", "modern", "game", "consume", "texture", "geometry", "lagging", "far", "behind", "we", "find", "use", "viewpoint", "partition", "provide", "reasonable", "trade-off", "model", "we", "test", "amount", "memory", "use", "significantly", "higher", "than", "partition", "marked", "decrease", "average", "segment", "size", "translate", "performance", "gain", "render", "time", "remainder", "experiment", "section", "we", "use", "viewpoint", "partition", "preprocess", "Figure", "show", "preprocessing", "time", "we", "method", "depend", "model", "number", "triangle", "can", "take", "anywhere", "between", "few", "minute", "several", "hour", "complete", "computation", "different", "segment", "parallelize", "use", "multiple", "CPU", "core", "while", "preprocessing", "algorithm", "can", "slow", "large", "input", "important", "point", "out", "only", "need", "execute", "once", "each", "static", "model", "further", "optimization", "could", "improve", "preprocessing", "time", "we", "instead", "concentrate", "we", "effort", "optimize", "better", "run-time", "result", "which", "ultimate", "goal", "render", "approach", "figure", "compare", "performance", "three", "version", "we", "run-time", "selection", "procedure", "each", "use", "different", "stage", "pipeline", "geometry", "shader", "option", "significantly", "slower", "due", "fact", "add", "new", "shade", "stage", "render", "pipeline", "therefore", "we", "only", "see", "option", "be", "viable", "when", "rendering", "effect", "already", "require", "geometry", "shader", "which", "case", "would", "require", "simply", "add", "plane", "test", "exist", "shader", "vertex", "shader", "fragment", "shader", "version", "significantly", "faster", "very", "low-resolution", "model", "rendering", "fill-bound", "make", "fragment", "shader", "option", "more", "costly", "mediumand", "high-resolution", "model", "however", "vertex", "processing", "overhead", "vertex", "shader", "approach", "dominate", "thus", "most", "practical", "model", "size", "fragment", "shader", "option", "most", "efficient", "we", "algorithm", "be", "only", "slower", "than", "baseline", "overall", "performance", "we", "compare", "overall", "performance", "we", "fragment", "shader", "algorithm", "selection", "state-of-theart", "real-time", "depth-sorting", "algorithm", "per-pixel", "dynamic", "link", "list", "-lrb-", "ll", "-rrb-", "-lsb-", "Yang", "et", "al.", "2010", "-rsb-", "stochastic", "transparency", "-lrb-", "st", "-rrb-", "-lsb-", "Enderton", "et", "al.", "2010", "-rsb-", "dual", "depth", "peeling", "-lrb-", "ddp", "-rrb-", "-lsb-", "Bavoil", "Myers", "2008", "-rsb-", "st", "approximate", "algorithm", "while", "ddp", "ll", "produce", "exact", "result", "-lrb-", "ddp", "use", "occlusion", "query", "ensure", "further", "pass", "require", "ll", "use", "sophisticated", "sorting", "operation", "available", "legacy", "hardware", "-rrb-", "test", "be", "run", "each", "we", "model", "640", "480", "-lrb-", "figure", "-rrb-", "1280", "720", "-lrb-", "figure", "-rrb-", "screen", "resolution", "demonstrate", "different", "trade-off", "involve", "we", "algorithm", "significantly", "faster", "than", "alternative", "particularly", "high", "screen", "resolution", "conversely", "advantage", "we", "method", "even", "higher", "smaller", "model", "because", "relative", "overhead", "increase", "pixel", "count", "negligible", "we", "method", "contrast", "effect", "increase", "input", "triangle", "count", "nevertheless", "even", "low", "screen", "resolution", "larger", "model", "we", "method", "significantly", "faster", "than", "alternative", "we", "method", "become", "slower", "than", "alternative", "would", "require", "combination", "enormous", "amount", "geometry", "either", "small", "screen", "coverage", "-lrb-", "pixel", "base", "approach", "-rrb-", "very", "small", "maximum", "depth-complexity", "-lrb-", "depth-peeling", "approach", "-rrb-", "since", "gpus", "heavily", "optimize", "batch", "processing", "few", "large", "index", "buffer", "we", "simpler", "singlepass", "method", "faster", "practical", "scenario", "even", "up", "several", "million", "transparent", "triangle", "complex", "scene", "we", "test", "we", "approach", "complex", "room", "scene", "-lrb-", "figure", "10", "-rrb-", "consist", "physical", "simulation", "multiple", "semi-transparent", "dragon", "interact", "collide", "one", "another", "we", "use", "screen", "resolution", "1280", "720", "4x-msaa", "refer", "accompany", "video", "entire", "animation", "sequence", "intermodel", "depth-sorting", "perform", "CPU", "use", "model", "convex", "bound", "volume", "which", "also", "use", "collision", "detection", "trivial", "fast", "small", "number", "object", "since", "convex", "bound", "volume", "allow", "inter-penetrate", "sorting", "result", "guarantee", "correct", "standard", "rendering", "-lrb-", "figure", "10a", "-rrb-", "do", "render", "triangle", "each", "model", "depth", "sort", "order", "therefore", "yield", "incorrect", "transparency", "effect", "example", "rear", "left", "foot", "dragon", "show", "closeup", "appear", "very", "prominently", "even", "though", "behind", "body", "expect", "we", "method", "-lrb-", "figure", "10b", "-rrb-", "ll", "st", "ddp", "generate", "correct", "result", "we", "measure", "render", "time", "entire", "scene", "vary", "number", "dragon", "-lrb-", "figure", "10c", "-rrb-", "result", "scene", "geometric", "complexity", "40,000", "2,000,000", "triangle", "-lrb-", "50", "dragon", "-rrb-", "clearly", "performance", "inversely", "proportional", "number", "dragon", "scene", "we", "method", "significantly", "faster", "compare", "other", "approach", "furthermore", "we", "method", "ddp", "produce", "exact", "result", "which", "case", "st", "ll", "msaa", "refer", "accompany", "video", "entire", "animation", "sequence", "get", "sense", "performance", "implication", "we", "approach", "scenario", "we", "vary", "resolution", "we", "semi-transparent", "model", "order", "present", "we", "performance", "result", "function", "percentage", "scene", "primitive", "semi-transparent", "so", "instance", "approximately", "15", "game?s", "primitive", "semitransparent", "slowdown", "have", "triangle", "sort", "order", "just", "about", "1.1", "we", "present", "new", "algorithm", "efficient", "exact", "depth-sorted", "rendering", "static", "triangle", "model", "we", "method", "produce", "depthpresorted", "triangle", "list", "which", "each", "triangle", "annotated", "test", "plane", "list", "can", "render", "depth-sorted", "order", "use", "single", "draw", "call", "give", "viewpoint", "simple", "run-time", "culling", "procedure", "execute", "GPU", "rasterize", "subsequence", "triangle", "produce", "depth-sorted", "rendering", "model", "relative", "viewpoint", "we", "show", "approach", "significantly", "faster", "than", "alternative", "method", "main", "limitation", "we", "method", "-lrb-", "-rrb-", "standard", "rendering", "-lrb-", "-rrb-", "we", "result", "-lrb-", "-rrb-", "rendering", "we", "approach", "only", "suitable", "static", "model", "viewpoint", "outside", "bound", "polyhedron", "however", "we", "feel", "exist", "wide", "range", "application", "which", "limitation", "do", "matter", "finally", "we", "believe", "novel", "selection", "base", "scheme", "use", "single", "draw", "call", "significant", "departure", "from", "exist", "method", "most", "which", "require", "either", "sort", "multipass", "rendering", "we", "believe", "direction", "worth", "further", "investigation", "particularly", "way", "handle", "deformable", "model", "would", "interesting", "consider", "generate", "set", "order", "conjunction", "allow", "limited", "range", "deformation", "run-time", "work", "partly", "support", "Hong", "Kong?s", "RGC", "GRF", "grant", "619509", "inst", "grant", "from", "FAPERJ" ],
  "content" : "We present a novel approach for real-time rendering of static 3D models front-to-back or back-to-front relative to any viewpoint outside its bounding volume. Selected subsequences are statically presorted by depth and contain each input triangle exactly once. In this work, we present a technique that possesses a unique combination of desirable properties. Whereas most previous depth-sorting algorithms work seamlessly with deformable geometry at run-time, our method assumes static geometry viewed from outside the model?s bounding volume. Finally, our preprocessing stage can take hours to complete when run on larger models, and the resulting data-structure consumes more memory than the input. In this scenario, which we demonstrate in the results section, the relative order between objects is determined by the CPU, and our method ensures correct triangle ordering within each object. At the end of the release cycle, required models can be preprocessed and the engine set up to take advantage of the simplicity of our run-time component, and of the large performance gains that ensue. Our key insight is that the space of different triangle orders that result from depth-sorting a triangle model under each possible viewpoint constitutes a tiny fraction of all triangle permutations. Moreover, this ?space of depth-sorted orders? is extremely redundant in the sense that, with few modifications, the same order is valid for large portions of the viewpoint space. We explore this insight in the following way. During a preprocessing stage, we create an extended sequence of triangles (i.e., a list that contains one or more instances of each input triangle). These view-dependent subsequences are guaranteed to include each input triangle exactly once. The entire extended sequence is sent for rendering by the GPU, at which point an extremely simple and efficient run-time procedure selects those triangles for which the associated half-space contains the viewpoint. Since there is no run-time sorting, only a trivial run-time selection procedure, our method runs at an order of magnitude faster than previous approaches. In summary, our contributions include: ? The fastest single-draw-call, exact, real-time depth-sorted rendering algorithm for static models; ? A preprocessing algorithm for creating a compact extended sequence of triangles and associated half-spaces containing depth-sorted subsequences relative to all viewpoints; ? Three versions of the run-time algorithm for selecting the subsequence associated to a given viewpoint, all leading to state-of-the-art run-time performance. The rest of the paper is organized as follows. In section 2 we position our method in context with previous work. Section 3 presents two simple examples that will be helpful in understanding the preprocessing algorithm, which is described in section 4. Section 6 provides relevant statistics specific to our method, as well as performance comparisons against previous approaches. Note that many depth-sorting methods can be used to render dynamic (or even self-intersecting) geometry. Naturally, when comparing them against our approach, we assume the target application does not require this functionality. Each node in a BSP tree includes a half-space test. The BSP tree is created during a preprocessing stage, much like our extended triangle list. To render from a BSP, the tree is traversed recursively at run-time. For back-to-front rendering, when visiting a node, the subtree representing half-spaces that contain the viewpoint are visited last. In our method, the half-spaces are instead used to separate the viewpoints for which a given individual triangle instance must be drawn from those for which it must be ignored. Our method is therefore better suited for modern GPUs, where recursiveness and pointer manipulation are difficult or otherwise inefficient to accomplish. Early CPU-based approaches also generate flat or semi-flat datastructures. Newell et al. [1972] and Goad [1982] both describe automatic procedures that sort triangles into a priority order for given viewpoints. Schumacker et al. [1969] propose a method that separates the scene into convex clusters during preprocessing. Our method leverages GPU hardware in order to render the model using a single draw call without requiring ordering computations at run-time. Our method requires a single pass, uses constant memory, and is significantly faster, particularly when multiple samples per pixel are used for anti-aliasing (e.g. MSAA). These include the Rbuffer [Wittenbrink 2001], the F-buffer [Mark and Proudfoot 2001], Delay Streams [Aila et al. 2003], and the FreePipe architecture [Liu et al. 2010]. Our method runs on the standard rendering pipeline. Another alternative is to render the scene as many times as required by the maximum depth complexity. At each pass, the Z-buffer is used to select the next closest fragment [Mammen 1989; Everitt 2001; Thibieroz 2008] (much like selection sort). For performance reasons, variations of this idea split the scene into pieces that are presorted [Wexler et al. 2005], peel multiple layers per pass [Liu et al. 2006; Bavoil and Myers 2008], or exploit any ordered structure that may already be present [Carr et al. 2008]. Our method is simpler and, depending on the depth-complexity, significantly faster. Many methods rely on approximations for performance reasons. Our method always produces noisefree renderings and is significantly faster. Finally, in the context of overdraw reduction, some static orders may succeed in eliminating most of the overdraw [Nehab et al. 2006; Sander et al. 2007]. We begin by presenting two simple examples that will motivate our strategy for building depth-presorted triangle lists. For simplicity, we show both examples in 2D (see figures 2 and 3), with triangles represented by line segments. The arrows next to each triangle represent the normal direction. Consider the non-convex model in figure 2 (top left). We will show that it is possible to produce depth-sorted renderings of this model (including back-facing triangles) from any viewpoint, using a fixed triangle ordering. The trick is to duplicate each triangle by including an additional instance with the opposite orientation. The augmented model, with newly instanced back-facing triangles in blue, is shown in figure 2 (top right). Although there are now twice as many triangles as in the original model, back-face culling ensures the hardware will rasterize at most one instance of each triangle. The additional freedom awarded by the duplication will allow us to create the triangle ordering we seek. By the same token, CDE are never occluded by any triangle: they can be added to the front of the list. These triangles have more complex occlusion relationships. To solve the general case automatically, we first construct a graph that captures all occlusion relationships. This occlusion graph is shown in figure 2 (bottom). There is such an order whenever the directed graph is acyclic (i.e., it is a DAG), as is the case of the occlusion graph in figure 2 . Surprisingly, it is possible to construct an ordering as described above for many simple objects. Unfortunately, in the general case, there may be cycles in the occlusion graph, even with back-face culling, so that no topological sort can be found. The simplest such case is shown in figure 3 (left). The corresponding occlusion graph containing a cycle is shown underneath it. (We have omitted the back-facing triangles from the graph to isolate this single cycle.) The key observation is that H can only occlude F if the viewpoint is inside the yellow region, and G can only occlude H if the viewpoint is in the gray region. Furthermore, these regions can be separated by a cutting plane p (the red dashed-line). Thus, we can solve the cycle problem by creating an extra copy of H, as shown in figure 3 (bottom right), and using the cutting plane p to select the copy of H to render depending on which side of p the current viewpoint lies. In this section, we describe an algorithm for automatically generating a depth-presorted triangle list for arbitrary input models. While in this description we assume a back-to-front ordering is desired, the algorithm can be trivially adjusted to create a front-to-back order. Since our method focuses on static models, we assume intersecting triangles have been split prior to invocation of our preprocessing algorithm, so the input list contains no intersecting triangles. Moreover, we assume there is a way to depth-sort the triangles from any viewpoint. In other words, we assume there are no single-viewpoint visibility cycles in the input model. Self-intersections, which are common in production models, must anyway be eliminated when rendering with transparency. Additional preprocessing can break cycles by splitting triangles when needed. As in the example of section 3.1, we start by creating back-facing duplicates for each input triangle in order to relax the occlusion restrictions. Then, we compute the occlusion graph and generate a preliminary ordering. If the graph has no cycles, a topological sort completely solves the problem [Skiena 2008]. When there are cycles, a good preliminary ordering is one that minimizes the number of back-edges. Finding an optimal preliminary order is equivalent to solving the minimum feedback arc-set problem, which is NP-complete [Karp 1972]. Fortunately, the correctness of our algorithm does not depend on optimality, and therefore we use a fast heuristic that is detailed in section 4.2. The final and most important preprocessing stage deals with backedges in the preliminary order. To do so, we scan the ordering from start to finish, duplicating triangles and associating them with halfspaces whenever we find a back-edge. This step follows along the lines of the example of section 3.2, and is described below. At each iteration, we process a graph node, moving along the preliminary order from start to finish. Nodes that send no back-edges can be safely ignored, but all back-edges must be dealt with. An example will guide us through the algorithm:  Here, moving along the list from right to left, the current iteration reaches a yellow node x with back-edges (in red) that must be eliminated. This works whenever there are no triangles between b 1 and x with edges that point to x. Plane p must be such that the set of viewpoints from which x occludes the b ? is contained in one of the half-spaces, whereas the set of viewpoints from which the f ? occlude x is contained in the other half-space. An algorithm for finding such a plane (when it exists) is given in section 4.1.1. With p, we can duplicate x as follows: We then annotate the right copy of x with the half-space test for p, so that the run-time algorithm described in section 5 will only render this copy of x if the viewpoint is in the correct half-space. The left copy of x does not need to be annotated with the plane. Using Z-buffering with depth-test of less ensures that the fragments generated by the left copy of x are shaded and stored if and only if the right copy was skipped (Recall the back-to-front rendering proceeds from right to left.) This fact allows us to avoid dealing with multiple half-space tests in most practical cases. Whenever we can find p that completely separates the viewpoints associated to edges to the b ? from those associated to edges from the f ? , it is clear we can move on to the next offending node. Thus, duplicating x with p may introduce into the graph new back-edges emanating from a subset of the f ? , as shown below: In that case, we proceed to the next iteration and postpone handling of new back-edges to the iteration that analyzes the nodes from which they emanate (f 1 in the example). As we noted earlier, in general only the right copy is assigned a half-space test: the Z-buffer deals with the left copy. Therefore, as we traverse the list from right to left, each node copy is processed only once and is assigned at most one plane. It is important to notice that, as long as we manage to separate at least one of the edges between f ? and x from at least one of edges between x and b ? , we have made progress. Since that number is finite, the algorithm terminates. We focus on three nodes in the graph: the current node x, the right-most node b to which x sends a back-edge, and the right-most node f , between b and x, such that f sends a forward-edge to x. We further assume that there exists a path from b to f , so that there is a cycle in the graph (otherwise we could simply move b to the right of x). If the viewpoints of edge (x, b) can be separated from the viewpoints of edge (f, x), we duplicate x as usual. If the viewpoints of edge (x, b) can be separated from those of edge (b, f ), we duplicate b instead. Finally, if the viewpoints of edge (b, f ) can be separated from those of edge (f, x), we duplicate node f . These configurations are shown below: At least one of these separations must be possible. Otherwise, there would be a viewpoint from which the entire cycle is visible. This would preclude the existence of a depth-sorted triangle ordering for this viewpoint. But this contradicts our assumptions and therefore completes the proof. Note that if we follow this strategy that duplicates b by moving it to the right, it is possible that b may have other back-edges and require further duplication. In that case, additional planes will have to be associated with the right copy of b. Fortunately, this must be relatively rare since we have never observed it in practice. Let us begin with a few definitions. We associate an occlusion region O i?j to each edge from node i to node j, defined as the set of viewpoints from whence i occludes j. Thus, from viewpoints outside of O i?j , it is as if the edge did not exist. Similarly, we associate to each node i (i.e., to each triangle instance) a rendering region E i , representing the set of viewpoints from which i is rendered. As nodes are duplicated, rendering regions of new nodes are cumulatively restricted to their associated half-spaces and can therefore become rather small. Therefore, each edge is relevant only inside a reduced occlusion region With these definitions in hand, we can define the problem of finding an appropriate cutting plane p. Let x be the current node being analyzed. We want to duplicate x, placing the new copy to the left of b 1 . We hope to find a plane p that partitions the edges among the two instances of x: back-edges go to the new (left) instance, forward-edges remain with the current (right) instance. Since the ideal plane may not exist, we greedily look for a good alternative. We start our search by separating the back-edge region R b from an empty forward-edge region (The plane of x itself does the job.) Then, we try to progressively add forward-edge regions to R f by setting if we can find a separating plane between R b and R f (i?1) ? O  ? f i ?x . Otherwise, we set and consider adding the occlusion region for the next forward-edge. When we are done considering all forward-edges (in order, for efficiency), we assign the last successful separating plane to the orig(n) inal x, and move the edges not accounted for the final region R f to its new copy. These will be addressed when the time comes, by duplicating the required subset of the f ? . As shown in section 4.1, it is in fact always possible to separate at least one O  ? f i ?x from at least one O  ? x?b j , and we can rely on this fall-back procedure to ensure the termination of the algorithm. In this section, we detail the geometric operations used to efficiently compute R f and R b , and ultimately the cutting plane p that separates them. Computations involving convex-hulls, half-space intersections, and linear-programming are performed using the Qhull [Barber et al. 1996] and lp_solve [Berkelaar et al. 2004] libraries. Intersection of viewpoint regions Determining the reduced occlusion region O  ? i?j amounts to finding the intersection between three convex regions. To do so, we form the intersection between all half-spaces defining each of O i?j , E i , and E j . Since this intersection is often empty, as an optimization that avoids the costly half-space intersections, we first check if all vertices of either E i or E j are on the outside of one of the planes bounding O i?j . If so, the intersection is empty. Union of viewpoint regions We conservatively approximate (i) each region R b and R f by their convex-hulls. Note that this does not compromise in finding the ideal cutting plane p, since any plane (i) that separates R f from R b also separates their convex-hulls. (i) Cutting plane Given the convex-hulls of R b and R f , we use linear programming to determine whether they intersect. If so, no cutting plane can separate them and the algorithm proceeds without (i) updating R f . Otherwise, we check if any of the bounding planes of the two regions is suitable as a cutting plane (i.e., all of the vertices of the other region lie on the opposite side of the plane). At least one of these planes will necessarily separate the two convex-hulls and this becomes the candidate plane p.  In practice, we found that generating a single depth-presorted triangle list for the entire range of viewpoints requires far too many triangle duplications and leads to a list with many times as many triangles as the input model. By dividing the space of viewpoints into a small number of partitions and creating independent depth-presorted triangle lists for each partition, we get a much better trade-off between total memory usage and run-time performance (see results in section 6). To divide the space of view points into partitions, we first enclose the model in a bounding polyhedron with a given number of faces (we have experimented with 4, 6, 16, and 64). Each partition is defined by one of the polyhedron faces, and by the boundaries with neighboring partitions, as in figure 4 . By limiting the set of valid viewpoints to lie outside the bounding polyhedron, we further reduce the number of constraints in the occlusion graph. The only further modification is that when computing the depth-presorted triangle list for each partition, all of the rendering regions E ? are further restricted to the corresponding partition. We experimented with different orientations for the polyhedron and obtained very similar results. Depth-presorted lists for each partition can be computed simultaneously, leveraging the parallelism of multi-core CPUs. The lists are concatenated into an index buffer with multiple segments. At run-time, we issue a draw call that renders the segment of the index buffer corresponding to the partition that contains the current viewpoint. Thus, the CPU performs the coarse-level viewpoint selection (which is trivial) and the GPU completes the fine-level triangle selection, as described below. The task at run-time is to select those triangles from the depthpresorted list that pass a half-space test. Recall each triangle t is annotated by a test plane p t (a 4D vector storing the plane equation). To decide whether to render a triangle t from viewpoint v xyz , we use a single dot product, which is extremely efficient in modern GPUs: For triangles with no associated test plane, we use p t = [0, 0, 0, ?1], which causes the test to always succeed. The test can be implemented in either the vertex, geometry, or fragment shader programmable pipeline stages. Although each alternative has advantages and disadvantages depending on the application and rendering configuration (see section 6), we favor the fragment shader test:  Option 1: Fragment shader (FS) The 4D plane vectors are kept in a 32-bit 4-channel texture indexed by triangle ID. (Although in practice the need has not arisen, it would be simple to encode an entire linked-list of test-planes in the texture.) The FS issues the lookup and performs the dot product. Since one dot product test is performed per triangle fragment, this method may suffer in pixelbound scenes. Fortunately, the tests are inexpensive and the texture access is coherent. Option 2: Vertex shader (VS) The 4D plane vectors are sent as vertex attributes. When the dot product test fails, the VS moves the vertex to the viewpoint position so that it gets culled by the near plane, otherwise it applies the standard vertex transformation. Since all three vertices of each triangle perform the same exact test, the result is consistent. The drawback of this approach is that triangles can no longer share vertices, which may impact vertex bound scenes. The GS emits only the triangles that pass the dot product test. In this section we discuss the performance and memory consumption of our approach. All experiments were conducted on an Intel R Xeon R 2.27GHz E5520 CPU with 12GB of RAM and an AMD Radeon HD 6970 GPU. We used models with resolutions ranging from 1,000 to 100,000 triangles, which we believe are representative of the resolution and depth complexity of most static models found in games. All renderings used alpha blending for proper semitransparency when rendering back-to-front as in figure 1 . The runtime performance results in figures 7, 8, and 9 are averaged over 256 viewpoints around the model and reported as ratios relative to a baseline standard rendering, measured directly in clock ticks. The baseline renders all input triangles in a order optimized for vertex-cache locality (completely disregarding depth-sorting). For example, if rendering a depth-sorted model with our method is twice as expensive as the baseline rendering, we report the performance ratio of two. Segment partitioning Figure 5 shows the effect of increasing the number of viewpoint partitions on the average number of triangles per segment (i.e, that are actually processed by the draw-call at run-time), as well as on the total memory consumption. The average draw call size is reported as a ratio to the number of triangles in the input triangle list. The calculation assumes that each vertex contains a position, normal, and texture coordinates. Note that although increasing the number of partitions increases memory consumption, it reduces the average segment size. It is important to note that the total memory increase only happens for the transparent parts of models that have any transparency effect at all. Furthermore, the vast majority of memory in modern games is consumed by textures, with geometry lagging far behind. We found that using 6 viewpoint partitions provides a reasonable trade-off for the models we tested. The amount of memory used is not significantly higher than that of 4 partitions, but there is a marked decrease in average segment size. This translates to performance gains at rendering time. For the remainder of the experiments in this section we used 6 viewpoint partitions. Preprocessing Figure 6 shows the preprocessing time of our method. Depending on model and number of triangles, it can take anywhere between a few minutes to several hours to complete. The computation of different segments was parallelized using multiple CPU cores. While the preprocessing algorithm can be slow on large input, it is important to point out that it only needs to be executed once for each static model. Further optimizations could improve the preprocessing time, but we instead concentrated our efforts on optimizing for better run-time results, which is the ultimate goal. Rendering approaches Figure 7 compares performance of the three versions of our run-time selection procedure, each using a different stage of the pipeline. The geometry shader option is significantly slower due to the fact that it adds a new shading stage to the rendering pipeline. Therefore, we only see this option being viable when the rendering effect already requires a geometry shader, in which case it would require simply adding the plane test to an existing shader. The vertex shader and fragment shader versions are significantly faster. For very low-resolution models, the rendering is fill-bound, making the fragment shader option more costly. For mediumand high-resolution models, however, the vertex processing overhead of the vertex shader approach dominates. Thus, for most practical model sizes, the fragment shader option is the most efficient, with our algorithm being only 2?3? slower than baseline. Overall performance We compared the overall performance of our fragment shader algorithm with a selection of state-of-theart real-time depth-sorting algorithms: per-pixel dynamic linked lists (LL) [Yang et al. 2010], stochastic transparency (ST) [Enderton et al. 2010], and dual depth peeling (DDP) [Bavoil and Myers 2008]. ST is an approximate algorithm, while DDP and LL produce exact results. (DDP uses occlusion queries to ensure that no further passes are required and LL uses a sophisticated sorting operation that is not available in legacy hardware.) Tests were run for each of our models at 640?480 ( figure 8 ) and 1280?720 ( figure 9 ) screen resolutions to demonstrate the different trade-offs involved. Our algorithm is significantly faster than the alternatives, particularly at high screen resolutions. Conversely, the advantage of our method is even higher for smaller models. This is because the relative overhead of increasing pixel count is negligible in our method, in contrast to the effect of increasing input triangle count. Nevertheless, even at low screen resolutions and with larger models, our method is significantly faster than the alternatives. For our method to become slower than the alternatives, it would require the combination of an enormous amount of geometry with either small screen coverage (for pixel based approaches) or very small maximum depth-complexity (for depth-peeling approaches). Since GPUs are heavily optimized for batch processing with few large index buffers, our simpler, singlepass method is faster for practical scenarios of even up to several million of transparent triangles. Complex scene We tested our approach on a complex Room scene ( figure 10 ) consisting of a physical simulation with multiple semi-transparent dragons interacting and colliding with one another. We used a screen resolution of 1280?720 and 4X-MSAA. Refer to the accompanying video for the entire animation sequence. Intermodel depth-sorting was performed in the CPU using the models? convex bounding volumes, which are also used for collision detection. This is trivial and fast for a small number of objects. Since the convex bounding volumes are not allowed to inter-penetrate, the sorting results are guaranteed to be correct. Standard rendering ( figure 10a ) does not render the triangles of each model in depth sorted order and therefore yields an incorrect transparency effect. For example, the rear left foot of the dragon shown in the closeup appears very prominently even though it is behind the body. As expected, our method ( figure 10b ), LL, ST, and DDP generate correct results. We measured rendering time of the entire scene for a varying number of dragons ( figure 10c ), resulting in a scene geometric complexity of 40,000 to 2,000,000 triangles (1 to 50 dragons). Clearly, the performance is inversely proportional to the number of dragons in the scene and our method is significantly faster compared to other approaches. Furthermore, our method and DDP produce exact results, which is not the case for ST and LL with MSAA. Refer to the accompanying video for the entire animation sequence. To get a sense of the performance implications of our approach on these scenarios, we varied the resolution of our semi-transparent model in order to present our performance results as a function of the percentage of scene primitives that are semi-transparent. So, for instance, if approximately 15% of the game?s primitives are semitransparent, the slowdown for having the triangles in sorted order is just about 1.1?. We presented a new algorithm for efficient, exact, depth-sorted rendering of static triangle models. Our method produces a depthpresorted triangle list in which each triangle is annotated by test planes. These lists can be rendered in depth-sorted order using a single draw call. Given a viewpoint, a simple run-time culling procedure executed by the GPU rasterizes a subsequence of the triangles that produce a depth-sorted rendering of the model relative to that viewpoint. We show that this approach is significantly faster than the alternative methods. The main limitations of our method is (a) Standard rendering\n        (b) Our result (a) Renderings with our approach that it is only suitable for static models, and for viewpoints outside of a bounding polyhedron. However, we feel that there exists a wide range of applications for which these limitations do not matter. Finally, we believe that this novel selection based scheme using a single draw call is a significant departure from existing methods, most of which require either sorting or multipass rendering. We believe that this direction is worth further investigation, particularly on ways to handle deformable models. It would be interesting to consider generating a set of orders that, in conjunction, allow for a limited range of deformation at run-time. This work was partly supported by Hong Kong?s RGC GRF grant #619509 and by an INST grant from FAPERJ.",
  "resources" : [ ]
}