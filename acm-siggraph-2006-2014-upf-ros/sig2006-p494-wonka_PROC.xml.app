{
  "uri" : "sig2006-p494-wonka_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2006/p494-wonka_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Guided Visibility Sampling",
    "published" : "2006",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Peter-Wonka",
      "name" : "Peter",
      "surname" : "Wonka"
    }, {
      "uri" : "http://drinventor/Michael-Wimmer",
      "name" : "Michael",
      "surname" : "Wimmer"
    }, {
      "uri" : "http://drinventor/Kaichi-Zhou",
      "name" : "Kaichi",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Stefan-Maierhofer",
      "name" : "Stefan",
      "surname" : "Maierhofer"
    }, {
      "uri" : "http://drinventor/Gerd-Hesina",
      "name" : "Gerd",
      "surname" : "Hesina"
    }, {
      "uri" : "http://drinventor/Alexander-Reshetov",
      "name" : "Alexander",
      "surname" : "Reshetov"
    } ]
  },
  "bagOfWords" : [ "paper", "address", "problem", "compute", "triangle", "visible", "from", "region", "space", "propose", "aggressive", "visibility", "solution", "base", "stochastic", "ray", "shooting", "can", "take", "any", "triangular", "model", "input", "we", "do", "rely", "connectivity", "information", "volumetric", "occluder", "availability", "large", "occluder", "can", "therefore", "process", "any", "give", "input", "scene", "propose", "algorithm", "practically", "memoryless", "thereby", "alleviate", "large", "memory", "consumption", "problem", "prevalent", "several", "previous", "algorithm", "strategy", "we", "algorithm", "use", "ray", "mutation", "ray", "space", "cast", "ray", "likely", "sample", "new", "triangle", "visibility", "fundamental", "problem", "computer", "graphic", "visibility", "computation", "necessary", "occlusion", "culling", "shadow", "generation", "inside-outside", "classification", "image-based", "rendering", "motion", "-lcb-", "peter.wonka", "kaichi.zhou", "-rcb-", "@asu", "edu", "Tempe", "AZ", "85287-0112", "wimmer@cg.tuwien.ac.at", "1040", "Vienna", "Austria", "-lcb-", "sm", "hesina", "-rcb-", "@vrvis", "1220", "Vienna", "Austria", "alexander.reshetov@intel.com", "Santa", "Clara", "CA", "95054", "planning", "navigation", "name", "just", "few", "example", "while", "visibility", "from", "single", "viewpoint", "can", "calculate", "quite", "easily", "many", "application", "require", "potentially", "visible", "set", "-lrb-", "pv", "-rrb-", "region", "space", "which", "unfortunately", "much", "more", "complicated", "therefore", "sampling-based", "solution", "have", "become", "very", "popular", "practical", "application", "due", "robustness", "general", "applicability", "ease", "implementation", "paper", "we", "improve", "upon", "previous", "sampling-based", "algorithm", "significantly", "improve", "sampling", "efficiency", "i.e.", "number", "sample", "require", "detect", "certain", "set", "visible", "polygon", "motivate", "we", "design", "choice", "we", "look", "two", "key", "aspect", "any", "visibility", "algorithm", "behavior", "algorithm", "ray", "space", "datum", "structure", "use", "store", "acquire", "visibility", "information", "figure", "illustrate", "concept", "ray", "space", "2d", "give", "view", "cell", "show", "edge", "parameterize", "scene", "object", "show", "grey", "we", "can", "compute", "visibility", "consider", "all", "ray", "from", "view", "cell", "plane", "behind", "scene", "parameterize", "t.", "2d", "scene", "2d", "set", "ray", "3d", "scene", "4d", "set", "ray", "set", "ray", "sample", "densely", "enough", "we", "have", "good", "visibility", "solution", "therefore", "would", "beneficial", "we", "could", "only", "sample", "area", "have", "be", "sample", "before", "total", "little", "more", "than", "1d", "subspace", "2d", "ray", "space", "need", "explore", "example", "due", "spatial", "coherence", "visibility", "paper", "we", "exploit", "coherence", "start", "from", "stochastically", "sample", "point", "we", "grow", "lower-dimensional", "subspace", "ray", "space", "use", "newly", "introduce", "strategy", "adaptive", "border", "sampling", "reverse", "sampling", "which", "guide", "property", "scene", "visibility", "large", "scene", "entail", "prohibitive", "level", "memory", "consumption", "conservative", "algorithm", "often", "store", "shadow", "volume", "whereas", "sampling", "algorithm", "use", "volume", "3d", "space", "have", "be", "sample", "yet", "-lrb-", "so-called", "void", "volume", "Figure", "-rrb-", "datum", "structure", "still", "require", "several", "time", "memory", "take", "scene", "description", "itself", "paper", "we", "do", "store", "visibility", "information", "beyond", "pv", "all", "rely", "we", "new", "reverse", "sampling", "approach", "penetrate", "void", "surface", "base", "current", "sample", "only", "key", "contribution", "paper", "intelligent", "sampling", "algorithm", "drastically", "improve", "performance", "previous", "sampling", "approach", "combine", "random", "sampling", "deterministic", "exploration", "phase", "we", "consider", "visibility", "problem", "pose", "follow", "first", "input", "we", "take", "three-dimensional", "scene", "consist", "set", "triangle", "we", "do", "rely", "connectivity", "information", "volumetric", "object", "large", "polygon", "potential", "occluder", "-lrb-", "set", "triangle", "often", "call", "triangle", "soup", "-rrb-", "second", "input", "we", "consider", "subset", "ray", "space", "usually", "define", "ray", "emanate", "within", "3d", "polyhedron", "call", "view", "cell", "intersect", "bound", "box", "scene", "ray", "can", "define", "start", "point", "direction", "algorithm", "paper", "base", "ray", "shooting", "assume", "capability", "trace", "ray", "compute", "its", "first", "intersection", "scene", "triangle", "i.e.", "compute", "triangle", "-lrb-", "-rrb-", "-lrb-", "fast", "ray", "tracer", "include", "openrt", "-lsb-", "Wald", "et", "al.", "2003", "-rsb-", "recently", "present", "mlrta", "-lsb-", "Reshetov", "et", "al.", "2005", "-rsb-", "-rrb-", "idea", "sampling", "solution", "select", "sequence", "ray", "trace", "ray", "add", "triangle", "-lrb-", "-rrb-", "visibility", "set", "pv", "paper", "we", "address", "problem", "how", "sample", "efficiently", "how", "improve", "chance", "find", "new", "triangle", "we", "show", "how", "use", "visibility", "information", "from", "previous", "sample", "construct", "intelligent", "sampling", "strategy", "base", "ray", "mutation", "complement", "random", "sampling", "adaptive", "border", "sampling", "algorithm", "quickly", "find", "nearby", "triangle", "sampling", "along", "border", "triangle", "previously", "find", "visible", "-lrb-", "section", "3.2", "-rrb-", "section", "3.4", "we", "show", "how", "combine", "different", "sampling", "algorithm", "order", "obtain", "guide", "visibility", "sampling", "complete", "hybrid", "random", "deterministic", "sampling", "algorithm", "typical", "visibility", "query", "give", "region", "3d", "space", "ask", "what", "visible", "along", "ray", "leave", "region", "-lrb-", "view", "cell", "-rrb-", "strategy", "leave", "ray", "start", "point", "view", "cell", "fix", "while", "cover", "adjacent", "triangle", "object", "space", "practically", "construct", "local", "visibility", "map", "-lsb-", "Bittner", "2002", "-rsb-", "from", "select", "view", "cell", "point", "therefore", "unlikely", "subpixel", "triangle", "miss", "which", "problem", "method", "sample", "object", "regularly", "connected", "region", "discover", "random", "sampling", "step", "-lrb-", "therefore", "scene", "many", "small", "disconnect", "mesh", "like", "tree", "remain", "challenge", "approach", "-rrb-", "triangle", "-lrb-", "-rrb-", "hit", "first", "time", "sample", "ray", "-lrb-", "dir", "-rrb-", "we", "enlarge", "small", "amount", "obtain", "enlarged", "polygon", "adaptively", "sample", "along", "its", "edge", "-lrb-", "figure", "-rrb-", "ray", "hit", "different", "triangle", "we", "recursively", "subdivide", "edge", "up", "give", "threshold", "order", "miss", "any", "adjacent", "triangle", "border", "polygon", "should", "tight", "possible", "enlargement", "be", "do", "object", "space", "would", "happen", "near", "edge-on", "very", "distant", "triangle", "we", "therefore", "enlarge", "ray", "space", "rotate", "ray", "vertex", "new", "position", "small", "angle", "possible", "only", "vertex", "since", "sliver", "triangle", "would", "lead", "singularity", "we", "therefore", "choose", "polygon", "vertex", "two", "vertex", "generate", "each", "vector", "perpendicular", "ray", "one", "adjacent", "edge", "respectively", "choose", "numerically", "robust", "algorithm", "deterministic", "mutation", "strategy", "allow", "penetrate", "yet", "uncovered", "region", "space", "discontinuity", "detect", "during", "adaptive", "sampling", "edge", "compare", "distance", "ray", "origin", "actual", "hitpoint", "hit", "-lrb-", "-rrb-", "distance", "predict", "hitpoint", "predict", "-lrb-", "-rrb-", "intersect", "line", "we", "select", "point", "new", "which", "lie", "just", "outside", "new", "triangle", "mutate", "ray", "now", "construct", "new", "dir", "predict", "-lrb-", "-rrb-", "new", "direction", "vector", "new", "intersect", "-lrb-", "viewcell", "line", "-lrb-", "new", "predict", "-lrb-", "-rrb-", "-rrb-", "origin", "-lrb-", "see", "Figure", "-rrb-", "new", "ray", "contain", "ray", "space", "-lrb-", "i.e.", "do", "intersect", "view", "cell", "-rrb-", "however", "discard", "new", "ray", "new", "now", "treat", "independent", "ray", "triangle", "intersect", "add", "adaptive", "border", "sampling", "like", "any", "other", "triangle", "time", "new", "view", "cell", "origin", "Inlays", "view", "from", "view", "cell", "top", "left", "image", "show", "gv", "converge", "linearly", "long", "deterministic", "strategy", "-lrb-", "ab", "r", "-rrb-", "can", "use", "most", "triangle", "especially", "noteworthy", "even", "15m", "sample", "when", "GVS", "have", "already", "long", "converge", "rand", "still", "50k", "triangle", "behind", "gv", "most", "view", "cell", "difficult", "directly", "compare", "NIR", "GVS", "furthermore", "should", "point", "out", "rasterization", "benefit", "from", "hardware", "acceleration", "whereas", "ray", "trace", "still", "run", "software", "however", "main", "difference", "between", "algorithm", "principal", "goal", "while", "approach", "valuable", "application", "like", "quick", "preview", "etc.", "where", "resolution", "can", "fix", "average", "example", "1000", "false", "pixel", "tolerable", "many", "application", "require", "more", "accurate", "pv", "important", "any", "visualization", "application", "rely", "visibility", "preprocessing", "-lrb-", "especially", "antialiasing", "use", "output", "resolution", "fix", "advance", "-rrb-", "also", "number", "other", "application", "where", "reliable", "-lrb-", "practically", "exact", "-rrb-", "visibility", "require", "e.g.", "computational", "geometry", "gi", "robotic", "reason", "nir?s", "inability", "pick", "up", "complete", "pv", "lie", "both", "regular", "sampling", "strategy", "which", "force", "very", "fine", "subdivision", "view", "cell", "order", "pick", "up", "sub-pixel", "triangle", "thresholding", "adaptive", "subdivision", "which", "can", "prematurely", "terminate", "subdivision", "high", "run", "time", "high", "complexity", "implementation", "critical", "numerical", "robustness", "issue", "can", "actually", "make", "solution", "approximate", "sampling-based", "strategy", "-lrb-", "see", "-lsb-", "Bittner", "2003", "-rsb-", "-rrb-", "context", "view", "planning", "laser", "range", "scanner", "sampling", "algorithm", "exist", "store", "void", "surface", "void", "volume", "compute", "next-best", "view", "-lsb-", "Pito", "1999", "-rsb-", "therefore", "we", "can", "give", "any", "hard", "guarantee", "pixel", "error", "calculate", "pv", "example", "scene", "current", "computer", "game", "become", "increasingly", "general", "so", "special", "purpose", "algorithm", "-lrb-", "cell", "portal", "2.5", "solution", "-rrb-", "can", "use", "anymore", "while", "exact", "algorithm", "difficult", "implement", "error-prone", "very", "important", "create", "pv", "close", "EVS", "possible", "dependent", "particular", "output", "resolution", "since", "resolution", "application", "run", "know", "advance" ],
  "content" : "This paper addresses the problem of computing the triangles visible from a region in space. The proposed aggressive visibility solution is based on stochastic ray shooting and can take any triangular model as input. We do not rely on connectivity information, volumetric occluders, or the availability of large occluders, and can therefore process any given input scene. The proposed algorithm is practically memoryless, thereby alleviating the large memory consumption problems prevalent in several previous algorithms. The strategy of our algorithm is to use ray mutations in ray space to cast rays that are likely to sample new triangles. Visibility is a fundamental problem in computer graphics: visibility computations are necessary for occlusion culling, shadow generation, inside-outside classifications, image-based rendering, motion ? {peter.wonka|kaichi.zhou}@asu.edu , Tempe, AZ 85287-0112 ? wimmer@cg.tuwien.ac.at , 1040 Vienna, Austria ? {sm|hesina}@vrvis.at , 1220 Vienna, Austria ? alexander.reshetov@intel.com , Santa Clara, CA 95054 planning, and navigation, to name just a few examples. While visibility from a single viewpoint can be calculated quite easily, many applications require the potentially visible set (PVS) for a region in space, which is, unfortunately, much more complicated. Therefore, sampling-based solutions have become very popular for practical applications due to their robustness, general applicability, and ease of implementation. In this paper we will improve upon previous sampling-based algorithms by significantly improving the sampling efficiency, i.e., the number of samples required to detect a certain set of visible polygons. To motivate our design choices, we will look at two key aspects of any visibility algorithm: the behavior of the algorithm in ray space, and the data structure used to store and acquire visibility information. Figure 2 illustrates the concept of ray space in 2D. Given a view cell, shown as edge parameterized with s, and a scene with objects shown in grey, we can compute visibility by considering all rays from the view cell to a plane behind the scene, parameterized with t. For a 2D scene, this is a 2D set of rays; for a 3D scene this is a 4D set of rays. If this set of rays is sampled densely enough, we will have a good visibility solution. Therefore, it would be beneficial if we could only sample areas that have not been sampled before. In total, little more than a 1D subspace of the 2D ray space needs to be explored in this example. This is due to the spatial coherence of visibility. In this paper, we exploit this coherence: starting from stochastically sampled points, we grow lower-dimensional subspaces of ray space using the newly introduced strategies of adaptive border sampling and reverse sampling, which are guided by the properties of scene visibility. For large scenes, this entails prohibitive levels of memory consumption. Conservative algorithms often store the shadow volume, whereas sampling algorithms use the volume of 3D space that has not been sampled yet (the so-called void volume, Figure 4 ); but these data structures still require several times the memory taken by the scene description itself. In this paper, we do not store visibility information beyond the PVS at all, relying on our new reverse sampling approach to penetrate the void surface based on the current sample only. The key contribution of this paper is an intelligent sampling algorithm that drastically improves the performance of previous sampling approaches by combining random sampling with deterministic exploration phases. We consider visibility problems that are posed as follows: As first input we take a three-dimensional scene consisting of a set of triangles, T S. We do not rely on connectivity information, volumetric  objects, or large polygons as potential occluders (such a set of triangles is often called triangle soup). As second input we consider a subset of ray space ?, usually defined by the rays emanating within a 3D polyhedron called view cell and intersecting the bounding box of the scene. A ray can be defined by a starting point and a direction. The algorithms in this paper are based on ray shooting and assume the capability to trace a ray x and compute its first intersection with a scene triangle t ? T S, i.e., to compute the triangle t = v(x) (fast ray tracers include OpenRT [Wald et al. 2003] and the recently presented MLRTA [Reshetov et al. 2005]). The idea of a sampling solution is to select a sequence of rays X = x i , trace the ray and add the triangle v(x i ) to the visibility set PV S. In this paper, we will address the problem on how to sample efficiently, that is how to improve the chances of finding new triangles. Then we will show how to use visibility information from previous samples to construct intelligent sampling strategies based on ray mutation to complement random sampling: Adaptive Border Sampling is an algorithm to quickly find nearby triangles by sampling along the borders of triangles previously found to be visible (Section 3.2). In Section 3.4, we will show how to combine the different sampling algorithms in order to obtain guided visibility sampling, a complete hybrid random and deterministic sampling algorithm. A typical visibility query is to give a region R in 3D space and ask what is visible along the rays leaving the region (view cell). This strategy leaves the ray starting point x p on the view cell fixed while covering adjacent triangles in object space, practically constructing a local visibility map [Bittner 2002] from the selected view cell point. Therefore, it is unlikely that subpixel triangles are missed, which is a problem for methods that sample objects regularly. The connected regions are discovered in the random sampling step (therefore, scenes with many small disconnected meshes like trees remain a challenge for the approach). If a triangle t = (p 1 , p 2 , p 3 ) is hit for the first time by a sample ray x = (x p , x dir ), we enlarge t by a small amount to obtain an enlarged polygon t , and adaptively sample along its edges ( Figure 5 ). If the rays x l and x r hit different triangles, we recursively subdivide the edge, up to a given threshold. In order not to miss any adjacent triangles, the border polygon t should be as tight as possible. If the enlargement were done in object space, this would happen for near edge-on or very distant triangles. We therefore enlarge t in ray space by rotating rays to the vertices of t to their new positions on t by a small angle. This is not possible with only 3 vertices, since sliver triangles would lead to singularities. We therefore chose t to be a polygon of 9 vertices. Two vertices are generated each on a vector d i, j perpendicular to the ray and to one of the adjacent edges, respectively. d i,i is chosen to be numerically robust. This algorithm is a deterministic mutation strategy that allows penetrating into as yet uncovered regions of space. A discontinuity is detected during the adaptive sampling of an edge by comparing the distance of the ray origin to the actual hitpoint |hit(x) ? x p | with the distance to a ?predicted? hitpoint |predicted(x) ? x p |. On the intersecting line, we select a point p new which lies just outside of the new triangle. The mutated ray is now constructed with x new,dir = predicted(x) ? p new as direction vector, and x new,p = intersect(viewcell, line(p new , predicted(x)) as origin (see Figure 6 ). If the new ray is not contained in the ray space ? (i.e., it does not intersect the view cell), however, it is discarded. The new ray x new is now treated as independent ray, and the triangle it intersects will be added for adaptive border sampling like any other triangle, but this time with the new view cell origin. Inlays: view from a view cell. The top left image shows that GVS converges linearly as long as the deterministic strategies (ABS and RS) can be used for most triangles. It is especially noteworthy that even at 15M samples, when GVS has already long converged, RAND is still 50K triangles behind GVS for most view cells. It is difficult to directly compare NIR and GVS. Furthermore, it should be pointed out that rasterization benefits from hardware acceleration, whereas ray tracing is still run in software. However, the main difference between the algorithms is the principal goal. While this approach is valuable for applications like quick previewing etc., where a resolution can be fixed, and an average of, for example, 1000 false pixels is tolerable, many applications require a more accurate PVS. This is important for any visualization application that relies on visibility preprocessing (especially if antialiasing is used or the output resolution is not fixed in advance), but also for a number of other applications where reliable (and practically exact) visibility is required, e.g., computational geometry, GI, and robotics. The reason for NIR?s inability to pick up the complete PVS lies both in the regular sampling strategy, which forces a very fine subdivision on the view cell in order to pick up sub-pixel triangles, and in the thresholding for the adaptive subdivision, which can prematurely terminate the subdivision. The high running times and high complexity of implementation are critical, and numerical robustness issues can actually make the solution as approximate as a sampling-based strategy (see [Bittner 2003]). In the context of view planning for laser range scanners, sampling algorithms exist that store the void surface or the void volume to compute the next-best view [Pito 1999]. Therefore, we cannot give any hard guarantees for the pixel error of the calculated PVS. For example, the scenes of current computer games are becoming increasingly general, so that special purpose algorithms (cells and portals, and 2.5D solutions) cannot be used anymore, while exact algorithms are difficult to implement and error-prone. It is very important to create a PVS that is as close to the EVS as possible and not dependent on a particular output resolution, since the resolution the application will be run at is not known in advance.",
  "resources" : [ ]
}