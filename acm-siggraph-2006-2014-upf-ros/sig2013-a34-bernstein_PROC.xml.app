{
  "uri" : "sig2013-a34-bernstein_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2013/a34-bernstein_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces",
    "published" : "2013",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Gilbert Louis-Bernstein",
      "name" : "Gilbert Louis",
      "surname" : "Bernstein"
    }, {
      "uri" : "http://drinventor/Chris-Wojtan",
      "name" : "Chris",
      "surname" : "Wojtan"
    } ]
  },
  "bagOfWords" : [ "paper", "present", "method", "compute", "topology", "change", "triangle", "mesh", "interactive", "geometric", "modeling", "environment", "specifically", "we", "provide", "first", "method", "topology", "change", "applicable", "arbitrary", "non-solid", "non-manifold", "non-closed", "self-intersecting", "surface", "beyond", "solid", "surface", "we", "present", "empirical", "evidence", "we", "method", "remain", "tolerant", "variety", "surface", "aberration", "through", "incorporation", "novel", "error", "correction", "scheme", "program", "3d", "modeling", "surface", "must", "support", "way", "change", "topology", "surface", "else", "severely", "limit", "capability", "instance", "without", "some", "way", "edit", "change", "topology", "surface", "impossible", "model", "donut", "start", "from", "sphere", "ability", "model", "change", "topology", "also", "critical", "assembly", "surface", "from", "part", "well", "permit", "surface", "merge", "split", "manipulate", "name", "just", "few", "more", "consequence", "while", "ability", "change", "topology", "critical", "all", "3d", "modeling", "software", "strategy", "vary", "widely", "depend", "representation", "surface", "modeling", "paradigm", "use", "sketch-based", "modeler", "vein", "Teddy", "-lsb-", "Igarashi", "et", "al.", "1999", "-rsb-", "incorporate", "special", "stroke", "gesture", "which", "allow", "user", "add", "tunnel", "handle", "surface", "meanwhile", "voxel-based", "modeling", "exemplify", "3d", "coat", "-lsb-", "2013", "-rsb-", "game", "minecraft", "-lsb-", "2013", "-rsb-", "naturally", "incorporate", "change", "topology", "by-product", "representation", "paper", "we", "propose", "novel", "method", "support", "topology", "change", "surface-deformation", "modeling", "software", "-lrb-", "e.g.", "zbrush", "-lsb-", "2013b", "-rsb-", "sculptri", "-lsb-", "2013a", "-rsb-", "mudbox", "-lsb-", "2013c", "-rsb-", "-rrb-", "like", "voxel", "modeling", "we", "would", "like", "we", "topology", "change", "incidental", "occur", "natural", "side", "effect", "use", "exist", "tools/brushes", "choose", "incidental", "topology", "change", "over", "specialize", "tool", "we", "can", "achieve", "greater", "parsimony", "-lrb-", "-rrb-", "we", "modeling", "system", "many", "surface", "model", "available", "wild", "-lrb-", "over", "90", "we", "measurement", "2.2", "-rrb-", "fail", "meet", "criterion", "so", "order", "design", "modeling", "system", "which", "fully", "interoperate", "exist", "ecosystem", "we", "have", "handle", "all", "surface", "just", "conveniently", "solid", "one", "achieve", "goal", "topology", "change", "arbitrary", "surface", "we", "rely", "one", "key", "observation", "motion", "surface", "during", "editing", "sufficient", "determine", "how", "topology", "surface", "should", "change", "even", "absence", "reliable", "surface", "normal", "enclosure", "space?both", "surrogate", "solidity", "simply", "track", "point", "surface", "move", "over", "time", "count", "number", "time", "experience", "collision", "we", "can", "determine", "whether", "part", "surface", "should", "keep", "around", "delete", "point", "which", "collide", "surface", "odd", "number", "time", "delete", "while", "one", "which", "collide", "even", "number", "time", "retain", "however", "can", "sensitive", "collision", "detection", "error", "surface", "hole", "boundary", "other", "aberration", "increase", "reliability", "we", "framework", "presence", "imperfection", "we", "introduce", "error", "correction", "scheme", "base", "graph", "partitioning", "throughout", "paper", "we", "work", "triangle", "mesh", "can", "specify", "list", "vertex", "position", "list", "triangle", "-lrb-", "triple", "index", "vertex", "list", "-rrb-", "many", "surface", "classification", "can", "determine", "locally", "from", "look", "degree", "mesh", "edge", "-lrb-", "i.e.", "number", "triangle", "which", "ring", "around", "edge", "-rrb-", "inside", "surface", "those", "outside", "sometimes", "term", "watertight", "find", "instead", "solid", "non-orientable", "surface", "can", "assign", "continuous", "surface", "normal", "field", "prevent", "we", "from", "rely", "normal", "source", "information", "topology", "change", "arbitrary", "mesh", "only", "do", "bad", "mesh", "exist", "wild", "quite", "common", "illustrate", "various", "condition", "which", "might", "arise", "we", "develop", "coffee", "mug", "example", "-lrb-", "figure", "-rrb-", "besides", "accidental", "cause", "reason", "people", "choose", "model", "undesirable", "feature", "character", "model", "animation", "skin", "model", "regularly", "require", "armpit", "other", "creased", "area", "geometry", "self-intersect", "order", "achieve", "reasonable", "appearance", "thin", "object", "like", "cloth", "flag", "regularly", "model", "thin", "sheet", "without", "any", "intention", "represent", "closed", "object", "scan", "reconstruct", "geometry", "especially", "large", "object", "like", "building", "often", "incomplete", "produce", "mesh", "hole", "order", "preserve", "fidelity", "relative", "raw", "scan", "datum", "after", "surface", "deform", "mesh-repair-like", "algorithm", "run", "surface", "final", "position", "all", "self-intersecting", "surface", "must", "correct", "open", "surface", "must", "have", "hole", "fill", "even", "when", "do", "so", "would", "lead", "nonsensical", "result", "-lrb-", "e.g.", "hole-filling", "ground", "plane", "-rrb-", "rather", "than", "attempt", "repair", "final", "position", "mesh", "attempt", "stitch", "proximate", "collide", "piece", "mesh", "together", "deformation", "progress", "both", "Brochu", "Bridson", "well", "St", "anculescu", "et", "al.", "assume", "displacement", "small", "can", "rewind", "necessary", "prevent", "collision", "coerce", "rest", "simulation", "modeling", "system", "-lrb-", "respectively", "-rrb-", "satisfy", "constraint", "conflation", "pose", "problem", "when", "one", "attempt", "integrate", "topology", "change", "exist", "commercial", "modeler", "use", "different", "more", "sophisticated", "surface", "re-meshing", "technique", "field", "determine", "whether", "surface", "should", "delete", "-lrb-", "odd", "parity", "-rrb-", "preserve", "-lrb-", "even", "parity", "-rrb-", "we", "begin", "-lrb-", "figure", "-rrb-", "run", "collision", "detection", "compute", "raw", "parity", "field", "correct", "error", "produce", "more", "desirable", "parity", "field", "we", "perform", "error", "correction", "step", "inform", "mesh?s", "self-intersection", "final", "frame?s", "position", "correct", "parity", "field", "hand", "we", "can", "subdivide", "mesh", "glue", "mesh", "delete", "appropriate", "triangle", "order", "tabulate", "number", "collision", "we", "must", "first", "run", "continuous", "collision", "detection", "every", "vertex", "mesh", "order", "accelerate", "computation", "so", "less", "than", "quadratically", "many", "collision", "must", "test", "we", "use", "acceleration", "structure", "namely", "axis-aligned", "bound", "volume", "hierarchy", "besides", "speed", "correctness", "frequently", "problem", "collision", "detection", "algorithm", "however", "implement", "truly", "robust", "collision", "difficult", "problem", "since", "we", "already", "intend", "run", "error", "correction", "step", "tolerate", "mesh", "aberration", "we", "can", "likewise", "tolerate", "small", "number", "error", "parity", "field", "which", "result", "from", "imprecise", "collision", "detection", "we", "observe", "case", "two", "align", "grid", "add", "perturbation", "eliminate", "100", "numeric", "error", "finally", "we", "identify", "any", "point", "form", "intersection", "three", "triangle", "complete", "intersection", "computation", "we", "identify", "triple", "triangle", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "all", "intersection", "edge", "because", "we", "intersection", "curve", "use", "input", "triangle", "subdivision", "algorithm", "-lrb-", "actual", "coordinate", "intersection", "always", "compute", "machine", "precision", "big", "number", "arithmetic", "-rrb-", "however", "degenerate", "case", "may", "still", "occur", "-lrb-", "e.g.", "when", "test", "potential", "edge-triangle", "intersection", "edge", "be", "test", "might", "pass", "exactly", "through", "edge", "triangle", "be", "test", "-rrb-", "while", "symbolic", "perturbation", "-lsb-", "edelsbrunner", "m?cke", "1990", "-rsb-", "one", "popular", "way", "achieve", "end", "we", "instead", "rely", "explicit", "numeric", "perturbation", "coordinate", "scale", "well", "beneath", "smallest", "resolution", "triangle", "edge", "use", "-lrb-", "we", "perturb", "order", "10", "unit", "we", "prototype", "code", "-rrb-", "any", "degeneracy", "detect", "during", "computation", "intersection", "we", "abort", "computation", "perturb", "all", "geometry", "try", "again", "acceleration", "structure", "we", "choose", "strategy", "expedient", "implementation", "because", "we", "advocate", "choice", "best", "option", "production", "code", "we", "view", "process", "compute", "more", "appropriate", "parity", "field", "form", "error", "correction", "section", "we", "propose", "two", "error", "correction", "scheme", "ultimately", "discard", "first", "favor", "second", "Whichever", "parity", "-lrb-", "even", "odd", "-rrb-", "get", "more", "vote", "assign", "all", "vertex", "component", "address", "shortcoming", "we", "propose", "second", "error", "correction", "scheme", "base", "graph", "partioning", "vertex", "mark", "even", "marked", "odd", "when", "we", "play", "try", "tweak", "balance", "between", "binary", "unary", "term", "we", "be", "unable", "find", "happy", "medium", "get", "around", "problem", "we", "take", "cue", "from", "isoperimetric", "graph", "partitioning", "-lsb-", "Grady", "Schwartz", "2006", "-rsb-", "use", "two-stage", "partitioning", "algorithm", "first", "stage", "we", "compute", "continuous", "relaxation", "graph", "partitioning", "problem", "use", "energy", "which", "prioritize", "smoothness", "focus", "smoothness", "term", "stage", "we", "can", "limit", "we", "search", "cut", "only", "smooth", "candidate", "second", "stage", "we", "select", "one", "isocontour", "choose", "how", "round", "continuous", "solution", "discrete", "one", "each", "new", "binary", "term", "associate", "edge", "-lrb-", "-rrb-", "which", "cut", "some", "intersection", "curve", "do", "turn", "out", "significant", "problem", "we", "test", "case", "order", "balance", "two", "term", "we", "use", "-lrb-", "half", "isoperimetric", "constant", "-rrb-", "square", "boundary", "length", "term", "sum", "all", "edge", "weight", "between", "even", "odd", "parity", "vertex", "should", "approximate", "length", "perimeter", "curve", "while", "sum", "vertex", "weight", "should", "approximate", "surface", "area", "area", "each", "quadrilateral", "can", "add", "each", "vertex", "weight", "while", "length", "midpoint-barycenter", "line", "segment", "can", "add", "appropriate", "edge", "weight", "we", "discard", "some", "curve", "add", "new", "curve", "goal", "produce", "set", "curve", "separate", "even", "parity", "portion", "surface", "from", "odd", "parity", "portion", "surface", "next", "we", "identify", "all", "edge", "triangle", "mesh", "-lrb-", "intersection", "edge", "-rrb-", "which", "both", "separate", "even", "odd", "parity", "vertex", "themselves", "cross", "intersection", "curve", "each", "triangle", "have", "false", "intersection", "vertex", "insert", "along", "exactly", "two", "edge", "therefore", "we", "must", "glue", "together", "duplicate", "curve", "replace", "duplicated", "vertex", "edge", "unique", "vertex", "edge", "effect", "step", "connect", "surface", "along", "those", "intersection", "we", "do", "discard", "step", "we", "must", "now", "propagate", "parity", "field", "onto", "triangle", "delete", "odd", "portion", "however", "because", "both", "gap", "introduce", "step", "potential", "complicated", "intersection", "happen", "entirely", "within", "single", "triangle", "may", "some", "triangle", "which", "lack", "parity", "cover", "triangle", "we", "perform", "50", "round", "iterated", "diffusion", "parity", "already", "decide", "triangle", "hold", "constant", "while", "value", "propagate", "between", "any", "two", "adjacent", "triangle", "separate", "intersection", "curve", "incorporate", "topology", "change", "scenario", "we", "take", "different", "approach", "order", "aid", "user", "we", "also", "compute", "correct", "parity", "field", "every", "frame", "display", "result", "immediate", "feedback", "different", "form", "topology", "change", "more", "focus", "merge", "collide", "surface", "would", "probably", "more", "appropriate", "consequently", "we", "observe", "goal", "produce", "intuitive", "behavior", "method", "applicable", "arbitrary", "surface", "likely", "fool?s", "errand", "none-the-less", "we", "can", "propose", "method", "topology", "change", "which", "may", "useful", "artist", "whose", "idiosyncrasy", "can", "learn", "over", "time" ],
  "content" : "This paper presents a method for computing topology changes for triangle meshes in an interactive geometric modeling environment. Specifically, we provide the first method for topology change applicable to arbitrary non-solid, non-manifold, non-closed, self-intersecting surfaces. Beyond solid surfaces, we present empirical evidence that our method remains tolerant to a variety of surface aberrations through the incorporation of a novel error correction scheme. Programs for the 3d modeling of surfaces must support ways to change the topology of a surface or else be severely limited in their capabilities. For instance, without some way to edit or change the  topology of a surface, it is impossible to model a donut starting from a sphere. The ability to model changes in topology is also critical for the assembly of surfaces from parts, as well as permitting surfaces to merge or split as they are manipulated, to name just a few more consequences. While the ability to change topology is critical for all 3d modeling software, strategies vary widely depending on the representation of the surface and the modeling paradigm in use. Sketch-based modelers in the vein of Teddy [Igarashi et al. 1999] incorporate special stroke gestures which allow users to add tunnels or handles to a surface. Meanwhile voxel-based modeling, exemplified by 3D Coat [2013] or the game Minecraft [2013], naturally incorporates changing topology as a by-product of the representation. In this paper we propose a novel method for supporting topology change in surface-deformation modeling software (e.g. Zbrush [2013b], Sculptris [2013a], Mudbox [2013c]). Like voxel modeling, we would like our topology change to be incidental, occurring as a natural side effect of using existing tools/brushes. By choosing incidental topology change over specialized tools, we can achieve greater parsimony (?8) in our modeling system. Many surface models available in the wild (over 90% in our measurements ?2.2) fail to meet this criterion. So, in order to design a modeling system which fully interoperates with the existing ecosystem, we have to handle all surfaces, not just the conveniently solid ones. To achieve the goal of topology change for arbitrary surfaces, we rely on one key observation: the motion of a surface during editing is sufficient to determine how the topology of that surface should change, even in the absence of reliable surface normals or the enclosure of space?both surrogates for solidity. By simply tracking points on the surface as they move over time and counting the number of times they experience collisions, we can determine whether that part of the surface should be kept around or deleted: a point which collides with the surface an odd number of times is deleted, while one which collides an even number of times is retained. However, it can be sensitive to collision detection errors, surface holes, boundaries, and other aberrations. To increase the reliability of our framework in the presence of such imperfections, we introduce an error correction scheme based on graph partitioning. Throughout this paper, we will work with triangle meshes that can be specified as a list of vertex positions and a list of triangles (triples of indices into the vertex list). Many surface classifications can be determined locally from looking at the degree of mesh edges (i.e. the number of triangles which ring around an edge). inside the surface, and those outside of it. Sometimes the term ?watertight? is found instead of solid. Non-orientable surfaces cannot be assigned a continuous surface normal field, preventing us from relying on normals as a source of information for topology change of arbitrary meshes. Not only do bad meshes exist in the wild, they are quite common. To illustrate various conditions which might arise, we developed the coffee mug example( figure 3 ). Besides accidental causes, there are reasons people choose to model these ?undesirable? features. In character models for animation, skinning models regularly requires armpits and other creased areas of geometry to self-intersect in order to achieve reasonable appearances. Thin objects like cloth and flags are regularly modeled as thin sheets, without any intention of representing closed objects. Scanned and reconstructed geometry, especially of large objects like buildings is often incomplete, producing meshes with holes in order to preserve fidelity relative to the raw scan data. After a surface is deformed, a mesh-repair-like algorithm is run on the surface at the final position. All self-intersecting surfaces must be ?corrected? and open surfaces must have their holes filled, even when doing so would lead to nonsensical results (e.g. hole-filling a ground plane). Rather than attempting to repair the final position of the mesh, they attempt to stitch proximate or colliding pieces of the mesh together as the deformation progresses. Both Brochu & Bridson, as well as St anculescu et al. assume that displacements are small and can be rewound as necessary to prevent collision, coercing the rest of their simulation and modeling systems (respectively) to satisfy these constraints. Such a conflation poses problems when one attempts to integrate topology change with an existing commercial modeler that uses different, and more sophisticated surface re-meshing techniques. This field determines whether the surface should be deleted (odd parity) or preserved (even parity). We begin ( figure 5 ) by running collision detection to compute a raw parity field. To correct these errors and produce a more desirable parity field, we perform an error correction step informed by the mesh?s self-intersections at the final frame?s position. With the corrected parity field in hand, we can then subdivide the mesh, glue the mesh, and delete the appropriate triangles. In order to tabulate the number of collisions, we must first run continuous collision detection for every vertex of the mesh. In order to accelerate this computation so that less than quadratically many collisions must be tested, we use an acceleration structure, namely an axis-aligned bounding volume hierarchy. Besides speed, correctness is frequently a problem with collision detection algorithms. However, implementing truly robust collisions is a difficult problem. Since we already intend to run an ?error correction? step to tolerate mesh aberrations, we can likewise tolerate the small number of errors in the parity field which result from imprecise collision detection. We observed that in the case of two aligned grids, adding a perturbation eliminated 100% of the numeric errors. Finally, we identify any points formed by the intersection of three triangles. To complete the intersection computation, we identify triples of triangles {t 1 , t 2 , t 3 } such that {t 1 , t 2 }, {t 1 , t 3 }, and {t 2 , t 3 } are all intersection edges. This is because our intersection curves are used as input to a triangle subdivision algorithm. (The actual coordinates of intersection are always computed to machine precision in big number arithmetic.) However, degenerate cases may still occur (e.g. when testing a potential edge-triangle intersection, the edge being tested might pass exactly through an edge of the triangle being tested). While symbolic perturbation [Edelsbrunner and M?cke 1990] is one popular way to achieve this end, we instead rely on explicit numeric perturbation of coordinates on a scale well beneath the smallest resolution of triangle edges in use. (We perturb on the order of 10 ?5 units in our prototype code.) If any degeneracies are detected during the computation of intersections, we abort the computation, perturb all geometry and try again. As with acceleration structures, we chose this strategy for expedient implementation, not because we advocate the choice as the best option for production code. We view the process of computing a more appropriate parity field as a form of error correction. In this section we will propose two such error correction schemes, ultimately discarding the first in favor of the second. Whichever parity (even or odd) gets more votes is assigned to all vertices in the component. To address this shortcoming, we propose a second error correction scheme based on graph partioning. r i = 1 if the vertex is marked even and r i = ?1 if it is marked odd. When we played with trying to tweak this balance between the binary and unary terms, we were unable to find a happy medium. To get around these problems we take a cue from isoperimetric graph partitioning [Grady and Schwartz 2006] and use a two-stage partitioning algorithm. In the first stage, we compute a continuous relaxation of the graph partitioning problem using an energy which prioritizes smoothness. By focusing on the smoothness term at this stage, we can limit our search for a cut to only smooth candidates. In the second stage, we select one of these isocontours by choosing how to round the continuous solution into a discrete one. Each new binary term is associated with an edge (i, j) ? E c which is cut by some intersection curve. This did not turn out to be a significant problem in our test cases. In order to balance these two terms, we use ? = 2? (half the isoperimetric constant) and square the boundary length term. Summing all of the edge weights between the even and odd parity vertices should approximate the length of that perimeter curve, while summing the vertex weights should approximate surface area. Then, the area of this each quadrilateral can be added to each vertex weight, while the length of the midpoint-barycenter line segment can be added to the appropriate edge weight. We will discard some of these curves, and add in new curves with the goal of producing a set of curves to separate the even parity portion of the surface from the odd parity portion of the surface. Next, we identify all edges of the triangle mesh (not intersection edges) which both separate even and odd parity vertices, but are not themselves crossed by an intersection curve. Each such triangle will have false ?intersection? vertices inserted along exactly two edges. Therefore we must glue together the duplicate curves by replacing duplicated vertices and edges with unique vertices and edges. In effect, this step connects the surfaces along those intersections we did not discard in step 1. We must now propagate the parity field onto the triangles and delete the odd portions. However, because of both the gaps introduced by step 1 and the potential for complicated intersections happening entirely within a single triangle, there may be some triangles which lack parity. To cover these triangles, we perform a 50 round iterated diffusion. The parity at already decided triangles is held constant, while values are propagated between any two adjacent triangles not separated by an intersection curve. To incorporate topology change in this scenario, we take a different approach. In order to aid the user, we also compute the corrected parity field every frame and display the result as immediate feedback. A different form of topology change more focused on merging colliding surfaces would probably be more appropriate. Consequently, we observe that the goal of producing ?intuitive? behavior for a method applicable to arbitrary surfaces is likely to be a fool?s errand. None-the-less we can propose methods for topology change which may be useful to artists and whose idiosyncrasies can be learnt over time.",
  "resources" : [ ]
}