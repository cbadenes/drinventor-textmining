{
  "uri" : "sig2014a-a186-tang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2014a/a186-tang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Fast and Exact Continuous Collision Detection with Bernstein Sign Classification",
    "published" : "2014",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Dinesh-Manocha",
      "name" : "Dinesh",
      "surname" : "Manocha"
    } ]
  },
  "bagOfWords" : [ "we", "present", "fast", "algorithm", "perform", "accurate", "CCD", "query", "between", "triangulated", "model", "we", "formulation", "use", "property", "Bernstein", "basis", "b?zier", "curve", "reduce", "problem", "evaluate", "sign", "polynomial", "we", "present", "geometrically", "exact", "CCD", "algorithm", "base", "exact", "geometric", "computation", "paradigm", "perform", "reliable", "boolean", "collision", "query", "we", "algorithm", "more", "than", "order", "magnitude", "faster", "than", "prior", "exact", "algorithm", "we", "evaluate", "its", "performance", "cloth", "fem", "simulation", "cpus", "gpus", "highlight", "benefit", "problem", "fast", "reliable", "collision", "detection", "arise", "physically-based", "simulation", "geometric", "computing", "robotic", "many", "application", "require", "accurate", "algorithm", "do", "miss", "single", "collision", "maintain", "intersection-free", "mesh", "throughout", "simulation", "some", "widely-used", "algorithm", "contact", "computation", "base", "continuous", "collision", "detection", "-lrb-", "CCD", "-rrb-", "give", "two", "discrete", "instance", "configuration", "rigid", "deformable", "model", "CCD", "algorithm", "model", "motion", "each", "object", "mesh", "element", "use", "continuous", "trajectory", "between", "configuration", "check", "collision", "along", "trajectory", "algorithm", "widely", "use", "cloth", "simulation", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "Harmon", "et", "al.", "2008", "Brochu", "et", "al.", "2012", "-rsb-", "rigid-body", "simulation", "-lsb-", "Redon", "et", "al.", "2002", "-rsb-", "hair", "simulation", "-lsb-", "Selle", "et", "al.", "2008", "-rsb-", "FEM", "simulation", "-lsb-", "Tang", "et", "al.", "2011", "-rsb-", "robot", "motion", "planning", "-lsb-", "LaValle", "2006", "Tang", "et", "al.", "2010a", "-rsb-", "dynamic", "solver", "-lsb-", "Stam", "2009", "-rsb-", "etc.", "simplest", "algorithm", "triangular", "mesh", "linearly", "interpolate", "trajectory", "vertex", "case", "contact", "computation", "reduce", "perform", "series", "elementary", "test", "between", "vertex", "edge", "face", "use", "cubic", "polynomial", "root", "solver", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "-rsb-", "many", "high-level", "culling", "technique", "parameter", "properly", "tune", "floating-point-based", "CCD", "algorithm", "-lrb-", "-rrb-", "can", "result", "penetration", "artifact", "numerical", "error", "arithmetic", "operation", "along", "tolerance", "can", "impact", "elementary", "test", "accuracy", "-lrb-", "fig.", "-rrb-", "order", "overcome", "problem", "Brochu", "et", "al.", "-lsb-", "2012", "-rsb-", "propose", "algorithm", "exact", "CCD", "computation", "can", "perform", "reliable", "collision", "query", "however", "approach", "can", "relatively", "expensive", "due", "use", "large", "number", "exact", "arithmetic", "operation", "moreover", "its", "portability", "may", "limit", "efficient", "implementation", "exact", "computation", "library", "easily", "available", "all", "processor", "-lrb-", "e.g.", "gpus", "-rrb-", "we", "use", "BSC", "design", "two", "algorithm", "compare", "prior", "exact", "CCD", "algorithm", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "we", "observe", "10", "25x", "speedup", "single", "CPU", "core", "we", "highlight", "benefit", "algorithm", "use", "cloth", "fem", "simulation", "benchmark", "section", "we", "give", "brief", "overview", "prior", "work", "CCD", "algorithm", "high-level", "collision", "culling", "computation", "root", "polynomial", "other", "CCD", "algorithm", "base", "conservative", "local", "advancement", "-lsb-", "Tang", "et", "al.", "2009b", "-rsb-", "extensive", "literature", "symbolic", "computation", "computational", "geometry", "reliably", "compute", "root", "polynomial", "use", "exact", "arithmetic", "-lsb-", "yap", "2004", "Mourrain", "et", "al.", "2005", "-rsb-", "section", "we", "formulate", "CCD", "query", "term", "algebraic", "equation", "inequality", "Boolean", "query", "return", "positive", "answer", "we", "can", "use", "technique", "base", "interval", "arithmetic", "compute", "intersection", "point", "first", "time", "contact", "desire", "precision", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "1st", "2nd", "order", "derivative", "scalar", "function", "-lrb-", "-rrb-", "respectively", "all", "proof", "lemma", "theorem", "corollary", "supplementary", "material", "well-known", "polynomial", "express", "Bernstein", "basis", "have", "better", "numerical", "stability", "under", "perturbation", "coefficient", "than", "do", "those", "power", "basis", "-lsb-", "Farouki", "Rajan", "1987", "-rsb-", "we", "exploit", "some", "geometric", "property", "cubic", "b?zier", "curve", "order", "characterize", "inflection", "point", "extreme", "point", "existence", "inflection", "point", "extreme", "point", "can", "check", "base", "lemma", "supplementary", "material", "inside", "test", "addition", "satisfy", "coplanarity", "condition", "we", "need", "check", "whether", "move", "vertex", "inside", "triangle", "-lrb-", "VF", "-rrb-", "two", "edge", "intersect", "each", "other", "interior", "point", "-lrb-", "ee", "-rrb-", "coplanarity", "inside", "test", "can", "combine", "find", "common", "root", "follow", "system", "algebraic", "equation", "inequality", "-lrb-", "i.e.", "semi-algebraic", "set", "-rrb-", "order", "check", "coplanarity", "vertex", "triangle", "-lrb-", "define", "-rrb-", "we", "need", "calculate", "project", "distance", "between", "they", "along", "direction", "we", "goal", "compute", "root", "cubic", "polynomial", "-lrb-", "-rrb-", "-lrb-", "define", "equation", "-lrb-", "11", "-rrb-", "domain", "-lsb-", "-rsb-", "-rrb-", "therefore", "problem", "compute", "sign", "-lrb-", "-rrb-", "reduce", "compute", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "goal", "eliminate", "many", "VF", "pair", "do", "satisfy", "coplanarity", "condition", "-lrb-", "see", "equation", "-lrb-", "11", "-rrb-", "-rrb-", "all", "test", "positive", "response", "VF", "collision", "query", "positive", "-lrb-", "line", "22", "-rrb-", "finally", "we", "would", "like", "develop", "reliable", "algorithm", "high-level", "CCD", "culling", "collision-response" ],
  "content" : "We present fast algorithms to perform accurate CCD queries between triangulated models. Our formulation uses properties of the Bernstein basis and B?zier curves and reduces the problem to evaluating signs of polynomials. We present a geometrically exact CCD algorithm based on the exact geometric computation paradigm to perform reliable Boolean collision queries. Our algorithm is more than an order of magnitude faster than prior exact algorithms. We evaluate its performance for cloth and FEM simulations on CPUs and GPUs, and highlight the benefits. The problem of fast and reliable collision detection arises in physically-based simulation, geometric computing, and robotics. Many applications require accurate algorithms that do not miss a single collision and maintain intersection-free meshes throughout the simulation. Some of the widely-used algorithms for contact computation are based on continuous collision detection (CCD). Given two discrete instances or configurations of rigid or deformable models, CCD algorithms model the motion of each object or a mesh element using a continuous trajectory between the configurations and check for collisions along the trajectory. These algorithms are widely used for cloth simulation [Provot 1997; Bridson et al. 2002; Harmon et al. 2008; Brochu et al. 2012], rigid-body simulation [Redon et al. 2002], hair simulation [Selle et al. 2008], FEM simulation [Tang et al. 2011], robot motion planning [LaValle 2006; Tang et al. 2010a], dynamic solvers [Stam 2009], etc. The simplest algorithms for triangular meshes linearly interpolate the trajectories of the vertices. In this case, contact computation reduces to performing a series of elementary tests between the vertices, edges, and faces using cubic polynomial root solvers [Provot 1997; Bridson et al. 2002]. Many high-level culling techniques If parameters are not properly tuned, floating-point-based CCD algorithms (b) can result in penetrations and artifacts. The numerical errors in arithmetic operations along with the tolerances can impact these elementary tests? accuracy ( Fig. 1 ). In order to overcome these problems, Brochu et al. [2012] proposed algorithms for exact CCD computation that can perform reliable collision queries. However, their approach can be relatively expensive due to use of large number of exact arithmetic operations. Moreover, its portability may be limited as efficient implementations of exact computation libraries are not easily available on all processors (e.g. GPUs). We use BSC to design two algorithms: 1. As compared to prior exact CCD algorithm [Brochu et al. 2012], we observe 10 ? 25X speedup on a single CPU core. We highlight the benefits of algorithms using cloth and FEM simulation benchmarks. In this section, we give a brief overview of prior work on CCD algorithms, high-level collision culling, and the computation of the roots of polynomials. Other CCD algorithms are based on conservative local advancement [Tang et al. 2009b]. There is extensive literature in symbolic computation and computational geometry on reliably computing the roots of polynomials using exact arithmetic [Yap 2004; Mourrain et al. 2005]. In this section, we formulate CCD queries in terms of algebraic equations and inequalities. If the Boolean query returns a positive answer, we can use techniques based on interval arithmetic to compute the intersection points or first time of contact to a desired precision. F (t) and F (t) are the 1st and 2nd order of derivatives of a scalar function F (t), respectively. All the proofs of the lemmas, theorems and corollaries are in the supplementary material. It is well-known that the polynomials expressed in the Bernstein basis have better numerical stability under perturbation of their coefficients than do those in the power basis [Farouki and Rajan 1987]. We exploit some geometric properties of cubic B?zier curves in order to characterize inflection points and extreme points. The existence of an inflection point or an extreme point can be checked based on the lemmas in the supplementary material. ? Inside test: In addition to satisfy the coplanarity condition, we need to check whether the moving vertex is inside the triangle (VF), or the two edges intersect with each other at an interior point (EE). The coplanarity and inside tests can be combined to find a common root of the following system of algebraic equation and inequalities (i.e. a semi-algebraic set). In order to check the coplanarity of a vertex p t and a triangle (defined by a t , b t , and c t ), we need to calculate the projected distance between them along the direction of n t . Our goal is to compute the roots of a cubic polynomial Y (t) (defined by Equation (11) in domain [0, 1]). Therefore, the problem of computing the sign of P ( t) reduces to computing the signs of K( t) and L( t). Our goal is to eliminate many VF pairs that do not satisfy the coplanarity condition (see Equation (11)). If all these tests are positive, the response to VF collision query is positive (Line 22). Finally, we would like to develop reliable algorithms for high-level CCD culling and collision-response.",
  "resources" : [ ]
}