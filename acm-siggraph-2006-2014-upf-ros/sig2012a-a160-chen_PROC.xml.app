{
  "uri" : "sig2012a-a160-chen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2012a/a160-chen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Depth-Presorted Triangle Lists",
    "published" : "2012",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ge-Chen",
      "name" : "Ge",
      "surname" : "Chen"
    }, {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Lei-Yang",
      "name" : "Lei",
      "surname" : "Yang"
    }, {
      "uri" : "http://drinventor/Liang-Hu",
      "name" : "Liang",
      "surname" : "Hu"
    } ]
  },
  "bagOfWords" : [ "approach", "render", "depth-sorted", "triangle", "use", "single", "draw-call", "run-time", "we", "replace", "traditional", "sorting", "strategy", "exist", "algorithm", "faster", "triangle", "selection", "strategy", "selection", "process", "operate", "extended", "sequence", "triangle", "annotated", "test", "plane", "create", "we", "off-line", "preprocessing", "stage", "we", "method", "run", "legacy", "hardware", "render", "depth-sorted", "static", "model", "significantly", "faster", "than", "previous", "approach", "we", "conclude", "demonstrate", "real-time", "rendering", "order-independent", "transparency", "effect", "real-time", "rendering", "application", "employ", "z-buffer", "visibility", "determination", "-lsb-", "Catmull", "1974", "-rsb-", "still", "many", "scenario", "which", "depth-sorting", "necessary", "desirable", "most", "common", "order-independent", "transparency", "translucency", "since", "composit", "operation", "commutative", "-lsb-", "Porter", "Duff", "1984", "-rsb-", "blend", "must", "happen", "depth-sorted", "order", "we", "discuss", "section", "large", "number", "technique", "have", "be", "propose", "perform", "real-time", "depth", "sorting", "can", "implement", "standard", "graphic", "pipeline", "require", "single", "render", "pass", "use", "fixed", "amount", "memory", "produce", "exact", "result", "very", "simple", "integrate", "exist", "render", "engine", "extremely", "efficient", "advantage", "come", "certain", "limitation", "we", "target", "performance-critical", "application", "must", "render", "number", "moderately", "complex", "static", "object", "translucency", "effect", "computer", "game", "during", "game", "development", "instant", "feedback", "can", "provide", "artist", "use", "earlier", "less", "efficient", "method", "construction", "extended", "sequence", "view-dependent", "subsequence", "triangle", "depth-sorted", "relative", "each", "every", "viewpoint", "outside", "bound", "volume", "selection", "happen", "single", "render", "pass", "can", "implement", "any", "stage", "render", "pipeline", "-lrb-", "vertex", "geometry", "fragment", "shader", "-rrb-", "run-time", "selection", "algorithm", "present", "section", "problem", "depth-sorting", "tightly", "connect", "problem", "visibility", "which", "vast", "amount", "prior", "work", "other", "than", "BSP", "additional", "data-structure", "use", "depth", "sort", "include", "direct", "acyclic", "graph", "-lsb-", "Williams", "1992", "-rsb-", "feudal", "priority", "tree", "-lsb-", "Chen", "Wang", "1996", "-rsb-", "Voronoi", "diagram", "-lsb-", "fukushige", "Suzuki", "2006", "-rsb-", "contrast", "we", "extend", "list", "flat", "data-structure", "potentially", "include", "multiple", "copy", "each", "triangle", "each", "which", "select", "viewpoint", "face", "each", "cluster", "can", "assign", "fix", "order", "which", "after", "back-face", "culling", "provide", "correct", "visibility", "from", "any", "viewpoint", "cluster", "must", "mutually", "separable", "plane", "order", "display", "cluster", "compute", "run-time", "typical", "strategy", "generate", "per-pixel", "fragment", "list", "sort", "each", "list", "a-buffer", "-lsb-", "Carpenter", "1984", "-rsb-", "challenging", "since", "way", "guess", "total", "number", "fragment", "storage", "need", "number", "fragment", "need", "per", "pixel", "case", "order-independent", "transparency", "ignore", "order", "sometimes", "acceptable", "-lsb-", "meshkin", "2007", "Bavoil", "Myers", "2008", "-rsb-", "some", "approximation", "work", "particularly", "well", "hair", "volumetric", "datum", "both", "-lsb-", "Kim", "Neumann", "2001", "Callahan", "et", "al.", "2005", "Yuksel", "Keyser", "2008", "Sintorn", "Assarsson", "2008", "2009", "Jansen", "Bavoil", "2010", "Salvi", "et", "al.", "2011", "-rsb-", "we", "method", "suitable", "high", "depth-complexity", "first", "sight", "seem", "difficult", "give", "occlusion", "relationship", "between", "two", "triangle", "may", "reverse", "when", "viewpoint", "change", "-lrb-", "i.e.", "when", "view", "from", "above", "occlude", "while", "when", "view", "from", "below", "occlude", "-rrb-", "safe", "place", "they", "end", "list", "all", "remain", "place", "remain", "triangle", "AA", "BB", "between", "CDE", "-lrb-", "some", "appropriate", "relative", "order", "-rrb-", "specifically", "may", "occlude", "may", "occlude", "a.", "thus", "we", "need", "find", "order", "front", "front", "a.", "multiple", "order", "exist", "particular", "follow", "order", "satisfy", "all", "requirement", "cdea", "abc", "when", "process", "list", "10", "triangle", "order", "from", "any", "viewpoint", "back-face", "culling", "select", "exactly", "triangle", "render", "model", "sort", "depth", "each", "node", "represent", "triangle", "edge", "connect", "triangle", "triangle", "only", "viewpoint", "which", "triangle", "occlude", "triangle", "culling", "operation", "which", "addition", "back-face", "culling", "can", "perform", "very", "efficiently", "run-time", "-lrb-", "see", "section", "-rrb-", "unfortunately", "case", "here", "move", "give", "rise", "two", "new", "back-edge", "come", "from", "address", "issue", "we", "proceed", "section", "3.2", "look", "plane", "partition", "viewpoint", "space", "two", "half-space", "however", "ideal", "cut", "plane", "may", "exist", "therefore", "possible", "left", "copy", "node", "have", "be", "duplicate", "further", "duplicated", "iteration", "eventually", "process", "we", "now", "prove", "under", "mild", "assumption", "always", "case", "naturally", "outside", "edge", "between", "do", "exist", "either", "although", "we", "can", "conceive", "situation", "where", "possible", "separate", "any", "from", "all", "have", "happen", "any", "we", "test", "case", "preliminary", "order", "which", "preprocess", "algorithm", "operate", "simply", "depth-sorted", "list", "triangle", "relative", "some", "viewpoint", "corresponding", "partition", "can", "easily", "accomplish", "specify", "start", "buffer", "index", "total", "number", "triangle", "command", "issue", "draw", "call", "although", "most", "natural", "implementation", "additional", "pipeline", "stage", "can", "impact", "performance", "application", "already", "use", "g", "Game", "scene", "show", "we", "method", "also", "apply", "more", "typical", "game", "scene", "-lrb-", "figure", "11", "-rrb-", "we", "create", "another", "experiment", "include", "animation", "sequence", "which", "character", "move", "around", "game", "scene", "multiple", "solid", "object", "semi-transparent", "model" ],
  "content" : "The approach renders depth-sorted triangles using a single draw-call. At run-time, we replace the traditional sorting strategy of existing algorithms with a faster triangle selection strategy. The selection process operates on an extended sequence of triangles annotated by test planes, created by our off-line preprocessing stage. Our method runs on legacy hardware and renders depth-sorted static models significantly faster than previous approaches. We conclude demonstrating the real-time rendering of order-independent transparency effects. In real-time rendering applications that employ the Z-buffer for visibility determination [Catmull 1974], there are still many scenarios in which depth-sorting is necessary or desirable. The most common is order-independent transparency or translucency. Since the compositing operation is not commutative [Porter and Duff 1984], blending must happen in depth-sorted order. As we discuss in section 2, a large number of techniques have been proposed for performing real-time depth sorting. It can be implemented with the standard graphics pipeline, requires a single rendering pass, uses a fixed amount of memory, produces exact results, is very simple to integrate with existing rendering engines, and is extremely efficient. These advantages come with certain limitations. We target performance-critical applications that must render a number of moderately complex static objects with translucency effects, such as computer games. During game development, instant feedback can be provided to artists using earlier, less efficient methods. By construction, this extended sequence is such that there is a view-dependent subsequence of triangles that is depth-sorted relative to each and every viewpoint outside of a bounding volume. This selection happens in a single rendering pass, and can be implemented at any stage of the rendering pipeline (vertex, geometry, or fragment shaders). The run-time selection algorithms are presented in section 5. The problem of depth-sorting is tightly connected to the problem of visibility, for which there is a vast amount of prior work. Other than the BSP, additional data-structures used for depth sorting include directed acyclic graphs [Williams 1992], feudal priority trees [Chen and Wang 1996], and Voronoi diagrams [Fukushige and Suzuki 2006]. In contrast, our extended list is a flat data-structure,  potentially including multiple copies of each triangle, each of which is selected or not by the viewpoint. The faces in each cluster can be assigned a fixed order which, after back-face culling, provides correct visibility from any viewpoint. These clusters must be mutually separable by planes, and the order of displaying these clusters is computed at run-time. The typical strategy is to generate per-pixel fragments lists and then sort each list, as in the A-buffer [Carpenter 1984]. This is challenging, since there is no way to guess the total number of fragment storage that will be needed, or the number of fragments needed per pixel. In the case of order-independent transparency, ignoring order is sometimes acceptable [Meshkin 2007; Bavoil and Myers 2008]. Some approximations work particularly well for hair, volumetric data, or both [Kim and Neumann 2001; Callahan et al. 2005; Yuksel and Keyser 2008; Sintorn and Assarsson 2008, 2009; Jansen and Bavoil 2010; Salvi et al. 2011]. Our method is not suitable for such high depth-complexities. At first sight, this seems difficult, given that the occlusion relationship between two triangles may be reversed when the viewpoint changes (i.e., when viewing from above, C occludes E, while when viewing from below, E occludes C). It is safe to place them in the end of the list. All that remains is to place the remaining triangles AA BB between CDE and C D E (in some appropriate relative order). Specifically, A may occlude B and B may occlude A. Thus, we need to find an order such that A is in front of B and B is in front of A. Multiple such orders exist and in particular the following order satisfies all requirements: CDEA B ABC D E . When processing the list of 10 triangles in this order, and from any viewpoint, back-face culling will select exactly the 5 triangles that render the model sorted by depth. Each node represents a triangle, and there is an edge connecting a triangle X to a triangle Y if and only if there is a viewpoint in which triangle X occludes triangle Y . This culling operation, which is in addition to back-face culling, can be performed very efficiently at run-time (see section 5). Unfortunately, this is not the case here and moving x gives rise to two new back-edges, coming from the f ? : To address this issue, we proceed as in section 3.2, and look for a plane p that partitions the viewpoint space into two half-spaces. However, such an ideal cutting plane may not exist. It is therefore possible for the left copy of a node that has been duplicated to be further duplicated by the iteration that eventually processes it. We now prove that, under mild assumptions, this is always the case. Naturally, outside E i or E j , it is as if an edge between i and j did not exist either. Although we can conceive of a situation where it is not possible to separate any of the O  ? f i ?x from all of R b , this has not happened in any of our test cases. The preliminary order on which the preprocessing algorithm operates is simply a depth-sorted list of triangles relative to some viewpoint in the corresponding partition. This can be easily accomplished by specifying the starting buffer index and total number of triangles in the command that issues the draw call. Although this is the most natural implementation, the additional pipeline stage can impact performance if the application is not already using a GS. Game scene To show that our method also applies to a more typical Game scene ( figure 11 ), we created another experiment including an animation sequence in which a character moves around a game scene with multiple solid objects and a semi-transparent model.",
  "resources" : [ ]
}