{
  "uri" : "sig2009-a91-wang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a91-wang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "An Efficient GPU-based Approach for Interactive Global Illumination",
    "published" : "2009",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Minghao-Pan",
      "name" : "Minghao",
      "surname" : "Pan"
    }, {
      "uri" : "http://drinventor/Hujun-Bao",
      "name" : "Hujun",
      "surname" : "Bao"
    } ]
  },
  "bagOfWords" : [ "sample", "irradiance", "value", "interpolate", "all", "shade", "point", "produce", "rendering", "although", "same", "property", "have", "be", "exploit", "previous", "caching", "adaptive", "sampling", "method", "method", "typically", "require", "sequential", "computation", "sample", "point", "make", "they", "ill-suited", "GPU", "interactive", "computation", "global", "illumination", "major", "challenge", "computer", "graphic", "research", "today", "effect", "multi-bounce", "indirect", "lighting", "caustic", "complex", "surface", "reflection", "important", "visual", "cue", "perception", "photorealism", "synthesize", "image", "exist", "method", "however", "typically", "focus", "very", "limited", "set", "illumination", "effect", "cpu-based", "global", "illumination", "fundamental", "difficulty", "global", "illumination", "high", "computation", "cost", "incur", "indirect", "lighting", "where", "all", "surface", "contribute", "illumination", "scene", "instant", "radiosity", "-lsb-", "Keller", "1997", "-rsb-", "popular", "technique", "convert", "indirect", "illumination", "small", "set", "virtual", "point", "light", "-lrb-", "vpl", "-rrb-", "photon", "mapping", "-lsb-", "Jensen", "2001", "-rsb-", "another", "popular", "solution", "-lsb-", "2002", "-rsb-", "Wald", "et", "al.", "implement", "interactive", "global", "illumination", "use", "cluster", "pc", "work", "aim", "high-quality", "rendering", "run", "offline", "irradiance", "caching", "-lrb-", "ic", "-rrb-", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "popular", "technique", "progressively", "cache", "diffuse", "irradiance", "sample", "octree", "reuse", "they", "along", "computation", "radiance", "caching", "-lsb-", "riv", "nek", "Gautron", "2005", "-rsb-", "extend", "ic", "record", "directional", "radiance", "use", "spherical", "harmonic", "-lsb-", "1999", "-rsb-", "Bala", "et", "al.", "present", "general", "approach", "exploit", "both", "spatial", "temporal", "coherence", "ray", "radiance", "interpolation", "recently", "-lsb-", "Arikan", "et", "al.", "2005", "-rsb-", "introduce", "fast", "approximation", "global", "illumination", "decompose", "radiance", "field", "farand", "near-field", "component", "which", "compute", "separately", "improve", "efficiency", "general", "cache", "scheme", "require", "sequentially", "insert", "spatial", "sample", "point", "datum", "structure", "which", "have", "frequently", "query", "update", "during", "computation", "shade", "cache", "-lsb-", "Tole", "et", "al.", "2002", "-rsb-", "perform", "caching", "interpolation", "object", "space", "lead", "faster", "convergence", "improve", "render", "quality", "however", "require", "scene", "geometry", "subdivide", "patch", "which", "unsuitable", "complex", "model", "furthermore", "lighting", "geometry", "change", "lead", "noticeable", "temporal", "artifact", "gpu-based", "global", "illumination", "rapidly", "increase", "computation", "power", "modern", "gpus", "much", "recent", "work", "have", "focus", "gpu-based", "solution", "global", "illumination", "-lsb-", "nijasure", "et", "al.", "2005", "-rsb-", "sample", "incident", "radiance", "GPU", "uniform", "3d", "grid", "point", "use", "low-resolution", "fix", "sample", "method", "do", "provide", "high", "accuracy", "reflective", "shadow", "map", "-lsb-", "dachsbacher", "Stamminger", "2005", "-rsb-", "treat", "shadow", "map", "pixel", "project", "from", "direct", "light", "source", "indirect", "source", "illuminate", "scene", "similarly", "radiance", "cache", "splatting", "-lsb-", "Gautron", "et", "al.", "2005", "-rsb-", "use", "image-based", "final", "gathering", "approximate", "irradiance", "caching", "while", "fast", "method", "ignore", "occlusion", "final", "gather", "step", "which", "important", "produce", "indirect", "shadow", "Matrix", "row-column", "sampling", "-lsb-", "ha", "san", "et", "al.", "2007", "-rsb-", "convert", "illumination", "many", "point", "light", "exploit", "GPU", "shadow", "map", "cluster", "they", "representative", "light", "compute", "shadowed", "illumination", "from", "each", "method", "do", "yet", "perform", "interactive", "rate", "Photon", "mapping", "first", "implement", "GPU", "-lsb-", "Purcell", "et", "al.", "2003", "-rsb-", "use", "uniform", "grid", "structure", "store", "photon", "rendering", "take", "several", "seconds", "converge", "-lsb-", "Wyman", "Davis", "2006", "-rsb-", "propose", "image-space", "caustic", "algorithm", "capable", "simulate", "plausible", "caustic", "effect", "real-time", "method", "aim", "include", "other", "global", "illumination", "effect", "we", "focus", "scene", "where", "direct", "light", "source", "point", "light", "so", "direct", "illumination", "can", "compute", "real-time", "use", "gpu-based", "ray", "trace", "accord", "render", "equation", "-lsb-", "Kajiya", "1986", "-rsb-", "outgoing", "radiance", "shading", "point", "view", "direction", "compute", "follow", "integral", "accurate", "render", "large", "number", "final", "gather", "ray", "need", "compute", "result", "evaluate", "integral", "every", "shading", "point", "impractical", "interactive", "setting", "while", "idea", "spatial", "caching", "have", "long", "be", "exploit", "irradiance", "caching", "adaptive", "sampling", "method", "method", "require", "sample", "point", "progressively", "insert", "spatial", "structure", "-lrb-", "i.e.", "kd-tree", "-rrb-", "which", "repeatedly", "update", "during", "computation", "computation", "model", "unsuitable", "direct", "GPU", "mapping", "center", "each", "cut", "node", "represent", "illumination", "cluster", "we", "use", "radial", "basis", "function", "-lrb-", "rbf", "-rrb-", "smoothly", "interpolate", "between", "they", "next", "we", "take", "shade", "point", "compute", "from", "ray", "trace", "partition", "they", "1000", "6000", "shade", "cluster", "base", "each", "point?s", "geometric", "information", "method", "construct", "kd-tree", "breadth", "first", "order", "-lrb-", "bf", "-rrb-", "use", "greedy", "top-down", "approach", "which", "recursively", "split", "current", "kd-tree", "node", "two", "sub-node", "however", "specular", "object", "compute", "shade", "point", "require", "ray", "trace", "building", "Photon", "Maps", "we", "shoot", "photon", "from", "direct", "light", "source", "scatter", "they", "scene", "store", "they", "photon", "map", "when", "hit", "non-specular", "surface", "because", "point", "use", "interpolation", "remain", "shade", "point", "need", "carefully", "select", "preserve", "underlie", "illumination", "change", "-lsb-", "ha", "san", "et", "al.", "2006", "-rsb-", "importance", "sampling", "method", "introduce", "distribute", "gather", "point", "direct-to-indirect", "transfer", "computation", "use", "variation", "photon", "mapping", "estimate", "importance", "triangle", "scene", "where", "shading", "point", "classify", "center", "position", "cluster", "denote", "surface", "normal", "order", "seed", "sample", "point", "we", "use", "hierarchical", "histogram-based", "method", "evaluate", "geometric", "variation", "image", "space", "can", "do", "trivially", "since", "shade", "point", "have", "one-to-one", "mapping", "screen", "pixel", "one", "possible", "solution", "introduce", "temporal", "filter", "blend", "new", "irradiance", "value", "across", "adjacent", "frame" ],
  "content" : "The sampled irradiance values are then interpolated at all shading points to produce rendering. Although the same property has been exploited by previous caching and adaptive sampling methods, these methods typically require sequential computation of sample points, making them ill-suited for the GPU. Interactive computation of global illumination is a major challenge in computer graphics research today. Effects such as multi-bounce indirect lighting, caustics, and complex surface reflections are important visual cues for the perception of photorealism in synthesized images. Existing methods, however, typically focus on a very limited set of illumination effects. CPU-based Global Illumination A fundamental difficulty in global illumination is the high computation cost incurred by indirect lighting, where all surfaces contribute illumination to the scene. Instant radiosity [Keller 1997] is a popular technique that converts indirect illumination to a small set of virtual point lights (VPLs). Photon mapping [Jensen 2001] is another popular solution. In [2002], Wald et al. implemented interactive global illumination using a cluster of PCs. Their work is aimed at high-quality rendering and runs offline. Irradiance caching (IC) [Ward et al. 1988] is a popular technique that progressively caches diffuse irradiance samples into an octree, and reuses them along the computation. Radiance caching [K riv? nek and Gautron 2005] extends IC by recording directional radiance using spherical harmonics. In [1999], Bala et al. presented a general approach to exploiting both spatial and temporal coherence of rays for radiance interpolation. Recently [Arikan et al. 2005] introduced a fast approximation to global illumination by decomposing radiance fields into farand near-field components, which are computed separately to improve efficiency. In general, these caching schemes require sequentially inserting spatial sample points into a data structure, which has to be frequently queried and updated during the computation. The Shading Cache [Tole et al. 2002] performs caching and interpolation in object space, leading to faster convergence and improved rendering quality. However, it requires scene geometry to be subdivided into patches, which is unsuitable for complex models. Furthermore, lighting and geometry changes lead to noticeable temporal artifacts. GPU-based Global Illumination With the rapidly increasing computation power of modern GPUs, much recent work has focused on GPU-based solutions for global illumination. [Nijasure et al. 2005] sample incident radiance on the GPU at uniform 3D grid points. By using a low-resolution of fixed samples, this method does not provide high accuracy. Reflective shadow maps [Dachsbacher and Stamminger 2005] treat shadow map pixels projected from the direct light source as indirect sources illuminating the scene. Similarly, radiance cache splatting [Gautron et al. 2005] uses image-based final gathering to approximate irradiance caching. While fast, these methods ignore occlusions in the final gather step, which are important for producing indirect shadows. Matrix row-column sampling [Ha san et al. 2007] converts illumination to many point lights, then exploits GPU shadow mapping to cluster them into representative lights and compute shadowed illumination from each. This method does not yet perform at interactive rates. Photon mapping was first implemented on the GPU in [Purcell et al. 2003] by using a uniform grid structure to store photons; their rendering takes several seconds to converge. [Wyman and Davis 2006] proposed an image-space caustics algorithm, capable of simulating plausible caustics effects in real-time. This method is not aimed to include other global illumination effects. We focus on scenes where the direct light source is a point light, so the direct illumination can be computed in real-time using GPU-based ray tracing. According to the rendering equation [Kajiya 1986], the outgoing radiance L o at a shading point x in view direction ? o is computed by the following integral: For accurate rendering, a large number of final gather rays needs to be computed. As a result, evaluating this integral at every shading point is impractical for interactive settings. While the idea of spatial caching has long been exploited in irradiance caching and adaptive sampling methods, these methods require sample points to be progressively inserted into a spatial structure (i.e. kd-tree), which is repeatedly updated during the computation. This computation model is unsuitable for a direct GPU mapping. The center of each cut node represents an illumination cluster, and we use radial basis functions (RBFs) to smoothly interpolate between them. Next, we take the shading points computed from ray tracing, and partition them into 1000 ? 6000 shading clusters based on each point?s geometric information. This method constructs the kd-tree in breadth first order (BFS) using a greedy top-down approach, which recursively splits the current kd-tree node into two sub-nodes. However, with specular objects, computing shading points requires ray tracing. Building Photon Maps We shoot photons from the direct light source, scatter them in the scene, and store them in photon maps when they hit non-specular surfaces. Because these points will be used for interpolation at the remaining shading points, they need to be carefully selected to preserve the underlying illumination changes. In [Ha san et al. 2006], an importance sampling method is introduced to distribute gather points for direct-to-indirect transfer computation. It uses a variation of photon mapping to estimate the importance of triangles in the scene. where x i is a shading point to be classified, x k is the center position of a cluster C k , and n denotes a surface normal. In order to seed K sample points, we use a hierarchical histogram-based method to evaluate the geometric variations in image space. This can be done trivially since the shading points have a one-to-one mapping to screen pixels. One possible solution is to introduce a temporal filter that blends new irradiance values across adjacent frames.",
  "resources" : [ ]
}