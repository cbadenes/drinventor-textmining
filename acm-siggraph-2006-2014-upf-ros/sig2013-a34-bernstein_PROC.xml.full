{
  "uri" : "sig2013-a34-bernstein_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2013/a34-bernstein_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces",
    "published" : "2013",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Gilbert Louis-Bernstein",
      "name" : "Gilbert Louis",
      "surname" : "Bernstein"
    }, {
      "uri" : "http://drinventor/Chris-Wojtan",
      "name" : "Chris",
      "surname" : "Wojtan"
    } ]
  },
  "bagOfWords" : [ "1027be43154480cd600fd82958eea1a516ba82fddde0ae4f226e397c45dfd1ce", "mjd", "10.1145", "2461912.2462027", "name", "identification", "possible", "put", "hole", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "Gilbert", "Louis", "Bernstein", "University", "Washington", "Stanford", "University", "Figure", "zombie", "model", "-lrb-", "-rrb-", "have", "numerous", "open", "surface", "non-manifold", "edge", "self-intersection", "display", "red", "here", "-lrb-", "-rrb-", "nonethe-less", "use", "technique", "describe", "paper", "we", "able", "-lrb-", "-rrb-", "poke", "through", "zombie?s", "chest", "-lrb-", "-rrb-", "create", "desire", "tunnel/hole", "paper", "present", "method", "compute", "topology", "change", "triangle", "mesh", "interactive", "geometric", "modeling", "environment", "most", "triangle", "mesh", "practice", "do", "exhibit", "desirable", "geometric", "property", "so", "we", "develop", "solution", "independent", "standard", "assumption", "robust", "geometric", "error", "specifically", "we", "provide", "first", "method", "topology", "change", "applicable", "arbitrary", "non-solid", "non-manifold", "non-closed", "self-intersecting", "surface", "we", "prove", "new", "method", "topology", "change", "produce", "expected", "conventional", "result", "when", "apply", "solid", "-lrb-", "closed", "manifold", "non-self-intersecting", "-rrb-", "surfaces?that", "we", "prove", "backwardscompatibility", "property", "relative", "prior", "work", "beyond", "solid", "surface", "we", "present", "empirical", "evidence", "we", "method", "remain", "tolerant", "variety", "surface", "aberration", "through", "incorporation", "novel", "error", "correction", "scheme", "finally", "we", "demonstrate", "how", "topology", "change", "apply", "non-solid", "object", "enable", "wholly", "new", "useful", "behavior", "cr", "category", "i.", "3.7", "-lsb-", "Computer", "Graphics", "-rsb-", "computational", "geometry", "object", "modeling?geometric", "algorithm", "language", "system", "keyword", "topology", "intersection", "deformation", "sculpt", "3d", "modeling", "non-manifold", "geometry", "Links", "dl", "pdf", "EB", "IDEO", "ODE", "introduction", "program", "3d", "modeling", "surface", "must", "support", "way", "change", "topology", "surface", "else", "severely", "limit", "capability", "instance", "without", "some", "way", "edit", "change", "topology", "surface", "impossible", "model", "donut", "start", "from", "sphere", "ability", "model", "change", "topology", "also", "critical", "assembly", "surface", "from", "part", "well", "permit", "surface", "merge", "split", "manipulate", "name", "just", "few", "more", "consequence", "while", "ability", "change", "topology", "critical", "all", "3d", "modeling", "software", "strategy", "vary", "widely", "depend", "representation", "surface", "modeling", "paradigm", "use", "instance", "traditional", "cad-derived", "modeling", "software", "like", "maya", "-lsb-", "2013b", "-rsb-", "3d", "max", "-lsb-", "2013a", "-rsb-", "special", "tool", "allow", "user", "directly", "edit", "connectivity", "polygon", "comprise", "mesh", "sketch-based", "modeler", "vein", "Teddy", "-lsb-", "Igarashi", "et", "al.", "1999", "-rsb-", "incorporate", "special", "stroke", "gesture", "which", "allow", "user", "add", "tunnel", "handle", "surface", "meanwhile", "voxel-based", "modeling", "exemplify", "3d", "coat", "-lsb-", "2013", "-rsb-", "game", "minecraft", "-lsb-", "2013", "-rsb-", "naturally", "incorporate", "change", "topology", "by-product", "representation", "paper", "we", "propose", "novel", "method", "support", "topology", "change", "surface-deformation", "modeling", "software", "-lrb-", "e.g.", "zbrush", "-lsb-", "2013b", "-rsb-", "sculptri", "-lsb-", "2013a", "-rsb-", "mudbox", "-lsb-", "2013c", "-rsb-", "-rrb-", "like", "voxel", "modeling", "we", "would", "like", "we", "topology", "change", "incidental", "occur", "natural", "side", "effect", "use", "exist", "tools/brushes", "contrast", "note", "cad-like", "sketch-based", "modeler", "require", "specialized", "tool", "topology", "change", "choose", "incidental", "topology", "change", "over", "specialize", "tool", "we", "can", "achieve", "greater", "parsimony", "-lrb-", "-rrb-", "we", "modeling", "system", "have", "make", "choice", "incorporate", "topology", "change", "incidentally", "number", "method", "topology", "change", "primarily", "use", "simulation", "literature", "available", "we", "-lsb-", "Wojtan", "et", "al.", "2009", "Brochu", "Bridson", "2009", "-rsb-", "unfortunately", "method", "all", "require", "surface", "represent", "solid", "object?one", "can", "faithfully", "represent", "voxel", "grid", "many", "surface", "model", "available", "wild", "-lrb-", "over", "90", "we", "measurement", "2.2", "-rrb-", "fail", "meet", "criterion", "one", "simple", "example", "height-mapped", "planar", "grid", "quadrilateral", "general", "character", "model", "other", "object", "build", "function", "3d", "application", "where", "skinning", "animation", "visual", "appearance", "trump", "other", "concern", "like", "solidity", "physical", "manufacturability", "like", "facade", "set", "spaghetti", "western", "model", "have", "be", "tailor", "tell", "story", "compound", "problem", "most", "exist", "program", "do", "guarantee", "export", "model", "solid", "so", "order", "design", "modeling", "system", "which", "fully", "interoperate", "exist", "ecosystem", "we", "have", "handle", "all", "surface", "just", "conveniently", "solid", "one", "achieve", "goal", "topology", "change", "arbitrary", "surface", "we", "rely", "one", "key", "observation", "motion", "surface", "during", "editing", "sufficient", "determine", "how", "topology", "surface", "should", "change", "even", "absence", "reliable", "surface", "normal", "enclosure", "space?both", "surrogate", "solidity", "simply", "track", "point", "surface", "move", "over", "time", "count", "number", "time", "experience", "collision", "we", "can", "determine", "whether", "part", "surface", "should", "keep", "around", "delete", "point", "which", "collide", "surface", "odd", "number", "time", "delete", "while", "one", "which", "collide", "even", "number", "time", "retain", "simple", "idea?using", "collision", "parity", "drive", "topology", "change", "work", "well", "solid", "surface", "many", "non-solid", "surface", "well", "however", "can", "sensitive", "collision", "detection", "error", "surface", "hole", "boundary", "other", "aberration", "increase", "reliability", "we", "framework", "presence", "imperfection", "we", "introduce", "error", "correction", "scheme", "base", "graph", "partitioning", "contribution", "we", "provide", "first", "method", "topology", "change", "applicable", "arbitrary", "non-solid", "non-manifold", "non-closed", "selfintersecting", "surface", "we", "prove", "new", "method", "produce", "expect", "conventional", "result", "when", "apply", "solid", "-lrb-", "closed", "manifold", "non-self-intersecting", "-rrb-", "surfaces?that", "we", "prove", "backwards-compatibility", "property", "relative", "prior", "work", "beyond", "solid", "surface", "we", "present", "empirical", "evidence", "we", "method", "remain", "tolerant", "variety", "surface", "aberration", "through", "incorporation", "novel", "error", "correction", "scheme", "finally", "we", "demonstrate", "how", "topology", "change", "apply", "non-solid", "object", "enable", "wholly", "new", "useful", "behavior", "e-mail", "gilbert@gilbertbernstein.com", "e-mail", "wojtan@ist.ac.at", "ACM", "Reference", "Format", "Bernstein", "G.", "Wojtan", "C.", "2013", "put", "hole", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "ACM", "Trans", "graph", "32", "Article", "34", "-lrb-", "July", "2013", "-rrb-", "11", "page", "dous", "10.1145", "2461912.2462027", "http://doi.acm.org/10.1145/2461912.2462027", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "all", "part", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "commercial", "advantage", "copy", "bear", "notice", "full", "citation", "fus", "rst", "page", "copyright", "component", "work", "own", "other", "than", "author", "-lrb-", "-rrb-", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "require", "prior", "specific", "permission", "and/or", "fee", "request", "permission", "from", "permissions@acm.org", "2013", "copyright", "hold", "Owner/Author", "publication", "rights", "license", "ACM", "0730-0301/13", "07-art34", "15.00", "DOI", "http://dx.doi.org/10.1145/2461912.2462027", "Chris", "Wojtan", "IST", "Austria", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "34:2", "G.", "Bernstein", "et", "al.", "Voxel", "Method", "Super", "pose", "gr", "d.", "re", "ray", "co", "ute", "spher", "nto", "...", "...", "Saturday", "January", "12", "13", "surface", "March", "ng", "...", "another", "sphere", "nd", "farthest", "po", "nt", "ood", "Saturday", "January", "12", "13", "coll", "Par", "ty", "how", "should", "topology", "change", "we", "Method", "Count", "coll", "Voxel", "Method", "surface", "March", "ng", "Insta", "ty", "what", "happen", "when", "we", "hole", "corrupt", "nor", "al", "add", "hole", "de/outs", "de", "...", "...", "so", "we", "can", "deter", "ne", "de", "vs.", "outs", "de", "ove", "non-boundary", "surface", "we?re", "do", "Saturday", "January", "12", "13", "use", "nor", "al", "choose", "rect", "on", "Kee", "ood", "shell", "Saturday", "January", "12", "13", "Record", "Par", "ty", "even", "odd", "delete", "odd", "ons", "par", "ty", "part", "Saturday", "January", "12", "13", "coll", "Par", "ty", "pped", "nor", "als", "change", "...", "par", "unaffected", "arch", "ng", "result", "related", "Work", "Background", "2.1", "what", "make", "Mesh", "Solid", "throughout", "paper", "we", "work", "triangle", "mesh", "can", "specify", "list", "vertex", "position", "list", "triangle", "-lrb-", "triple", "index", "vertex", "list", "-rrb-", "rule", "out", "possibility", "any", "isolate", "vertex", "dangling", "edge", "do", "allow", "variety", "interesting", "mesh", "type", "many", "surface", "classification", "can", "determine", "locally", "from", "look", "degree", "mesh", "edge", "-lrb-", "i.e.", "number", "triangle", "which", "ring", "around", "edge", "-rrb-", "edge", "mesh", "manifold", "have", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "put", "hole", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "34:3", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "mesh", "type", "locally", "depend", "number", "triangle", "incident", "edge", "-lrb-", "-rrb-", "manifold", "edge", "-lrb-", "-rrb-", "boundary", "edge", "-lrb-", "-rrb-", "close", "edge", "-lrb-", "-rrb-", "non-manifold", "non-closed", "non-boundary", "edge", "degree", "boundary", "edge", "have", "degree", "close", "have", "even", "degree", "all", "edge", "mesh", "close", "we", "say", "mesh", "itself", "close", "all", "close", "mesh", "need", "manifold", "second", "critical", "property", "surface", "whether", "self-intersecting", "any", "two", "triangle", "mesh", "have", "non-trivial", "intersection", "-lrb-", "intersection", "along", "something", "other", "than", "shared", "vertex", "edge", "-rrb-", "we", "say", "mesh", "self-intersecting", "we", "say", "mesh", "which", "both", "closed", "non-self-intersecting", "solid", "solid", "mesh", "can", "also", "characterize", "those", "mesh", "which", "partition", "ambient", "space", "two", "part", "those", "point", "inside", "surface", "those", "outside", "base", "classification", "every", "solid", "mesh", "have", "canonical", "surface", "normal", "field", "normal", "point", "outward", "sometimes", "term", "watertight", "find", "instead", "solid", "we", "prefer", "use", "solid", "since", "definition", "watertight", "inconsistent", "imprecise", "across", "literature", "outside", "class", "solid", "mesh", "we", "say", "mesh", "unoriented", "any", "pair", "triangle", "share", "manifold", "edge", "orient", "face", "opposite", "direction", "some", "mesh", "which", "inherently", "non-orientable", "most", "famous", "example", "be", "M?bius", "band", "non-orientable", "surface", "can", "assign", "continuous", "surface", "normal", "field", "prevent", "we", "from", "rely", "normal", "source", "information", "topology", "change", "arbitrary", "mesh", "2.2", "why", "Aren?t", "All", "mesh", "solid", "only", "do", "bad", "mesh", "exist", "wild", "quite", "common", "demonstrate", "fact", "we", "run", "statistics", "brown", "mesh", "set", "-lsb-", "McGuire", "2004", "-rsb-", "less", "than", "25", "-lrb-", "263/1136", "-rrb-", "mesh", "be", "close", "manifold", "over", "40", "-lrb-", "472/1136", "-rrb-", "be", "neither", "manifold", "nor", "close", "over", "90", "-lrb-", "1046/1136", "-rrb-", "be", "self-intersecting", "illustrate", "various", "condition", "which", "might", "arise", "we", "develop", "coffee", "mug", "example", "-lrb-", "figure", "-rrb-", "besides", "accidental", "cause", "reason", "people", "choose", "model", "undesirable", "feature", "character", "model", "animation", "skin", "model", "regularly", "require", "armpit", "other", "creased", "area", "geometry", "self-intersect", "order", "achieve", "reasonable", "appearance", "thin", "object", "like", "cloth", "flag", "regularly", "model", "thin", "sheet", "without", "any", "intention", "represent", "closed", "object", "scan", "reconstruct", "geometry", "especially", "large", "object", "like", "building", "often", "incomplete", "produce", "mesh", "hole", "order", "preserve", "fidelity", "relative", "raw", "scan", "datum", "most", "method", "available", "today", "compute", "topology", "change", "frame", "problem", "context", "mesh-repair", "-lsb-", "attene", "et", "al.", "2013", "Ju", "2009", "-rsb-", "after", "surface", "deform", "mesh-repair-like", "algorithm", "run", "surface", "final", "position", "can", "accomplish", "through", "convert", "surface", "implicit", "function", "representation", "-lsb-", "Wojtan", "et", "al.", "2009", "Wojtan", "et", "al.", "2010", "-rsb-", "bsp-based", "volume", "representation", "-lsb-", "Campen", "Kobbelt", "2010", "-rsb-", "march", "around", "outside", "mesh", "use", "normal", "-lsb-", "Zaharescu", "et", "al.", "2011", "-rsb-", "all", "technique", "use", "infer", "volumetric", "interpretation", "-lrb-", "inside", "vs.", "outside", "-rrb-", "mesh", "discard", "those", "part", "surface", "which", "necessary", "enclose", "infer", "volume", "we", "believe", "dynamesh", "feature", "add", "zbrush", "-lsb-", "2013b", "-rsb-", "late", "2012", "use", "similar", "kind", "volumetric", "method", "because", "method", "-lrb-", "-rrb-", "force", "all", "surface", "represent", "solid", "-lrb-", "-rrb-", "ignore", "motion", "datum", "allow", "inference", "what", "have", "change", "between", "two", "frame", "unable", "handle", "arbitrary", "mesh", "-lrb-", "see", "comic", "figure", "-rrb-", "all", "self-intersecting", "surface", "must", "correct", "open", "surface", "must", "have", "hole", "fill", "even", "when", "do", "so", "would", "lead", "nonsensical", "result", "-lrb-", "e.g.", "hole-filling", "ground", "plane", "-rrb-", "method", "can", "disambiguate", "symmetric", "geometric", "arrangement", "-lrb-", "e.g.", "cylinder", "penetrate", "ground", "plane", "figure", "-rrb-", "because", "only", "inspect", "final", "position", "mesh", "full", "motion", "more", "similar", "we", "approach", "Brochu", "Bridson", "-lsb-", "2009", "-rsb-", "St", "anculescu", "et", "al.", "-lsb-", "2011", "-rsb-", "make", "use", "motion", "datum", "rather", "than", "attempt", "repair", "final", "position", "mesh", "attempt", "stitch", "proximate", "collide", "piece", "mesh", "together", "deformation", "progress", "Brochu", "Bridson", "use", "combination", "collision", "detection", "local", "remeshing", "time-step", "control", "get", "surface", "mesh", "close", "touch", "allow", "tunnel", "stitch", "similarly", "St", "anculescu", "et", "al.", "tightly", "control", "size", "both", "mesh", "element", "time-step", "order", "create", "safe", "condition", "tunnel", "stitching", "both", "Brochu", "Bridson", "well", "St", "anculescu", "et", "al.", "assume", "displacement", "small", "can", "rewind", "necessary", "prevent", "collision", "coerce", "rest", "simulation", "modeling", "system", "-lrb-", "respectively", "-rrb-", "satisfy", "constraint", "however", "nei", "ther", "constraint", "necessarily", "true", "modeling", "system", "evidence", "we", "grab", "brush", "-lrb-", "-rrb-", "furthermore", "method", "closely", "interweave", "local", "surface", "remesh", "topology", "change", "conflation", "pose", "problem", "when", "one", "attempt", "integrate", "topology", "change", "exist", "commercial", "modeler", "use", "different", "more", "sophisticated", "surface", "re-meshing", "technique", "contrast", "prior", "work", "we", "make", "special", "assumption", "about", "what", "kind", "mesh", "we", "algorithm", "present", "currently", "artist", "tend", "directly", "edit", "connectivity", "mesh", "make", "use", "boolean", "operation", "-lrb-", "aka", "CSG", "-rrb-", "however", "boolean", "operation", "only", "define", "close", "orientable", "surface", "-lsb-", "Requicha", "1977", "-rsb-", "when", "work", "open", "surface", "artist", "force", "directly", "edit", "connectivity", "other", "option", "available", "they", "Figure", "example", "mesh", "exhibit", "undesirable", "mesh", "property", "since", "artist", "expect", "coffee", "mug", "always", "sit", "table", "choose", "-lrb-", "-rrb-", "leave", "bottom", "open", "furthermore", "handle", "have", "be", "-lrb-", "-rrb-", "attach", "mug", "body", "non-closed", "manner", "lastly", "water", "surface", "have", "be", "leave", "-lrb-", "-rrb-", "intersect", "wall", "mug", "order", "permit", "flexible", "animation", "later", "initial", "position", "final", "position", "result", "figure", "when", "cylinder", "plunge", "downward", "ground", "plane", "we", "method", "react", "depict", "however", "method", "which", "only", "inspect", "final", "position", "mesh", "face", "ambiguously", "symmetric", "problem", "2.3", "prior", "work", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "34:4", "G.", "Bernstein", "et", "al.", "input", "detection", "collision", "intersection", "compute", "Figure", "overview", "we", "method", "its", "component", "method", "3.1", "Overview", "we", "approach", "topology", "change", "rely", "exist", "well", "understand", "computation", "component", "collision", "detection", "static", "intersection", "identification", "triangulation", "perhaps", "only", "exception", "formulation", "graph", "partitioning", "specialize", "serve", "form", "error", "correction", "we", "string", "component", "together", "order", "compute", "parity", "field", "over", "mesh", "record", "parity", "number", "time", "point", "collide", "surface", "during", "give", "motion", "field", "determine", "whether", "surface", "should", "delete", "-lrb-", "odd", "parity", "-rrb-", "preserve", "-lrb-", "even", "parity", "-rrb-", "throughout", "process", "we", "store", "approximation", "-lrb-", "conceptually", "-rrb-", "continuous", "field", "sampling", "its", "value", "mesh", "vertex", "input", "we", "algorithm", "we", "require", "triangle", "mesh", "initial", "time/frame", "linear", "displacement", "vertex", "transport", "mesh", "its", "position", "final", "time/frame", "we", "begin", "-lrb-", "figure", "-rrb-", "run", "collision", "detection", "compute", "raw", "parity", "field", "we", "only", "work", "solid", "surface", "raw", "field", "would", "suffice", "because", "we", "expect", "we", "mesh", "exhibit", "aberration", "other", "shortcoming", "we", "treat", "raw", "parity", "field", "have", "some", "-lrb-", "relatively", "-rrb-", "small", "number", "corrupted", "entry", "correct", "error", "produce", "more", "desirable", "parity", "field", "we", "perform", "error", "correction", "step", "inform", "mesh?s", "self-intersection", "final", "frame?s", "position", "correct", "parity", "field", "hand", "we", "can", "subdivide", "mesh", "glue", "mesh", "delete", "appropriate", "triangle", "result", "we", "final", "output", "mesh", "suitably", "altered", "topology", "output", "3.2", "Collision", "detection", "we", "method", "topology", "change", "rely", "know", "parity", "number", "collision", "each", "vertex", "make", "rest", "surface", "order", "tabulate", "number", "collision", "we", "must", "first", "run", "continuous", "collision", "detection", "every", "vertex", "mesh", "every", "vertex", "mesh", "every", "triangle", "contain", "vertex", "we", "compute", "root", "usual", "cubic", "equation", "-lrb-", "appendix", "-rrb-", "associate", "barycentric", "coordinate", "we", "use", "they", "determine", "whether", "any", "collision", "occur", "we", "arrive", "desire", "collision", "parity", "value", "accumulate", "result", "computation", "each", "vertex", "across", "all", "potentially", "intersecting", "triangle", "order", "accelerate", "computation", "so", "less", "than", "quadratically", "many", "collision", "must", "test", "we", "use", "acceleration", "structure", "namely", "axis-aligned", "bound", "volume", "hierarchy", "we", "build", "aabvh", "over", "line", "segment", "trace", "out", "move", "vertex", "we", "stream", "triangle", "over", "structure", "identify", "potential", "collision", "rather", "than", "attempt", "maintain", "acceleration", "structure", "between", "frame", "we", "use", "fast", "median-split", "top-down", "divide-and-conquer", "build", "inspire", "work", "real-time", "ray", "trace", "-lsb-", "Wald", "2007", "-rsb-", "each", "node", "dimension", "-lrb-", "-rrb-", "select", "geometry", "rearrange", "via", "quick", "select", "search", "median", "build", "recurse", "two", "half", "result", "build", "algorithm", "take", "time", "comparable", "quick", "sort", "geometry", "consume", "small", "fraction", "-lrb-", "10", "-rrb-", "total", "time", "spend", "perform", "collision", "detection", "since", "heuristic", "use", "ensure", "quality", "acceleration", "structure", "since", "we", "don?t", "make", "use", "narrow-phase", "collision", "culling", "technique", "we", "expect", "overall", "cost", "collision", "detection", "could", "significantly", "improve", "just", "apply", "exist", "method", "-lsb-", "Teschner", "et", "al.", "2005", "-rsb-", "nonetheless", "simple", "strategy", "suffice", "demonstrate", "we", "prototype", "besides", "speed", "correctness", "frequently", "problem", "collision", "detection", "algorithm", "when", "use", "application", "like", "cloth", "simulation", "accurate", "collision", "detection", "become", "critical", "keep", "surface", "from", "snag", "themselves", "however", "implement", "truly", "robust", "collision", "difficult", "problem", "standard", "robustness", "method", "-lrb-", "3.3", "-rrb-", "restricted", "handle", "rational", "arithmetic", "collision", "detection", "require", "cubic", "root", "finding", "Brochu", "et", "al.", "-lsb-", "2012", "-rsb-", "recently", "give", "very", "clever", "solution", "problem", "formulate", "collision", "detection", "series", "predicate", "rely", "solely", "rational", "arithmetic", "here", "we", "only", "need", "approximation", "parity", "field", "we", "compute", "from", "collision", "detection", "since", "we", "already", "intend", "run", "error", "correction", "step", "tolerate", "mesh", "aberration", "we", "can", "likewise", "tolerate", "small", "number", "error", "parity", "field", "which", "result", "from", "imprecise", "collision", "detection", "unless", "we", "present", "highly", "degenerate", "motion", "-lrb-", "e.g.", "collision", "two", "perfectly", "align", "grid", "-rrb-", "numeric", "error", "rare", "help", "ensure", "remain", "rare", "we", "apply", "slight", "perturbation", "-lrb-", "similar", "perturbation", "intersection", "computation", "follow", "section", "-rrb-", "we", "observe", "case", "two", "align", "grid", "add", "perturbation", "eliminate", "100", "numeric", "error", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "34:5", "Figure", "when", "surface", "have", "hole", "-lrb-", "inset", "initial", "-rrb-", "raw", "parity", "field", "can", "corrupt", "-lrb-", "raw", "parity", "inset", "-rrb-", "run", "error", "correction", "remove", "isolate", "error", "3.3", "static", "intersection", "once", "mesh", "have", "reach", "its", "final", "position", "end", "frame", "movement", "we", "determine", "region", "where", "final", "mesh", "statically", "intersect", "itself", "we", "find", "static", "intersection", "curve", "two", "reason", "First", "information", "use", "guide", "error", "correction", "procedure", "secondly", "intersection", "curve", "use", "cleanly", "segment", "mesh", "preserved", "deleted", "portion", "we", "find", "intersection", "curve", "three", "step", "first", "we", "identify", "all", "edge-triangle", "intersection", "point", "present", "second", "we", "infer", "set", "all", "intersection", "edge", "from", "point", "finally", "we", "identify", "any", "point", "form", "intersection", "three", "triangle", "efficiently", "find", "edge-triangle", "intersection", "we", "use", "second", "aabvh", "like", "one", "compute", "collision", "detection", "time", "build", "over", "edge", "mesh", "triangle", "stream", "over", "structure", "test", "intersection", "edge", "encounter", "each", "intersect", "edge-triangle", "pair", "-lrb-", "-rrb-", "we", "collect", "set", "triangle", "edge", "emanate", "from", "point", "where", "intersect", "must", "exactly", "one", "intersection", "edge", "each", "triangle", "which", "uniquely", "identify", "pair", "-lcb-", "-rcb-", "we", "accumulate", "all", "pair", "identify", "via", "combinatorial", "generation", "procedure", "eliminate", "duplicate", "form", "set", "triangle-triangle", "intersection", "edge", "complete", "intersection", "computation", "we", "identify", "triple", "triangle", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "all", "intersection", "edge", "each", "triple", "test", "see", "whether", "three", "triangle", "intersect", "point", "triangle-triangle-triangle", "intersection", "candidate", "rare", "so", "step", "take", "negligible", "amount", "time", "geometric", "robustness", "unfortunately", "unlike", "collision", "we", "rely", "robustly", "compute", "intersection", "because", "we", "intersection", "curve", "use", "input", "triangle", "subdivision", "algorithm", "curve", "reveal", "any", "inconsistency", "subdivision", "algorithm", "could", "segmentation", "fault", "produce", "non-sensical", "output", "ensure", "consistent", "result", "from", "we", "intersection", "computation", "reasonable", "overhead", "we", "use", "variety", "technique", "from", "robust", "geometric", "computation", "first", "we", "use", "float", "point", "filter", "-lsb-", "Shewchuk", "1997", "-rsb-", "efficiently", "decide", "result", "most", "intersection", "predicate", "when", "filter", "fail", "we", "fallback", "exact", "big", "number", "arithmetic", "ensure", "all", "predicate", "correctly", "compute", "-lrb-", "actual", "coordinate", "intersection", "always", "compute", "machine", "precision", "big", "number", "arithmetic", "-rrb-", "however", "degenerate", "case", "may", "still", "occur", "-lrb-", "e.g.", "when", "test", "potential", "edge-triangle", "intersection", "edge", "be", "test", "might", "pass", "exactly", "through", "edge", "triangle", "be", "test", "-rrb-", "because", "degenerate", "case", "measure-zero", "event", "definition", "can", "eliminate", "through", "perturbation", "geometry", "-lsb-", "Seidel", "1994", "-rsb-", "while", "symbolic", "perturbation", "-lsb-", "edelsbrunner", "m?cke", "1990", "-rsb-", "one", "popular", "way", "achieve", "end", "we", "instead", "rely", "explicit", "numeric", "perturbation", "coordinate", "scale", "well", "beneath", "smallest", "resolution", "triangle", "edge", "use", "-lrb-", "we", "perturb", "order", "10", "unit", "we", "prototype", "code", "-rrb-", "any", "degeneracy", "detect", "during", "computation", "intersection", "we", "abort", "computation", "perturb", "all", "geometry", "try", "again", "we", "test", "case", "highly", "degenerate", "geometry", "strategy", "suffice", "eliminate", "degeneracy", "after", "single", "perturbation", "acceleration", "structure", "we", "choose", "strategy", "expedient", "implementation", "because", "we", "advocate", "choice", "best", "option", "production", "code", "correct", "parity", "scalar", "field", "correct", "parity", "result", "figure", "Majority", "vote", "work", "poorly", "when", "intersection", "curve", "don?t", "separate", "surface", "graph", "partitioning", "allow", "we", "introduce", "new", "cut", "mesh", "3.4", "error", "correction", "error", "various", "sort", "source", "may", "result", "collision", "detection", "produce", "corrupted", "parity", "field", "some", "error", "may", "due", "numeric", "inaccuracy", "-lrb-", "3.2", "-rrb-", "while", "other", "may", "due", "aberration", "-lrb-", "e.g.", "hole", "-rrb-", "mesh", "itself", "we", "view", "process", "compute", "more", "appropriate", "parity", "field", "form", "error", "correction", "section", "we", "propose", "two", "error", "correction", "scheme", "ultimately", "discard", "first", "favor", "second", "one", "strategy", "suppress", "outlier", "parity", "field", "through", "majority", "voting", "we", "split", "they", "surface", "connected", "component", "use", "static", "intersection", "curve", "-lrb-", "compute", "mesh?s", "final", "position", "-rrb-", "vote", "within", "each", "component", "independently", "concretely", "we", "take", "vertex-edge", "graph", "give", "triangle", "mesh", "remove", "all", "edge", "which", "cut", "some", "intersection", "curve", "connected", "component", "result", "graph", "form", "connected", "component", "surface", "within", "each", "component", "vertex", "get", "one", "vote", "weight", "proportional", "area", "surface", "represent", "Whichever", "parity", "-lrb-", "even", "odd", "-rrb-", "get", "more", "vote", "assign", "all", "vertex", "component", "Majority", "voting", "work", "well", "when", "intersection", "curve", "neatly", "partition", "surface", "primarily", "odd", "even", "component", "however", "when", "user", "manipulate", "open", "surface", "near", "its", "boundary", "-lrb-", "figure", "-rrb-", "result", "intersection", "rarely", "partition", "surface", "nicely", "address", "shortcoming", "we", "propose", "second", "error", "correction", "scheme", "base", "graph", "partioning", "graph", "partitioning", "algorithm", "label", "vertex", "graph", "one", "two", "possible", "label", "splitting", "graph", "image", "segmentation", "label", "foreground/background", "use", "here", "we", "compute", "even/odd", "parity", "label", "desire", "labeling", "find", "solve", "optimization", "problem", "both", "binary", "smoothness", "term", "-lrb-", "minimize", "size", "cut", "between", "two", "region", "-rrb-", "unary", "accuracy", "term", "-lrb-", "deviation", "from", "raw", "parity", "field", "-rrb-", "Vision", "researcher", "have", "ex", "plored", "range", "different", "formulation", "algorithm", "graph", "partitioning", "-lsb-", "Boykov", "et", "al.", "2001", "Grady", "Schwartz", "2006", "-rsb-", "follow", "previous", "example", "we", "can", "formulate", "we", "graph", "partition", "problem", "follow", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "34:6", "G.", "Bernstein", "et", "al.", "3.1", "min", "ij", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "i?v", "-lrb-", "here", "remainder", "section", "we", "let", "denote", "value", "raw", "parity", "field", "vertex", "denote", "continuous", "error", "correct", "value", "which", "we", "solve", "vertex", "mark", "even", "marked", "odd", "denote", "only", "those", "edge", "triangle", "mesh", "which", "already", "cut", "intersection", "edge", "Edge", "vertex", "weight", "-lrb-", "ij", "-rrb-", "explain", "end", "section", "-rrb-", "energy", "equation", "3.1", "can", "optimize", "solve", "linear", "system", "round", "all", "alternatively", "energy", "can", "optimize", "use", "min-cut", "algorithm", "-lsb-", "Boykov", "et", "al.", "2001", "-rsb-", "we", "try", "both", "approach", "above", "formulation", "value", "critical", "one", "hand", "we", "want", "ensure", "solution", "boundary", "between", "even", "odd", "portion", "surface", "smooth", "-lrb-", "low", "-rrb-", "however", "when", "set", "too", "low", "accuracy", "ignore", "when", "we", "play", "try", "tweak", "balance", "between", "binary", "unary", "term", "we", "be", "unable", "find", "happy", "medium", "every", "setting", "would", "break", "some", "test", "case", "further", "complication", "arise", "when", "we", "try", "apply", "min-cut", "algorithm", "although", "we", "be", "able", "get", "reasonable", "result", "most", "test", "case", "ignore", "edge", "cut", "intersection", "lead", "fail", "case", "follow", "we", "see", "how", "both", "prying", "apart", "value", "near", "intersection", "-lrb-", "eq", "3.2", "-rrb-", "penalize", "unused", "intersection", "-lrb-", "eq", "3.3", "-rrb-", "help", "coerce", "more", "desirable", "behavior", "get", "around", "problem", "we", "take", "cue", "from", "isoperimetric", "graph", "partitioning", "-lsb-", "Grady", "Schwartz", "2006", "-rsb-", "use", "two-stage", "partitioning", "algorithm", "first", "stage", "we", "compute", "continuous", "relaxation", "graph", "partitioning", "problem", "use", "energy", "which", "prioritize", "smoothness", "result", "field", "encode", "constrain", "set", "possible", "cut", "form", "its", "isocontour", "focus", "smoothness", "term", "stage", "we", "can", "limit", "we", "search", "cut", "only", "smooth", "candidate", "second", "stage", "we", "select", "one", "isocontour", "choose", "how", "round", "continuous", "solution", "discrete", "one", "re-introduce", "stronger", "accuracy", "term", "only", "after", "we", "reach", "second", "stage", "we", "ensure", "reasonable", "degree", "accuracy", "while", "simultaneously", "guarantee", "smoothness", "stage", "we", "minimize", "follow", "quadratic", "energy", "within", "each", "connected-component", "3.5", "Subdivision", "Gluing", "deletion", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "3.2", "-rrb-", "-lrb-", "-rrb-", "3.2", "-lrb-", "-rrb-", "ij", "-lrb-", "-lrb-", "-rrb-", "ij", "-lrb-", "i?v", "-lrb-", "appendix", "explain", "how", "problem", "solve", "more", "detail", "-rrb-", "unfortunately", "since", "we", "make", "small", "-lrb-", "10", "-rrb-", "solve", "value", "unreliably", "small", "avoid", "problem", "we", "introduce", "few", "extra", "binary", "term", "each", "new", "binary", "term", "associate", "edge", "-lrb-", "-rrb-", "which", "cut", "some", "intersection", "curve", "extra", "term", "pry", "apart", "value", "opposite", "side", "intersection", "curve", "use", "observe", "difference", "raw", "parity", "field", "aside", "from", "we", "dependence", "unfortunately", "heuristic", "term", "necessarily", "asymmetric", "allow", "compromise", "when", "sizable", "number", "raw", "parity", "error", "near", "intersection", "curve", "do", "turn", "out", "significant", "problem", "we", "test", "case", "stage", "we", "sort", "vertex", "value", "perform", "sweep", "cut", "determine", "round", "threshold", "each", "vertex", "round", "down", "-lrb-", "odd", "-rrb-", "otherwise", "round", "up", "-lrb-", "even", "-rrb-", "we", "begin", "below", "all", "sweep", "upward", "until", "greater", "than", "all", "we", "select", "whichever", "minimize", "cut", "energy", "i?v", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ij", "-lrb-", "-rrb-", "-lrb-", "3.3", "-rrb-", "-lrb-", "where", "round", "value", "-lsb-", "-rsb-", "indicator", "function", "-rrb-", "note", "we", "penalize", "both", "newly", "introduce", "boundary", "-lrb-", "-rrb-", "well", "unused", "intersection", "-lrb-", "-rrb-", "order", "balance", "two", "term", "we", "use", "-lrb-", "half", "isoperimetric", "constant", "-rrb-", "square", "boundary", "length", "term", "result", "geometrically", "nice", "scale-free", "energy", "Edge", "vertex", "weight", "Edge", "weight", "ij", "vertex", "weight", "should", "set", "suitably", "encode", "geometry", "mesh", "sum", "all", "edge", "weight", "between", "even", "odd", "parity", "vertex", "should", "approximate", "length", "perimeter", "curve", "while", "sum", "vertex", "weight", "should", "approximate", "surface", "area", "accomplish", "we", "use", "follow", "scheme", "Conceptually", "we", "can", "think", "each", "triangle", "be", "divide", "quadrilateral", "edge", "which", "connect", "midpoint", "each", "edge", "barycenter", "triangle", "area", "each", "quadrilateral", "can", "add", "each", "vertex", "weight", "while", "length", "midpoint-barycenter", "line", "segment", "can", "add", "appropriate", "edge", "weight", "once", "we", "have", "successfully", "compute", "intersection", "curve", "correct", "parity", "field", "we", "have", "all", "datum", "necessary", "actually", "change", "topology", "surface", "we", "complete", "change", "four", "step", "decide", "which", "curve", "resolve", "when", "begin", "step", "we", "have", "all", "intersection", "curve", "already", "detect", "we", "discard", "some", "curve", "add", "new", "curve", "goal", "produce", "set", "curve", "separate", "even", "parity", "portion", "surface", "from", "odd", "parity", "portion", "surface", "first", "we", "group", "intersection", "curve", "connected", "component", "any", "connected", "component", "intersection", "which", "adjacent", "only", "even", "only", "odd", "parity", "region", "remove", "from", "consideration", "-lrb-", "i.e.", "leave", "un-subdivided", "-rrb-", "next", "we", "identify", "all", "edge", "triangle", "mesh", "-lrb-", "intersection", "edge", "-rrb-", "which", "both", "separate", "even", "odd", "parity", "vertex", "themselves", "cross", "intersection", "curve", "intersection", "vertex", "insert", "midway", "along", "each", "edge", "we", "examine", "all", "triangle", "untouch", "intersection", "curve", "both", "even", "odd", "parity", "vertex", "each", "triangle", "have", "false", "intersection", "vertex", "insert", "along", "exactly", "two", "edge", "we", "introduce", "false", "intersection", "edge", "connect", "vertex", "-lrb-", "note", "result", "false", "intersection", "curve", "terminate", "just", "before", "enter", "triangle", "contain", "actual", "intersection", "curve", "produce", "slight", "gap", "curve", "separate", "even", "odd", "parity", "closing", "gap", "explicitly", "involve", "more", "complex", "geometric", "reasoning", "instead", "we", "fix", "up", "minor", "shortcoming", "post-process", "after", "subdivide", "-rrb-", "subdivide", "mesh", "we", "solve", "constrain", "triangulation", "problem", "triangle-by-triangle", "basis", "we", "accumulate", "all", "point", "edge", "intersection", "lie", "each", "triangle", "run", "Shewchuk?s", "Triangle", "-lsb-", "1996", "-rsb-", "produce", "constrain", "triangulation", "glue", "vertex", "edge", "except", "false", "intersection", "curve", "insert", "during", "step", "intersection", "necessarily", "lie", "two", "different", "part", "surface", "therefore", "we", "must", "glue", "together", "duplicate", "curve", "replace", "duplicated", "vertex", "edge", "unique", "vertex", "edge", "effect", "step", "connect", "surface", "along", "those", "intersection", "we", "do", "discard", "step", "delete", "triangle", "odd", "parity", "finally", "we", "back", "normal", "mesh", "without", "intersection", "curve", "we", "must", "now", "propagate", "parity", "field", "onto", "triangle", "delete", "odd", "portion", "occur", "two", "sub-step", "first", "observe", "triangle", "subdivision", "can", "have", "both", "odd", "even", "parity", "vertex", "after", "subdivision", "because", "we", "insert", "some", "kind", "intersection", "vertex", "every", "edge", "original", "mesh", "opposite", "parity", "endpoint", "take", "advantage", "observation", "we", "decide", "parity", "majority", "triangle", "simply", "copy", "value", "from", "vertex", "however", "because", "both", "gap", "introduce", "step", "potential", "complicated", "intersection", "happen", "entirely", "within", "single", "triangle", "may", "some", "triangle", "which", "lack", "parity", "cover", "triangle", "we", "perform", "50", "round", "iterated", "diffusion", "parity", "already", "decide", "triangle", "hold", "constant", "while", "value", "propagate", "between", "any", "two", "adjacent", "triangle", "separate", "intersection", "curve", "triangle", "still", "undecided", "end", "process", "mark", "even", "parity", "finally", "odd", "parity", "triangle", "delete", "Figure", "we", "method", "even", "work", "some", "triangle", "soup", "variation", "earlier", "case", "we", "disconnect", "all", "triangle", "ground", "plane", "jitter", "vertex", "same", "result", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "put", "hole", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "34:7", "integration", "Mesh", "Modeler", "demonstrate", "we", "method", "topology", "change", "we", "construct", "rudimentary", "surface", "deformation", "modeler", "-lrb-", "see", "supplementary", "material", "-rrb-", "modeler", "equip", "four", "brush", "inflate/deflate", "paint", "cause", "instantaneous", "displacement", "direction", "surface", "normal", "smooth", "paint", "cause", "instantaneous", "explicit", "laplacian", "smooth", "Grab", "hold", "onto", "part", "surface", "-lrb-", "distance-based", "falloff", "influence", "-rrb-", "drag", "around", "move", "hold", "onto", "entire", "connected", "component", "surface", "rigidly", "drag", "around", "between", "every", "pair", "frame", "we", "run", "edge-based", "-lrb-", "split/collapse", "-rrb-", "remeshing", "algorithm", "dynamically", "adapt", "mesh", "resolution", "inflate", "smooth", "brush", "we", "incorporate", "topology", "change", "obvious", "manner", "between", "every", "pair", "frame", "-lrb-", "before", "remesh", "-rrb-", "we", "run", "we", "algorithm", "do", "so", "produce", "instantaneous", "topology", "change", "grab", "move", "brush", "user", "interaction", "often", "involve", "exploration", "different", "option", "drag", "through", "they", "user", "decide", "against", "take", "action", "be", "contemplate", "return", "mouse", "position", "which", "drag", "begin", "effectively", "cancel", "action", "incorporate", "topology", "change", "scenario", "we", "take", "different", "approach", "while", "mouse", "depress", "we", "run", "collision", "detection", "each", "frame", "accumulate", "new", "collision", "run", "tally", "keep", "raw", "parity", "field", "only", "when", "mouse", "release", "do", "we", "execute", "full", "topology", "change", "algorithm", "-lrb-", "use", "accumulate", "raw", "parity", "-rrb-", "commit", "result", "order", "aid", "user", "we", "also", "compute", "correct", "parity", "field", "every", "frame", "display", "result", "immediate", "feedback", "analysis", "collision", "parity", "tend", "produce", "similar", "result", "compare", "method", "which", "require", "solid", "mesh", "sense", "we", "can", "think", "parity", "be", "backwards-compatible", "semantically?with", "prior", "work", "order", "allow", "more", "formal", "exploration", "claim", "we", "restrict", "we", "attention", "case", "solid", "surface", "where", "all", "method", "behavior", "well", "define", "give", "restricted", "setting", "we", "can", "make", "follow", "claim", "Theorem", "5.1", "Theorem", "5.2", "proposition", "5.3", "-lrb-", "informal", "-rrb-", "give", "solid", "mesh", "deformation", "thereof", "parity-based", "topology", "change", "produce", "solid", "mesh", "give", "two", "solid", "mesh", "undergo", "independent", "rigid", "motion", "parity-based", "topology", "change", "yield", "boolean", "union", "compute", "via", "CSG", "most", "common", "case", "give", "deform", "solid", "mesh", "parity-based", "topology", "change", "compute", "expected", "result", "give", "solid", "interpretation", "appendix", "we", "formalize", "final", "proposition", "more", "precise", "claim", "from", "which", "first", "two", "claim", "follow", "corollary", "total", "argument", "serve", "establish", "notion", "soundness", "we", "method", "solid", "surface", "handle", "expect", "addition", "formal", "argument", "we", "also", "measure", "time", "space", "usage", "we", "prototype", "system", "code", "system", "be", "make", "available", "under", "LGPL", "we", "able", "operate", "mesh", "up", "10", "000", "triangle", "interactive", "rate", "use", "less", "than", "120mb", "RAM", "majority", "time", "spend", "compute", "intersection", "collision", "detection", "so", "we", "expect", "method", "can", "scale", "larger", "mesh", "through", "use", "more", "aggressive", "acceleration", "structure", "point", "comparison", "grid-based", "method", "use", "Wojtan", "et", "al.", "-lsb-", "2009", "-rsb-", "can", "use", "interactive", "sculpting", "solid", "surface", "up", "40", "000", "triangle", "application", "Mr.", "potato", "head", "modeling", "part", "assembly", "-lrb-", "figure", "-rrb-", "very", "easy", "use", "modeler", "can", "build", "around", "idea", "assemble", "model", "from", "exist", "part", "-lsb-", "Chaudhuri", "et", "al.", "2011", "Schmidt", "Singh", "2010", "Hecker", "et", "al.", "2008", "-rsb-", "modeler", "depend", "some", "algorithm", "allow", "user", "join", "various", "part", "together", "method", "like", "one", "use", "Mesh", "Mixer", "-lsb-", "Schmidt", "Singh", "2010", "-rsb-", "require", "target", "surface", "patch", "manifold", "disk-like", "-lrb-", "i.e.", "simply", "connect", "-rrb-", "part/surface", "be", "attach", "have", "single", "loop", "boundary", "which", "can", "stitch", "disk", "contrast", "method", "present", "here", "enable", "attachment", "part", "side", "effect", "when", "use", "we", "move", "tool", "unlike", "more", "specialized", "algorithm", "ours", "universally", "applicable", "allow", "any", "two", "surface", "become", "attach", "wherever", "user", "desire", "pinch", "closing", "-lrb-", "figure", "10", "-rrb-", "many", "brush", "mesh", "sculpting", "program", "may", "cause", "surface", "become", "pinch", "instance", "paint", "crease", "surface", "displacement", "along", "normal", "-lrb-", "inflate", "-rrb-", "brush", "often", "cause", "surface", "pinch", "when", "topology", "change", "add", "system", "pinch", "correctly", "delete", "close", "up", "ensure", "surface", "remain", "well", "behave", "successive", "operation", "apply", "near", "crease", "Paper", "mache", "-lrb-", "figure", "11", "-rrb-", "while", "design", "purpose", "topology", "change", "can", "use", "join", "two", "surface", "slot", "one", "other", "conjunction", "laplacian", "smoothing", "brush", "surface", "can", "join", "smooth", "together", "one", "be", "paper", "mache-ing", "object", "more", "complex", "example", "-lrb-", "figure", "12", "-rrb-", "example", "exhibit", "model", "cow", "two", "wing", "consist", "about", "25,000", "triangle", "total", "cow", "model", "purchase", "colleague", "part", "mesh", "set", "provide", "cow", "model", "compose", "hundred", "disconnect", "mesh", "component", "many", "which", "intersect", "each", "other", "needless", "say", "present", "challenging", "case", "topology", "change", "representative", "issue", "which", "arise", "practice", "nevertheless", "we", "method", "able", "successfully", "join", "wing", "cow", "body", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "34:8", "G.", "Bernstein", "et", "al.", "Figure", "use", "topology", "change", "model-by-part", "hand", "close", "while", "foot", "nose", "open", "surface", "Figure", "10", "Topology", "change", "help", "clean", "up", "undesirable", "feature", "arise", "while", "sculpting", "like", "pinched", "surface", "Figure", "11", "improvise", "use", "topology", "change", "pull", "surface", "edge", "around", "-lrb-", "-rrb-", "repeatedly", "another", "surface", "-lrb-", "-rrb-", "two", "surface", "become", "connect", "once", "connect", "smooth", "brush", "dynamic", "remeshing", "can", "use", "-lrb-", "-rrb-", "clean", "up", "join", "achieve", "paper-mache-like", "process", "Limitations", "formal", "property", "we", "method", "prove", "continuous", "setting", "however", "discretization", "parity", "field", "which", "we", "use", "-lrb-", "sampling", "only", "mesh", "vertex", "-rrb-", "can", "miss", "important", "collision", "instance", "when", "cylinder", "plunge", "single", "large", "triangle", "-lrb-", "figure", "13", "-rrb-", "parity", "sample", "lie", "triangle", "within", "cylinder", "result", "incorrect", "topology", "change", "shortcoming", "can", "eliminate", "adaptively", "refine", "mesh", "response", "collision", "particular", "scenario", "we", "give", "add", "single", "vertex", "large", "triangle", "-lrb-", "place", "inside", "cylinder", "-rrb-", "would", "result", "correct", "topology", "change", "order", "keep", "we", "prototype", "implementation", "simpler", "we", "choose", "address", "issue", "we", "have", "show", "some", "example", "we", "method", "deal", "multiple", "disconnect", "mesh", "component", "-lrb-", "figure", "12", "-rrb-", "we", "method", "able", "successfully", "handle", "some", "case", "arbitrary", "triangle", "soup", "may", "still", "pose", "problem", "because", "error", "correction", "algorithm", "section", "3.4", "assume", "connected", "graph", "we", "method", "design", "general", "purpose", "use", "tailor", "specific", "application", "unfortunately", "choice", "also", "lead", "unexpected", "behavior", "some", "more", "specific", "context", "instance", "when", "assemble", "model", "from", "exist", "part", "some", "those", "part", "have", "open", "boundary", "side", "where", "attach", "can", "lead", "preservation", "occluded", "surface", "component", "whose", "presence", "user", "unaware", "take", "another", "example", "when", "mimic", "paper", "mache", "process", "bring", "two", "sheet", "together", "often", "create", "tunnels/holes", "process", "connect", "two", "surface", "different", "form", "topology", "change", "more", "focus", "merge", "collide", "surface", "would", "probably", "more", "appropriate", "another", "issue", "arrise", "when", "self-intersecting", "geometry", "begin", "move", "currently", "we", "do", "resolve", "self-intersection", "so", "long", "remain", "static", "however", "once", "intersect", "portion", "surface", "begin", "move", "result", "raw", "parity", "field", "may", "overwhelm", "suppressing", "effect", "error", "correction", "cause", "hole", "open", "mesh", "result", "when", "discuss", "system", "other", "we", "repeatedly", "receive", "opinion", "we", "system", "-lrb-", "variant", "-rrb-", "produce", "intuitive", "unintuitive", "behavior", "frequently", "we", "would", "receive", "both", "opinion", "about", "same", "example", "when", "we", "restrict", "ourselves", "case", "solid", "object", "disagreement", "disappear", "non-solid", "case", "disagreement", "common", "consequently", "we", "observe", "goal", "produce", "intuitive", "behavior", "method", "applicable", "arbitrary", "surface", "likely", "fool?s", "errand", "none-the-less", "we", "can", "propose", "method", "topology", "change", "which", "may", "useful", "artist", "whose", "idiosyncrasy", "can", "learn", "over", "time", "some", "shortcoming", "could", "probably", "address", "-lrb-", "least", "particular", "case", "-rrb-", "specialize", "hack", "however", "from", "we", "experience", "experiment", "error", "correction", "scheme", "we", "observe", "fix", "one", "problem", "generate", "host", "other", "interest", "keep", "we", "approach", "simple", "focus", "we", "choose", "explore", "complicate", "fix", "some", "issue", "like", "those", "paper", "mache-ing", "go", "beyond", "hack", "case", "different", "kind", "topology", "change", "different", "behavior", "might", "more", "appropriate", "consider", "behavior", "soap", "film", "when", "two", "soap", "bubble", "collide", "low", "speed", "rather", "than", "annihilate", "each", "other", "two", "collide", "surface", "merge", "single", "interface", "example", "like", "one", "suggest", "multiple", "different", "kind", "topology", "change", "behavior", "necessary", "satisfy", "user", "expectation", "one", "interesting", "direction", "future", "research", "explore", "how", "organize", "categorize", "different", "kind", "topology", "change", "work", "under", "premise", "can", "one", "universally", "appropriate", "behavior", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "put", "hole", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "34:9", "Figure", "12", "we", "attach", "pair", "wing", "cow", "model", "-lrb-", "-rrb-", "compose", "many", "disconnect", "component", "intersect", "show", "-lrb-", "-rrb-", "red", "nonetheless", "we", "able", "-lrb-", "-rrb-", "compute", "topology", "change", "-lrb-", "Inset", "-rrb-", "error", "correction", "can", "fix", "completely", "disconnect", "component", "Figure", "13", "failure", "case", "we", "algorithm", "closed", "cylinder", "plunge", "downward", "through", "single", "giant", "triangle", "-lrb-", "left", "-rrb-", "because", "parity", "sample", "triangle", "itself", "we", "algorithm", "do", "properly", "delete", "hole", "cause", "cylinder", "instead", "cause", "non-manifold", "junction", "between", "both", "model", "-lrb-", "right", "-rrb-", "conclusion", "outlook", "closing", "we", "have", "provide", "method", "compute", "topological", "change", "triangle", "mesh", "subject", "typical", "restriction", "common", "among", "most", "geometric", "algorithm", "we", "method", "do", "require", "input", "mesh", "represent", "solid", "object", "so", "more", "widely", "applicable", "than", "most", "exist", "algorithm", "further", "improve", "method?s", "reliability", "we", "provide", "novel", "error", "correction", "mechanism", "both", "handle", "poor-quality", "mesh", "tolerate", "inaccuracy", "collision", "detection", "computation", "because", "we", "method", "error-tolerant", "applicable", "wide", "range", "potential", "input", "we", "believe", "can", "integrate", "nicely", "geometric", "modeling", "application", "future", "algorithm?s", "efficiency", "simplicity", "allow", "topology", "change", "happen", "naturally", "any", "deformation", "tool", "instead", "need", "explicitly", "effect", "through", "special", "tool", "consequence", "ease", "integration", "we", "believe", "we", "method", "have", "potential", "significantly", "improve", "standard", "work", "flow", "geometric", "modeler", "once", "user", "understand", "general", "idea", "behavior", "like", "topology", "change", "how", "different", "tool", "can", "use", "deform", "surface", "can", "discover", "new", "strategy", "through", "exploration", "continue", "use", "way", "comparison", "sketch-based", "modeling", "program", "must", "incorporate", "special", "new", "gesture", "type", "which", "user", "must", "learn", "how", "execute", "order", "introduce", "tunnel", "handle", "exist", "surface", "tool", "less", "likely", "lead", "user", "discover", "serendipitous", "use", "combination", "we", "see", "we", "method", "way", "easily", "incorporate", "topology", "change", "3d", "modeler", "similar", "way", "Harmon", "et", "al.", "-lsb-", "2011", "-rsb-", "incorporate", "collision", "detection", "response", "we", "suspect", "line", "thinking", "may", "lead", "further", "innovation", "3d", "modeling", "tool", "how", "can", "we", "incorporate", "more", "behavior", "-lrb-", "e.g.", "topology", "change", "collision", "response", "-rrb-", "natural", "otherwise", "compound", "effect", "we", "tool", "how", "few", "tool", "behavior", "can", "we", "use", "build", "parsimonious", "compelling", "flexible", "modeling", "system", "acknowledgement", "most", "all", "we", "would", "like", "thank", "Zoran", "Popovic", "he", "help", "guidance", "earlier", "iteration", "research", "thank", "you", "researcher", "involve", "compile", "maintain", "both", "Brown", "Mesh", "set", "Princeton", "shape", "Benchmark", "thank", "you", "also", "Siddhartha", "Chaudhuri", "provide", "cow", "model", "we", "use", "research", "support", "via", "NSF", "grfp", "dge-0718124", "reference", "3d-c", "oat", "2013", "3d-coat", "TTENE", "M.", "AMPEN", "M.", "OBBELT", "L.", "2013", "Polygon", "mesh", "repair", "application", "perspective", "ACM", "Computing", "survey", "appear", "UTODESK", "2013", "3d", "Max", "UTODESK", "2013", "maya", "UTODESK", "2013", "Mudbox", "oykov", "Y.", "EKSLER", "O.", "abih", "R.", "2001", "fast", "approximate", "energy", "minimization", "via", "graph", "cut", "IEEE", "Trans", "pattern", "Anal", "Mach", "Intell", "23", "11", "-lrb-", "Nov.", "-rrb-", "1222", "1239", "rochu", "T.", "RIDSON", "R.", "2009", "robust", "topological", "operation", "dynamic", "explicit", "surface", "SIAM", "J.", "Sci", "Comput", "31", "2472", "2493", "rochu", "T.", "DWARDS", "E.", "RIDSON", "R.", "2012", "efficient", "geometrically", "exact", "continuous", "collision", "detection", "ACM", "Trans", "graph", "31", "-lrb-", "July", "-rrb-", "96:1", "96:7", "ampen", "m.", "OBBELT", "L.", "2010", "exact", "robust", "-lrb-", "self", "-rrb-", "intersection", "polygonal", "mesh", "Computer", "Graphics", "Forum", "29", "397", "406", "haudhurus", "S.", "ALOGERAKIS", "E.", "UIBAS", "L.", "OLTUN", "V.", "2011", "probabilistic", "reasoning", "assembly-based", "3d", "modeling", "ACM", "transaction", "graphic", "-lrb-", "Proc", "SIGGRAPH", "-rrb-", "30", "delsbrunner", "H.", "ucke", "E.", "1990", "simulation", "simplicity", "technique", "cope", "degenerate", "case", "geometric", "algorithm", "ACM", "transaction", "graphic", "-lrb-", "tog", "-lrb-", "Jan", "-rrb-", "rady", "L.", "CHWARTZ", "E.", "L.", "2006", "isoperimetric", "graph", "partition", "image", "segmentation", "IEEE", "Trans", "Pat", "Anal", "Mach", "int", "28", "469", "475", "ARMON", "D.", "anozzo", "D.", "orkine", "O.", "orin", "D.", "2011", "interference-aware", "geometric", "modeling", "ACM", "Trans", "graph", "30", "-lrb-", "Dec.", "-rrb-", "137:1", "137:10", "ecker", "C.", "AABE", "B.", "NSLOW", "R.", "W.", "EESE", "J.", "AY", "NARD", "J.", "VAN", "rooijen", "K.", "2008", "real-time", "motion", "retargeting", "highly", "varied", "user-created", "morphology", "ACM", "SIGGRAPH", "2008", "papers", "ACM", "New", "York", "NY", "USA", "SIGGRAPH", "08", "27:1", "27:11", "garashi", "T.", "atsuoka", "S.", "anaka", "H.", "1999", "Teddy", "sketch", "interface", "3d", "freeform", "design", "Proceedings", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "34:10", "G.", "Bernstein", "et", "al.", "26th", "annual", "conference", "computer", "graphic", "inter", "active", "technique", "ACM", "Press/Addison-Wesley", "Publishing", "Co.", "New", "York", "NY", "USA", "SIGGRAPH", "99", "409", "416", "T.", "2009", "fix", "geometric", "error", "polygonal", "model", "survey", "J.", "Comput", "Sci", "Technol", "24", "-lrb-", "Jan.", "-rrb-", "19", "29", "uire", "M.", "2004", "observation", "silhouette", "size", "journal", "graphic", "gpu", "game", "tool", "12", "ojang", "2013", "Minecraft", "ixologic", "2013", "Sculptris", "ixologic", "2013", "zbrush", "equicha", "a.", "A.", "G.", "1977", "mathematical", "model", "rigid", "solid", "object", "Tech", "Rep.", "TM-28", "Production", "Automation", "Project", "University", "Rochester", "Rochester", "New", "York", "14627", "November", "chmidt", "R.", "INGH", "K.", "2010", "meshmixer", "interface", "rapid", "mesh", "composition", "ACM", "SIGGRAPH", "2010", "talk", "ACM", "New", "York", "NY", "USA", "SIGGRAPH", "10", "6:1", "6:1", "eidel", "R.", "1994", "nature", "meaning", "perturbation", "geometric", "computing", "stac", "94", "Proceedings", "11th", "annual", "symposium", "theoretical", "aspect", "Computer", "Science", "Springer-Verlag", "London", "UK", "17", "hewchuk", "J.", "R.", "1996", "triangle", "Engineering", "2d", "quality", "mesh", "generator", "delaunay", "triangulator", "selected", "papers", "from", "Workshop", "Applied", "Computational", "Geormetry", "towards", "Geo", "metric", "Engineering", "Springer-Verlag", "London", "UK", "UK", "FCRC", "96/wacg", "96", "203", "222", "hewchuk", "J.", "R.", "1997", "adaptive", "precision", "Floating-Point", "Arithmetic", "fast", "robust", "geometric", "predicate", "Discrete", "Computational", "Geometry", "18", "-lrb-", "Oct.", "-rrb-", "305", "363", "anculescu", "L.", "HAINE", "R.", "anus", "m.-p", "2011", "Smi", "2011", "full", "paper", "Freestyle", "sculpt", "mesh", "self-adaptive", "topology", "Comput", "graph", "35", "-lrb-", "June", "-rrb-", "614", "622", "eschner", "M.", "EIDELBERGER", "B.", "ANOCHA", "D.", "OVIN", "DARAJU", "N.", "ACHMANN", "G.", "IMMERLE", "S.", "ezger", "J.", "uhrmann", "a.", "2005", "Collision", "handle", "dynamic", "simulation", "environment", "eurographic", "2005", "Tutorial", "Notes", "ALD", "I.", "2007", "fast", "construction", "sah-based", "bound", "volume", "hierarchy", "Proceedings", "2007", "IEEE", "Symposium", "Interactive", "Ray", "Tracing", "IEEE", "Computer", "Society", "Washington", "DC", "USA", "rt", "07", "33", "40", "OJTAN", "C.", "urey", "N.", "ROSS", "M.", "urk", "G.", "2009", "deform", "mesh", "split", "merge", "SIGGRAPH", "09", "ACM", "SIGGRAPH", "2009", "papers", "ACM", "New", "York", "NY", "USA", "10", "OJTAN", "C.", "urey", "N.", "ROSS", "M.", "urk", "G.", "2010", "physics-inspired", "topology", "change", "thin", "fluid", "feature", "SIGGRAPH", "10", "ACM", "SIGGRAPH", "2010", "papers", "ACM", "New", "York", "NY", "USA", "aharescu", "a.", "oyer", "E.", "oraud", "R.", "2011", "topologyadaptive", "mesh", "deformation", "surface", "evolution", "morph", "multiview", "reconstruction", "IEEE", "transaction", "Pattern", "Analysis", "Machine", "Intelligence", "33", "823", "837", "appendix", "give", "point", "triangle", "-lrb-", "-rrb-", "motion", "from", "from", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "point", "collide", "triangle?s", "plane", "whenever", "triple", "product", "vanish", "produce", "cubic", "equation", "whose", "root", "find", "via", "interval", "search", "candidate", "intersection", "point", "test", "containment", "triangle", "time", "interval", "-lrb-", "-rrb-", "Standard", "floating-point", "arithmetic", "use", "exact", "method", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "could", "use", "instead", "avoid", "inaccuracy", "due", "floatingpoint", "unnecessary", "due", "error", "correction", "-lsb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rsb-", "appendix", "quadratic", "energy", "use", "during", "error", "correction", "minimize", "solve", "linear", "equation", "ax", "use", "sparse", "cholesky", "solver", "system", "can", "set", "up", "use", "follow", "formula", "-lrb-", "-rrb-", "cut", "ij", "ij", "otherwise", "ii", "ij", "ij", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "cut", "appendix", "we", "begin", "define", "and/or", "recall", "few", "concept", "relate", "point", "polygon", "test", "after", "we", "present", "lemma", "corollary", "recall", "every", "solid", "surface", "-lrb-", "closed", "non-self-intersecting", "-rrb-", "have", "canonical", "normal", "field", "normal", "point", "outward", "-lrb-", "2.1", "-rrb-", "follow", "we", "assume", "all", "solid", "surface", "equip", "canonical", "normal", "field", "furthermore", "we", "assume", "every", "surface", "begin", "end", "its", "motion", "general", "position", "we", "make", "assumption", "here", "simplify", "analysis", "we", "code", "we", "use", "perturbation", "exact", "geometric", "predicate", "treat", "general", "positionrelated", "issues?we", "do", "ignore", "they", "give", "closed", "surface", "equip", "normal", "field", "we", "define", "containment", "number", "-lrb-", "-rrb-", "point", "surface", "follow", "Select", "any", "continuous", "path", "start", "diverge", "towards", "infinity", "path", "never", "cross", "surface", "-lrb-", "-rrb-", "otherwise", "we", "may", "compute", "-lrb-", "-rrb-", "follow", "procedure", "-lrb-", "-rrb-", "trace", "along", "path", "beginning", "p.", "every", "time", "path", "cross", "surface", "increment", "containment", "number", "we", "cross", "surface", "same", "direction", "surface", "normal", "decrement", "containment", "number", "we", "cross", "opposite", "direction", "closed", "surface", "quantity", "compute", "procedure", "invariant", "choice", "path", "surface", "move", "containment", "number", "preserve", "so", "long", "surface", "do", "pass", "over", "p.", "so", "surface", "move", "adjust", "containment", "number", "only", "pass", "over", "rule", "update", "derive", "from", "above", "definition", "surface", "pass", "over", "travel", "direction", "its", "surface", "normal", "containment", "number", "increment", "otherwise", "decrement", "2d", "containment", "number", "equivalent", "wind", "number", "curve", "containment", "number", "can", "use", "classify", "space", "around", "surface", "space", "contain", "inside", "surface", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "space", "outside", "surface", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "binary", "interpretation", "containment", "number", "suffice", "solid", "surface", "we", "consider", "two", "possible", "extension", "self-intersecting", "close", "surface", "sign", "interpretation", "say", "point", "inside", "-lrb-", "-rrb-", "outside", "-lrb-", "-rrb-", "modulo", "interpretation", "say", "point", "inside", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "inside", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "two", "interpretation", "sign", "interpretation", "probably", "more", "natural", "however", "without", "argue", "relative", "merit", "we", "can", "observe", "so", "long", "-lrb-", "-rrb-", "-lcb-", "-rcb-", "both", "interpretation", "agree", "-lrb-", "i.e.", "so", "long", "containment", "number", "deviate", "most", "one", "from", "expect", "value", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013", "put", "hole", "Holey", "Geometry", "Topology", "Change", "Arbitrary", "Surfaces", "34:11", "Lemma", "8.1", "give", "initially", "solid", "surface", "undergo", "deformation", "track", "collision", "parity", "result", "topology", "change", "equivalent", "modulo", "interpretation", "containment", "number", "proof", "sketch", "consider", "point", "surface", "undergo", "deformation", "point", "displaced", "infinitesimally", "away", "from", "normal", "direction", "point", "displaced", "infinitesimally", "far", "away", "from", "opposite", "direction", "before", "surface", "begin", "move", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "during", "movement", "collide", "other", "piece", "surface", "even", "odd", "number", "time", "collide", "even", "number", "time", "containment", "number", "must", "both", "change", "same", "amount", "some", "multiple", "say", "2k", "so", "either", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "under", "modulo", "interpretation", "containment", "number", "mean", "either", "outside", "while", "inside", "vice-versa", "so", "under", "modulo", "interpretation", "we", "would", "choose", "delete", "point", "surface", "which", "collide", "even", "number", "time", "collide", "odd", "number", "time", "containment", "number", "must", "both", "change", "same", "amount", "2k", "so", "either", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "under", "modulo", "interpretation", "containment", "number", "mean", "either", "both", "inside", "both", "outside", "either", "case", "we", "would", "choose", "delete", "since", "do", "serve", "separate", "inside", "from", "outside", "first", "theorem", "-lrb-", "5.1", "-rrb-", "follow", "directly", "from", "lemma", "since", "we", "just", "demonstrate", "parity", "base", "topology", "change", "can", "interpret", "provide", "inside/outside", "classification", "closed", "surface", "corollary", "8.2", "-lrb-", "Theorem", "5.2", "-rrb-", "give", "two", "solid", "mesh", "undergo", "independent", "rigid", "motion", "parity-based", "topology", "change", "yield", "boolean", "union", "compute", "via", "CSG", "proof", "consider", "two", "solid", "mesh", "undergo", "independent", "rigid", "motion", "when", "do", "move", "every", "point", "space", "either", "outside", "both", "mesh", "inside", "one", "mesh", "inside", "both", "thus", "-lrb-", "-rrb-", "-lcb-", "-rcb-", "under", "modulo", "interpretation", "containment", "number", "we", "interpret", "value", "outside", "both", "inside", "leverage", "lemma", "8.1", "we", "know", "compute", "parity-based", "topology", "change", "yield", "solid", "mesh", "under", "modulo", "interpretation", "therefore", "result", "mesh", "represent", "boolean", "union", "two", "solid", "mesh", "question", "finally", "extent", "we", "willing", "accept", "informal", "proposition", "-lrb-", "i.e.", "observation", "-rrb-", "-lrb-", "-rrb-", "often", "confine", "set", "value", "-lcb-", "-rcb-", "we", "observe", "compute", "paritybased", "topology", "change", "initially", "solid", "surface", "often", "yield", "same", "result", "under", "sign", "interpretation", "containment", "number", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "34", "publication", "date", "July", "2013" ],
  "content" : "\n  \n    1027be43154480cd600fd82958eea1a516ba82fddde0ae4f226e397c45dfd1ce\n    mjd\n    10.1145/2461912.2462027\n    Name identification was not possible. \n  \n  \n    \n      \n        Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces\n      \n      Gilbert Louis Bernstein ? University of Washington Stanford University\n      \n        \n        Figure 1: This zombie model (a) has numerous open surfaces, non-manifold edges, and self-intersections, displayed in red here (b). Nonethe-less, using the technique described in this paper, we are able to (c) poke through the zombie?s chest and (d) create the desired tunnel/hole.\n      \n      This paper presents a method for computing topology changes for triangle meshes in an interactive geometric modeling environment. Most triangle meshes in practice do not exhibit desirable geometric properties, so we develop a solution that is independent of standard assumptions and robust to geometric errors. Specifically, we provide the first method for topology change applicable to arbitrary non-solid, non-manifold, non-closed, self-intersecting surfaces. We prove that this new method for topology change produces the expected conventional results when applied to solid (closed, manifold, non-self-intersecting) surfaces?that is, we prove a backwardscompatibility property relative to prior work. Beyond solid surfaces, we present empirical evidence that our method remains tolerant to a variety of surface aberrations through the incorporation of a novel error correction scheme. Finally, we demonstrate how topology change applied to non-solid objects enables wholly new and useful behaviors. CR Categories: I.3.7 [Computer Graphics]: Computational Geometry and Object Modeling?Geometric algorithms, languages, and systems; Keywords: topology, intersections, deformations, sculpting, 3d modeling, non-manifold geometry\n      Links:\n      \n        \n      \n      DL PDF W\n      \n        \n        \n      \n      EB\n      \n        \n      \n      V IDEO\n      \n        \n      \n      C ODE\n    \n    \n      \n        1 Introduction\n      \n      Programs for the 3d modeling of surfaces must support ways to change the topology of a surface or else be severely limited in their capabilities. For instance, without some way to edit or change the  topology of a surface, it is impossible to model a donut starting from a sphere. The ability to model changes in topology is also critical for the assembly of surfaces from parts, as well as permitting surfaces to merge or split as they are manipulated, to name just a few more consequences. While the ability to change topology is critical for all 3d modeling software, strategies vary widely depending on the representation of the surface and the modeling paradigm in use. For instance, in traditional CAD-derived modeling software like Maya [2013b], or 3DS Max [2013a], special tools allow the user to directly edit the connectivity of the polygons comprising the mesh. Sketch-based modelers in the vein of Teddy [Igarashi et al. 1999] incorporate special stroke gestures which allow users to add tunnels or handles to a surface. Meanwhile voxel-based modeling, exemplified by 3D Coat [2013] or the game Minecraft [2013], naturally incorporates changing topology as a by-product of the representation. In this paper we propose a novel method for supporting topology change in surface-deformation modeling software (e.g. Zbrush [2013b], Sculptris [2013a], Mudbox [2013c]). Like voxel modeling, we would like our topology change to be incidental, occurring as a natural side effect of using existing tools/brushes. In contrast, note that CAD-like and sketch-based modelers require specialized tools for topology change. By choosing incidental topology change over specialized tools, we can achieve greater parsimony (?8) in our modeling system. Having made the choice to incorporate topology change incidentally, a number of methods for topology change primarily used in the simulation literature are available to us [Wojtan et al. 2009; Brochu and Bridson 2009]. Unfortunately, these methods all require that the surface represents a solid object?one that can be faithfully represented by a voxel grid. Many surface models available in the wild (over 90% in our measurements ?2.2) fail to meet this criterion. One simple example is a height-mapped or planar grid of quadrilaterals. In general, character models and other objects are built to function in 3d applications where skinning, animation, and visual appearance trump other concerns like solidity or physical manufacturability. Like a facade on the set of a spaghetti western, these models have been tailored to tell stories. Compounding this problem, most existing programs do not guarantee that exported models are ?solid?. So, in order to design a modeling system which fully interoperates with the existing ecosystem, we have to handle all surfaces, not just the conveniently solid ones. To achieve the goal of topology change for arbitrary surfaces, we rely on one key observation: the motion of a surface during editing is sufficient to determine how the topology of that surface should change, even in the absence of reliable surface normals or the enclosure of space?both surrogates for solidity. By simply tracking points on the surface as they move over time and counting the number of times they experience collisions, we can determine whether that part of the surface should be kept around or deleted: a point which collides with the surface an odd number of times is deleted, while one which collides an even number of times is retained. This simple idea?using collision parity to drive topology change? works well for solid surfaces and many non-solid surfaces as well. However, it can be sensitive to collision detection errors, surface holes, boundaries, and other aberrations. To increase the reliability of our framework in the presence of such imperfections, we introduce an error correction scheme based on graph partitioning. Contributions We provide the first method for topology change applicable to arbitrary non-solid, non-manifold, non-closed, selfintersecting surfaces. We prove that this new method produces expected, conventional results when applied to solid (closed, manifold, non-self-intersecting) surfaces?that is, we prove a backwards-compatibility property relative to prior work. Beyond solid surfaces, we present empirical evidence that our method remains tolerant to a variety of surface aberrations through the incorporation of a novel error correction scheme. Finally, we demonstrate how topology change applied to non-solid objects enables wholly new and useful behaviors.\n      ? e-mail: gilbert@gilbertbernstein.com ? e-mail: wojtan@ist.ac.at ACM Reference Format Bernstein, G., Wojtan, C. 2013. Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces. ACM Trans. Graph. 32, 4, Article 34 (July 2013), 11 pages. DOI = 10.1145/2461912.2462027 http://doi.acm.org/10.1145/2461912.2462027. Copyright Notice Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the fi rst page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org . 2013 Copyright held by the Owner/Author. Publication rights licensed to ACM. 0730-0301/13/07-ART34 $15.00. DOI: http://dx.doi.org/10.1145/2461912.2462027\n      Chris Wojtan ? IST Austria\n      ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n      34:2\n      ?\n      G. Bernstein et al.\n      Voxel Method Super pose a gr d. re rays to co ute A spher e nto... ... Saturday, January 12, 13 Surface March ng ...another sphere. nd farthest po nt, an ood. Saturday, January 12, 13 Coll on Par ty How should the topology change? Our Method Count coll Voxel Method Surface March ng Insta l ty! What happens when we Holes corrupt p nor als and add holes? de/outs de, or or ...\n      ...so we can deter ne de vs. outs de + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + ove non-boundary surfaces and we?re done! Saturday, January 12, 13 Use nor als to choose rect ons Kee ooded shell Saturday, January 12, 13 Record Par ty even odd Delete the odd ons par ty parts. Saturday, January 12, 13 Coll on Par ty .. pped nor als change ...BUT, par unaffected! arch ng results, or or\n      \n        2 Related Work & Background\n        \n          2.1 What Makes a Mesh Solid?\n          Throughout this paper, we will work with triangle meshes that can be specified as a list of vertex positions and a list of triangles (triples of indices into the vertex list). This rules out the possibility of any isolated vertices or dangling edges, but does allow for a variety of interesting mesh types. Many surface classifications can be determined locally from looking at the degree of mesh edges (i.e. the number of triangles which ring around an edge). An edge of the mesh is manifold if it has\n          ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n          Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces\n          ?\n          34:3\n          (a) (b) (c) (d)\n          \n            Figure 2: Mesh type locally depends on the number of triangles incident to an edge: (a) manifold edge, (b) boundary edge, (c) closed edge, (d) non-manifold, non-closed, non-boundary edge degree 2, a boundary edge if it has degree 1, and closed if it has even degree. If all of the edges in a mesh are closed, we say the mesh itself is closed. Not all closed meshes need be manifold. A second critical property of surfaces is whether or not they are self-intersecting. If any two triangles of the mesh have a non-trivial intersection (that is an intersection along something other than a shared vertex or edge), then we say the mesh is self-intersecting. We say that a mesh which is both closed and non-self-intersecting is solid. Solid meshes can also be characterized as those meshes which partition the ambient space R 3 into two parts: those points\n          \n          inside the surface, and those outside of it. Based on this classification, every solid mesh has a canonical surface normal field with normals pointing outward. Sometimes the term ?watertight? is found instead of solid. We prefer to use solid, since the definition of watertight is inconsistent and imprecise across the literature. Outside the class of solid meshes, we say that a mesh is unoriented if any pair of triangles sharing a manifold edge are oriented facing opposite directions. There are some meshes which are inherently non-orientable, the most famous example being a M?bius band. Non-orientable surfaces cannot be assigned a continuous surface normal field, preventing us from relying on normals as a source of information for topology change of arbitrary meshes. 2.2 Why Aren?t All Meshes Solid?\n          Not only do bad meshes exist in the wild, they are quite common. To demonstrate this fact, we ran statistics on the Brown mesh set [McGuire 2004]: less than 25% (263/1136) of the meshes were closed manifolds, and over 40% (472/1136) were neither manifold, nor closed; over 90% (1046/1136) were self-intersecting. To illustrate various conditions which might arise, we developed the coffee mug example( figure 3 ). Besides accidental causes, there are reasons people choose to model these ?undesirable? features. In character models for animation, skinning models regularly requires armpits and other creased areas of geometry to self-intersect in order to achieve reasonable appearances. Thin objects like cloth and flags are regularly modeled as thin sheets, without any intention of representing closed objects. Scanned and reconstructed geometry, especially of large objects like buildings is often incomplete, producing meshes with holes in order to preserve fidelity relative to the raw scan data. Most methods available today for computing topology changes frame the problem in the context of mesh-repair [Attene et al. 2013; Ju 2009]. After a surface is deformed, a mesh-repair-like algorithm is run on the surface at the final position. This can be accomplished through converting the surface into an implicit function representation [Wojtan et al. 2009; Wojtan et al. 2010], into a BSP-based volume representation [Campen and Kobbelt 2010] or by marching around the outside of the mesh, using normals [Zaharescu et al. 2011]. All of these techniques are used to infer a volumetric interpretation (inside vs. outside) of the mesh and discard those parts of the surface which are not necessary to enclose the inferred volume. We believe that the dynamesh feature added to ZBrush [2013b] in late 2012 uses a similar kind of volumetric method. Because these methods (a) force all surfaces to represent solids, and (b) ignore motion data allowing for the inference of what has changed between two frames, they are unable to handle arbitrary meshes (see comic figure). All self-intersecting surfaces must be ?corrected? and open surfaces must have their holes filled, even when doing so would lead to nonsensical results (e.g. hole-filling a ground plane). These methods cannot disambiguate symmetric geometric arrangements (e.g. a cylinder penetrating a ground plane, figure 4 ) because they only inspect the final position of the mesh, not the full motion. More similar to our approach, Brochu & Bridson [2009], and St anculescu et al. [2011] make use of motion data. Rather than attempting to repair the final position of the mesh, they attempt to stitch proximate or colliding pieces of the mesh together as the deformation progresses. Brochu & Bridson use a combination of collision detection, local remeshing, and time-step control to get the surfaces of the mesh close but not touching, allowing for a tunnel to be stitched. Similarly, St anculescu et al. tightly control the size of both mesh elements and time-steps in order to create safe conditions for tunnel stitching. Both Brochu & Bridson, as well as St anculescu et al. assume that displacements are small and can be rewound as necessary to prevent collision, coercing the rest of their simulation and modeling systems (respectively) to satisfy these constraints. However, nei- ther of these constraints are necessarily true in a modeling system, as evidenced by our ?grab? brush(?4). Furthermore, these methods closely interweave local surface remeshing with topology change. Such a conflation poses problems when one attempts to integrate topology change with an existing commercial modeler that uses different, and more sophisticated surface re-meshing techniques. In contrast to prior work, we make no special assumptions about what kinds of meshes our algorithm is presented with. Currently, artists tend to directly edit the connectivity of their meshes, or make use of Boolean operations (aka. CSG). However, Boolean operations are only defined on closed, orientable surfaces [Requicha 1977]. When working with open surfaces, artists are forced to directly edit the connectivity ? no other options are available to them.\n          \n            \n            Figure 3: An example mesh exhibiting ?undesirable? mesh properties. Since the artist expects the coffee mug to always sit on a table, they chose (a) to leave the bottom open. Furthermore the handle has been (b) attached to the mug body in a non-closed manner. Lastly, the water surface has been left (c) intersecting the walls of the mug in order to permit flexible animation later.\n          \n          \n            \n          \n          initial position final position result\n          \n            Figure 4: When a cylinder is plunged downwards into a ground plane, our method reacts as depicted. However, methods which only inspect the final position of the mesh are faced with an ambiguously symmetric problem.\n          \n          2.3 Prior Work\n          ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n          34:4\n          ?\n          G. Bernstein et al.\n          INPUT\n          detection collision\n          \n            \n          \n          intersections compute\n          \n            Figure 5: Overview of our method and its components\n            \n          \n        \n      \n      \n        3 Method\n        \n          3.1 Overview\n          Our approach to topology change relies on existing, well understood computations as components: collision detection, static intersection identification, and triangulation. Perhaps the only exception is a formulation of graph partitioning specialized to serve as a form of error correction. We string these components together in order to compute a parity field over the mesh, recording the parity of the number of times that point collided with the surface during the given motion. This field determines whether the surface should be deleted (odd parity) or preserved (even parity). Throughout this process we store an approximation to this (conceptually) continuous field by sampling its value at mesh vertices.  As input for our algorithm, we require a triangle mesh at the initial time/frame and a linear displacement of vertices transporting the mesh to its position at the final time/frame. We begin ( figure 5 ) by running collision detection to compute a raw parity field. If we only worked with solid surfaces, this raw field would suffice, but because we expect our mesh to exhibit aberrations or other shortcomings we treat the raw parity field as if it has some (relatively) small number of corrupted entries. To correct these errors and produce a more desirable parity field, we perform an error correction step informed by the mesh?s self-intersections at the final frame?s position. With the corrected parity field in hand, we can then subdivide the mesh, glue the mesh, and delete the appropriate triangles. This results in our final output mesh with suitably altered topology.\n          OUTPUT\n          &\n          \n            \n          \n        \n        \n          3.2 Collision Detection\n          Our method for topology change relies on knowing the parity of the number of collisions each vertex makes with the rest of the surface. In order to tabulate the number of collisions, we must first run continuous collision detection for every vertex of the mesh. For every vertex of the mesh and every triangle not containing that vertex, we compute the roots of the usual cubic equation (Appendix A) and the associated barycentric coordinates, and we use them to determine whether any collisions occurred. We arrive at the desired collision parity value by accumulating the results of this computation for each vertex across all potentially intersecting triangles. In order to accelerate this computation so that less than quadratically many collisions must be tested, we use an acceleration structure, namely an axis-aligned bounding volume hierarchy. We build this AABVH over the line segments traced out by the moving vertices. We then stream the triangles over this structure to identify potential collisions. Rather than attempt to maintain this acceleration structure between frames, we use a fast, median-split, top-down, divide-and-conquer build inspired by work on real-time ray tracing [Wald 2007]. At each node, a dimension (x, y, or z) is selected and the geometry is rearranged via a quick select search for the median. The build then recurses on the two halves. The resulting build algorithm takes time comparable to a quick sort of the geometry and consumes a small fraction (10%) of the total time spent performing collision detection. Since no heuristics are used to ensure a quality acceleration structure, and since we don?t make use of narrow-phase collision culling techniques, we expect that the overall cost of collision detection could be significantly improved by just applying existing methods [Teschner et al. 2005]. Nonetheless, this simple strategy suffices to demonstrate our prototype. Besides speed, correctness is frequently a problem with collision detection algorithms. When used in applications like cloth simulation, accurate collision detection becomes critical to keep surfaces from snagging on themselves. However, implementing truly robust collisions is a difficult problem. Standard robustness methods (?3.3) are restricted to handling rational arithmetic, but collision detection requires cubic root finding. Brochu et al. [2012] recently gave a very clever solution to this problem, formulating collision detection as a series of predicates relying solely on rational arithmetic. Here we only need an approximation to the parity field that we compute from collision detection. Since we already intend to run an ?error correction? step to tolerate mesh aberrations, we can likewise tolerate the small number of errors in the parity field which result from imprecise collision detection. Unless we are presented  with a highly degenerate motion (e.g. the collision of two perfectly aligned grids) these numeric errors are rare. To help ensure that they remain rare, we apply a slight perturbation (similar to perturbations for the intersection computation in the following section). We observed that in the case of two aligned grids, adding a perturbation eliminated 100% of the numeric errors.\n          ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n          Holey Geometry: Topology Change for Arbitrary Surfaces\n          ?\n          34:5\n          \n            Figure 6: When surfaces have holes (inset, initial) the raw parity field can be corrupted (raw parity, inset). Running error correction removes these isolated errors.\n            \n          \n        \n        \n          3.3 Static Intersections\n          Once the mesh has reached its final position at the end of a frame of movement, we determine the region where the final mesh statically intersects itself. We find these static intersection curves for two reasons: First, this information is used to guide the error correction procedure. Secondly, the intersection curves are used to cleanly segment the mesh into preserved and deleted portions. We find the intersection curves in three steps. First, we identify all edge-triangle intersection points present. Second, we infer the set of all intersection edges from these points. Finally, we identify any points formed by the intersection of three triangles. To efficiently find edge-triangle intersections, we use a second AABVH, like the one computed for collision detection, this time built over the edges of the mesh. Triangles are streamed over this structure and tested for intersection with the edges they encounter. For each intersecting edge-triangle pair (e, t), we collect the set of triangles t i with e as an edge. Then, emanating from the point where e and t intersect, there must be exactly one intersection edge on t for each triangle t i , which is uniquely identified by the pair {t, t i }. We accumulate all such pairs identified via this combinatorial generation procedure and eliminate duplicates to form a set of triangle-triangle intersection edges. To complete the intersection computation, we identify triples of triangles {t 1 , t 2 , t 3 } such that {t 1 , t 2 }, {t 1 , t 3 }, and {t 2 , t 3 } are all intersection edges. Each triple is tested to see whether the three triangles intersect in a point. Triangle-triangle-triangle intersection candidates are rare, so this step takes a negligible amount of time.  Geometric robustness Unfortunately, unlike collisions, we rely on robustly computed intersections. This is because our intersection curves are used as input to a triangle subdivision algorithm. If these curves reveal any inconsistencies, then the subdivision algorithm could segmentation fault or produce non-sensical output. To ensure consistent results from our intersection computation at a reasonable overhead, we use a variety of techniques from robust geometric computation. First, we use floating point filters [Shewchuk 1997] to efficiently decide the results of most intersection predicates. When these filters fail, we fallback to exact big number arithmetic, ensuring that all predicates are correctly computed. (The actual coordinates of intersection are always computed to machine precision in big number arithmetic.) However, degenerate cases may still occur (e.g. when testing a potential edge-triangle intersection, the edge being tested might pass exactly through an edge of the triangle being tested). Because degenerate cases are measure-zero events, by definition they can be eliminated through perturbation of the geometry [Seidel 1994]. While symbolic perturbation [Edelsbrunner and M?cke 1990] is one popular way to achieve this end, we instead rely on explicit numeric perturbation of coordinates on a scale well beneath the smallest resolution of triangle edges in use. (We perturb on the order of 10 ?5 units in our prototype code.) If any degeneracies are detected during the computation of intersections, we abort the computation, perturb all geometry and try again. On our test cases with highly degenerate geometry, this strategy sufficed to eliminate degeneracies after a single perturbation. As with acceleration structures, we chose this strategy for expedient implementation, not because we advocate the choice as the best option for production code.\n          \n            \n            \n            \n          \n          corrected parity scalar field corrected parity result\n          \n            Figure 7: Majority voting works poorly when intersection curves don?t separate the surface. Graph partitioning allows us to introduce new cuts into the mesh.\n          \n        \n        \n          3.4 Error Correction\n          ?Errors? of various sorts and sources may result in collision detection producing a corrupted parity field. Some of these errors may be due to numeric inaccuracies (?3.2) while others may be due to aberrations (e.g. holes) in the mesh itself. We view the process of computing a more appropriate parity field as a form of error correction. In this section we will propose two such error correction schemes, ultimately discarding the first in favor of the second. One strategy is suppressing outliers in the parity field through majority voting. We split them surface into connected components using the static intersection curves (computed at the mesh?s final position) and vote within each component independently. Concretely, we take the vertex-edge graph given by the triangle mesh and remove all edges which are cut by some intersection curve. The connected components of the resulting graph form the connected components of the surface. Within each component, a vertex gets one vote with weight proportional to the area of the surface that it represents. Whichever parity (even or odd) gets more votes is assigned to all vertices in the component. Majority voting works well when the intersection curves neatly partition the surface into primarily odd or even components. However, when the user manipulates an open surface near its boundary (Figure 7), the resulting intersections rarely partition the surface nicely. To address this shortcoming, we propose a second error correction scheme based on graph partioning. Graph partitioning algorithms label the vertices of a graph with one of two possible labels, splitting the graph. In image segmentation, labels such as foreground/background are used; here we compute even/odd parity labels. The desired labeling is found by solving an optimization problem with both a binary ?smoothness? term (minimizing the size of the cut between the two regions) and a unary ?accuracy? term. (deviation from the raw parity field) Vision researchers have ex plored a range of different formulations and algorithms for graph partitioning [Boykov et al. 2001; Grady and Schwartz 2006]. Following previous examples, we can formulate our graph partitioning problem as follows:\n          ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n          34:6\n          ?\n          G. Bernstein et al.\n          \n            3.1\n            min w ij (x i ? x j ) 2 + ? w i (x i ? r i ) 2 x (i,j)?E o i?V\n          \n          (Here and for the remainder of this section, we let r i denote the value of the raw parity field at vertex i, and x i denote the continuous error corrected value which we solve for. r i = 1 if the vertex is marked even and r i = ?1 if it is marked odd. E o denotes only those edges of the triangle mesh which are not already cut by an intersection edge. Edge and vertex weights (w ij , w i ) are explained at the end of this section.) The energy in equation 3.1 can be optimized by solving a linear system and rounding all x i > 0 to 1; x i < 0 to ?1. Alternatively, the energy can be optimized using a min-cut algorithm [Boykov et al. 2001]. We tried both approaches. In the above formulation, the value of ? is critical. On the one hand, we want to ensure that the solution boundary between the even and odd portions of the surface is smooth (low ?). However, when ? is set too low, accuracy will be ignored. When we played with trying to tweak this balance between the binary and unary terms, we were unable to find a happy medium. Every setting would break some test case. Further complications arose when we tried to apply the min-cut algorithm. Although we were able to get reasonable results on most test cases, ignoring edges cut by intersections led to failed cases. In the following, we will see how both prying apart values near the intersections (eq. 3.2) and penalizing unused intersections (eq. 3.3) helps to coerce more desirable behavior. To get around these problems we take a cue from isoperimetric graph partitioning [Grady and Schwartz 2006] and use a two-stage partitioning algorithm. In the first stage, we compute a continuous relaxation of the graph partitioning problem using an energy which prioritizes smoothness. The resulting field encodes a constrained set of possible cuts in the form of its isocontours. By focusing on the smoothness term at this stage, we can limit our search for a cut to only smooth candidates. In the second stage, we select one of these isocontours by choosing how to round the continuous solution into a discrete one. By re-introducing a stronger accuracy term only after we reach this second stage, we ensure a reasonable degree of accuracy while simultaneously guaranteeing smoothness. In stage 1, we minimize the following quadratic energy within each connected-component:\n        \n        \n          3.5 Subdivision, Gluing, and Deletion ? x j ) + ? x j ? (r i ? r )) (3.2) + ? (x )\n          \n            3.2\n            (i,j)?E o w ij (x i 2 (i,j)?E c w ij (x i j 2 i?V i ? r i 2\n          \n          (Appendix B explains how this problem is solved in more detail.) Unfortunately, since we make ? small (= 10 ?3 ) the solved values x will be unreliably small. To avoid this problem, we introduce a few extra binary terms. Each new binary term is associated with an edge (i, j) ? E c which is cut by some intersection curve. The extra terms pry apart the values of x on opposite sides of the intersection curve, using the observed difference in the raw parity field. Aside from our dependence on Unfortunately, this heuristic term is necessarily asymmetric, allowing it to be compromised when there are a sizable number of raw parity errors near the intersection curves. This did not turn out to be a significant problem in our test cases. In stage 2, we sort the vertices by their x values and perform a sweep cut to determine the rounding threshold x 0 . Each vertex with  x i < x 0 will be rounded down to ?1 (odd) and otherwise will be rounded up to 1 (even). We begin with x 0 below all x i and ?sweep? upwards until x 0 is greater than all x i . We select whichever x 0 minimizes the cut energy: ? i?V w i 1[r i = y i ] 2 (i, j) ? E c and y i = y j or + (i,j)?E w ij 1 (i, j) ? E o and y i = y j (3.3) (where y i is the rounded value of x i and 1[?] is an indicator function.) Note that we penalize both newly introduced boundary (i, j) ? E o , as well as unused intersections (i, j) ? E c . In order to balance these two terms, we use ? = 2? (half the isoperimetric constant) and square the boundary length term. This results in a geometrically nice, scale-free energy. Edge and vertex weights Edge weights w ij and vertex weights w i should be set to suitably encode the geometry of the mesh. Summing all of the edge weights between the even and odd parity vertices should approximate the length of that perimeter curve, while summing the vertex weights should approximate surface area. To accomplish this, we use the following scheme: Conceptually, we can think of each triangle as being divided into 3 quadrilaterals by edges which connect the midpoint of each edge to the barycenter of the triangle. Then, the area of this each quadrilateral can be added to each vertex weight, while the length of the midpoint-barycenter line segment can be added to the appropriate edge weight. Once we have successfully computed intersection curves and a corrected parity field, we have all the data necessary to actually change the topology of the surface. We complete this change in four steps: 1. Decide which curves to resolve. When beginning this step, we have all of the intersection curves already detected. We will discard some of these curves, and add in new curves with the goal of producing a set of curves to separate the even parity portion of the surface from the odd parity portion of the surface. First, we group the intersection curves into connected components. Any connected component of intersections which is adjacent to only even or only odd parity regions is removed from consideration (i.e. it will be left un-subdivided). Next, we identify all edges of the triangle mesh (not intersection edges) which both separate even and odd parity vertices, but are not themselves crossed by an intersection curve. ?Intersection? vertices are inserted midway along each of these edges. Then, we examine all triangles untouched by an intersection curve, but with both even and odd parity vertices. Each such triangle will have false ?intersection? vertices inserted along exactly two edges. We then introduce a false ?intersection? edge connecting these vertices. (Note that the resulting false intersection curves will terminate just before entering a triangle containing an actual intersection curve. This produces slight gaps in the curve separating even and odd parity. Closing these gaps explicitly involves more complex geometric reasoning. Instead, we will fix up this minor shortcoming with a post-process after subdividing.) 2. Subdivide the mesh. We solve a constrained triangulation problem on a triangle-by-triangle basis. We accumulate all of the points and edges of intersection lying on each triangle and run Shewchuk?s Triangle[1996] to produce a constrained triangulation. 3. Glue vertices and edges. Except for the false intersection curves inserted during step 1, intersections necessarily lie on two different parts of the surface. Therefore we must glue together the duplicate curves by replacing duplicated vertices and edges with unique vertices and edges. In effect, this step connects the surfaces along those intersections we did not discard in step 1. 4. Delete triangles with odd parity. Finally, we are back to a normal mesh without intersection curves. We must now propagate the parity field onto the triangles and delete the odd portions. This occurs in two sub-steps. First, observe that no triangle in the subdivision can have both odd and even parity vertices after subdivision. This is because we inserted some kind of intersection vertex into every edge of the original mesh with opposite parity endpoints. Taking advantage of this observation, we decide the parity of the majority of triangles by simply copying values from the vertices. However, because of both the gaps introduced by step 1 and the potential for complicated intersections happening entirely within a single triangle, there may be some triangles which lack parity. To cover these triangles, we perform a 50 round iterated diffusion. The parity at already decided triangles is held constant, while values are propagated between any two adjacent triangles not separated by an intersection curve. Triangles still undecided at the end of this process are marked with even parity. Finally, the odd parity triangles are deleted.\n          \n            \n            \n            Figure 8: Our method even works on some triangle soups. In this variation on an earlier case, we disconnect all of the triangles in the ground plane and jitter their vertices; same result.\n          \n          ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n          Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces\n          ?\n          34:7\n        \n      \n      \n        4 Integration with Mesh Modeler\n        To demonstrate our method of topology change, we constructed a rudimentary surface deformation modeler (See supplementary material). This modeler is equipped with four brushes: Inflate/Deflate paint to cause instantaneous displacement in the direction of the surface normal Smooth paint to cause instantaneous explicit Laplacian smoothing Grab hold onto part of the surface (with a distance-based falloff in influence) and drag it around Move hold onto an entire connected component of the surface rigidly and drag it around Between every pair of frames we run an edge-based (split/collapse) remeshing algorithm to dynamically adapt mesh resolution. For the inflate and smooth brushes, we incorporate topology change in the obvious manner. Between every pair of frames (before remeshing) we run our algorithm. Doing so produces instantaneous topology change. For the grab and move brushes, user interaction often involves the exploration of different options by dragging through them. If the  user decides against taking the action they were contemplating, returning the mouse to the position at which the drag began effectively cancels the action. To incorporate topology change in this scenario, we take a different approach. While the mouse is depressed, we run collision detection each frame, accumulating new collisions into the running tally kept by the raw parity field. Only when the mouse is released do we execute the full topology change algorithm (using the accumulated raw parity) and commit the result. In order to aid the user, we also compute the corrected parity field every frame and display the result as immediate feedback.\n      \n      \n        5 Analysis\n        Collision parity tends to produce similar results compared to methods which require solid meshes. In this sense, we can think of parity as being backwards-compatible?semantically?with prior work. In order to allow for a more formal exploration of this claim, we restrict our attention to the case of solid surfaces, where all methods? behaviors are well defined. Given this restricted setting, we can make the following claims.\n        Theorem 5.1.\n        Theorem 5.2.\n        Proposition 5.3 (informal).\n      \n      \n        Given a solid mesh and a deformation thereof, parity-based topology change will produce a solid mesh. Given two solid meshes undergoing independent rigid motion, parity-based topology change will yield their Boolean union as if computed via CSG. For most common cases, given a deforming solid mesh, parity-based topology change will compute the expected result, given a solid interpretation.\n        In Appendix C, we formalize the final proposition in to a more precise claim, from which the first two claims follow as corollaries. In total, this argument serves to establish a notion of soundness for our method: solid surfaces are handled as expected. In addition to formal arguments, we also measured the time and space usage of our prototype system. The code for this system is being made available under the LGPL. We are able to operate on meshes of up to ? 10, 000 triangles at interactive rates using less than 120MB RAM. The majority of time is spent computing intersections and collision detection, so we expect that the method can be scaled to larger meshes through the use of more aggressive acceleration structures. As a point of comparison, the grid-based method used by Wojtan et al. [2009] can be used for interactive sculpting of solid surfaces with up to ? 40, 000 triangles.\n      \n      \n        6 Applications\n        Mr. potato head modeling ? part assembly ( Figure 9 ) Very easy to use modelers can be built around the idea of assembling a model from existing parts [Chaudhuri et al. 2011; Schmidt and Singh 2010; Hecker et al. 2008]. Such modelers depend on some algorithm to allow users to join various parts together. Methods like the one used in Mesh Mixer [Schmidt and Singh 2010] require that the target surface patch be manifold and disk-like (i.e. simply connected), and that the part/surface being attached has a single loop boundary which can be stitched into this disk. By contrast the method presented here enables the attachment of parts as a side effect when used with our move tool. Unlike the more specialized algorithms, ours is universally applicable, allowing any two surfaces to become attached wherever the user desires. Pinch closing ( Figure 10 ) Many brushes in mesh sculpting programs may cause the surface to become pinched. For instance, painting a crease in the surface with a displacement along normal (?inflate?) brush often causes the surface to pinch. When topology change is added to the system, these pinches are correctly deleted as they close up. This ensures that the surface remains well behaved as successive operations are applied near the crease. Paper mache ( Figure 11 ) While not designed for this purpose, topology change can be used to join two surfaces by slotting one into the other. In conjunction with a Laplacian smoothing brush, surfaces can be joined and smoothed together as if one were paper mache-ing an object. More complex example ( Figure 12 ) This example exhibits models of a cow and two wings consisting of about 25,000 triangles in total. This cow model was purchased by a colleague as part of a mesh set. As provided, the cow model is composed of hundreds of disconnected mesh components, many of which intersect each other. Needless to say, this presents a challenging case for topology change, representative of the issues which arise in practice. Nevertheless, our method is able to successfully join the wing to the cow body.\n        ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n        34:8\n        ?\n        G. Bernstein et al.\n        \n          \n          \n          Figure 9: Using topology change to model-by-parts. The hands are closed, while the feet and nose are open surfaces.\n        \n        \n          \n          Figure 10: Topology change helps clean up undesirable features that arise while sculpting, like pinched surfaces.\n        \n        \n          \n          Figure 11: An improvised use of topology change. By pulling a surface edge around (b) and repeatedly into another surface, (c) the two surfaces become connected. Once connected, the ?smooth? brush with dynamic remeshing can be used (d) to clean up the join, achieving a paper-mache-like process.\n        \n      \n      \n        7 Limitations\n        Formal properties of our method are proven for the continuous setting. However, the discretization of the parity field which we use (sampling only at mesh vertices) can miss important collisions. For instance, when a cylinder is plunged into a single large triangle ( Figure 13 ), no parity samples lie on the triangle, within the cylinder. The result is incorrect topology change. This shortcoming can be eliminated by adaptively refining the mesh in response to collisions. In the particular scenario we give, adding a single vertex to the large triangle (placed inside the cylinder) would result in correct topology change. In order to keep our prototype implementation simpler, we chose not to address this issue. We have shown some examples of our method dealing with multiple disconnected mesh components (Figures 8 and 12). Our method is able to successfully handle some of these cases, but arbitrary triangle soups may still pose a problem because the error correction algorithm in Section 3.4 assumes a connected graph. Our method is designed for general purpose use, not tailored to specific applications. Unfortunately, this choice also leads to unexpected behavior in some more specific contexts. For instance, when assembling models from existing parts, some of those parts will have open boundaries on the side where they are attached. This can lead to the preservation of occluded surface components whose presence the user is unaware of. To take another example, when mimicking a paper mache process, bringing two sheets together will often create tunnels/holes in the process of connecting the two surfaces. A different form of topology change more focused on merging colliding surfaces would probably be more appropriate. Another issue arrises when self-intersecting geometry begins to move. Currently, we do not resolve self-intersections so long as they remain static. However, once the intersecting portion of the surface begins moving, the resulting raw parity field may overwhelm the suppressing effect of error correction and cause holes to open in the mesh as a result. When discussing this system with others, we repeatedly received opinions that our system (or variants of it) produce ?intuitive? or ?unintuitive? behavior. Frequently, we would receive both opinions about the same example. When we restrict ourselves to the case of solid objects, these disagreements disappear, but in non-solid cases disagreement is common. Consequently, we observe that the goal of producing ?intuitive? behavior for a method applicable to arbitrary surfaces is likely to be a fool?s errand. None-the-less we can propose methods for topology change which may be useful to artists and whose idiosyncrasies can be learnt over time. Some of these shortcomings could probably be addressed (at least in particular cases) with specialized hacks. However, from our experience experimenting with error correction schemes, we observed that fixing one problem generates a host of others. In the interest of keeping our approach simple and focused, we chose not to explore complicating fixes. Some of these issues, like those with paper mache-ing, go beyond hacks. In that case, a different kind of topology change with a different behavior might be more appropriate. Consider the behavior of a soap film when two soap bubbles collide at low speed. Rather than annihilate each other, the two colliding surfaces merge into a single interface. Examples like this one suggest that multiple different kinds of topology change behavior are necessary to satisfy users? expectations. One interesting direction for future research is to explore how to organize and categorize different kinds of topology change, working under the premise that there cannot be one universally appropriate behavior.\n        ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n        Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces\n        ?\n        34:9\n        \n          \n          Figure 12: We attach a pair of wings to a cow model (a) composed of many disconnected components, intersecting as shown (b) in red. Nonetheless, we are able to (c) compute topology change. (Inset) Error correction cannot fix completely disconnected components.\n        \n        \n          \n          Figure 13: A failure case of our algorithm.\n        \n        A closed cylinder plunges downward through a single giant triangle (left). Because there are no parity samples on the triangle itself, our algorithm does not properly delete the hole caused by the cylinder. Instead, it causes a non-manifold junction between both models (right).\n      \n      \n        8 Conclusions and Outlook\n        In closing, we have provided a method for computing topological changes on triangle meshes that are not subject to the typical restrictions common among most geometric algorithms. Our method does not require the input meshes to represent solid objects, so it is more widely applicable than most existing algorithms. To further improve the method?s reliability, we provide a novel error correction mechanism that both handles poor-quality meshes and tolerates inaccuracies in collision detection computations. Because our method is error-tolerant and applicable to such a wide range of potential inputs, we believe that it can integrate nicely into geometric modeling applications of the future. The algorithm?s efficiency and simplicity allow topology change to happen naturally with any deformation tool, instead of needing to be explicitly effected through a special tool. As a consequence of this ease of integration, we believe our method has the potential to significantly improve the standard work flow of a geometric modeler. Once a user understands the general idea of a behavior like topology change and how their different tools can be used to deform a surface, they can discover new strategies through exploration and continued use. By way of comparison, sketch-based modeling programs must incorporate special new gesture types, which the user must then learn how to execute in order to  introduce tunnels or handles in an existing surface. These tools are less likely to lead the user to discover serendipitous uses or combinations. We see our method as a way to easily incorporate topology change into a 3d modeler, similar to the way Harmon et al. [2011] incorporate collision detection and response. We suspect that this line of thinking may lead to further innovations in 3d modeling tools. How can we incorporate more behaviors, (e.g. topology change, collision response) natural or otherwise, with compounding effects into our tools? How few tools and behaviors can we use to build a parsimonious, compelling and flexible modeling system?\n      \n      \n        Acknowledgements\n        Most of all we would like to thank Zoran Popovic for his help and guidance with earlier iterations of this research. Thank you to the researchers involved in compiling and maintaining both the Brown Mesh Set and Princeton Shape Benchmark. Thank you also to Siddhartha Chaudhuri for providing the cow model we used. This research was supported via the NSF GRFP DGE-0718124.\n      \n      \n        References\n        \n          3D-C OAT , 2013. 3D-Coat.\n          A TTENE , M., C AMPEN , M., AND K OBBELT , L. 2013. Polygon mesh repairing: An application perspective. ACM Computing Surveys. To appear.\n          A UTODESK , 2013. 3ds Max.\n          A UTODESK , 2013. Maya.\n          A UTODESK , 2013. Mudbox.\n          B OYKOV , Y., V EKSLER , O., AND Z ABIH , R. 2001. Fast approximate energy minimization via graph cuts. IEEE Trans. Pattern Anal. Mach. Intell. 23, 11 (Nov.), 1222?1239.\n          B ROCHU , T., AND B RIDSON , R. 2009. Robust topological operations for dynamic explicit surfaces. SIAM J. Sci. Comput. 31, 4, 2472?2493.\n          B ROCHU , T., E DWARDS , E., AND B RIDSON , R. 2012. Efficient geometrically exact continuous collision detection. ACM Trans. Graph. 31, 4 (July), 96:1?96:7.\n          C AMPEN , M., AND K OBBELT , L. 2010. Exact and robust (self)intersections for polygonal meshes. Computer Graphics Forum 29, 2, 397?406.\n          C HAUDHURI , S., K ALOGERAKIS , E., G UIBAS , L., AND K OLTUN , V. 2011. Probabilistic reasoning for assembly-based 3D modeling. ACM Transactions on Graphics (Proc. SIGGRAPH) 30, 4.\n          E DELSBRUNNER , H., AND M UCKE  ? , E. 1990. Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms. ACM Transactions on Graphics (TOG 9, 1 (Jan).\n          G RADY , L., AND S CHWARTZ , E. L. 2006. Isoperimetric graph partitioning for image segmentation. IEEE Trans. on Pat. Anal. and Mach. Int 28, 469?475.\n          H ARMON , D., P ANOZZO , D., S ORKINE , O., AND Z ORIN , D. 2011. Interference-aware geometric modeling. ACM Trans. Graph. 30 (Dec.), 137:1?137:10.\n          H ECKER , C., R AABE , B., E NSLOW , R. W., D E W EESE , J., M AY NARD , J., AND VAN P ROOIJEN , K. 2008. Real-time motion retargeting to highly varied user-created morphologies. In ACM SIGGRAPH 2008 papers, ACM, New York, NY, USA, SIGGRAPH ?08, 27:1?27:11.\n          I GARASHI , T., M ATSUOKA , S., AND T ANAKA , H. 1999. Teddy: a sketching interface for 3d freeform design. In Proceedings\n        \n        ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n        34:10\n        ?\n        G. Bernstein et al.\n      \n      \n        of the 26th annual conference on Computer graphics and inter-\n        active techniques, ACM Press/Addison-Wesley Publishing Co., New York, NY, USA, SIGGRAPH ?99, 409?416. J U , T. 2009. Fixing geometric errors on polygonal models: a survey. J. Comput. Sci. Technol. 24, 1 (Jan.), 19?29. M C G UIRE , M. 2004. Observations on silhouette sizes. journal of graphics, gpu, and game tools 9, 1, 1?12. M OJANG , 2013. Minecraft. P IXOLOGIC , 2013. Sculptris. P IXOLOGIC , 2013. ZBrush. R EQUICHA , A. A. G. 1977. Mathematical models of rigid solid objects. Tech. Rep. TM-28, Production Automation Project, University of Rochester, Rochester, New York 14627, November. S CHMIDT , R., AND S INGH , K. 2010. meshmixer: an interface for rapid mesh composition. In ACM SIGGRAPH 2010 Talks, ACM, New York, NY, USA, SIGGRAPH ?10, 6:1?6:1. S EIDEL , R. 1994. The nature and meaning of perturbations in geometric computing. In STACS ?94: Proceedings of the 11th\n      \n      \n        Annual Symposium on Theoretical Aspects of Computer Science,\n        Springer-Verlag, London, UK, 3?17. S HEWCHUK , J. R. 1996. Triangle: Engineering a 2d quality mesh generator and delaunay triangulator. In Selected papers from the\n      \n      \n        Workshop on Applied Computational Geormetry, Towards Geo-\n        metric Engineering, Springer-Verlag, London, UK, UK, FCRC ?96/WACG ?96, 203?222. S HEWCHUK , J. R. 1997. Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates. Discrete & Computational Geometry 18, 3 (Oct.), 305?363. S T ANCULESCU  ? , L., C HAINE , R., AND C ANI , M.-P. 2011. Smi 2011: Full paper: Freestyle: Sculpting meshes with self-adaptive topology. Comput. Graph. 35, 3 (June), 614?622.  T ESCHNER , M., H EIDELBERGER , B., M ANOCHA , D., G OVIN DARAJU , N., Z ACHMANN , G., K IMMERLE , S., M EZGER , J., AND F UHRMANN , A. 2005. Collision handling in dynamic simulation environments. In Eurographics 2005: Tutorial Notes. W ALD , I. 2007. On fast construction of sah-based bounding volume hierarchies. In Proceedings of the 2007 IEEE Symposium on Interactive Ray Tracing, IEEE Computer Society, Washington, DC, USA, RT ?07, 33?40. W OJTAN , C., T H UREY  ? , N., G ROSS , M., AND T URK , G. 2009. Deforming meshes that split and merge. In SIGGRAPH ?09: ACM SIGGRAPH 2009 papers, ACM, New York, NY, USA, 1? 10. W OJTAN , C., T H UREY  ? , N., G ROSS , M., AND T URK , G. 2010. Physics-inspired topology changes for thin fluid features. In SIGGRAPH ?10: ACM SIGGRAPH 2010 papers, ACM, New York, NY, USA, 1?8. Z AHARESCU , A., B OYER , E., AND H ORAUD , R. 2011. Topologyadaptive mesh deformation for surface evolution, morphing, and multiview reconstruction. IEEE Transactions on Pattern Analysis and Machine Intelligence 33, 823?837.\n      \n      \n        Appendix A\n        Given a point p and triangle (a, b, c) in motion from p 0 to p 1 and from (a 0 , b 0 , c 0 ) to (a 1 , b 1 , c 1 ), the point collides with the triangle?s plane whenever the triple product  vanishes. This produces a cubic equation in t whose roots are found via interval search. Candidate intersection points are then tested for containment in the triangle and in the time interval (0, 1). Standard floating-point arithmetic is used. Exact methods [Brochu et al. 2012] could be used instead to avoid inaccuracies due to floatingpoint, but are unnecessary due to error correction.\n        [ (1 ? t)(a 0 ? p 0 ) + t(a 1 ? p 1 ) ; (1 ? t)(b 0 ? p 0 ) + t(b 1 ? p 1 ) ; (1 ? t)(c 0 ? p 0 ) + t(c 1 ? p 1 ) ]\n      \n      \n        Appendix B\n        The quadratic energy used during error correction is minimized by solving a linear equation Ax = b using a sparse Cholesky solver. This system can be set up using the following formulas.\n        0, (i, j) is cut with r i = r j A ij = ?w ij , otherwise A ii = ? A ij + ? j=i b i = ?r i + w ij (r i ? r j ) where (i, j)is cut and r i = r j j\n      \n      \n        Appendix C\n        We begin by defining and/or recalling a few concepts related to point in polygon tests. After that, we present a lemma and corollaries. Recall that every solid surface (closed and non-self-intersecting) has a canonical normal field with normals pointing outward(?2.1). In the following, we assume that all solid surfaces are equipped with this canonical normal field. Furthermore, we assume that every surface begins and ends its motion in general position. We make this  assumption here to simplify the analysis. In our code, we use perturbation and exact geometric predicates to treat general positionrelated issues?we do not ignore them. Given a closed surface equipped with a normal field, we define the containment number ?(p) of a point p not on the surface as follows: Select any continuous path starting at p and diverging towards infinity. If this path never crosses the surface, then ?(p) = 0. Otherwise, we may compute ?(p) by the following procedure. Start with ?(p) = 0. Then, trace along the path beginning at p. Every time the path crosses the surface, increment the containment number if we cross the surface in the same direction as the surface normal, and decrement the containment number if we cross in the opposite direction. For closed surfaces the quantity computed by this procedure is invariant to the choice of path. As the surface moves, the containment number at p is preserved so long as the surface does not pass over p. So, as the surface moves, it will adjust the containment number at p only as it passes over p. The rules for this update derive from the above definition. If the surface passes over p traveling in the direction of its surface normal, then the containment number at p is incremented; otherwise it is decremented. In 2d, this containment number is equivalent to the winding number of a curve. Containment numbers can be used to classify the space around a surface into space contained inside the surface (?(p) = 0) and space outside the surface (?(p) = 1). This binary interpretation of containment numbers suffices for solid surfaces; we consider two possible extensions to self-intersecting but closed surfaces: ? The sign interpretation says that a point p is inside if ?(p) > 0 and outside if ?(p) ? 0. ? The modulo interpretation says that a point p is inside if ?(p) ? 1 or 2(mod 4) and inside if ?(p) ? 0 or ?1(mod 4) Of these two interpretations the sign interpretation is probably more natural. However, without arguing their relative merits, we can observe that so long as ?(p) ? {?1, 0, 1, 2}, both interpretations agree. (i.e. so long as the containment number deviates by at most one from the expected values 0 and 1)\n        ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n        Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces\n        ?\n        34:11\n        Lemma 8.1.\n      \n      \n        Given an initially solid surface undergoing deformation, tracking collision parity results in topology change equivalent to the modulo interpretation for containment numbers.\n        Proof sketch. Consider a point p of the surface undergoing deformation, a point p + displaced infinitesimally away from p in the normal direction and a point p ? displaced infinitesimally far away from p in the opposite direction. Before the surface begins to move ?(p + ) = 0 and ?(p ? ) = 1. During movement p collides with other pieces of the surface an even or odd number of times. If p collides an even number of times, then the containment numbers of p + and p ? must both change by the same amount: some multiple of 2, say 2k. So either ?(p + ) ? 0(mod 4) while ?(p ? ) ? 1(mod 4), or ?(p + ) ? 2(mod 4) while ?(p ? ) ? ?1(mod 4). Under the modulo interpretation of containment number, this means that either p + is outside while p ? is inside, or vice-versa. So, under the modulo interpretation we would choose to not delete points p on the surface which collide an even number of times. If p collides an odd number of times, then the containment numbers of p + and p ? must both change by the same amount: 2k + 1. So either ?(p + ) ? 1(mod 4) while ?(p ? ) ? 2(mod 4), or ?(p + ) ? ?1(mod 4) while ?(p ? ) ? 0(mod 4). Under the modulo interpretation of containment number, this means that either p + and p ? are both inside, or they are both outside. In either case, we\n        would choose to delete p since it does not serve to separate inside from outside.\n        The first theorem(?5.1) follows directly from this lemma, since we just demonstrated that parity based topology change can be interpreted as providing an inside/outside classification for closed surfaces.\n        Corollary 8.2 (Theorem 5.2).\n      \n      \n        Given two solid meshes undergoing independent rigid motion, parity-based topology change will yield their Boolean union as if computed via CSG.\n        Proof. Consider two solid meshes undergoing independent rigid motion. When they are done moving every point p of space is either outside of both meshes, inside one of the meshes or inside both. Thus ?(p) ? {0, 1, 2}. Under the modulo interpretation of containment number, we interpret the value 0 as outside and both 1 and 2 as inside. Leveraging lemma 8.1, we know that computing parity-based topology change will yield a solid mesh under the modulo interpretation. Therefore this resulting mesh will represent the Boolean union of the two solid meshes in question.  Finally, to the extent that we are willing to accept the informal proposition (i.e. observation) that ?(p) is often confined to the set of values {?1, 0, 1, 2}, then we observe that computing paritybased topology change for initially solid surfaces often yields the same result as under a sign interpretation of containment numbers.\n        ACM Transactions on Graphics, Vol. 32, No. 4, Article 34, Publication Date: July 2013\n      \n    \n  ",
  "resources" : [ ]
}