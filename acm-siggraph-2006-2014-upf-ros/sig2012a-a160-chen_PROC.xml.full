{
  "uri" : "sig2012a-a160-chen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2012a/a160-chen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Depth-Presorted Triangle Lists",
    "published" : "2012",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ge-Chen",
      "name" : "Ge",
      "surname" : "Chen"
    }, {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Lei-Yang",
      "name" : "Lei",
      "surname" : "Yang"
    }, {
      "uri" : "http://drinventor/Liang-Hu",
      "name" : "Liang",
      "surname" : "Hu"
    } ]
  },
  "bagOfWords" : [ "34ddbaf8dea2f7cdcd33e0c33db8e6c24b412c2ecb822132429ef9fe9a4ceeea", "p2us", "10.1145", "2366145.2366179", "name", "identification", "possible", "depth-presorted", "triangle", "list", "Ge", "Chen", "Pedro", "V.", "Sander", "Diego", "Nehab", "Lei", "Yang", "1,3", "Hong", "Kong", "UST", "IMPA", "Bosch", "Research", "North", "America", "input", "static", "model", "input", "triangle", "off-line", "preprocess", "depth-presorted", "triangle", "list", "-lrb-", "triangle", "half-space", "-rrb-", "Figure", "we", "off-line", "preprocessing", "algorithm", "produce", "depth-presorted", "triangle", "list", "from", "static", "3d", "input", "model", "list", "contain", "copy", "model", "depth-sorted", "relative", "any", "viewpoint", "outside", "its", "bound", "volume", "each", "triangle", "come", "annotated", "half-space", "test", "enable", "fast", "run-time", "algorithm", "select", "exactly", "triangle", "need", "render", "complete", "depth-sorted", "model", "give", "viewpoint", "we", "present", "novel", "approach", "real-time", "rendering", "static", "3d", "model", "front-to-back", "back-to-front", "relative", "any", "viewpoint", "outside", "its", "bound", "volume", "approach", "render", "depth-sorted", "triangle", "use", "single", "draw-call", "run-time", "we", "replace", "traditional", "sorting", "strategy", "exist", "algorithm", "faster", "triangle", "selection", "strategy", "selection", "process", "operate", "extended", "sequence", "triangle", "annotated", "test", "plane", "create", "we", "off-line", "preprocessing", "stage", "base", "test", "plane", "simple", "run-time", "procedure", "use", "give", "viewpoint", "select", "subsequence", "triangle", "rasterization", "select", "subsequence", "statically", "presort", "depth", "contain", "each", "input", "triangle", "exactly", "once", "we", "method", "run", "legacy", "hardware", "render", "depth-sorted", "static", "model", "significantly", "faster", "than", "previous", "approach", "we", "conclude", "demonstrate", "real-time", "rendering", "order-independent", "transparency", "effect", "Links", "dl", "pdf", "introduction", "real-time", "rendering", "application", "employ", "z-buffer", "visibility", "determination", "-lsb-", "Catmull", "1974", "-rsb-", "still", "many", "scenario", "which", "depth-sorting", "necessary", "desirable", "most", "common", "ACM", "Reference", "Format", "Chen", "G.", "Sander", "P.", "Nehab", "D.", "Yang", "L.", "Hu", "L.", "2012", "depth-presorted", "triangle", "list", "ACM", "Trans", "graph", "31", "Article", "160", "-lrb-", "November", "2012", "-rrb-", "page", "dous", "10.1145", "2366145.2366179", "http://doi.acm.org/10.1145/2366145.2366179", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "fus", "rst", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "permissions@acm.org", "2012", "ACM", "0730-0301/2012", "11-art160", "15.00", "DOI", "10.1145", "2366145.2366179", "http://doi.acm.org/10.1145/2366145.2366179", "Liang", "Hu", "Google", "Inc.", "real-time", "depth-sorted", "run-time", "selection", "order-independent", "transparency", "translucency", "since", "composit", "operation", "commutative", "-lsb-", "Porter", "Duff", "1984", "-rsb-", "blend", "must", "happen", "depth-sorted", "order", "we", "discuss", "section", "large", "number", "technique", "have", "be", "propose", "perform", "real-time", "depth", "sorting", "work", "we", "present", "technique", "possess", "unique", "combination", "desirable", "property", "can", "implement", "standard", "graphic", "pipeline", "require", "single", "render", "pass", "use", "fixed", "amount", "memory", "produce", "exact", "result", "very", "simple", "integrate", "exist", "render", "engine", "extremely", "efficient", "advantage", "come", "certain", "limitation", "whereas", "most", "previous", "depth-sorting", "algorithm", "work", "seamlessly", "deformable", "geometry", "run-time", "we", "method", "assume", "static", "geometry", "view", "from", "outside", "model?s", "bound", "volume", "finally", "we", "preprocessing", "stage", "can", "take", "hour", "complete", "when", "run", "larger", "model", "result", "data-structure", "consume", "more", "memory", "than", "input", "we", "target", "performance-critical", "application", "must", "render", "number", "moderately", "complex", "static", "object", "translucency", "effect", "computer", "game", "scenario", "which", "we", "demonstrate", "result", "section", "relative", "order", "between", "object", "determine", "CPU", "we", "method", "ensure", "correct", "triangle", "order", "within", "each", "object", "during", "game", "development", "instant", "feedback", "can", "provide", "artist", "use", "earlier", "less", "efficient", "method", "end", "release", "cycle", "require", "model", "can", "preprocessed", "engine", "set", "up", "take", "advantage", "simplicity", "we", "run-time", "component", "large", "performance", "gain", "ensue", "since", "only", "transparent", "component", "object", "translucency", "effect", "must", "preprocess", "increase", "run-time", "memory", "significant", "limitation", "either", "we", "key", "insight", "space", "different", "triangle", "order", "result", "from", "depth-sort", "triangle", "model", "under", "each", "possible", "viewpoint", "constitute", "tiny", "fraction", "all", "triangle", "permutation", "moreover", "space", "depth-sorted", "order", "extremely", "redundant", "sense", "few", "modification", "same", "order", "valid", "large", "portion", "viewpoint", "space", "we", "explore", "insight", "following", "way", "during", "preprocessing", "stage", "we", "create", "extended", "sequence", "triangle", "-lrb-", "i.e.", "list", "contain", "one", "more", "instance", "each", "input", "triangle", "-rrb-", "construction", "extended", "sequence", "view-dependent", "subsequence", "triangle", "depth-sorted", "relative", "each", "every", "viewpoint", "outside", "bound", "volume", "view-dependent", "subsequence", "guarantee", "include", "each", "input", "triangle", "exactly", "once", "within", "extended", "sequence", "each", "triangle", "pair", "half-space", "entire", "extended", "sequence", "send", "render", "GPU", "which", "point", "extremely", "simple", "efficient", "run-time", "procedure", "select", "those", "triangle", "which", "associate", "half-space", "contain", "viewpoint", "result", "depth-sorted", "rendering", "original", "input", "triangle", "relative", "viewpoint", "since", "run-time", "sorting", "only", "trivial", "run-time", "selection", "procedure", "we", "method", "run", "order", "magnitude", "faster", "than", "previous", "approach", "selection", "happen", "single", "render", "pass", "can", "implement", "any", "stage", "render", "pipeline", "-lrb-", "vertex", "geometry", "fragment", "shader", "-rrb-", "finally", "CPU", "intervention", "result", "guarantee", "exact", "summary", "we", "contribution", "include", "fastest", "single-draw-call", "exact", "real-time", "depth-sorted", "rendering", "algorithm", "static", "model", "preprocessing", "algorithm", "create", "compact", "extended", "sequence", "triangle", "associate", "half-space", "contain", "depth-sorted", "subsequence", "relative", "all", "viewpoint", "three", "version", "run-time", "algorithm", "select", "subsequence", "associate", "give", "viewpoint", "all", "lead", "state-of-the-art", "run-time", "performance", "rest", "paper", "organize", "follow", "section", "we", "position", "we", "method", "context", "previous", "work", "section", "present", "two", "simple", "example", "helpful", "understand", "preprocess", "algorithm", "which", "describe", "section", "run-time", "selection", "algorithm", "present", "section", "section", "provide", "relevant", "statistics", "specific", "we", "method", "well", "performance", "comparison", "against", "previous", "approach", "we", "conclude", "revisit", "strength", "weakness", "method", "suggest", "venue", "future", "work", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "160:2", "G.", "Chen", "et", "al.", "related", "work", "problem", "depth-sorting", "tightly", "connect", "problem", "visibility", "which", "vast", "amount", "prior", "work", "here", "we", "focus", "method", "we", "believe", "most", "related", "ours", "note", "many", "depth-sorting", "method", "can", "use", "render", "dynamic", "-lrb-", "even", "self-intersecting", "-rrb-", "geometry", "naturally", "when", "compare", "they", "against", "we", "approach", "we", "assume", "target", "application", "do", "require", "functionality", "most", "well-known", "approach", "render", "depth-sorted", "static", "geometry", "BSP", "tree", "-lsb-", "Fuchs", "et", "al.", "1980", "Paterson", "Yao", "1989", "-rsb-", "each", "node", "BSP", "tree", "include", "half-space", "test", "root", "node", "represent", "entirety", "space", "each", "subtree", "represent", "fraction", "parent?s", "space", "reside", "one", "two", "halfspace", "BSP", "tree", "create", "during", "preprocessing", "stage", "much", "like", "we", "extended", "triangle", "list", "render", "from", "bsp", "tree", "traverse", "recursively", "run-time", "back-to-front", "rendering", "when", "visit", "node", "subtree", "represent", "half-space", "contain", "viewpoint", "visit", "last", "we", "method", "half-space", "instead", "use", "separate", "viewpoint", "which", "give", "individual", "triangle", "instance", "must", "draw", "from", "those", "which", "must", "ignore", "other", "than", "BSP", "additional", "data-structure", "use", "depth", "sort", "include", "direct", "acyclic", "graph", "-lsb-", "Williams", "1992", "-rsb-", "feudal", "priority", "tree", "-lsb-", "Chen", "Wang", "1996", "-rsb-", "Voronoi", "diagram", "-lsb-", "fukushige", "Suzuki", "2006", "-rsb-", "contrast", "we", "extend", "list", "flat", "data-structure", "potentially", "include", "multiple", "copy", "each", "triangle", "each", "which", "select", "viewpoint", "we", "method", "therefore", "better", "suit", "modern", "gpus", "where", "recursiveness", "pointer", "manipulation", "difficult", "otherwise", "inefficient", "accomplish", "early", "cpu-based", "approach", "also", "generate", "flat", "semi-flat", "datastructure", "Newell", "et", "al.", "-lsb-", "1972", "-rsb-", "Goad", "-lsb-", "1982", "-rsb-", "both", "describe", "automatic", "procedure", "sort", "triangle", "priority", "order", "give", "viewpoint", "Schumacker", "et", "al.", "-lsb-", "1969", "-rsb-", "propose", "method", "separate", "scene", "convex", "cluster", "during", "preprocessing", "face", "each", "cluster", "can", "assign", "fix", "order", "which", "after", "back-face", "culling", "provide", "correct", "visibility", "from", "any", "viewpoint", "cluster", "must", "mutually", "separable", "plane", "order", "display", "cluster", "compute", "run-time", "we", "method", "leverage", "GPU", "hardware", "order", "render", "model", "use", "single", "draw", "call", "without", "require", "order", "computation", "run-time", "most", "general", "technique", "operate", "pixel", "level", "typical", "strategy", "generate", "per-pixel", "fragment", "list", "sort", "each", "list", "a-buffer", "-lsb-", "Carpenter", "1984", "-rsb-", "challenging", "since", "way", "guess", "total", "number", "fragment", "storage", "need", "number", "fragment", "need", "per", "pixel", "New", "hardware", "capability", "have", "recently", "enable", "use", "dynamic", "link", "list", "collect", "fragment", "blend", "they", "order", "-lsb-", "Yang", "et", "al.", "2010", "-rsb-", "instead", "count", "number", "fragment", "first", "rasterization", "pass", "store", "they", "individual", "array", "during", "second", "pass", "-lsb-", "dx10", "SDK", "2010", "-rsb-", "before", "composit", "they", "parallel", "-lsb-", "patney", "et", "al.", "2010", "-rsb-", "we", "method", "require", "single", "pass", "use", "constant", "memory", "significantly", "faster", "particularly", "when", "multiple", "sample", "per", "pixel", "use", "anti-aliasing", "-lrb-", "e.g.", "msaa", "-rrb-", "many", "modification", "render", "pipeline", "have", "be", "propose", "support", "variation", "a-buffer", "include", "rbuffer", "-lsb-", "wittenbrink", "2001", "-rsb-", "f-buffer", "-lsb-", "Mark", "Proudfoot", "2001", "-rsb-", "Delay", "Streams", "-lsb-", "Aila", "et", "al.", "2003", "-rsb-", "freepipe", "architecture", "-lsb-", "Liu", "et", "al.", "2010", "-rsb-", "we", "method", "run", "standard", "render", "pipeline", "another", "alternative", "render", "scene", "many", "time", "require", "maximum", "depth", "complexity", "each", "pass", "z-buffer", "use", "select", "next", "closest", "fragment", "-lsb-", "mamman", "1989", "Everitt", "2001", "Thibieroz", "2008", "-rsb-", "-lrb-", "much", "like", "selection", "sort", "-rrb-", "performance", "reason", "variation", "idea", "split", "scene", "piece", "presorted", "-lsb-", "Wexler", "et", "al.", "2005", "-rsb-", "peel", "multiple", "layer", "per", "pass", "-lsb-", "Liu", "et", "al.", "2006", "Bavoil", "Myers", "2008", "-rsb-", "exploit", "any", "order", "structure", "may", "already", "present", "-lsb-", "Carr", "et", "al.", "2008", "-rsb-", "algorithm", "exact", "amount", "memory", "need", "fix", "we", "method", "simpler", "depend", "depth-complexity", "significantly", "faster", "many", "method", "rely", "approximation", "performance", "reason", "common", "approach", "limit", "maximum", "number", "fragment", "per", "pixel", "-lsb-", "Jouppi", "Chang", "1999", "Myers", "Bavoil", "2007a", "Bavoil", "et", "al.", "2007", "Liu", "et", "al.", "2009", "Huang", "et", "al.", "2010", "Salvi", "et", "al.", "2011", "-rsb-", "which", "case", "some", "heuristic", "must", "use", "merge", "evict", "overflow", "fragment", "case", "order-independent", "transparency", "ignore", "order", "sometimes", "acceptable", "-lsb-", "meshkin", "2007", "Bavoil", "Myers", "2008", "-rsb-", "another", "method", "avoid", "need", "sorting", "stochastic", "transparency", "-lsb-", "Enderton", "et", "al.", "2010", "Laine", "Karras", "2011", "-rsb-", "refreshing", "new", "take", "screen-door", "transparency", "-lsb-", "Foley", "et", "al.", "1990", "Mulder", "et", "al.", "1998", "-rsb-", "we", "method", "always", "produce", "noisefree", "rendering", "significantly", "faster", "some", "approximation", "work", "particularly", "well", "hair", "volumetric", "datum", "both", "-lsb-", "Kim", "Neumann", "2001", "Callahan", "et", "al.", "2005", "Yuksel", "Keyser", "2008", "Sintorn", "Assarsson", "2008", "2009", "Jansen", "Bavoil", "2010", "Salvi", "et", "al.", "2011", "-rsb-", "we", "method", "suitable", "high", "depth-complexity", "finally", "context", "overdraw", "reduction", "some", "static", "order", "may", "succeed", "eliminate", "most", "overdraw", "-lsb-", "Nehab", "et", "al.", "2006", "Sander", "et", "al.", "2007", "-rsb-", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "Depth-Presorted", "Triangle", "Lists", "160:3", "figure", "simple", "2d", "example", "-lrb-", "left", "-rrb-", "after", "duplicate", "triangle", "-lrb-", "right", "-rrb-", "result", "occlusion", "graph", "-lrb-", "bottom", "-rrb-", "motivate", "example", "we", "begin", "present", "two", "simple", "example", "motivate", "we", "strategy", "build", "depth-presorted", "triangle", "list", "simplicity", "we", "show", "both", "example", "2d", "-lrb-", "see", "figure", "-rrb-", "triangle", "represent", "line", "segment", "arrow", "next", "each", "triangle", "represent", "normal", "direction", "3.1", "view-independent", "depth-presorted", "model", "consider", "non-convex", "model", "figure", "-lrb-", "top", "left", "-rrb-", "we", "show", "possible", "produce", "depth-sorted", "rendering", "model", "-lrb-", "include", "back-facing", "triangle", "-rrb-", "from", "any", "viewpoint", "use", "fix", "triangle", "order", "first", "sight", "seem", "difficult", "give", "occlusion", "relationship", "between", "two", "triangle", "may", "reverse", "when", "viewpoint", "change", "-lrb-", "i.e.", "when", "view", "from", "above", "occlude", "while", "when", "view", "from", "below", "occlude", "-rrb-", "trick", "duplicate", "each", "triangle", "include", "additional", "instance", "opposite", "orientation", "augmented", "model", "newly", "instance", "back-facing", "triangle", "blue", "show", "figure", "-lrb-", "top", "right", "-rrb-", "although", "now", "twice", "many", "triangle", "original", "model", "back-face", "culling", "ensure", "hardware", "rasterize", "most", "one", "instance", "each", "triangle", "additional", "freedom", "award", "duplication", "allow", "we", "create", "triangle", "order", "we", "seek", "case", "figure", "-lrb-", "back-face", "culling", "-rrb-", "triangle", "never", "occlude", "other", "triangle", "since", "triangle", "half-space", "behind", "each", "they", "safe", "place", "they", "end", "list", "same", "token", "cde", "never", "occlude", "any", "triangle", "can", "add", "front", "list", "all", "remain", "place", "remain", "triangle", "AA", "BB", "between", "CDE", "-lrb-", "some", "appropriate", "relative", "order", "-rrb-", "triangle", "have", "more", "complex", "occlusion", "relationship", "specifically", "may", "occlude", "may", "occlude", "a.", "thus", "we", "need", "find", "order", "front", "front", "a.", "multiple", "order", "exist", "particular", "follow", "order", "satisfy", "all", "requirement", "cdea", "abc", "when", "process", "list", "10", "triangle", "order", "from", "any", "viewpoint", "back-face", "culling", "select", "exactly", "triangle", "render", "model", "sort", "depth", "solve", "general", "case", "automatically", "we", "first", "construct", "graph", "capture", "all", "occlusion", "relationship", "occlusion", "graph", "show", "figure", "-lrb-", "bottom", "-rrb-", "each", "node", "represent", "triangle", "edge", "connect", "triangle", "triangle", "only", "viewpoint", "which", "triangle", "occlude", "triangle", "we", "seek", "topological", "sort", "occlusion", "graph", "i.e.", "order", "which", "back-edges", "-lsb-", "skiena", "2008", "-rsb-", "order", "whenever", "direct", "graph", "acyclic", "-lrb-", "i.e.", "dag", "-rrb-", "case", "occlusion", "graph", "figure", "surprisingly", "possible", "construct", "order", "describe", "above", "many", "simple", "object", "Figure", "simple", "example", "cycle", "-lrb-", "left", "-rrb-", "result", "duplicate", "triangle", "use", "cut", "plane", "-lrb-", "right", "-rrb-", "3.2", "model", "require", "view-dependent", "selection", "unfortunately", "general", "case", "may", "cycle", "occlusion", "graph", "even", "back-face", "culling", "so", "topological", "sort", "can", "find", "simplest", "case", "show", "figure", "-lrb-", "left", "-rrb-", "corresponding", "occlusion", "graph", "contain", "cycle", "show", "underneath", "-lrb-", "we", "have", "omit", "back-facing", "triangle", "from", "graph", "isolate", "single", "cycle", "-rrb-", "key", "observation", "can", "only", "occlude", "viewpoint", "inside", "yellow", "region", "can", "only", "occlude", "viewpoint", "gray", "region", "furthermore", "region", "can", "separate", "cut", "plane", "-lrb-", "red", "dashed-line", "-rrb-", "thus", "we", "can", "solve", "cycle", "problem", "create", "extra", "copy", "show", "figure", "-lrb-", "bottom", "right", "-rrb-", "use", "cut", "plane", "select", "copy", "render", "depend", "which", "side", "current", "viewpoint", "lie", "culling", "operation", "which", "addition", "back-face", "culling", "can", "perform", "very", "efficiently", "run-time", "-lrb-", "see", "section", "-rrb-", "preprocess", "algorithm", "section", "we", "describe", "algorithm", "automatically", "generate", "depth-presorted", "triangle", "list", "arbitrary", "input", "model", "while", "description", "we", "assume", "back-to-front", "order", "desire", "algorithm", "can", "trivially", "adjust", "create", "front-to-back", "order", "since", "we", "method", "focus", "static", "model", "we", "assume", "intersect", "triangle", "have", "be", "split", "prior", "invocation", "we", "preprocess", "algorithm", "so", "input", "list", "contain", "intersect", "triangle", "moreover", "we", "assume", "way", "depth-sort", "triangle", "from", "any", "viewpoint", "other", "word", "we", "assume", "single-viewpoint", "visibility", "cycle", "input", "model", "self-intersection", "which", "common", "production", "model", "must", "anyway", "eliminate", "when", "render", "transparency", "additional", "preprocessing", "can", "break", "cycle", "splitting", "triangle", "when", "need", "example", "section", "3.1", "we", "create", "back-facing", "duplicate", "each", "input", "triangle", "order", "relax", "occlusion", "restriction", "we", "compute", "occlusion", "graph", "generate", "preliminary", "order", "graph", "have", "cycle", "topological", "sort", "completely", "solve", "problem", "-lsb-", "skiena", "2008", "-rsb-", "when", "cycle", "good", "preliminary", "order", "one", "minimize", "number", "back-edge", "find", "optimal", "preliminary", "order", "equivalent", "solve", "minimum", "feedback", "arc-set", "problem", "which", "np-complete", "-lsb-", "karp", "1972", "-rsb-", "fortunately", "correctness", "we", "algorithm", "do", "depend", "optimality", "therefore", "we", "use", "fast", "heuristic", "detail", "section", "4.2", "final", "most", "important", "preprocess", "stage", "deal", "backedge", "preliminary", "order", "do", "so", "we", "scan", "order", "from", "finish", "duplicate", "triangle", "associate", "they", "halfspace", "whenever", "we", "find", "back-edge", "step", "follow", "along", "line", "example", "section", "3.2", "describe", "below", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "160:4", "G.", "Chen", "et", "al.", "4.1", "duplicate", "triangle", "work", "around", "back-edge", "each", "iteration", "we", "process", "graph", "node", "move", "along", "preliminary", "order", "from", "finish", "node", "send", "back-edge", "can", "safely", "ignore", "all", "back-edge", "must", "deal", "example", "guide", "we", "through", "algorithm", "here", "move", "along", "list", "from", "right", "left", "current", "iteration", "reach", "yellow", "node", "back-edge", "-lrb-", "red", "-rrb-", "must", "eliminate", "-lrb-", "edge", "adjacent", "irrelevant", "iteration", "have", "be", "omit", "-rrb-", "remedy", "two", "back-edge", "point", "node", "often", "suffice", "move", "immediately", "before", "work", "whenever", "triangle", "between", "edge", "point", "x.", "unfortunately", "case", "here", "move", "give", "rise", "two", "new", "back-edge", "come", "from", "address", "issue", "we", "proceed", "section", "3.2", "look", "plane", "partition", "viewpoint", "space", "two", "half-space", "plane", "must", "set", "viewpoint", "from", "which", "occlude", "contain", "one", "half-space", "whereas", "set", "viewpoint", "from", "which", "occlude", "contain", "other", "half-space", "algorithm", "find", "plane", "-lrb-", "when", "exist", "-rrb-", "give", "section", "4.1.1", "we", "can", "duplicate", "follow", "we", "annotate", "right", "copy", "half-space", "test", "so", "run-time", "algorithm", "describe", "section", "only", "render", "copy", "viewpoint", "correct", "half-space", "left", "copy", "do", "need", "annotated", "plane", "use", "z-buffering", "depth-test", "less", "ensure", "fragment", "generate", "left", "copy", "shaded", "store", "only", "right", "copy", "skip", "-lrb-", "recall", "back-to-front", "render", "proceeds", "from", "right", "leave", "-rrb-", "fact", "allow", "we", "avoid", "deal", "multiple", "half-space", "test", "most", "practical", "case", "Whenever", "we", "can", "find", "completely", "separate", "viewpoint", "associate", "edge", "from", "those", "associate", "edge", "from", "clear", "we", "can", "move", "next", "offend", "node", "however", "ideal", "cut", "plane", "may", "exist", "thus", "duplicate", "may", "introduce", "graph", "new", "back-edge", "emanate", "from", "subset", "show", "below", "case", "we", "proceed", "next", "iteration", "postpone", "handling", "new", "back-edge", "iteration", "analyze", "node", "from", "which", "emanate", "-lrb-", "example", "-rrb-", "therefore", "possible", "left", "copy", "node", "have", "be", "duplicate", "further", "duplicated", "iteration", "eventually", "process", "we", "note", "earlier", "general", "only", "right", "copy", "assign", "half-space", "test", "z-buffer", "deal", "left", "copy", "therefore", "we", "traverse", "list", "from", "right", "left", "each", "node", "copy", "process", "only", "once", "assign", "most", "one", "plane", "important", "notice", "long", "we", "manage", "separate", "least", "one", "edge", "between", "from", "least", "one", "edge", "between", "we", "have", "make", "progress", "because", "we", "have", "succeed", "reduce", "total", "number", "edge", "must", "consider", "future", "since", "number", "finite", "algorithm", "terminate", "we", "now", "prove", "under", "mild", "assumption", "always", "case", "we", "focus", "three", "node", "graph", "current", "node", "right-most", "node", "which", "send", "back-edge", "right-most", "node", "between", "send", "forward-edge", "we", "further", "assume", "exist", "path", "from", "so", "cycle", "graph", "-lrb-", "otherwise", "we", "could", "simply", "move", "right", "-rrb-", "note", "cycle", "two", "node", "do", "exist", "since", "self-intersecting", "triangle", "viewpoint", "edge", "-lrb-", "-rrb-", "can", "separate", "from", "viewpoint", "edge", "-lrb-", "-rrb-", "we", "duplicate", "usual", "viewpoint", "edge", "-lrb-", "-rrb-", "can", "separate", "from", "those", "edge", "-lrb-", "-rrb-", "we", "duplicate", "instead", "finally", "viewpoint", "edge", "-lrb-", "-rrb-", "can", "separate", "from", "those", "edge", "-lrb-", "-rrb-", "we", "duplicate", "node", "configuration", "show", "below", "least", "one", "separation", "must", "possible", "otherwise", "would", "viewpoint", "from", "which", "entire", "cycle", "visible", "would", "preclude", "existence", "depth-sorted", "triangle", "order", "viewpoint", "contradict", "we", "assumption", "therefore", "complete", "proof", "note", "we", "follow", "strategy", "duplicate", "move", "right", "possible", "may", "have", "other", "back-edge", "require", "further", "duplication", "case", "additional", "plane", "have", "associate", "right", "copy", "b.", "fortunately", "must", "relatively", "rare", "since", "we", "have", "never", "observe", "practice", "4.1.1", "define", "cut", "plane", "let", "we", "begin", "few", "definition", "we", "associate", "occlusion", "region", "i?j", "each", "edge", "from", "node", "node", "define", "set", "viewpoint", "from", "whence", "occludes", "j.", "thus", "from", "viewpoint", "outside", "i?j", "edge", "do", "exist", "similarly", "we", "associate", "each", "node", "-lrb-", "i.e.", "each", "triangle", "instance", "-rrb-", "render", "region", "represent", "set", "viewpoint", "from", "which", "render", "node", "duplicated", "render", "region", "new", "node", "cumulatively", "restricted", "associate", "half-space", "can", "therefore", "become", "rather", "small", "naturally", "outside", "edge", "between", "do", "exist", "either", "therefore", "each", "edge", "relevant", "only", "inside", "reduce", "occlusion", "region", "i?j", "i?j", "definition", "hand", "we", "can", "define", "problem", "find", "appropriate", "cut", "plane", "p.", "let", "current", "node", "be", "analyze", "assume", "have", "back-edge", "point", "set", "node", "well", "forward-edge", "arrive", "from", "distinct", "node", "lie", "between", "we", "want", "duplicate", "place", "new", "copy", "left", "we", "hope", "find", "plane", "partition", "edge", "among", "two", "instance", "back-edge", "go", "new", "-lrb-", "left", "-rrb-", "instance", "forward-edge", "remain", "current", "-lrb-", "right", "-rrb-", "instance", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "Depth-Presorted", "Triangle", "Lists", "160:5", "formally", "ideal", "plane", "separate", "region", "x?b", "b?b", "since", "ideal", "plane", "may", "exist", "we", "greedily", "look", "good", "alternative", "we", "we", "search", "separate", "back-edge", "region", "from", "empty", "forward-edge", "region", "-lrb-", "-rrb-", "-lrb-", "plane", "itself", "do", "job", "-rrb-", "we", "try", "progressively", "add", "forward-edge", "region", "set", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "can", "find", "separate", "plane", "between", "-lrb-", "-rrb-", "otherwise", "we", "set", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "consider", "add", "occlusion", "region", "next", "forward-edge", "when", "we", "do", "consider", "all", "forward-edge", "-lrb-", "order", "efficiency", "-rrb-", "we", "assign", "last", "successful", "separate", "plane", "orig", "-lrb-", "-rrb-", "inal", "move", "edge", "account", "final", "region", "its", "new", "copy", "address", "when", "time", "come", "duplicate", "require", "subset", "although", "we", "can", "conceive", "situation", "where", "possible", "separate", "any", "from", "all", "have", "happen", "any", "we", "test", "case", "show", "section", "4.1", "fact", "always", "possible", "separate", "least", "one", "from", "least", "one", "x?b", "we", "can", "rely", "fall-back", "procedure", "ensure", "termination", "algorithm", "4.1.2", "Computing", "cut", "plane", "section", "we", "detail", "geometric", "operation", "use", "efficiently", "compute", "ultimately", "cut", "plane", "separate", "they", "computation", "involve", "convex-hull", "half-space", "intersection", "linear-programming", "perform", "use", "qhull", "-lsb-", "Barber", "et", "al.", "1996", "-rsb-", "lp_solve", "-lsb-", "berkelaar", "et", "al.", "2004", "-rsb-", "library", "intersection", "viewpoint", "region", "determine", "reduce", "occlusion", "region", "i?j", "amount", "find", "intersection", "between", "three", "convex", "region", "do", "so", "we", "form", "intersection", "between", "all", "half-space", "define", "each", "i?j", "since", "intersection", "often", "empty", "optimization", "avoid", "costly", "half-space", "intersection", "we", "first", "check", "all", "vertex", "either", "outside", "one", "plane", "bound", "i?j", "so", "intersection", "empty", "Union", "viewpoint", "region", "we", "conservatively", "approximate", "-lrb-", "-rrb-", "each", "region", "convex-hull", "note", "do", "compromise", "find", "ideal", "cut", "plane", "since", "any", "plane", "-lrb-", "-rrb-", "separate", "from", "also", "separate", "convex-hull", "-lrb-", "-rrb-", "cut", "plane", "give", "convex-hull", "we", "use", "linear", "programming", "determine", "whether", "intersect", "so", "cut", "plane", "can", "separate", "they", "algorithm", "proceeds", "without", "-lrb-", "-rrb-", "update", "otherwise", "we", "check", "any", "bound", "plane", "two", "region", "suitable", "cut", "plane", "-lrb-", "i.e.", "all", "vertex", "other", "region", "lie", "opposite", "side", "plane", "-rrb-", "do", "produce", "valid", "cut", "plane", "plane", "form", "use", "all", "possible", "combination", "vertex", "from", "one", "region", "edge", "from", "other", "region", "least", "one", "plane", "necessarily", "separate", "two", "convex-hull", "become", "candidate", "plane", "practice", "we", "find", "generate", "single", "depth-presorted", "triangle", "list", "entire", "range", "viewpoint", "require", "far", "too", "many", "triangle", "duplication", "lead", "list", "many", "time", "many", "triangle", "input", "model", "divide", "space", "viewpoint", "small", "number", "partition", "create", "independent", "depth-presorted", "triangle", "list", "each", "partition", "we", "get", "much", "better", "trade-off", "between", "total", "memory", "usage", "run-time", "performance", "-lrb-", "see", "result", "section", "-rrb-", "divide", "space", "view", "point", "partition", "we", "first", "enclose", "model", "bound", "polyhedron", "give", "number", "face", "-lrb-", "we", "have", "experiment", "16", "64", "-rrb-", "each", "partition", "define", "one", "polyhedron", "face", "boundary", "neighbor", "partition", "figure", "limit", "set", "valid", "viewpoint", "lie", "outside", "bound", "polyhedron", "we", "further", "reduce", "number", "constraint", "occlusion", "graph", "preliminary", "order", "which", "preprocess", "algorithm", "operate", "simply", "depth-sorted", "list", "triangle", "relative", "some", "viewpoint", "corresponding", "partition", "only", "further", "modification", "when", "compute", "depth-presorted", "triangle", "list", "each", "partition", "all", "render", "region", "further", "restricted", "corresponding", "partition", "we", "experiment", "different", "orientation", "polyhedron", "obtain", "very", "similar", "result", "depth-presorted", "list", "each", "partition", "can", "compute", "simultaneously", "leverage", "parallelism", "multi-core", "cpus", "list", "concatenate", "index", "buffer", "multiple", "segment", "run-time", "we", "issue", "draw", "call", "render", "segment", "index", "buffer", "correspond", "partition", "contain", "current", "viewpoint", "can", "easily", "accomplish", "specify", "start", "buffer", "index", "total", "number", "triangle", "command", "issue", "draw", "call", "thus", "CPU", "perform", "coarse-level", "viewpoint", "selection", "-lrb-", "which", "trivial", "-rrb-", "GPU", "complete", "fine-level", "triangle", "selection", "describe", "below", "Figure", "viewpoint", "partition", "optimization", "strike", "proper", "balance", "between", "memory", "consumption", "run-time", "performance", "we", "generate", "independent", "depth-presorted", "triangle", "list", "different", "part", "viewpoint", "space", "4.2", "viewpoint-space", "partition", "run-time", "selection", "algorithm", "task", "run-time", "select", "those", "triangle", "from", "depthpresorted", "list", "pass", "half-space", "test", "recall", "each", "triangle", "annotated", "test", "plane", "-lrb-", "4d", "vector", "store", "plane", "equation", "-rrb-", "decide", "whether", "render", "triangle", "from", "viewpoint", "xyz", "we", "use", "single", "dot", "product", "which", "extremely", "efficient", "modern", "gpus", "dot", "-lsb-", "xyz", "-rsb-", "triangle", "associated", "test", "plane", "we", "use", "-lsb-", "-rsb-", "which", "cause", "test", "always", "succeed", "test", "can", "implement", "either", "vertex", "geometry", "fragment", "shader", "programmable", "pipeline", "stage", "although", "each", "alternative", "have", "advantage", "disadvantage", "depend", "application", "render", "configuration", "-lrb-", "see", "section", "-rrb-", "we", "favor", "fragment", "shader", "test", "option", "fragment", "shader", "-lrb-", "f", "-rrb-", "4d", "plane", "vector", "keep", "32-bit", "4-channel", "texture", "index", "triangle", "id", "-lrb-", "although", "practice", "need", "have", "arise", "would", "simple", "encode", "entire", "linked-list", "test-plane", "texture", "-rrb-", "f", "issue", "lookup", "perform", "dot", "product", "since", "one", "dot", "product", "test", "perform", "per", "triangle", "fragment", "method", "may", "suffer", "pixelbound", "scene", "fortunately", "test", "inexpensive", "texture", "access", "coherent", "option", "Vertex", "shader", "-lrb-", "VS", "-rrb-", "4d", "plane", "vector", "send", "vertex", "attribute", "when", "dot", "product", "test", "fail", "v", "move", "vertex", "viewpoint", "position", "so", "get", "cull", "near", "plane", "otherwise", "apply", "standard", "vertex", "transformation", "since", "all", "three", "vertex", "each", "triangle", "perform", "same", "exact", "test", "result", "consistent", "drawback", "approach", "triangle", "can", "longer", "share", "vertex", "which", "may", "impact", "vertex", "bind", "scene", "option", "geometry", "shader", "-lrb-", "g", "-rrb-", "4d", "plane", "vector", "keep", "32-bit", "4-channel", "texture", "index", "triangle", "id", "g", "emit", "only", "triangle", "pass", "dot", "product", "test", "although", "most", "natural", "implementation", "additional", "pipeline", "stage", "can", "impact", "performance", "application", "already", "use", "g", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "160:6", "G.", "Chen", "et", "al.", "-lrb-", "solid", "-rrb-", "partitioning", "60", "ratio", "Fandisk", "Dragon", "Bunny", "-lrb-", "70k", "-rrb-", "-lrb-", "30k", "-rrb-", "-lrb-", "40k", "-rrb-", "45", "-lrb-", "dash", "-rrb-", "size", "feline", "-lrb-", "20k", "-rrb-", "ratio", "call", "30", "draw", "memory", "15", "avgerage", "total", "16", "64", "number", "partition", "Figure", "varying", "number", "segment", "trade-off", "between", "memory", "consumption", "size", "each", "individual", "draw", "call", "result", "section", "we", "discuss", "performance", "memory", "consumption", "we", "approach", "all", "experiment", "be", "conduct", "Intel", "xeon", "2.27", "GHz", "E5520", "CPU", "12gb", "RAM", "AMD", "Radeon", "HD", "6970", "GPU", "we", "use", "model", "resolution", "range", "from", "1,000", "100,000", "triangle", "which", "we", "believe", "representative", "resolution", "depth", "complexity", "most", "static", "model", "find", "game", "all", "rendering", "use", "alpha", "blend", "proper", "semitransparency", "when", "render", "back-to-front", "figure", "runtime", "performance", "result", "figure", "average", "over", "256", "viewpoint", "around", "model", "report", "ratio", "relative", "baseline", "standard", "rendering", "measure", "directly", "clock", "tick", "baseline", "render", "all", "input", "triangle", "order", "optimize", "vertex-cache", "locality", "-lrb-", "completely", "disregard", "depth-sorting", "-rrb-", "example", "render", "depth-sorted", "model", "we", "method", "twice", "expensive", "baseline", "rendering", "we", "report", "performance", "ratio", "two", "segment", "partitioning", "figure", "show", "effect", "increase", "number", "viewpoint", "partition", "average", "number", "triangle", "per", "segment", "-lrb-", "i.e", "actually", "process", "draw-call", "run-time", "-rrb-", "well", "total", "memory", "consumption", "average", "draw", "call", "size", "report", "ratio", "number", "triangle", "input", "triangle", "list", "total", "memory", "ratio", "report", "ratio", "total", "memory", "use", "standard", "triangle", "list", "duplicated", "triangle", "calculation", "assume", "each", "vertex", "contain", "position", "normal", "texture", "coordinate", "note", "although", "increase", "number", "partition", "increase", "memory", "consumption", "reduce", "average", "segment", "size", "important", "note", "total", "memory", "increase", "only", "happen", "transparent", "part", "model", "have", "any", "transparency", "effect", "all", "furthermore", "vast", "majority", "memory", "modern", "game", "consume", "texture", "geometry", "lagging", "far", "behind", "we", "find", "use", "viewpoint", "partition", "provide", "reasonable", "trade-off", "model", "we", "test", "amount", "memory", "use", "significantly", "higher", "than", "partition", "marked", "decrease", "average", "segment", "size", "translate", "performance", "gain", "render", "time", "remainder", "experiment", "section", "we", "use", "viewpoint", "partition", "preprocess", "Figure", "show", "preprocessing", "time", "we", "method", "depend", "model", "number", "triangle", "can", "take", "anywhere", "between", "few", "minute", "several", "hour", "complete", "computation", "different", "segment", "parallelize", "use", "multiple", "CPU", "core", "while", "preprocessing", "algorithm", "can", "slow", "large", "input", "important", "point", "out", "only", "need", "execute", "once", "each", "static", "model", "further", "optimization", "could", "improve", "preprocessing", "time", "we", "instead", "concentrate", "we", "effort", "optimize", "better", "run-time", "result", "which", "ultimate", "goal", "render", "approach", "figure", "compare", "performance", "three", "version", "we", "run-time", "selection", "procedure", "each", "use", "different", "stage", "pipeline", "geometry", "shader", "option", "significantly", "slower", "due", "fact", "add", "new", "shade", "stage", "render", "pipeline", "therefore", "we", "only", "see", "option", "be", "viable", "when", "rendering", "effect", "already", "require", "geometry", "shader", "which", "case", "would", "require", "simply", "add", "plane", "test", "exist", "shader", "vertex", "shader", "fragment", "shader", "version", "significantly", "faster", "very", "low-resolution", "model", "rendering", "fill-bound", "make", "fragment", "shader", "option", "more", "costly", "mediumand", "high-resolution", "model", "however", "vertex", "processing", "overhead", "vertex", "shader", "approach", "dominate", "thus", "most", "practical", "model", "size", "fragment", "shader", "option", "most", "efficient", "we", "algorithm", "be", "only", "slower", "than", "baseline", "overall", "performance", "we", "compare", "overall", "performance", "we", "fragment", "shader", "algorithm", "selection", "state-of-theart", "real-time", "depth-sorting", "algorithm", "per-pixel", "dynamic", "link", "list", "-lrb-", "ll", "-rrb-", "-lsb-", "Yang", "et", "al.", "2010", "-rsb-", "stochastic", "transparency", "-lrb-", "st", "-rrb-", "-lsb-", "Enderton", "et", "al.", "2010", "-rsb-", "dual", "depth", "peeling", "-lrb-", "ddp", "-rrb-", "-lsb-", "Bavoil", "Myers", "2008", "-rsb-", "st", "approximate", "algorithm", "while", "ddp", "ll", "produce", "exact", "result", "-lrb-", "ddp", "use", "occlusion", "query", "ensure", "further", "pass", "require", "ll", "use", "sophisticated", "sorting", "operation", "available", "legacy", "hardware", "-rrb-", "test", "be", "run", "each", "we", "model", "640", "480", "-lrb-", "figure", "-rrb-", "1280", "720", "-lrb-", "figure", "-rrb-", "screen", "resolution", "demonstrate", "different", "trade-off", "involve", "we", "algorithm", "significantly", "faster", "than", "alternative", "particularly", "high", "screen", "resolution", "conversely", "advantage", "we", "method", "even", "higher", "smaller", "model", "because", "relative", "overhead", "increase", "pixel", "count", "negligible", "we", "method", "contrast", "effect", "increase", "input", "triangle", "count", "nevertheless", "even", "low", "screen", "resolution", "larger", "model", "we", "method", "significantly", "faster", "than", "alternative", "we", "method", "become", "slower", "than", "alternative", "would", "require", "combination", "enormous", "amount", "geometry", "either", "small", "screen", "coverage", "-lrb-", "pixel", "base", "approach", "-rrb-", "very", "small", "maximum", "depth-complexity", "-lrb-", "depth-peeling", "approach", "-rrb-", "since", "gpus", "heavily", "optimize", "batch", "processing", "few", "large", "index", "buffer", "we", "simpler", "singlepass", "method", "faster", "practical", "scenario", "even", "up", "several", "million", "transparent", "triangle", "complex", "scene", "we", "test", "we", "approach", "complex", "room", "scene", "-lrb-", "figure", "10", "-rrb-", "consist", "physical", "simulation", "multiple", "semi-transparent", "dragon", "interact", "collide", "one", "another", "we", "use", "screen", "resolution", "1280", "720", "4x-msaa", "refer", "accompany", "video", "entire", "animation", "sequence", "intermodel", "depth-sorting", "perform", "CPU", "use", "model", "convex", "bound", "volume", "which", "also", "use", "collision", "detection", "trivial", "fast", "small", "number", "object", "since", "convex", "bound", "volume", "allow", "inter-penetrate", "sorting", "result", "guarantee", "correct", "standard", "rendering", "-lrb-", "figure", "10a", "-rrb-", "do", "render", "triangle", "each", "model", "depth", "sort", "order", "therefore", "yield", "incorrect", "transparency", "effect", "example", "rear", "left", "foot", "dragon", "show", "closeup", "appear", "very", "prominently", "even", "though", "behind", "body", "expect", "we", "method", "-lrb-", "figure", "10b", "-rrb-", "ll", "st", "ddp", "generate", "correct", "result", "we", "measure", "render", "time", "entire", "scene", "vary", "number", "dragon", "-lrb-", "figure", "10c", "-rrb-", "result", "scene", "geometric", "complexity", "40,000", "2,000,000", "triangle", "-lrb-", "50", "dragon", "-rrb-", "clearly", "performance", "inversely", "proportional", "number", "dragon", "scene", "we", "method", "significantly", "faster", "compare", "other", "approach", "furthermore", "we", "method", "ddp", "produce", "exact", "result", "which", "case", "st", "ll", "msaa", "Game", "scene", "show", "we", "method", "also", "apply", "more", "typical", "game", "scene", "-lrb-", "figure", "11", "-rrb-", "we", "create", "another", "experiment", "include", "animation", "sequence", "which", "character", "move", "around", "game", "scene", "multiple", "solid", "object", "semi-transparent", "model", "refer", "accompany", "video", "entire", "animation", "sequence", "get", "sense", "performance", "implication", "we", "approach", "scenario", "we", "vary", "resolution", "we", "semi-transparent", "model", "order", "present", "we", "performance", "result", "function", "percentage", "scene", "primitive", "semi-transparent", "so", "instance", "approximately", "15", "game?s", "primitive", "semitransparent", "slowdown", "have", "triangle", "sort", "order", "just", "about", "1.1", "other", "hand", "more", "extreme", "scenario", "where", "semi-transparent", "object", "dominate", "have", "50", "primitive", "count", "slowdown", "more", "significant", "1.5", "preprocess", "10", "-lrb-", "hour", "-rrb-", "Dragon", "Bunny", "Fandisk", "time", "feline", "preprecessing", "20k", "40k", "60k", "80k", "100k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Figure", "preprocessing", "time", "different", "mesh", "different", "resolution", "-lrb-", "all", "mesh", "preprocess", "segment", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "Depth-Presorted", "Triangle", "Lists", "160:7", "Bunny", "Dragon", "14", "14", "v", "ratio", "12", "g", "12", "10", "f", "10", "Performance", "20k", "40k", "60k", "80k", "20k", "40k", "60k", "80k", "100k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Model", "size", "-lrb-", "triangle", "-rrb-", "figure", "Performance", "comparison", "between", "geometry", "shader", "vertex", "shader", "fragment", "shader", "implementation", "Dragon", "256", "64", "16", "80k", "Bunny", "256", "ratio", "64", "Performance", "16", "Ours", "DDP", "st", "ll", "20k", "40k", "60k", "Model", "size", "-lrb-", "triangle", "-rrb-", "20k", "40k", "60k", "80k", "100k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Figure", "Performance", "comparison", "related", "technique", "use", "screen", "resolution", "640", "480", "Dragon", "256", "64", "16", "80k", "Bunny", "256", "ratio", "64", "Ours", "Performance", "16", "ddp", "st", "ll", "20k", "40k", "60k", "Model", "size", "-lrb-", "triangle", "-rrb-", "20k", "40k", "60k", "80k", "100k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Figure", "Performance", "comparison", "related", "technique", "use", "screen", "resolution", "1280", "720", "Fandisk", "Feline", "14", "14", "12", "12", "10", "10", "20k", "40k", "60k", "80k", "100k", "120k", "20k", "40k", "60k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Model", "size", "-lrb-", "triangle", "-rrb-", "Fandisk", "Feline", "256", "256", "64", "64", "16", "16", "20k", "40k", "60k", "80k", "100k", "120k", "20k", "40k", "60k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Model", "size", "-lrb-", "triangle", "-rrb-", "Fandisk", "Feline", "256", "256", "64", "64", "16", "16", "20k", "40k", "60k", "80k", "100k", "120k", "20k", "40k", "60k", "Model", "size", "-lrb-", "triangle", "-rrb-", "Model", "size", "-lrb-", "triangle", "-rrb-", "conclusion", "we", "present", "new", "algorithm", "efficient", "exact", "depth-sorted", "rendering", "static", "triangle", "model", "we", "method", "produce", "depthpresorted", "triangle", "list", "which", "each", "triangle", "annotated", "test", "plane", "list", "can", "render", "depth-sorted", "order", "use", "single", "draw", "call", "give", "viewpoint", "simple", "run-time", "culling", "procedure", "execute", "GPU", "rasterize", "subsequence", "triangle", "produce", "depth-sorted", "rendering", "model", "relative", "viewpoint", "we", "show", "approach", "significantly", "faster", "than", "alternative", "method", "main", "limitation", "we", "method", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "-lrb-", "-rrb-", "standard", "rendering", "-lrb-", "-rrb-", "we", "result", "figure", "10", "result", "performance", "comparison", "room", "scene", "screen", "resolution", "1280", "720", "4x-msaa", "-lrb-", "-rrb-", "rendering", "we", "approach", "figure", "11", "result", "performance", "comparison", "game", "scene", "screen", "resolution", "1280", "720", "4x-msaa", "only", "suitable", "static", "model", "viewpoint", "outside", "bound", "polyhedron", "however", "we", "feel", "exist", "wide", "range", "application", "which", "limitation", "do", "matter", "finally", "we", "believe", "novel", "selection", "base", "scheme", "use", "single", "draw", "call", "significant", "departure", "from", "exist", "method", "most", "which", "require", "either", "sort", "multipass", "rendering", "we", "believe", "direction", "worth", "further", "investigation", "particularly", "way", "handle", "deformable", "model", "would", "interesting", "consider", "generate", "set", "order", "conjunction", "allow", "limited", "range", "deformation", "run-time", "alternatively", "we", "finegrain", "triangle-level", "technique", "can", "combine", "coarse-level", "dynamic", "sort", "enable", "animated", "character", "rigid", "part", "acknowledgment", "work", "partly", "support", "Hong", "Kong?s", "RGC", "GRF", "grant", "619509", "inst", "grant", "from", "FAPERJ", "reference", "ilum", "T.", "IETTINEN", "V.", "ordlund", "P.", "2003", "delay", "stream", "graphic", "hardware", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "2003", "-rrb-", "22", "-lrb-", "-rrb-", ":792", "800", "arber", "C.", "B.", "OBKIN", "D.", "P.", "uhdanpaa", "H.", "1996", "quickhull", "algorithm", "convex", "hull", "ACM", "transaction", "mathematical", "Software", "22", "-lrb-", "-rrb-", ":469", "483", "avoil", "L.", "ALLAHAN", "S.", "P.", "EFOHN", "A.", "OMBA", "J.", "L.", "D.", "ilva", "c.", "t.", "2007", "multi-fragment", "effect", "GPU", "use", "k-buffer", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "94", "104", "avoil", "L.", "YERS", "K.", "2008", "Order", "independent", "transparency", "dual", "depth", "peeling", "NVIDIA", "whitepaper", "erkelaar", "M.", "IKLAND", "K.", "otebaert", "P.", "2004", "-lrb-", "-rrb-", "Performance", "comparison", "game", "ratio", "dragon", "bunny", "1.75", "time", "fandisk", "feline", "1.5", "armadillo", "rendering", "1.25", "10", "20", "30", "40", "50", "60", "70", "semi-transparent", "primitive", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "Performance", "comparison", "lp_solve", "5.5", "open", "source", "-lrb-", "mixed-integer", "-rrb-", "linear", "programming", "system", "Software", "allahan", "S.", "P.", "kit", "M.", "OMBA", "J.", "L.", "D.", "ilva", "c.", "t.", "2005", "hardware-assisted", "visibility", "sort", "unstructured", "volume", "rendering", "IEEE", "transaction", "visualization", "computer", "graphic", "11", "-lrb-", "-rrb-", ":285", "295", "arpenter", "L.", "1984", "a-buffer", "antialiased", "hidden", "surface", "method", "Computer", "Graphics", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "1984", "-rrb-", "18", "-lrb-", "-rrb-", ":103", "108", "arr", "N.", "ech", "R.", "iller", "G.", "2008", "coherent", "layer", "peel", "transparent", "high-depth-complexity", "scene", "Proceedings", "Graphics", "Hardware", "33", "40", "atmull", "E.", "1974", "Subdivision", "Algorithm", "Computer", "display", "Curved", "Surfaces", "phd", "thesis", "Dept.", "Computer", "Science", "hen", "h.-m", "ang", "w.-t", "1996", "feudal", "priority", "algorithm", "hidden-surface", "removal", "Proceedings", "ACM", "SIGGRAPH", "1996", "55", "64", "dx10", "sdk", "2010", "Microsoft", "Corporation", "February", "2010", "release", "nderton", "E.", "intorn", "E.", "hirley", "P.", "uebke", "D.", "2010", "stochastic", "transparency", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "157", "164", "VERITT", "C.", "2001", "interactive", "order-independent", "transparency", "NVIDIA", "whitepaper", "oley", "J.", "D.", "VAN", "AM", "a.", "EINER", "S.", "K.", "ughe", "J.", "F.", "1990", "Computer", "Graphics", "principle", "practice", "chapter", "16.5.1", "Addison-Wesley", "nd", "edition", "uch", "H.", "EDEM", "Z.", "M.", "aylor", "B.", "F.", "1980", "visible", "surface", "generation", "priori", "tree", "structure", "Computer", "Graphics", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "1980", "-rrb-", "14", "-lrb-", "-rrb-", ":124", "133", "ukushige", "S.", "UZUKI", "H.", "2006", "Voronoi", "diagram", "depth", "sort", "polygon", "visibility", "order", "Proceedings", "GRAPHITE", "06", "461", "467", "oad", "c.", "1982", "special", "purpose", "automatic", "programming", "hidden", "surface", "elimination", "Computer", "Graphics", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "1982", "-rrb-", "16", "-lrb-", "-rrb-", ":167", "178", "uang", "m.-c.", "iu", "F.", "IU", "X.-H.", "e.-h", "2010", "multifragment", "effect", "GPU", "use", "bucket", "sort", "W.", "Engel", "editor", "GPU", "pro", "Advanced", "Rendering", "Techniques", "chapter", "viii", ".1", "495", "508", "Peters", "ANSEN", "J.", "AVOIL", "L.", "2010", "fourier", "opacity", "mapping", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "165", "172", "OUPPI", "N.", "P.", "HANG", "c.-f", "1999", "economical", "hardware", "technique", "high-quality", "antialiasing", "transparency", "Proceedings", "Graphics", "Hardware", "85", "93", "ARP", "R.", "M.", "1972", "reducibility", "among", "combinatorial", "problem", "R.", "E.", "Miller", "J.", "W.", "Thatcher", "editor", "Proceedings", "Symposium", "Complexity", "Computer", "computation", "85", "103", "IM", "t.-y", "eumann", "U.", "2001", "opacity", "shadow", "map", "Proceedings", "Eurographics", "Workshop", "Rendering", "Techniques", "177", "182", "aine", "S.", "ARRAS", "T.", "2011", "stratify", "sampling", "stochastic", "transparency", "Computer", "Graphics", "Forum", "-lrb-", "Proceedings", "Eurographics", "Symposium", "Rendering", "2011", "-rrb-", "30", "-lrb-", "-rrb-", "iu", "b.-q.", "EI", "L.-Y.", "y.-q", "2006", "multi-layer", "depth", "peel", "via", "fragment", "sort", "Technical", "Report", "msr-tr-2006-81", "Microsoft", "Research", "Asia", "iu", "F.", "UANG", "M.-C.", "IU", "X.-H.", "e.-h", "2009", "efficient", "depth", "peel", "via", "bucket", "sort", "Proceedings", "ACM", "Symposium", "High", "Performance", "Graphics", "51", "57", "iu", "F.", "UANG", "M.-C.", "IU", "X.-H.", "e.-h", "2010", "FreePipe", "programmable", "parallel", "render", "architecture", "efficient", "multi-fragment", "effect", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "75", "82", "amman", "a.", "1989", "transparency", "antialiasing", "algorithm", "implement", "virtual", "pixel", "map", "technique", "IEEE", "Computer", "Graphics", "application", "-lrb-", "-rrb-", ":43", "55", "ark", "W.", "R.", "roudfoot", "K.", "2001", "f-buffer", "rasterization-order", "fifo", "buffer", "multi-pass", "rendering", "Proceedings", "Graphics", "Hardware", "57", "64", "eshkin", "H.", "2007", "sort-independent", "alpha", "blending", "gdc", "talk", "ulder", "J.", "D.", "ROEN", "F.", "C.", "A.", "VAN", "IJK", "J.", "J.", "1998", "Pixel", "mask", "screen-door", "transparency", "Proceedings", "visualization", "98", "351", "358", "yer", "K.", "AVOIL", "L.", "2007", "stencil", "route", "a-buffer", "ACM", "SIGGRAPH", "Technical", "sketch", "yer", "K.", "AVOIL", "L.", "2007", "stencil", "route", "k-buffer", "NVIDIA", "whitepaper", "ehab", "D.", "ARCZAK", "J.", "ander", "P.", "V.", "2006", "Triangle", "order", "optimization", "graphic", "hardware", "computation", "culling", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "207", "211", "ewell", "M.", "E.", "EWELL", "R.", "G.", "ancha", "T.", "L.", "1972", "new", "approach", "shaded", "picture", "problem", "Proceedings", "ACM", "National", "Conference", "aterson", "M.", "S.", "ao", "F.", "F.", "1989", "binary", "partition", "application", "hidden", "surface", "removal", "solid", "modelling", "Symposium", "Computational", "Geometry", "23", "32", "atney", "a.", "zeng", "S.", "wen", "J.", "D.", "2010", "Fragmentparallel", "composite", "filter", "Computer", "Graphics", "Forum", "-lrb-", "Proceedings", "Eurographics", "Symposium", "Rendering", "2010", "-rrb-", "29", "-lrb-", "-rrb-", "1251", "1258", "orter", "T.", "UFF", "T.", "1984", "composit", "digital", "image", "Computer", "Graphics", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "1984", "-rrb-", "18", "-lrb-", "-rrb-", "253", "259", "ALVI", "M.", "ONTGOMERY", "J.", "efohn", "a.", "2011", "adaptive", "transparency", "Proceedings", "ACM", "Symposium", "High", "Performance", "Graphics", "119", "126", "ander", "P.", "V.", "EHAB", "D.", "arczak", "J.", "2007", "fast", "triangle", "reordering", "vertex", "locality", "reduce", "overdraw", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "2007", "-rrb-", "26", "-lrb-", "-rrb-", ":89", "chumacker", "R.", "A.", "RAND", "B.", "ILLILAND", "M.", "G.", "harp", "W.", "H.", "1969", "study", "apply", "computer-generated", "image", "visual", "simulation", "Technical", "Report", "AFHRL-TR-69-14", "US", "Airforce", "Human", "Resources", "Laboratory", "intorn", "E.", "SSARSSON", "U.", "2008", "real-time", "approximate", "sorting", "self", "shadow", "transparency", "hair", "rendering", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "157", "162", "intorn", "E.", "SSARSSON", "U.", "2009", "hair", "self", "shadow", "transparency", "depth", "order", "use", "occupancy", "map", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "67", "74", "kiena", "S.", "S.", "2008", "Algorithm", "Design", "Manual", "chapter", "15.2", "Springer", "nd", "edition", "hibieroz", "N.", "2008", "robust", "order-independent", "transparency", "via", "reverse", "depth", "peel", "DirectX", "10", "W.", "Engel", "editor", "shaderx6", "Advanced", "Rendering", "Techniques", "chapter", "3.7", "211", "226", "Charles", "River", "Media", "EXLER", "D.", "RITZ", "L.", "NDERTON", "E.", "ice", "J.", "2005", "gpuaccelerated", "high-quality", "hidden", "surface", "removal", "Proceedings", "Graphics", "Hardware", "14", "ILLIAMS", "P.", "L.", "1992", "visibility-ordering", "mesh", "polyhedron", "ACM", "transaction", "graphic", "11", "-lrb-", "-rrb-", ":103", "126", "ITTENBRINK", "C.", "M.", "2001", "r-buffer", "pointerless", "a-buffer", "hardware", "architecture", "Proceedings", "Graphics", "Hardware", "73", "80", "ang", "J.", "C.", "ENSLEY", "J.", "UN", "H.", "hibieroz", "N.", "2010", "real-time", "concurrent", "link", "list", "construction", "GPU", "Computer", "Graphics", "Forum", "-lrb-", "Proceedings", "Eurographics", "Symposium", "Rendering", "2010", "-rrb-", "29", "-lrb-", "-rrb-", ":1297", "1304", "uksel", "C.", "EYSER", "J.", "2008", "deep", "opacity", "map", "Computer", "Graphics", "Forum", "-lrb-", "Proceedings", "Eurographics", "2008", "-rrb-", "27", "-lrb-", "-rrb-", ":675", "680", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012", "Depth-Presorted", "Triangle", "Lists", "160:9", "ACM", "transaction", "Graphics", "Vol", "31", "no.", "Article", "160", "publication", "date", "November", "2012" ],
  "content" : "\n  \n    34ddbaf8dea2f7cdcd33e0c33db8e6c24b412c2ecb822132429ef9fe9a4ceeea\n    p2i\n    10.1145/2366145.2366179\n    Name identification was not possible. \n  \n  \n    \n      \n        Depth-Presorted Triangle Lists\n      \n      Ge Chen 1 Pedro V. Sander 1 Diego Nehab 2 Lei Yang 1,3 1 Hong Kong UST 2 IMPA 3 Bosch Research North America\n      input static model\n      \n        \n        \n      \n      input triangles off-line preprocess depth-presorted triangle list (triangles & half-spaces)\n      \n        Figure 1: Our off-line preprocessing algorithm produces a depth-presorted triangle list from a static 3D input model. The list contains copies of the model that are depth-sorted relative to any viewpoint outside its bounding volume. Each triangle comes annotated with a half-space test that enables a fast run-time algorithm to select exactly the triangles needed to render a complete depth-sorted model for a given viewpoint.\n      \n      We present a novel approach for real-time rendering of static 3D models front-to-back or back-to-front relative to any viewpoint outside its bounding volume. The approach renders depth-sorted triangles using a single draw-call. At run-time, we replace the traditional sorting strategy of existing algorithms with a faster triangle selection strategy. The selection process operates on an extended sequence of triangles annotated by test planes, created by our off-line preprocessing stage. Based on these test planes, a simple run-time procedure uses the given viewpoint to select a subsequence of triangles for rasterization. Selected subsequences are statically presorted by depth and contain each input triangle exactly once. Our method runs on legacy hardware and renders depth-sorted static models significantly faster than previous approaches. We conclude demonstrating the real-time rendering of order-independent transparency effects.\n      Links:\n      \n        \n      \n      DL PDF\n      \n        \n      \n    \n    \n      \n        1 Introduction\n      \n      In real-time rendering applications that employ the Z-buffer for visibility determination [Catmull 1974], there are still many scenarios in which depth-sorting is necessary or desirable. The most common is\n      \n        ACM Reference Format\n      \n      Chen, G., Sander, P., Nehab, D., Yang, L., Hu, L. 2012. Depth-Presorted Triangle Lists. ACM Trans. Graph. 31 6, Article 160 (November 2012), 9 pages. DOI = 10.1145/2366145.2366179 http://doi.acm.org/10.1145/2366145.2366179.\n      \n        Copyright Notice\n      \n      Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the fi rst page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2012 ACM 0730-0301/2012/11-ART160 $15.00 DOI 10.1145/2366145.2366179 http://doi.acm.org/10.1145/2366145.2366179\n      Liang Hu 4 4 Google Inc.\n      real-time depth-sorted\n      \n        \n        \n      \n      run-time selection\n      order-independent transparency or translucency. Since the compositing operation is not commutative [Porter and Duff 1984], blending must happen in depth-sorted order. As we discuss in section 2, a large number of techniques have been proposed for performing real-time depth sorting. In this work, we present a technique that possesses a unique combination of desirable properties. It can be implemented with the standard graphics pipeline, requires a single rendering pass, uses a fixed amount of memory, produces exact results, is very simple to integrate with existing rendering engines, and is extremely efficient. These advantages come with certain limitations. Whereas most previous depth-sorting algorithms work seamlessly with deformable geometry at run-time, our method assumes static geometry viewed from outside the model?s bounding volume. Finally, our preprocessing stage can take hours to complete when run on larger models, and the resulting data-structure consumes more memory than the input. We target performance-critical applications that must render a number of moderately complex static objects with translucency effects, such as computer games. In this scenario, which we demonstrate in the results section, the relative order between objects is determined by the CPU, and our method ensures correct triangle ordering within each object. During game development, instant feedback can be provided to artists using earlier, less efficient methods. At the end of the release cycle, required models can be preprocessed and the engine set up to take advantage of the simplicity of our run-time component, and of the large performance gains that ensue. Since only the transparent components of objects with translucency effects must be preprocessed, the increase in run-time memory is not a significant limitation either. Our key insight is that the space of different triangle orders that result from depth-sorting a triangle model under each possible viewpoint constitutes a tiny fraction of all triangle permutations. Moreover, this ?space of depth-sorted orders? is extremely redundant in the sense that, with few modifications, the same order is valid for large portions of the viewpoint space.  We explore this insight in the following way. During a preprocessing stage, we create an extended sequence of triangles (i.e., a list that contains one or more instances of each input triangle). By construction, this extended sequence is such that there is a view-dependent subsequence of triangles that is depth-sorted relative to each and every viewpoint outside of a bounding volume. These view-dependent subsequences are guaranteed to include each input triangle exactly once. Within the extended sequence, each triangle is paired with a half-space. The entire extended sequence is sent for rendering by the GPU, at which point an extremely simple and efficient run-time procedure selects those triangles for which the associated half-space contains the viewpoint. The result is a depth-sorted rendering of the original input triangles, relative to the viewpoint. Since there is no run-time sorting, only a trivial run-time selection procedure, our method runs at an order of magnitude faster than previous approaches. This selection happens in a single rendering pass, and can be implemented at any stage of the rendering pipeline (vertex, geometry, or fragment shaders). Finally, there is no CPU intervention and results are guaranteed to be exact. In summary, our contributions include: ? The fastest single-draw-call, exact, real-time depth-sorted rendering algorithm for static models; ? A preprocessing algorithm for creating a compact extended sequence of triangles and associated half-spaces containing depth-sorted subsequences relative to all viewpoints; ? Three versions of the run-time algorithm for selecting the subsequence associated to a given viewpoint, all leading to state-of-the-art run-time performance. The rest of the paper is organized as follows. In section 2 we position our method in context with previous work. Section 3 presents two simple examples that will be helpful in understanding the preprocessing algorithm, which is described in section 4. The run-time selection algorithms are presented in section 5. Section 6 provides relevant statistics specific to our method, as well as performance comparisons against previous approaches. We conclude by revisiting the strengths and weaknesses of the method and suggesting venues for future work.\n      ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n      160:2\n      ?\n      G. Chen et al.\n      \n        2 Related work\n        The problem of depth-sorting is tightly connected to the problem of visibility, for which there is a vast amount of prior work. Here, we focus on the methods we believe are most related to ours. Note that many depth-sorting methods can be used to render dynamic (or even self-intersecting) geometry. Naturally, when comparing them against our approach, we assume the target application does not require this functionality. The most well-known approach for rendering depth-sorted static geometry is the BSP tree [Fuchs et al. 1980; Paterson and Yao 1989]. Each node in a BSP tree includes a half-space test. The root node represents the entirety of space, and each subtree represents the fraction of the parent?s space that reside in one of the two halfspaces. The BSP tree is created during a preprocessing stage, much like our extended triangle list. To render from a BSP, the tree is traversed recursively at run-time. For back-to-front rendering, when visiting a node, the subtree representing half-spaces that contain the viewpoint are visited last. In our method, the half-spaces are instead used to separate the viewpoints for which a given individual triangle instance must be drawn from those for which it must be ignored. Other than the BSP, additional data-structures used for depth sorting include directed acyclic graphs [Williams 1992], feudal priority trees [Chen and Wang 1996], and Voronoi diagrams [Fukushige and Suzuki 2006]. In contrast, our extended list is a flat data-structure,  potentially including multiple copies of each triangle, each of which is selected or not by the viewpoint. Our method is therefore better suited for modern GPUs, where recursiveness and pointer manipulation are difficult or otherwise inefficient to accomplish. Early CPU-based approaches also generate flat or semi-flat datastructures. Newell et al. [1972] and Goad [1982] both describe automatic procedures that sort triangles into a priority order for given viewpoints. Schumacker et al. [1969] propose a method that separates the scene into convex clusters during preprocessing. The faces in each cluster can be assigned a fixed order which, after back-face culling, provides correct visibility from any viewpoint. These clusters must be mutually separable by planes, and the order of displaying these clusters is computed at run-time. Our method leverages GPU hardware in order to render the model using a single draw call without requiring ordering computations at run-time. The most general techniques operate at the pixel level. The typical strategy is to generate per-pixel fragments lists and then sort each list, as in the A-buffer [Carpenter 1984]. This is challenging, since there is no way to guess the total number of fragment storage that will be needed, or the number of fragments needed per pixel. New hardware capabilities have recently enabled the use dynamic linked lists to collect fragments and blend them in order [Yang et al. 2010], or instead to count the number of fragments in a first rasterization pass and store them into individual arrays during a second pass [ DX10 SDK 2010 ], before compositing them in parallel [Patney et al. 2010]. Our method requires a single pass, uses constant memory, and is significantly faster, particularly when multiple samples per pixel are used for anti-aliasing (e.g. MSAA). Many modifications to the rendering pipeline have been proposed that support variations of the A-buffer. These include the Rbuffer [Wittenbrink 2001], the F-buffer [Mark and Proudfoot 2001], Delay Streams [Aila et al. 2003], and the FreePipe architecture [Liu et al. 2010]. Our method runs on the standard rendering pipeline. Another alternative is to render the scene as many times as required by the maximum depth complexity. At each pass, the Z-buffer is used to select the next closest fragment [Mammen 1989; Everitt 2001; Thibieroz 2008] (much like selection sort). For performance reasons, variations of this idea split the scene into pieces that are presorted [Wexler et al. 2005], peel multiple layers per pass [Liu et al. 2006; Bavoil and Myers 2008], or exploit any ordered structure that may already be present [Carr et al. 2008]. The algorithms are exact and the amount of memory needed is fixed. Our method is simpler and, depending on the depth-complexity, significantly faster. Many methods rely on approximations for performance reasons. A common approach is to limit the maximum number of fragments per pixel [Jouppi and Chang 1999; Myers and Bavoil 2007a,b; Bavoil et al. 2007; Liu et al. 2009; Huang et al. 2010; Salvi et al. 2011], in which case some heuristic must be used to merge or evict overflowing fragments. In the case of order-independent transparency, ignoring order is sometimes acceptable [Meshkin 2007; Bavoil and Myers 2008]. Another method that avoids the need for sorting is stochastic transparency [Enderton et al. 2010; Laine and Karras 2011], a refreshing new take on screen-door transparency [Foley et al. 1990; Mulder et al. 1998]. Our method always produces noisefree renderings and is significantly faster. Some approximations work particularly well for hair, volumetric data, or both [Kim and Neumann 2001; Callahan et al. 2005; Yuksel and Keyser 2008; Sintorn and Assarsson 2008, 2009; Jansen and Bavoil 2010; Salvi et al. 2011]. Our method is not suitable for such high depth-complexities. Finally, in the context of overdraw reduction, some static orders may succeed in eliminating most of the overdraw [Nehab et al. 2006; Sander et al. 2007].\n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n        Depth-Presorted Triangle Lists\n        ?\n        160:3\n        \n          Figure 2: A simple 2D example (left), after duplicating triangles (right), and the resulting occlusion graph (bottom).\n        \n      \n      \n        3 Motivating examples\n        We begin by presenting two simple examples that will motivate our strategy for building depth-presorted triangle lists. For simplicity, we show both examples in 2D (see figures 2 and 3), with triangles represented by line segments. The arrows next to each triangle represent the normal direction.\n        \n          3.1 A view-independent depth-presorted model\n          Consider the non-convex model in figure 2 (top left). We will show that it is possible to produce depth-sorted renderings of this model (including back-facing triangles) from any viewpoint, using a fixed triangle ordering. At first sight, this seems difficult, given that the occlusion relationship between two triangles may be reversed when the viewpoint changes (i.e., when viewing from above, C occludes E, while when viewing from below, E occludes C). The trick is to duplicate each triangle by including an additional instance with the opposite orientation. The augmented model, with newly instanced back-facing triangles in blue, is shown in figure 2 (top right). Although there are now twice as many triangles as in the original model, back-face culling ensures the hardware will rasterize at most one instance of each triangle. The additional freedom awarded by the duplication will allow us to create the triangle ordering we seek. In the case of figure 2 (with back-face culling), triangles C D E never occlude other triangles, since there are no triangles in the half-space behind each of them. It is safe to place them in the end of the list. By the same token, CDE are never occluded by any triangle: they can be added to the front of the list. All that remains is to place the remaining triangles AA BB between CDE and C D E (in some appropriate relative order). These triangles have more complex occlusion relationships. Specifically, A may occlude B and B may occlude A. Thus, we need to find an order such that A is in front of B and B is in front of A. Multiple such orders exist and in particular the following order satisfies all requirements: CDEA B ABC D E . When processing the list of 10 triangles in this order, and from any viewpoint, back-face culling will select exactly the 5 triangles that render the model sorted by depth. To solve the general case automatically, we first construct a graph that captures all occlusion relationships. This occlusion graph is shown in figure 2 (bottom). Each node represents a triangle, and there is an edge connecting a triangle X to a triangle Y if and only if there is a viewpoint in which triangle X occludes triangle Y . We seek a topological sort of the occlusion graph, i.e., an ordering in which there are no back-edges [Skiena 2008]. There is such an order whenever the directed graph is acyclic (i.e., it is a DAG), as is the case of the occlusion graph in figure 2 . Surprisingly, it is possible to construct an ordering as described above for many simple objects.\n          \n            Figure 3: A simple example with a cycle (left), and the result of duplicating triangle H using the cutting plane p (right).\n          \n        \n        \n          3.2 A model requiring view-dependent selection\n          Unfortunately, in the general case, there may be cycles in the occlusion graph, even with back-face culling, so that no topological sort can be found. The simplest such case is shown in figure 3 (left). The corresponding occlusion graph containing a cycle is shown underneath it. (We have omitted the back-facing triangles from the graph to isolate this single cycle.) The key observation is that H can only occlude F if the viewpoint is inside the yellow region, and G can only occlude H if the viewpoint is in the gray region. Furthermore, these regions can be separated by a cutting plane p (the red dashed-line). Thus, we can solve the cycle problem by creating an extra copy of H, as shown in figure 3 (bottom right), and using the cutting plane p to select the copy of H to render depending on which side of p the current viewpoint lies. This culling operation, which is in addition to back-face culling, can be performed very efficiently at run-time (see section 5).\n        \n      \n      \n        4 Preprocessing algorithm\n        In this section, we describe an algorithm for automatically generating a depth-presorted triangle list for arbitrary input models. While in this description we assume a back-to-front ordering is desired, the algorithm can be trivially adjusted to create a front-to-back order. Since our method focuses on static models, we assume intersecting triangles have been split prior to invocation of our preprocessing algorithm, so the input list contains no intersecting triangles. Moreover, we assume there is a way to depth-sort the triangles from any viewpoint. In other words, we assume there are no single-viewpoint visibility cycles in the input model. Self-intersections, which are common in production models, must anyway be eliminated when rendering with transparency. Additional preprocessing can break cycles by splitting triangles when needed. As in the example of section 3.1, we start by creating back-facing duplicates for each input triangle in order to relax the occlusion restrictions. Then, we compute the occlusion graph and generate a preliminary ordering. If the graph has no cycles, a topological sort completely solves the problem [Skiena 2008]. When there are cycles, a good preliminary ordering is one that minimizes the number of back-edges. Finding an optimal preliminary order is equivalent to solving the minimum feedback arc-set problem, which is NP-complete [Karp 1972]. Fortunately, the correctness of our algorithm does not depend on optimality, and therefore we use a fast heuristic that is detailed in section 4.2.  The final and most important preprocessing stage deals with backedges in the preliminary order. To do so, we scan the ordering from start to finish, duplicating triangles and associating them with halfspaces whenever we find a back-edge. This step follows along the lines of the example of section 3.2, and is described below.\n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n        160:4\n        ?\n        G. Chen et al.\n        \n          4.1 Duplicating triangles to work around back-edges\n          At each iteration, we process a graph node, moving along the preliminary order from start to finish. Nodes that send no back-edges can be safely ignored, but all back-edges must be dealt with. An example will guide us through the algorithm:  Here, moving along the list from right to left, the current iteration reaches a yellow node x with back-edges (in red) that must be eliminated. (Edges that are not adjacent to x are irrelevant to this iteration and have been omitted.) To remedy the two back-edges pointing to the b ? nodes, it often suffices to move x immediately before b 1 . This works whenever there are no triangles between b 1 and x with edges that point to x. Unfortunately, this is not the case here and moving x gives rise to two new back-edges, coming from the f ? : To address this issue, we proceed as in section 3.2, and look for a plane p that partitions the viewpoint space into two half-spaces. Plane p must be such that the set of viewpoints from which x occludes the b ? is contained in one of the half-spaces, whereas the set of viewpoints from which the f ? occlude x is contained in the other half-space. An algorithm for finding such a plane (when it exists) is given in section 4.1.1. With p, we can duplicate x as follows: We then annotate the right copy of x with the half-space test for p, so that the run-time algorithm described in section 5 will only render this copy of x if the viewpoint is in the correct half-space. The left copy of x does not need to be annotated with the plane. Using Z-buffering with depth-test of less ensures that the fragments generated by the left copy of x are shaded and stored if and only if the right copy was skipped (Recall the back-to-front rendering proceeds from right to left.) This fact allows us to avoid dealing with multiple half-space tests in most practical cases. Whenever we can find p that completely separates the viewpoints associated to edges to the b ? from those associated to edges from the f ? , it is clear we can move on to the next offending node. However, such an ideal cutting plane may not exist. Thus, duplicating x with p may introduce into the graph new back-edges emanating from a subset of the f ? , as shown below: In that case, we proceed to the next iteration and postpone handling of new back-edges to the iteration that analyzes the nodes from which they emanate (f 1 in the example). It is therefore possible for the left copy of a node that has been duplicated to be further duplicated by the iteration that eventually processes it. As we noted earlier, in general only the right copy is assigned a half-space test: the Z-buffer deals with the left copy. Therefore, as we traverse the list from right to left, each node copy is processed only once and is assigned at most one plane. It is important to notice that, as long as we manage to separate at least one of the edges between f ? and x from at least one of edges between x and b ? , we have made progress. This is because we have succeeded in reducing the total number of edges that must be considered in the future. Since that number is finite, the algorithm terminates. We now prove that, under mild assumptions, this is always the case. We focus on three nodes in the graph: the current node x, the right-most node b to which x sends a back-edge, and the right-most node f , between b and x, such that f sends a forward-edge to x. We further assume that there exists a path from b to f , so that there is a cycle in the graph (otherwise we could simply move b to the right of x). Note that cycles of two nodes do not exist since there are no self-intersecting triangles. If the viewpoints of edge (x, b) can be separated from the viewpoints of edge (f, x), we duplicate x as usual. If the viewpoints of edge (x, b) can be separated from those of edge (b, f ), we duplicate b instead. Finally, if the viewpoints of edge (b, f ) can be separated from those of edge (f, x), we duplicate node f . These configurations are shown below: At least one of these separations must be possible. Otherwise, there would be a viewpoint from which the entire cycle is visible. This would preclude the existence of a depth-sorted triangle ordering for this viewpoint. But this contradicts our assumptions and therefore completes the proof. Note that if we follow this strategy that duplicates b by moving it to the right, it is possible that b may have other back-edges and require further duplication. In that case, additional planes will have to be associated with the right copy of b. Fortunately, this must be relatively rare since we have never observed it in practice.\n          \n            4.1.1 Defining the cutting plane\n            Let us begin with a few definitions. We associate an occlusion region O i?j to each edge from node i to node j, defined as the set of viewpoints from whence i occludes j. Thus, from viewpoints outside of O i?j , it is as if the edge did not exist. Similarly, we associate to each node i (i.e., to each triangle instance) a rendering region E i , representing the set of viewpoints from which i is rendered. As nodes are duplicated, rendering regions of new nodes are cumulatively restricted to their associated half-spaces and can therefore become rather small. Naturally, outside E i or E j , it is as if an edge between i and j did not exist either. Therefore, each edge is relevant only inside a reduced occlusion region\n            \n              1\n              O  ? i?j = O i?j ? E i ? E j .\n            \n            With these definitions in hand, we can define the problem of finding an appropriate cutting plane p. Let x be the current node being analyzed. Assume x has back-edges pointing to a set of nodes b ? , as well as forward-edges arriving from n distinct nodes f ? that lie between x and b 1 . We want to duplicate x, placing the new copy to the left of b 1 . We hope to find a plane p that partitions the edges among the two instances of x: back-edges go to the new (left) instance, forward-edges remain with the current (right) instance.\n            ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n            Depth-Presorted Triangle Lists\n            ?\n            160:5\n            Formally, the ideal plane p separates the regions\n            \n              2\n              R b = O  ? x?b and R f = O  ? f ?x . b?b ? f ?f ?\n            \n            Since the ideal plane may not exist, we greedily look for a good alternative. We start our search by separating the back-edge region R b from an empty forward-edge region\n            \n              3\n              (0) R = ?. f\n            \n            (The plane of x itself does the job.) Then, we try to progressively add forward-edge regions to R f by setting\n            \n              4\n              R f (i) = R f (i?1) ? O  ? f i ?x\n            \n            if we can find a separating plane between R b and R f (i?1) ? O  ? f i ?x . Otherwise, we set\n            \n              5\n              (i) (i?1) R = R f f\n            \n            and consider adding the occlusion region for the next forward-edge. When we are done considering all forward-edges (in order, for efficiency), we assign the last successful separating plane to the orig(n) inal x, and move the edges not accounted for the final region R f to its new copy. These will be addressed when the time comes, by duplicating the required subset of the f ? . Although we can conceive of a situation where it is not possible to separate any of the O  ? f i ?x from all of R b , this has not happened in any of our test cases. As shown in section 4.1, it is in fact always possible to separate at least one O  ? f i ?x from at least one O  ? x?b j , and we can rely on this fall-back procedure to ensure the termination of the algorithm.\n          \n          \n            4.1.2 Computing the cutting plane\n            In this section, we detail the geometric operations used to efficiently compute R f and R b , and ultimately the cutting plane p that separates them. Computations involving convex-hulls, half-space intersections, and linear-programming are performed using the Qhull [Barber et al. 1996] and lp_solve [Berkelaar et al. 2004] libraries. Intersection of viewpoint regions Determining the reduced occlusion region O  ? i?j amounts to finding the intersection between three convex regions. To do so, we form the intersection between all half-spaces defining each of O i?j , E i , and E j . Since this intersection is often empty, as an optimization that avoids the costly half-space intersections, we first check if all vertices of either E i or E j are on the outside of one of the planes bounding O i?j . If so, the intersection is empty. Union of viewpoint regions We conservatively approximate (i) each region R b and R f by their convex-hulls. Note that this does not compromise in finding the ideal cutting plane p, since any plane (i) that separates R f from R b also separates their convex-hulls. (i) Cutting plane Given the convex-hulls of R b and R f , we use linear programming to determine whether they intersect. If so, no cutting plane can separate them and the algorithm proceeds without (i) updating R f . Otherwise, we check if any of the bounding planes of the two regions is suitable as a cutting plane (i.e., all of the vertices of the other region lie on the opposite side of the plane). If that does not produce a valid cutting plane, then planes are formed using all possible combinations of vertices from one region and edges from the other region. At least one of these planes will necessarily separate the two convex-hulls and this becomes the candidate plane p.  In practice, we found that generating a single depth-presorted triangle list for the entire range of viewpoints requires far too many triangle duplications and leads to a list with many times as many triangles as the input model. By dividing the space of viewpoints into a small number of partitions and creating independent depth-presorted triangle lists for each partition, we get a much better trade-off between total memory usage and run-time performance (see results in section 6). To divide the space of view points into partitions, we first enclose the model in a bounding polyhedron with a given number of faces (we have experimented with 4, 6, 16, and 64). Each partition is defined by one of the polyhedron faces, and by the boundaries with neighboring partitions, as in figure 4 . By limiting the set of valid viewpoints to lie outside the bounding polyhedron, we further reduce the number of constraints in the occlusion graph. The preliminary order on which the preprocessing algorithm operates is simply a depth-sorted list of triangles relative to some viewpoint in the corresponding partition. The only further modification is that when computing the depth-presorted triangle list for each partition, all of the rendering regions E ? are further restricted to the corresponding partition. We experimented with different orientations for the polyhedron and obtained very similar results. Depth-presorted lists for each partition can be computed simultaneously, leveraging the parallelism of multi-core CPUs. The lists are concatenated into an index buffer with multiple segments. At run-time, we issue a draw call that renders the segment of the index buffer corresponding to the partition that contains the current viewpoint. This can be easily accomplished by specifying the starting buffer index and total number of triangles in the command that issues the draw call. Thus, the CPU performs the coarse-level viewpoint selection (which is trivial) and the GPU completes the fine-level triangle selection, as described below.\n            \n              Figure 4: Viewpoint partitioning optimization. To strike the proper balance between memory consumption and run-time performance, we generate independent depth-presorted triangle lists different parts of the viewpoint space.\n            \n            4.2 Viewpoint-space partitioning\n          \n        \n      \n      \n        5 Run-time selection algorithm\n        The task at run-time is to select those triangles from the depthpresorted list that pass a half-space test. Recall each triangle t is annotated by a test plane p t (a 4D vector storing the plane equation). To decide whether to render a triangle t from viewpoint v xyz , we use a single dot product, which is extremely efficient in modern GPUs:\n        \n          6\n          dot p t , [v xyz , ?1] > 0.\n        \n        For triangles with no associated test plane, we use p t = [0, 0, 0, ?1], which causes the test to always succeed. The test can be implemented in either the vertex, geometry, or fragment shader programmable pipeline stages. Although each alternative has advantages and disadvantages depending on the application and rendering configuration (see section 6), we favor the fragment shader test:  Option 1: Fragment shader (FS) The 4D plane vectors are kept in a 32-bit 4-channel texture indexed by triangle ID. (Although in practice the need has not arisen, it would be simple to encode an entire linked-list of test-planes in the texture.) The FS issues the lookup and performs the dot product. Since one dot product test is performed per triangle fragment, this method may suffer in pixelbound scenes. Fortunately, the tests are inexpensive and the texture access is coherent. Option 2: Vertex shader (VS) The 4D plane vectors are sent as vertex attributes. When the dot product test fails, the VS moves the vertex to the viewpoint position so that it gets culled by the near plane, otherwise it applies the standard vertex transformation. Since all three vertices of each triangle perform the same exact test, the result is consistent. The drawback of this approach is that triangles can no longer share vertices, which may impact vertex bound scenes. Option 3: Geometry shader (GS) The 4D plane vectors are kept in a 32-bit 4-channel texture indexed by triangle ID. The GS emits only the triangles that pass the dot product test. Although this is the most natural implementation, the additional pipeline stage can impact performance if the application is not already using a GS.\n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n        160:6\n        ?\n        G. Chen et al.\n        (solid) Partitioning 60 ratio 3 Fandisk Dragon Bunny (70k) (30k) (40k) 45 (dashed) size Feline (20k) ratio call 30 draw 2 memory 15 Avgerage 1 0 Total 4 6 16 64 Number of partitions\n        \n          Figure 5: Varying the number of segments as a trade-off between memory consumption and the size of each individual draw call.\n        \n      \n      \n        6 Results\n        In this section we discuss the performance and memory consumption of our approach. All experiments were conducted on an Intel R Xeon R 2.27GHz E5520 CPU with 12GB of RAM and an AMD Radeon HD 6970 GPU. We used models with resolutions ranging from 1,000 to 100,000 triangles, which we believe are representative of the resolution and depth complexity of most static models found in games. All renderings used alpha blending for proper semitransparency when rendering back-to-front as in figure 1 . The runtime performance results in figures 7, 8, and 9 are averaged over 256 viewpoints around the model and reported as ratios relative to a baseline standard rendering, measured directly in clock ticks. The baseline renders all input triangles in a order optimized for vertex-cache locality (completely disregarding depth-sorting). For example, if rendering a depth-sorted model with our method is twice as expensive as the baseline rendering, we report the performance ratio of two. Segment partitioning Figure 5 shows the effect of increasing the number of viewpoint partitions on the average number of triangles per segment (i.e, that are actually processed by the draw-call at run-time), as well as on the total memory consumption. The average draw call size is reported as a ratio to the number of triangles in the input triangle list. The total memory ratio is reported as a ratio to the total memory used by a standard triangle list with no duplicated triangles. The calculation assumes that each vertex contains a position, normal, and texture coordinates. Note that although increasing the number of partitions increases memory consumption, it reduces the average segment size. It is important to note that the total memory increase only happens for the transparent parts of models that have any transparency effect at all. Furthermore, the vast majority of memory in modern games is consumed by textures, with geometry lagging far behind. We found that using 6 viewpoint partitions provides a reasonable trade-off for the models we tested. The amount of memory used is not significantly higher than that of 4 partitions, but there is a marked decrease in average segment size. This translates to performance gains at rendering time. For the remainder of the experiments in this section we used 6 viewpoint partitions. Preprocessing Figure 6 shows the preprocessing time of our method. Depending on model and number of triangles, it can take anywhere between a few minutes to several hours to complete. The computation of different segments was parallelized using multiple CPU cores. While the preprocessing algorithm can be slow on large input, it is important to point out that it only needs to be executed once for each static model. Further optimizations could improve the preprocessing time, but we instead concentrated our efforts on optimizing for better run-time results, which is the ultimate goal. Rendering approaches Figure 7 compares performance of the three versions of our run-time selection procedure, each using a different stage of the pipeline. The geometry shader option is significantly slower due to the fact that it adds a new shading stage to the rendering pipeline. Therefore, we only see this option being viable when the rendering effect already requires a geometry shader, in which case it would require simply adding the plane test to an existing shader. The vertex shader and fragment shader versions are significantly faster. For very low-resolution models, the rendering is fill-bound, making the fragment shader option more costly. For mediumand high-resolution models, however, the vertex processing overhead of the vertex shader approach dominates. Thus, for most practical model sizes, the fragment shader option is the most efficient, with our algorithm being only 2?3? slower than baseline. Overall performance We compared the overall performance of our fragment shader algorithm with a selection of state-of-theart real-time depth-sorting algorithms: per-pixel dynamic linked lists (LL) [Yang et al. 2010], stochastic transparency (ST) [Enderton et al. 2010], and dual depth peeling (DDP) [Bavoil and Myers 2008]. ST is an approximate algorithm, while DDP and LL produce exact results. (DDP uses occlusion queries to ensure that no further passes are required and LL uses a sophisticated sorting operation that is not available in legacy hardware.) Tests were run for each of our models at 640?480 ( figure 8 ) and 1280?720 ( figure 9 ) screen resolutions to demonstrate the different trade-offs involved. Our algorithm is significantly faster than the alternatives, particularly at high screen resolutions. Conversely, the advantage of our method is even higher for smaller models. This is because the relative overhead of increasing pixel count is negligible in our method, in contrast to the effect of increasing input triangle count. Nevertheless, even at low screen resolutions and with larger models, our method is significantly faster than the alternatives. For our method to become slower than the alternatives, it would require the combination of an enormous amount of geometry with either small screen coverage (for pixel based approaches) or very small maximum depth-complexity (for depth-peeling approaches). Since GPUs are heavily optimized for batch processing with few large index buffers, our simpler, singlepass method is faster for practical scenarios of even up to several million of transparent triangles. Complex scene We tested our approach on a complex Room scene ( figure 10 ) consisting of a physical simulation with multiple semi-transparent dragons interacting and colliding with one another. We used a screen resolution of 1280?720 and 4X-MSAA. Refer to the accompanying video for the entire animation sequence. Intermodel depth-sorting was performed in the CPU using the models? convex bounding volumes, which are also used for collision detection. This is trivial and fast for a small number of objects. Since the convex bounding volumes are not allowed to inter-penetrate, the sorting results are guaranteed to be correct. Standard rendering ( figure 10a ) does not render the triangles of each model in depth sorted order and therefore yields an incorrect transparency effect. For example, the rear left foot of the dragon shown in the closeup appears very prominently even though it is behind the body. As expected, our method ( figure 10b ), LL, ST, and DDP generate correct results. We measured rendering time of the entire scene for a varying number of dragons ( figure 10c ), resulting in a scene geometric complexity of 40,000 to 2,000,000 triangles (1 to 50 dragons). Clearly, the performance is inversely proportional to the number of dragons in the scene and our method is significantly faster compared to other approaches. Furthermore, our method and DDP produce exact results, which is not the case for ST and LL with MSAA. Game scene To show that our method also applies to a more typical Game scene ( figure 11 ), we created another experiment including an animation sequence in which a character moves around a game scene with multiple solid objects and a semi-transparent model. Refer to the accompanying video for the entire animation sequence. To get a sense of the performance implications of our approach on these scenarios, we varied the resolution of our semi-transparent model in order to present our performance results as a function of the percentage of scene primitives that are semi-transparent. So, for instance, if approximately 15% of the game?s primitives are semitransparent, the slowdown for having the triangles in sorted order is just about 1.1?. On the other hand, in a more extreme scenario where the semi-transparent objects start to dominate by having 50% of the primitive count, the slowdown is a more significant 1.5?.\n        Preprocessing 10 (hour) 8 9 Dragon Bunny Fandisk time 7 6 Feline 5 Preprecessing 4 3 2 1 0 0 20k 40k 60k 80k 100k Model size (triangles)\n        \n          Figure 6: Preprocessing time for different meshes at different resolutions (all meshes preprocessed with 6 segments).\n        \n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n        Depth-Presorted Triangle Lists\n        ?\n        160:7\n        Bunny Dragon 14 14 VS ratio 12 GS 12 10 FS 10 Performance 8 6 6 8 4 4 2 2 0 20k 40k 60k 80k 0 20k 40k 60k 80k 100k Model size (triangles) Model size (triangles)\n        \n          Figure 7: Performance comparison between geometry shader, vertex shader, and fragment shader implementations. Dragon 256\n        \n        64 16 4 1 80k 0\n        Bunny 256 ratio 64 Performance 16 4 Ours DDP ST LL 1 0 20k 40k 60k Model size (triangles)\n        20k 40k 60k 80k 100k Model size (triangles)\n        \n          Figure 8: Performance comparison with related techniques using a screen resolution of 640?480. Dragon 256\n        \n        64 16 4 1 80k 0\n        Bunny 256 ratio 64 Ours Performance 16 4 DDP ST LL 1 0 20k 40k 60k Model size (triangles)\n        20k 40k 60k 80k 100k Model size (triangles)\n        \n          Figure 9: Performance comparison with related techniques using a screen resolution of 1280?720.\n        \n        Fandisk Feline 14 14 12 12 10 10 8 8 6 6 4 4 2 2 0 20k 40k 60k 80k 100k 120k 0 20k 40k 60k Model size (triangles) Model size (triangles)\n        Fandisk Feline 256 256\n        64 64 16 16 4 4 1 1 0 20k 40k 60k 80k 100k 120k 0 20k 40k 60k Model size (triangles) Model size (triangles)\n        Fandisk Feline 256 256\n        64 64 16 16 4 4 1 1 0 20k 40k 60k 80k 100k 120k 0 20k 40k 60k Model size (triangles) Model size (triangles)\n      \n      \n        7 Conclusion\n        We presented a new algorithm for efficient, exact, depth-sorted rendering of static triangle models. Our method produces a depthpresorted triangle list in which each triangle is annotated by test planes. These lists can be rendered in depth-sorted order using a single draw call. Given a viewpoint, a simple run-time culling procedure executed by the GPU rasterizes a subsequence of the triangles that produce a depth-sorted rendering of the model relative to that viewpoint. We show that this approach is significantly faster than the alternative methods. The main limitations of our method is\n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n        (a) Standard rendering\n        (b) Our result\n        \n          \n          Figure 10: Results and performance comparison of the room scene with a screen resolution of 1280?720 and 4X-MSAA.\n        \n        \n          \n          \n        \n        (a) Renderings with our approach\n        \n          Figure 11: Results and performance comparison of the game scene with a screen resolution of 1280?720 and 4X-MSAA.\n        \n        that it is only suitable for static models, and for viewpoints outside of a bounding polyhedron. However, we feel that there exists a wide range of applications for which these limitations do not matter. Finally, we believe that this novel selection based scheme using a single draw call is a significant departure from existing methods, most of which require either sorting or multipass rendering. We believe that this direction is worth further investigation, particularly on ways to handle deformable models. It would be interesting to consider generating a set of orders that, in conjunction, allow for a limited range of deformation at run-time. Alternatively, our finegrained triangle-level technique can be combined with coarse-level dynamic sorting to enable animated characters with rigid parts.\n      \n      \n        Acknowledgments\n        This work was partly supported by Hong Kong?s RGC GRF grant #619509 and by an INST grant from FAPERJ.\n      \n      \n        References\n        \n          A ILA , T., M IETTINEN , V., and N ORDLUND , P. 2003. Delay streams for graphics hardware. ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2003), 22(3):792?800.\n          B ARBER , C. B., D OBKIN , D. P., and H UHDANPAA , H. 1996. The quickhull algorithm for convex hulls. ACM Transactions on Mathematical Software, 22(4):469?483.\n          B AVOIL , L., C ALLAHAN , S. P., L EFOHN , A., C OMBA , J. L. D., and S ILVA , C. T. 2007. Multi-fragment effects on the GPU using the k-buffer. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 94?104.\n          B AVOIL , L. and M YERS , K. 2008. Order independent transparency with dual depth peeling. NVIDIA whitepaper.\n          B ERKELAAR , M., E IKLAND , K., and N OTEBAERT , P. 2004.\n          2 (c) Performance comparison  Game 2 ratio dragon bunny 1.75 time fandisk feline 1.5 armadillo Rendering 1.25 1 0 10 20 30 40 50 60 70 Semi-transparent primitives (%) (b) Performance comparison lp_solve 5.5, open source (mixed-integer) linear programming system. Software. C ALLAHAN , S. P., I KITS , M., C OMBA , J. L. D., and S ILVA , C. T. 2005. Hardware-assisted visibility sorting for unstructured volume rendering. IEEE Transactions on Visualization and Computer Graphics, 11(3):285?295.\n          C ARPENTER , L. 1984. The A-buffer, an antialiased hidden surface method. Computer Graphics (Proceedings of ACM SIGGRAPH 1984), 18(3):103?108.\n          C ARR , N., M ECH , R., and M ILLER , G. 2008. Coherent layer peeling for transparent high-depth-complexity scenes. In Proceedings of Graphics Hardware, 33?40.\n          C ATMULL , E. 1974. A Subdivision Algorithm for Computer Display of Curved Surfaces. PhD thesis, Dept. Computer Science.\n          C HEN , H.-M. and W ANG , W.-T. 1996. The feudal priority algorithm on hidden-surface removal. In Proceedings of ACM SIGGRAPH 1996, 55?64.\n          DX10 SDK. 2010. Microsoft Corporation. February 2010 release.\n          E NDERTON , E., S INTORN , E., S HIRLEY , P., and L UEBKE , D. 2010. Stochastic transparency. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 157?164.\n          E VERITT , C. 2001. Interactive order-independent transparency. NVIDIA whitepaper.\n          F OLEY , J. D., VAN D AM , A., F EINER , S. K., and H UGHES , J. F. 1990. Computer Graphics: Principles and Practice, chapter 16.5.1. Addison-Wesley, 2 nd edition.\n          F UCHS , H., K EDEM , Z. M., and N AYLOR , B. F. 1980. On visible surface generation by a priori tree structures. Computer Graphics (Proceedings of ACM SIGGRAPH 1980), 14(3):124?133.\n          F UKUSHIGE , S. and S UZUKI , H. 2006. Voronoi diagram depth sorting for polygon visibility ordering. In Proceedings of GRAPHITE ?06, 461?467.\n          G OAD , C. 1982. Special purpose automatic programming for hidden surface elimination. Computer Graphics (Proceedings of ACM SIGGRAPH 1982), 16(3):167?178.\n          H UANG , M.-C., L IU , F., L IU , X.-H., and W U , E.-H. 2010. Multifragment effects on the GPU using bucket sort. In W. Engel, editor, GPU Pro: Advanced Rendering Techniques, chapter VIII.1, 495? 508. A K Peters.\n          J ANSEN , J. and B AVOIL , L. 2010. Fourier opacity mapping. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 165?172.\n          J OUPPI , N. P. and C HANG , C.-F. 1999. Z 3 : An economical hardware technique for high-quality antialiasing and transparency. In Proceedings of Graphics Hardware, 85?93.\n          K ARP , R. M. 1972. Reducibility among combinatorial problems. In R. E. Miller and J. W. Thatcher, editors, Proceedings of Symposium on the Complexity of Computer Computations, 85?103.\n          K IM , T.-Y. and N EUMANN , U. 2001. Opacity shadow maps. In Proceedings of the Eurographics Workshop on Rendering Techniques, 177?182.\n          L AINE , S. and K ARRAS , T. 2011. Stratified sampling for stochastic transparency. Computer Graphics Forum (Proceedings of Eurographics Symposium on Rendering 2011), 30(4).\n          L IU , B.-Q., W EI , L.-Y., and X U , Y.-Q. 2006. Multi-layer depth peeling via fragment sort. Technical Report MSR-TR-2006-81, Microsoft Research Asia.\n          L IU , F., H UANG , M.-C., L IU , X.-H., and W U , E.-H. 2009. Efficient depth peeling via bucket sort. In Proceedings of the ACM Symposium on High Performance Graphics, 51?57.\n          L IU , F., H UANG , M.-C., L IU , X.-H., and W U , E.-H. 2010. FreePipe: A programmable parallel rendering architecture for efficient multi-fragment effects. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 75?82.\n          M AMMEN , A. 1989. Transparency and antialiasing algorithms implemented with the virtual pixel maps technique. IEEE Computer Graphics and Applications, 9(4):43?55.\n          M ARK , W. R. and P ROUDFOOT , K. 2001. The F-buffer: A rasterization-order FIFO buffer for multi-pass rendering. In Proceedings of Graphics Hardware, 57?64.\n          M ESHKIN , H. 2007. Sort-independent alpha blending. GDC Talk.\n          M ULDER , J. D., G ROEN , F. C. A., and VAN W IJK , J. J. 1998. Pixel masks for screen-door transparency. In Proceedings of Visualization ?98, 351?358.\n          M YERS , K. and B AVOIL , L. 2007. Stencil routed A-buffer. ACM SIGGRAPH Technical Sketch.\n          M YERS , K. and B AVOIL , L. 2007. Stencil routed k-buffer. NVIDIA whitepaper.\n          N EHAB , D., B ARCZAK , J., and S ANDER , P. V. 2006. Triangle order optimization for graphics hardware computation culling. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 207?211.\n          N EWELL , M. E., N EWELL , R. G., and S ANCHA , T. L. 1972. A new approach to the shaded picture problem. In Proceedings of the ACM National Conference.\n          P ATERSON , M. S. and Y AO , F. F. 1989. Binary partitions with applications to hidden surface removal and solid modelling. In Symposium on Computational Geometry, 23?32.\n          P ATNEY , A., T ZENG , S., and O WENS , J. D. 2010. Fragmentparallel composite and filter. Computer Graphics Forum (Proceedings of Eurographics Symposium on Rendering 2010), 29(4): 1251?1258.\n          P ORTER , T. and D UFF , T. 1984. Compositing digital images. Computer Graphics (Proceedings of ACM SIGGRAPH 1984), 18(3): 253?259.\n          S ALVI , M., M ONTGOMERY , J., and L EFOHN , A. 2011. Adaptive transparency. In Proceedings of the ACM Symposium on High Performance Graphics, 119?126.\n          S ANDER , P. V., N EHAB , D., and B ARCZAK , J. 2007. Fast triangle reordering for vertex locality and reduced overdraw. ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2007), 26 (3):89.\n          S CHUMACKER , R. A., B RAND , B., G ILLILAND , M. G., and S HARP , W. H. 1969. Study for applying computer-generated images to visual simulation. Technical Report AFHRL-TR-69-14, US Airforce Human Resources Laboratory.\n          S INTORN , E. and A SSARSSON , U. 2008. Real-time approximate sorting for self shadowing and transparency in hair rendering. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 157?162.\n          S INTORN , E. and A SSARSSON , U. 2009. Hair self shadowing and transparency depth ordering using occupancy maps. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), 67?74.\n          S KIENA , S. S. 2008. The Algorithm Design Manual, chapter 15.2. Springer, 2 nd edition.\n          T HIBIEROZ , N. 2008. Robust order-independent transparency via reverse depth peeling in DirectX 10. In W. Engel, editor, ShaderX6: Advanced Rendering Techniques, chapter 3.7, 211?226. Charles River Media.\n          W EXLER , D., G RITZ , L., E NDERTON , E., and R ICE , J. 2005. GPUaccelerated high-quality hidden surface removal. In Proceedings of Graphics Hardware, 7?14.\n          W ILLIAMS , P. L. 1992. Visibility-ordering meshed polyhedra. ACM Transactions on Graphics, 11(2):103?126.\n          W ITTENBRINK , C. M. 2001. R-buffer: a pointerless A-buffer hardware architecture. In Proceedings of Graphics Hardware, 73?80.\n          Y ANG , J. C., H ENSLEY , J., G R UN  ? , H., and T HIBIEROZ , N. 2010. Real-time concurrent linked list construction on the GPU. Computer Graphics Forum (Proceedings of Eurographics Symposium on Rendering 2010), 29(4):1297?1304.\n          Y UKSEL , C. and K EYSER , J. 2008. Deep opacity maps. Computer Graphics Forum (Proceedings of Eurographics 2008), 27(2):675? 680.\n        \n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n        Depth-Presorted Triangle Lists\n        ?\n        160:9\n        ACM Transactions on Graphics, Vol. 31, No. 6, Article 160, Publication Date: November 2012\n      \n    \n  ",
  "resources" : [ ]
}