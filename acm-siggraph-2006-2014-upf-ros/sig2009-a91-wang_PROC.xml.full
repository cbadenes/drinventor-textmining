{
  "uri" : "sig2009-a91-wang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a91-wang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "An Efficient GPU-based Approach for Interactive Global Illumination",
    "published" : "2009",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Minghao-Pan",
      "name" : "Minghao",
      "surname" : "Pan"
    }, {
      "uri" : "http://drinventor/Hujun-Bao",
      "name" : "Hujun",
      "surname" : "Bao"
    } ]
  },
  "bagOfWords" : [ "6352b89e134fb747befa74058cbb0a63682fa41a10f68206cd66e831cb6f9592", "oxe", "10.1145", "1531326.1531397", "name", "identification", "possible", "efficient", "gpu-based", "approach", "interactive", "global", "illumination", "Rui", "Wang", "Rui", "Wang", "Kun", "Zhou", "State", "Key", "Lab", "CAD&CG", "Zhejiang", "University", "paper", "present", "gpu-based", "method", "interactive", "global", "illumination", "integrate", "complex", "effect", "multi-bounce", "indirect", "lighting", "glossy", "reflection", "caustic", "arbitrary", "specular", "path", "we", "method", "build", "upon", "scatter", "datum", "sampling", "interpolation", "GPU", "we", "raytraced", "shade", "point", "partition", "they", "coherent", "shade", "cluster", "use", "adaptive", "seeding", "follow", "k-means", "each", "cluster", "center", "we", "apply", "final", "gather", "evaluate", "its", "incident", "irradiance", "use", "gpu-based", "photon", "mapping", "we", "approximate", "entire", "photon", "tree", "compact", "illumination", "cut", "thus", "reduce", "final", "gather", "cost", "each", "ray", "sample", "irradiance", "value", "interpolate", "all", "shade", "point", "produce", "rendering", "we", "method", "exploit", "spatial", "coherence", "illumination", "reduce", "sampling", "cost", "we", "sample", "sparsely", "distribution", "sample", "point", "conform", "underlie", "illumination", "change", "therefore", "we", "method", "both", "fast", "preserve", "high", "render", "quality", "although", "same", "property", "have", "be", "exploit", "previous", "caching", "adaptive", "sampling", "method", "method", "typically", "require", "sequential", "computation", "sample", "point", "make", "they", "ill-suited", "GPU", "contrast", "we", "select", "sample", "point", "adaptively", "single", "pass", "enable", "parallel", "computation", "result", "we", "algorithm", "run", "entirely", "GPU", "achieve", "interactive", "rate", "scene", "complex", "illumination", "effect", "keyword", "global", "illumination", "GPU", "photon", "mapping", "final", "gather", "k-means", "illumination", "cut", "introduction", "interactive", "computation", "global", "illumination", "major", "challenge", "computer", "graphic", "research", "today", "effect", "multi-bounce", "indirect", "lighting", "caustic", "complex", "surface", "reflection", "important", "visual", "cue", "perception", "photorealism", "synthesize", "image", "however", "conventional", "cpu-based", "algorithm", "simulation", "cost", "effect", "often", "too", "high", "permit", "dynamic", "interaction", "where", "user", "can", "simultaneously", "change", "lighting", "viewpoint", "material", "geometry", "expect", "accurate", "real-time", "feedback", "change", "rapidly", "increase", "computation", "power", "modern", "gpus", "much", "attention", "have", "be", "direct", "exploit", "GPU", "achieve", "interactive", "global", "illumination", "exist", "method", "however", "typically", "focus", "very", "limited", "set", "illumination", "effect", "instance", "gpu-based", "ambient", "occlusion", "-lsb-", "Shanmugam", "Arikan", "bution", "point", "conform", "actual", "irradiance", "change", "next", "each", "cluster", "center", "we", "perform", "final", "gather", "sample", "its", "incident", "radiance", "field", "due", "indirect", "lighting", "step", "use", "fast", "gpu-based", "photon", "mapping", "algorithm", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "accelerate", "density", "estimation", "final", "gather", "we", "approximate", "entire", "photon", "tree", "compact", "illumination", "cut", "compute", "dynamically", "GPU", "we", "interpolate", "sample", "irradiance", "value", "each", "shade", "point", "produce", "final", "render", "result", "we", "method", "also", "handle", "one-bounce", "low-frequency", "glossy", "reflection", "approximate", "both", "sample", "radiance", "field", "brdf", "onto", "spherical", "harmonic", "-lrb-", "sh", "-rrb-", "basis", "set", "select", "irradiance", "sample", "point", "adaptively", "single", "pass", "we", "eliminate", "sequential", "computation", "require", "standard", "caching", "base", "method", "result", "we", "algorithm", "enable", "parallel", "computation", "implement", "entirely", "GPU", "achieve", "interactive", "frame", "rate", "variety", "complex", "global", "illumination", "effect", "Figure", "show", "example", "we", "gpu-based", "solution", "can", "easily", "adapt", "other", "many-core", "platform", "intel?s", "upcome", "Larrabee", "-lsb-", "Seiler", "et", "al.", "2008", "-rsb-", "today?s", "chip", "design", "quickly", "switch", "streaming", "massively", "parallel", "processor", "model", "we", "believe", "essential", "develop", "new", "algorithm", "exploit", "architecture", "achieve", "interactive", "global", "illumination", "kunzhou@acm.org", "-lcb-", "rwang", "panminghao", "bao", "-rcb-", "@cad", "zju.edu.cn", "ruiwang@cs.umass.edu", "ACM", "Reference", "Format", "Wang", "R.", "Wang", "R.", "Zhou", "K.", "Pan", "M.", "Bao", "H.", "2009", "efficient", "gpu-based", "approach", "interactive", "global", "illumination", "ACM", "Trans", "graph", "28", "Article", "91", "-lrb-", "August", "2009", "-rrb-", "page", "dous", "10.1145", "1531326.1531397", "http://doi.acm.org/10.1145/1531326.1531397", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "fus", "rst", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "permissions@acm.org", "2009", "ACM", "0730-0301/2009", "03-art91", "10.00", "DOI", "10.1145", "1531326.1531397", "http://doi.acm.org/10.1145/1531326.1531397", "Minghao", "Pan", "Hujun", "Bao", "University", "Massachusetts", "Amherst", "Figure", "global", "illumination", "result", "render", "use", "we", "algorithm", "user", "can", "dynamically", "manipulate", "any", "part", "scene", "include", "lighting", "viewpoint", "material", "geometry", "1.5", "fp", "2007", "-rsb-", "simulate", "global", "shadow", "effect", "ignore", "interreflection", "approach", "base", "instant", "radiosity", "shadow", "mapping", "-lsb-", "Keller", "1997", "Dachsbacher", "Stamminger", "2005", "-rsb-", "compute", "single-bounce", "indirect", "lighting", "ignore", "caustic", "multibounce", "interreflection", "precomputed", "radiance", "transfer", "-lsb-", "Sloan", "et", "al.", "2002", "-rsb-", "incorporate", "many", "illumination", "effect", "entail", "large", "amount", "precomputed", "datum", "inefficient", "dynamic", "geometry", "material", "goal", "we", "work", "study", "gpu-based", "global", "illumination", "method", "integrate", "wide", "range", "illumination", "effect", "single", "algorithm", "allow", "sufficient", "flexibility", "we", "build", "upon", "kdtree", "base", "photon", "mapping", "recent", "work", "have", "successfully", "implement", "fast", "kd-tree", "modern", "gpus", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "achieve", "interactive", "caustic", "specular", "reflection", "however", "incorporate", "full", "global", "illumination", "effect", "remain", "challenging", "main", "difficulty", "reside", "final", "gather", "step", "which", "involve", "compute", "large", "number", "secondary", "ray", "can", "quickly", "saturate", "gpu?s", "computation", "power", "well-known", "final", "gather", "step", "can", "benefit", "greatly", "from", "exploit", "spatial", "coherence", "illumination", "change", "use", "irradiance", "caching", "-lsb-", "Ward", "et", "al.", "1988", "Tole", "et", "al.", "2002", "-rsb-", "unfortunately", "irradiance", "caching", "naturally", "amenable", "gpu?s", "data-parallel", "processing", "model", "because", "require", "sequential", "computation", "spatial", "sample", "point", "frequent", "update", "spatial", "structure", "store", "point", "result", "even", "though", "irradiance", "caching", "common", "practice", "cpu-based", "ray", "trace", "very", "few", "gpu-based", "solution", "have", "be", "able", "utilize", "those", "do", "typically", "have", "re-formulate", "algorithm", "ignore", "indirect", "shadow", "-lsb-", "Gautron", "et", "al.", "2005", "-rsb-", "similar", "irradiance", "caching", "we", "solution", "build", "upon", "spatial", "datum", "caching", "interpolation", "reduce", "sampling", "cost", "however", "derive", "practical", "gpu-based", "solution", "we", "main", "contribution", "robust", "method", "select", "irradiance", "sample", "point", "before", "final", "gather", "allow", "we", "perform", "all", "step", "global", "illumination", "parallel", "do", "so", "we", "partition", "raytraced", "shade", "point", "spatially", "coherent", "cluster", "we", "introduce", "method", "base", "adaptive", "sample", "seeding", "k-means", "compute", "partitioning", "efficiently", "GPU", "each", "cluster", "center", "now", "become", "spatial", "irradiance", "sample", "point", "we", "result", "show", "distrus", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "91:2", "R.", "Wang", "et", "al.", "related", "work", "cpu-based", "global", "illumination", "fundamental", "difficulty", "global", "illumination", "high", "computation", "cost", "incur", "indirect", "lighting", "where", "all", "surface", "contribute", "illumination", "scene", "instant", "radiosity", "-lsb-", "Keller", "1997", "-rsb-", "popular", "technique", "convert", "indirect", "illumination", "small", "set", "virtual", "point", "light", "-lrb-", "vpl", "-rrb-", "approach", "drastically", "reduce", "computation", "cost", "limit", "small", "number", "vpl", "only", "suitable", "primarily", "diffuse", "material", "photon", "mapping", "-lsb-", "Jensen", "2001", "-rsb-", "another", "popular", "solution", "involve", "photon", "scattering", "pass", "final", "gather", "pass", "accurately", "simulate", "indirect", "lighting", "complex", "scene", "large", "number", "photon", "need", "lead", "high", "computation", "cost", "-lsb-", "2002", "-rsb-", "Wald", "et", "al.", "implement", "interactive", "global", "illumination", "use", "cluster", "pc", "recently", "-lsb-", "Walter", "et", "al.", "2005", "-rsb-", "present", "LightCuts", "scalable", "method", "compute", "illumination", "from", "large", "number", "point", "light", "sublinear", "cost", "work", "aim", "high-quality", "rendering", "run", "offline", "caching", "interpolation", "since", "global", "illumination", "involve", "compute", "many", "ray", "common", "exploit", "coherence", "among", "ray", "reduce", "radiance", "sampling", "cost", "especially", "true", "indirect", "illumination", "which", "change", "smoothly", "make", "good", "candidate", "sparse", "sampling", "irradiance", "caching", "-lrb-", "ic", "-rrb-", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "popular", "technique", "progressively", "cache", "diffuse", "irradiance", "sample", "octree", "reuse", "they", "along", "computation", "radiance", "caching", "-lsb-", "riv", "nek", "Gautron", "2005", "-rsb-", "extend", "ic", "record", "directional", "radiance", "use", "spherical", "harmonic", "-lsb-", "1999", "-rsb-", "Bala", "et", "al.", "present", "general", "approach", "exploit", "both", "spatial", "temporal", "coherence", "ray", "radiance", "interpolation", "recently", "-lsb-", "Arikan", "et", "al.", "2005", "-rsb-", "introduce", "fast", "approximation", "global", "illumination", "decompose", "radiance", "field", "farand", "near-field", "component", "which", "compute", "separately", "improve", "efficiency", "general", "cache", "scheme", "require", "sequentially", "insert", "spatial", "sample", "point", "datum", "structure", "which", "have", "frequently", "query", "update", "during", "computation", "make", "they", "unsuitable", "gpu?s", "data-parallel", "computation", "model", "Render", "Cache", "-lsb-", "Walter", "et", "al.", "1999", "-rsb-", "reuse", "radiance", "sample", "from", "previous", "frame", "reproject", "they", "current", "frame", "follow", "insertion", "small", "number", "new", "sample", "exploit", "temporal", "coherence", "render", "take", "long", "time", "converge", "shade", "cache", "-lsb-", "Tole", "et", "al.", "2002", "-rsb-", "perform", "caching", "interpolation", "object", "space", "lead", "faster", "convergence", "improve", "render", "quality", "however", "require", "scene", "geometry", "subdivide", "patch", "which", "unsuitable", "complex", "model", "furthermore", "lighting", "geometry", "change", "lead", "noticeable", "temporal", "artifact", "gpu-based", "global", "illumination", "rapidly", "increase", "computation", "power", "modern", "gpus", "much", "recent", "work", "have", "focus", "gpu-based", "solution", "global", "illumination", "-lsb-", "nijasure", "et", "al.", "2005", "-rsb-", "sample", "incident", "radiance", "GPU", "uniform", "3d", "grid", "point", "use", "low-resolution", "fix", "sample", "method", "do", "provide", "high", "accuracy", "reflective", "shadow", "map", "-lsb-", "dachsbacher", "Stamminger", "2005", "-rsb-", "treat", "shadow", "map", "pixel", "project", "from", "direct", "light", "source", "indirect", "source", "illuminate", "scene", "use", "image-space", "computation", "method", "enable", "fast", "one-bounce", "indirect", "lighting", "do", "handle", "multi-bounce", "interreflection", "similarly", "radiance", "cache", "splatting", "-lsb-", "Gautron", "et", "al.", "2005", "-rsb-", "use", "image-based", "final", "gathering", "approximate", "irradiance", "caching", "while", "fast", "method", "ignore", "occlusion", "final", "gather", "step", "which", "important", "produce", "indirect", "shadow", "Matrix", "row-column", "sampling", "-lsb-", "ha", "san", "et", "al.", "2007", "-rsb-", "convert", "illumination", "many", "point", "light", "exploit", "GPU", "shadow", "map", "cluster", "they", "representative", "light", "compute", "shadowed", "illumination", "from", "each", "method", "do", "yet", "perform", "interactive", "rate", "imperfect", "shadow", "map", "-lsb-", "Ritschel", "et", "al.", "2008", "-rsb-", "evaluate", "approximate", "shadow", "map", "many", "point", "light", "single", "pass", "GPU", "dramatically", "improve", "computation", "speed", "due", "lack", "ray", "trace", "framework", "method", "only", "suitable", "primarily", "diffuse", "surface", "can", "handle", "caustic", "perfectly", "specular", "material", "Photon", "mapping", "first", "implement", "GPU", "-lsb-", "Purcell", "et", "al.", "2003", "-rsb-", "use", "uniform", "grid", "structure", "store", "photon", "rendering", "take", "several", "seconds", "converge", "-lsb-", "hachisuka", "2005", "-rsb-", "introduce", "fast", "acceleration", "method", "final", "gather", "use", "GPU", "rasterization", "greatly", "improve", "offline", "render", "speed", "-lsb-", "Wyman", "Davis", "2006", "-rsb-", "propose", "image-space", "caustic", "algorithm", "capable", "simulate", "plausible", "caustic", "effect", "real-time", "method", "aim", "include", "other", "global", "illumination", "effect", "recently", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "introduce", "fast", "gpu-based", "kd-tree", "algorithm", "real-time", "ray", "trace", "caustic", "however", "incorporate", "general", "illumination", "effect", "remain", "unsolved", "framework", "we", "method", "build", "upon", "algorithm", "we", "extend", "work", "include", "complex", "illumination", "effect", "multi-bounce", "interreflection", "caustics-incurred", "indirect", "lighting", "algorithm", "section", "provide", "overview", "we", "algorithm", "we", "focus", "scene", "where", "direct", "light", "source", "point", "light", "so", "direct", "illumination", "can", "compute", "real-time", "use", "gpu-based", "ray", "trace", "incorporate", "area", "environment", "lighting", "possible", "would", "require", "efficient", "method", "compute", "shadowed", "direct", "illumination", "from", "they", "therefore", "follow", "we", "focus", "discuss", "computation", "indirect", "illumination", "we", "assume", "scene", "material", "either", "diffuse", "perfectly", "specular", "standard", "method", "we", "can", "extend", "diffuse", "reflection", "one", "final", "bounce", "glossy", "reflection", "use", "spherical", "harmonic", "accord", "render", "equation", "-lsb-", "Kajiya", "1986", "-rsb-", "outgoing", "radiance", "shading", "point", "view", "direction", "compute", "follow", "integral", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "efficient", "gpu-based", "approach", "interactive", "global", "illumination", "91:3", "figure", "diagram", "show", "we", "main", "building", "block", "shaded", "box", "mark", "main", "contribution", "paper", "where", "incident", "radiance", "due", "indirect", "illumination", "incident", "direction", "surface", "brdf", "hemisphere", "center", "around", "surface", "normal", "irradiance", "use", "photon", "mapping", "-lsb-", "Jensen", "2001", "-rsb-", "we", "can", "evaluate", "two", "pass", "first", "pass", "emit", "scatter", "photon", "from", "main", "light", "source", "build", "global", "photon", "map", "caustic", "photon", "map", "each", "photon", "map", "store", "kd-tree", "efficient", "access", "second", "pass", "perform", "final", "gather", "send", "many", "secondary", "ray", "sample", "its", "incident", "radiance", "field", "radiance", "along", "each", "ray", "evaluate", "use", "density", "estimation", "photon", "map", "integrate", "cosine", "function", "accord", "eq", "accurate", "render", "large", "number", "final", "gather", "ray", "need", "compute", "result", "evaluate", "integral", "every", "shading", "point", "impractical", "interactive", "setting", "we", "goal", "reduce", "spatial", "sampling", "cost", "evaluate", "incident", "radiance", "only", "small", "number", "shade", "point", "indirect", "illumination", "change", "smoothly", "over", "scene", "sparse", "sample", "provide", "good", "approximation", "interpolation", "remain", "shade", "point", "while", "idea", "spatial", "caching", "have", "long", "be", "exploit", "irradiance", "caching", "adaptive", "sampling", "method", "method", "require", "sample", "point", "progressively", "insert", "spatial", "structure", "-lrb-", "i.e.", "kd-tree", "-rrb-", "which", "repeatedly", "update", "during", "computation", "computation", "model", "unsuitable", "direct", "GPU", "mapping", "avoid", "sequential", "computation", "we", "select", "irradiance", "sample", "point", "ahead", "time", "single", "pass", "allow", "we", "perform", "subsequent", "computation", "parallel", "GPU", "even", "spatial", "caching", "density", "estimation", "each", "secondary", "ray", "still", "quite", "expensive", "due", "large", "number", "photon", "store", "kd-tree", "reduce", "cost", "we", "introduce", "efficient", "approach", "approximate", "photon", "tree", "illumination", "cut", "which", "dynamically", "construct", "GPU", "center", "each", "cut", "node", "represent", "illumination", "cluster", "we", "use", "radial", "basis", "function", "-lrb-", "rbf", "-rrb-", "smoothly", "interpolate", "between", "they", "illumination", "cut", "size", "much", "smaller", "than", "total", "number", "photon", "we", "achieve", "significant", "speedup", "density", "estimation", "figure", "show", "main", "building", "block", "we", "algorithm", "first", "we", "build", "kd-tree", "scene", "GPU", "utilize", "ray", "trace", "photon", "mapping", "step", "follow", "kd-tree", "algorithm", "present", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "next", "we", "take", "shade", "point", "compute", "from", "ray", "trace", "partition", "they", "1000", "6000", "shade", "cluster", "base", "each", "point?s", "geometric", "information", "clustering", "compute", "use", "gpu-based", "adaptive", "sample", "seeding", "follow", "k-means", "we", "perform", "final", "gather", "each", "cluster", "center", "sample", "its", "incident", "radiance", "field", "order", "reduce", "cost", "density", "estimation", "we", "approximate", "global", "photon", "map", "compact", "illumination", "cut", "contain", "4000", "8000", "node", "each", "node?s", "center", "we", "evaluate", "cache", "irradiance", "value", "use", "density", "estimation", "global", "photon", "map", "result", "perform", "density", "estimation", "illumination", "cut", "signifus", "cantly", "faster", "than", "full", "photon", "tree", "finally", "we", "interpolate", "sample", "irradiance", "value", "all", "shade", "point", "produce", "indirect", "lighting", "result", "further", "combine", "direct", "lighting", "caustic", "produce", "final", "image", "3.1", "gpu-based", "kd-tree", "we", "algorithm", "require", "use", "kd-tree", "number", "step", "include", "ray", "trace", "photon", "mapping", "k-means", "clustering", "radiance", "interpolation", "therefore", "efficient", "kd-tree", "implementation", "important", "we", "follow", "method", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "build", "kdtree", "real-time", "use", "nvidia?s", "CUDA", "method", "construct", "kd-tree", "breadth", "first", "order", "-lrb-", "bf", "-rrb-", "use", "greedy", "top-down", "approach", "which", "recursively", "split", "current", "kd-tree", "node", "two", "sub-node", "efficient", "GPU", "processing", "node", "classify", "either", "large", "small", "base", "number", "geometric", "primitive", "belong", "they", "fast", "traversal", "kd-tree", "standard", "stackbased", "method", "implement", "maintain", "local", "stack", "each", "thread", "gpu?s", "share", "memory", "use", "algorithm", "Zhou", "et", "al.", "achieve", "real-time", "performance", "direct", "lighting", "caustic", "direct", "Lighting", "follow", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "we", "use", "ray", "trace", "compute", "direct", "lighting", "follow", "step", "-rrb-", "build", "kdtree", "scene", "trace", "eye", "ray", "parallel", "-rrb-", "collect", "ray", "hit", "non-specular", "surface", "use", "parallel", "list", "compaction", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "-rrb-", "similarly", "collect", "ray", "hit", "specular", "surface", "spawn", "reflect", "refract", "ray", "they", "-rrb-", "repeat", "step", "additional", "bounce", "-rrb-", "all", "non-specular", "hit", "point", "perform", "shadow", "test", "compute", "direct", "shading", "parallel", "shade", "point", "collection", "non-specular", "hit", "point", "step", "-rrb-", "above", "define", "we", "shade", "point", "represent", "all", "point", "either", "directly", "visible", "visible", "after", "specular", "path", "note", "absence", "specular", "object", "we", "can", "directly", "produce", "shade", "point", "via", "rasterization", "however", "specular", "object", "compute", "shade", "point", "require", "ray", "trace", "building", "Photon", "Maps", "we", "shoot", "photon", "from", "direct", "light", "source", "scatter", "they", "scene", "store", "they", "photon", "map", "when", "hit", "non-specular", "surface", "photon", "store", "global", "photon", "map", "its", "immediate", "previous", "hit", "non-specular", "surface", "otherwise", "we", "store", "caustic", "photon", "map", "we", "build", "kd-tree", "each", "photon", "map", "afterwards", "3.2", "select", "Irradiance", "Sample", "Points", "we", "next", "step", "select", "among", "all", "shade", "point", "small", "set", "representative", "point", "sampling", "incident", "irradiance", "because", "point", "use", "interpolation", "remain", "shade", "point", "need", "carefully", "select", "preserve", "underlie", "illumination", "change", "standard", "caching", "base", "scheme", "achieve", "progressively", "insert", "sample", "point", "exist", "set", "decision", "insert", "more", "sample", "base", "local", "variation", "irradiance", "sample", "already", "store", "set", "reduce", "datum", "parallelism", "since", "insertion", "sample", "irradiance", "evaluation", "dependent", "upon", "each", "other", "-lsb-", "ha", "san", "et", "al.", "2006", "-rsb-", "importance", "sampling", "method", "introduce", "distribute", "gather", "point", "direct-to-indirect", "transfer", "computation", "use", "variation", "photon", "mapping", "estimate", "importance", "triangle", "scene", "while", "require", "progressive", "insertion", "method", "unsuitable", "on-the-fly", "sample", "generation", "due", "expensive", "computation", "we", "solution", "find", "error", "metric", "can", "reliably", "predict", "actual", "irradiance", "change", "base", "scene?s", "geometric", "information", "allow", "we", "select", "sample", "point", "advance", "before", "irradiance", "evaluation", "step", "begin", "use", "metric", "we", "can", "partition", "shade", "point", "coherent", "shade", "cluster", "center", "each", "cluster", "become", "irradiance", "sample", "point", "do", "so", "we", "use", "modify", "version", "illumination", "change", "term", "introduce", "irradiance", "caching", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "define", "we", "error", "metric", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "91:4", "R.", "Wang", "et", "al.", "-lrb-", "-rrb-", "where", "shading", "point", "classify", "center", "position", "cluster", "denote", "surface", "normal", "weighting", "factor", "determine", "relative", "importance", "position", "normal", "incur", "change", "typically", "vary", "between", "0.1", "0.5", "we", "experiment", "-lrb-", "after", "scene", "geometry", "scale", "normalize", "-rrb-", "similar", "irradiance", "caching", "metric", "compute", "purely", "from", "geometric", "property", "intuition", "point", "geometrically", "close", "each", "other", "likely", "receive", "similar", "incident", "illumination", "note", "we", "have", "omit", "harmonic", "distance", "term", "original", "definition", "from", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "because", "evaluate", "require", "final", "gathering", "which", "what", "we", "would", "like", "avoid", "computing", "stage", "however", "we", "introduce", "adaptive", "sample", "seed", "approach", "account", "effect", "term", "explain", "below", "adaptive", "seeding", "Sample", "Points", "term", "original", "irradiance", "cache", "formulation", "account", "effect", "area", "close", "other", "surface", "likely", "experience", "rapid", "illumination", "change", "therefore", "more", "sample", "point", "should", "distribute", "account", "effect", "we", "use", "approximation", "distribute", "initial", "sample", "point", "accord", "local", "geometric", "variation", "scene", "order", "seed", "sample", "point", "we", "use", "hierarchical", "histogram-based", "method", "evaluate", "geometric", "variation", "image", "space", "we", "construct", "static", "screen-space", "quadtree", "all", "shade", "point", "can", "do", "trivially", "since", "shade", "point", "have", "one-to-one", "mapping", "screen", "pixel", "each", "quadtree", "node", "we", "compute", "its", "geometric", "variation", "accord", "eq", "treat", "all", "shade", "point", "belong", "quadtree", "node", "cluster", "we", "initialize", "average", "position", "normal", "each", "node", "we", "compute", "efficiently", "GPU", "evaluate", "all", "quadtree", "node", "parallel", "follow", "step", "we", "seed", "initial", "sample", "point", "hierarchically", "accord", "magnitude", "specifically", "we", "from", "root", "node", "quadtree", "each", "node", "we", "distribute", "sample", "point", "its", "four", "child", "node", "proportion", "its", "child", "node", "when", "node", "have", "only", "one", "sample", "distribute", "we", "use", "jitter", "sampling", "randomly", "select", "sample", "point", "within", "quad", "we", "process", "each", "level", "quadtree", "parallel", "k-means", "cluster", "after", "initial", "seeding", "we", "refine", "sample", "point", "use", "k-means", "partition", "all", "shade", "point", "coherent", "cluster", "do", "so", "we", "treat", "seed", "point", "we", "initial", "cluster", "center", "follow", "standard", "k-means", "classify", "every", "shading", "point", "its", "closest", "center", "use", "metric", "define", "eq", "after", "every", "shading", "point", "classify", "we", "recompute", "cluster", "center", "even", "GPU", "above", "algorithm", "still", "quite", "expensive", "run", "main", "bottleneck", "find", "nearest", "cluster", "center", "every", "shading", "point", "which", "incur", "computation", "cost", "linear", "use", "brute-force", "approach", "reduce", "cost", "we", "need", "avoid", "search", "among", "all", "cluster", "center", "do", "so", "we", "build", "kdtree", "all", "cluster", "center", "beginning", "each", "k-means", "iteration", "every", "shading", "point", "classify", "we", "utilize", "kd-tree", "constrain", "search", "within", "small", "euclidean", "distance", "shade", "point", "thereby", "significantly", "reduce", "search", "range", "Figure", "-lrb-", "-rrb-", "show", "we", "clustering", "result", "Cornell", "box", "scene", "compute", "1600", "cluster", "-lrb-", "-rrb-", "show", "cluster", "center", "top", "accurate", "irradiance", "image", "compute", "use", "offline", "raytracing", "note", "area", "rapid", "illumination", "change", "sample", "densely", "small", "cluster", "while", "those", "slow", "change", "sample", "sparsely", "large", "cluster", "example", "demonstrate", "sample", "we", "select", "conform", "underlie", "illumination", "change", "temporal", "coherence", "since", "we", "recompute", "irradiance", "sample", "point", "among", "shade", "point", "every", "frame", "we", "method", "viewdependent", "subject", "temporal", "artifact", "example", "camera", "move", "quickly", "select", "irradiance", "sample", "point", "differ", "from", "frame", "frame", "cause", "potential", "flicker", "artifact", "reduce", "artifact", "we", "attempt", "preserve", "temporal", "coherence", "among", "sample", "point", "beginning", "each", "new", "frame", "we", "fix", "cluster", "center", "compute", "from", "previous", "frame", "estimate", "whether", "every", "shading", "point", "new", "frame", "can", "classify", "exist", "cluster", "do", "so", "we", "keep", "each", "cluster", "largest", "error", "-lrb-", "eq", "-rrb-", "its", "current", "member", "cluster", "center", "use", "value", "threshold", "check", "whether", "new", "shade", "point", "can", "classify", "cluster", "end", "estimation", "we", "eliminate", "those", "cluster", "do", "have", "any", "shading", "point", "associate", "they", "other", "hand", "we", "create", "new", "cluster", "all", "shade", "point", "can", "classify", "new", "cluster", "generate", "use", "same", "algorithm", "describe", "above", "overall", "we", "maintain", "roughly", "same", "number", "shade", "cluster", "-lrb-", "hence", "irradiance", "sample", "point", "-rrb-", "each", "frame", "Figure", "-lrb-", "-rrb-", "show", "we", "clustering", "result", "Cornell", "box", "scene", "compute", "1600", "cluster", "-lrb-", "-rrb-", "display", "cluster", "center", "top", "raytraced", "reference", "show", "actual", "irradiance", "value", "average", "position", "normal", "all", "cluster", "member", "we", "repeat", "step", "until", "either", "clustering", "converge", "maximum", "number", "iteration", "have", "be", "reach", "finally", "each", "cluster", "we", "pick", "shading", "point", "smallest", "error", "we", "irradiance", "sample", "point", "3.3", "reduce", "cost", "final", "Gather", "once", "irradiance", "sample", "point", "select", "we", "sample", "incident", "radiance", "field", "send", "250", "500", "final", "gather", "ray", "distribute", "accord", "pdf", "cosine", "function", "evaluate", "radiance", "each", "final", "gather", "ray", "standard", "photon", "mapping", "require", "density", "estimation", "which", "perform", "knn", "search", "photon", "tree", "find", "nearby", "photon", "around", "ray?s", "hit", "point", "due", "large", "number", "photon", "search", "cost", "typically", "quite", "high", "reduce", "cost", "we", "goal", "use", "smaller", "set", "sample", "approximate", "illumination", "represent", "large", "number", "photon", "idea", "perform", "knn", "search", "reduce", "set", "point", "significantly", "improve", "search", "speed", "we", "achieve", "reduction", "dynamically", "compute", "illumination", "cut", "from", "photon", "tree", "although", "-lsb-", "Walter", "et", "al.", "2005", "-rsb-", "have", "introduce", "efficient", "method", "compute", "cut", "from", "set", "diffuse", "point", "light", "here", "we", "present", "new", "approach", "compute", "illumination", "cut", "directly", "from", "photon", "map", "more", "amenable", "GPU", "do", "so", "we", "first", "estimate", "approximate", "irradiance", "each", "photon", "tree", "node", "compute", "its", "illumination", "density", "define", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "efficient", "gpu-based", "approach", "interactive", "global", "illumination", "91:5", "i?p", "-lrb-", "-rrb-", "where", "power", "photon", "belong", "node", "incoming", "direction", "photon", "normal", "node", "center", "maximum", "side", "length", "node?s", "bound", "box", "equivalent", "perform", "density", "estimation", "use", "all", "photon", "area", "estimation", "overestimate", "search", "neighborhood", "reduce", "estimation", "cost", "note", "compute", "store", "when", "kd-tree", "photon", "map", "build", "thus", "we", "do", "have", "compute", "separately", "we", "next", "step", "find", "cut", "through", "tree", "approximate", "illumination", "give", "approximate", "irradiance", "each", "node", "coarse", "tree-cut", "select", "from", "photon", "tree", "parallel", "first", "node", "irradiance", "larger", "than", "predefined", "threshold", "min", "select", "add", "cut", "different", "level", "tree", "traverse", "iteratively", "ensure", "construction", "valid", "complete", "tree-cut", "do", "delete", "node", "whose", "child", "already", "cut", "add", "node", "cover", "leaf", "node", "do", "have", "parent", "represent", "they", "cut", "we", "pick", "threshold", "min", "average", "node", "12", "13-th", "level", "photon", "tree", "base", "heuristic", "initial", "illumination", "cut", "should", "close", "its", "target", "size", "which", "approximately", "4k", "8k", "give", "coarse", "tree", "cut", "we", "perform", "optimization", "improve", "its", "accuracy", "do", "compare", "accurate", "irradiance", "evaluate", "node", "p?s", "center", "use", "standard", "density", "estimation", "approximate", "irradiance", "compute", "above", "difference", "between", "two", "larger", "than", "user", "define", "threshold", "-lrb-", "which", "we", "typically", "set", "1.2", "-rrb-", "node", "remove", "from", "cut", "replace", "its", "child", "node", "thereby", "improve", "its", "accuracy", "we", "perform", "iteration", "refinement", "during", "each", "iteration", "node", "independently", "compute", "parallel", "once", "cut", "select", "each", "node", "cut", "become", "sample", "point", "illumination", "we", "therefore", "cache", "accurate", "irradiance", "value", "center", "each", "node", "use", "value", "smooth", "interpolation", "we", "use", "set", "spatial", "radial", "basis", "function", "-lrb-", "rbf", "-rrb-", "center", "each", "cut", "node", "interpolation", "basis", "specifically", "give", "hit", "point", "final", "gather", "ray", "radiance", "ray", "evaluate", "locate", "set", "nearby", "cut", "node", "interpolate", "from", "they", "use", "follow", "weight", "-lrb-", "-rrb-", "max", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "maximum", "side", "length", "node", "bound", "box", "note", "subtree", "define", "from", "root", "photon", "tree", "illumination", "cut", "can", "use", "directly", "kd-tree", "neighborhood", "search", "intuitively", "each", "node", "influence", "its", "surrounding", "space", "up", "size", "its", "bound", "box", "quadratic", "falloff", "weight", "indirect", "lighting", "global", "illumination", "figure", "Glass", "cube", "embedded", "torus", "Cornel", "box", "scene", "indirect", "lighting", "global", "illumination", "figure", "Cornell", "box", "animated", "water", "surface", "3.4", "interpolation", "rendering", "represent", "Radiance", "Fields", "use", "SH", "order", "allow", "glossy", "brdf", "final", "bounce", "similar", "previous", "work", "we", "approximate", "directional", "information", "sample", "radiance", "field", "-lrb-", "-rrb-", "use", "spherical", "harmonic", "-lrb-", "sh", "-rrb-", "basis", "-lrb-", "-rrb-", "where", "degree", "order", "sh", "function", "respectively", "we", "use", "4-th", "order", "sh", "we", "experiment", "result", "16", "project", "coefficient", "represent", "vector", "-lrb-", "-rrb-", "diffuse", "material", "we", "can", "treat", "sample", "irradiance", "value", "sh", "vector", "non-zero", "dc", "term", "while", "all", "other", "term", "zero", "interpolation", "render", "we", "interpolate", "irradiance", "value", "store", "each", "irradiance", "sample", "point", "glossy", "material", "we", "interpolate", "sh", "coefficient", "instead", "integrate", "result", "glossy", "brdf", "-lrb-", "also", "project", "onto", "sh", "-rrb-", "step", "require", "scatter", "datum", "interpolation", "which", "involve", "find", "nearby", "irradiance", "sample", "point", "each", "shade", "point", "perform", "smooth", "interpolation", "before", "we", "use", "kd-tree", "irradiance", "sample", "point", "efficient", "neighborhood", "search", "we", "perform", "interpolation", "same", "way", "irradiance", "caching", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "j?s", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "j?s", "-lrb-", "-rrb-", "where", "set", "nearby", "irradiance", "sample", "point", "located", "around", "shading", "point", "sample", "-lrb-", "-rrb-", "denote", "sh", "coefficient", "-lrb-", "-rrb-", "interpolation", "weight", "compute", "-lrb-", "-rrb-", "x?s", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "where", "harmonic", "mean", "distance", "object", "visible", "from", "evaluate", "during", "final", "gather", "keep", "track", "intersection", "distance", "each", "final", "gather", "ray", "perform", "parallel", "reduction", "afterwards", "compute", "harmonic", "distance", "lighting", "complex", "scene", "while", "we", "could", "increase", "number", "sample", "point", "we", "believe", "more", "appropriate", "approach", "would", "combine", "ours", "image-based", "occlusion", "method", "-lsb-", "Ritschel", "et", "al.", "2009", "-rsb-", "near-field", "illumination", "search", "-lsb-", "Arikan", "et", "al.", "2005", "-rsb-", "better", "compensate", "miss", "local", "detail", "second", "due", "use", "low-order", "sh", "we", "final", "gather", "step", "limit", "low-frequency", "glossy", "material", "fact", "happen", "reason", "why", "low-dimensional", "illumination", "cut", "suffice", "provide", "high", "quality", "result", "semus", "highly", "glossy", "material", "however", "we", "current", "approach", "inefficient", "material", "would", "require", "much", "longer", "illumination", "cut", "cause", "reduce", "search", "speed", "note", "since", "we", "keep", "full", "global", "photon", "map", "memory", "we", "could", "use", "perform", "more", "accurate", "density", "estimation", "highly", "glossy", "material", "remain", "direction", "we", "future", "work", "addition", "we", "recompute", "irradiance", "sample", "from", "scratch", "each", "frame", "we", "method", "subject", "temporal", "flicker", "artifact", "although", "we", "clustering", "method", "have", "incorporate", "temporal", "coherence", "irradiance", "sample", "artifact", "still", "difficult", "avoid", "completely", "one", "possible", "solution", "introduce", "temporal", "filter", "blend", "new", "irradiance", "value", "across", "adjacent", "frame", "finally", "work", "we", "encounter", "many", "engineering", "challenge", "successfully", "implement", "we", "algorithm", "onto", "GPU", "we", "believe", "because", "algorithm", "unsuitable", "GPU", "rather", "because", "fundamental", "challenge", "parallelize", "exist", "sequential", "algorithm", "give", "emerge", "trend", "many-core", "architecture", "design", "we", "believe", "develop", "new", "algorithm", "exploit", "architecture", "longer", "mere", "engineering", "practice", "necessity", "continued", "performance", "improvement", "future", "generation", "hardware", "acknowledgement", "we", "would", "like", "thank", "SIGGRAPH", "reviewer", "thoughtful", "comment", "work", "support", "part", "nsfc", "-lrb-", "no.", "60825201", "-rrb-", "973", "program", "China", "-lrb-", "No.", "2009cb320801", "-rrb-", "NSF", "CAREER", "grant", "ccf-0746577", "author", "would", "like", "thank", "NVIDIA", "generous", "donation", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "91:6", "R.", "Wang", "et", "al.", "-lrb-", "-rrb-", "5k", "irradiance", "sample", "-lrb-", "-rrb-", "16", "error", "image", "-lrb-", "-rrb-", "4k", "illumination", "Cut", "-lrb-", "-rrb-", "Ours", "-lrb-", "-rrb-", "Reference", "-lrb-", "-rrb-", "error", "image", "figure", "comparison", "indirect", "illumination", "result", "reference", "image", "first", "row", "show", "kitchen", "scene", "-lrb-", "-rrb-", "compute", "5k", "irr-adiance", "sample", "full", "photon", "map", "-lrb-", "-rrb-", "compute", "every", "shading", "point", "illumination", "cut", "size", "4k", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "show", "magnify", "error", "image", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "against", "reference", "-lrb-", "-rrb-", "second", "row", "show", "same", "comparison", "two", "additional", "scene", "where", "result", "use", "comparison", "compute", "use", "parameter", "list", "Table", "3.5", "Implementation", "Scene", "Tris", "G/C", "photon", "S.C.", "I.", "cut", "fp", "Box", "torus", "0.6", "239k/100k", "1.6", "4k", "4.2", "we", "have", "implement", "all", "we", "algorithm", "use", "bsgp", "-lsb-", "Hou", "et", "al.", "Box", "water", "17k", "268k/277k", "1.8", "8k", "2.7", "2008", "-rsb-", "general-purpose", "programming", "interface", "suitable", "elephant", "87k", "256k/24k", "3k", "4k", "3.1", "many-core", "architecture", "GPU", "bsgp", "build", "top", "elephant", "84k", "290k/107k", "4k", "4k", "2.5", "nvidia?s", "CUDA", "easier", "read", "write", "maintain", "we", "alkitchen", "21k", "470k/109k", "5k", "8k", "1.5", "gorithm", "make", "frequent", "use", "standard", "parallel", "computation", "prim", "Table", "table", "report", "each", "scene", "number", "triangle", "itive", "scan", "reduction", "list", "compaction", "segmented", "verglobal/caustics", "photon", "shade", "cluster", "-lrb-", "i.e.", "irradiance", "sample", "sion", "they", "directly", "available", "bsgp", "library", "point", "-rrb-", "illumination", "cut", "size", "render", "fp", "addition", "we", "require", "efficient", "GPU", "implementation", "kdtree", "which", "we", "follow", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "Demo", "Scenes", "Table", "summarize", "scene", "use", "demonstration", "first", "scene", "Cornell", "box", "glass", "cube", "most", "we", "datum", "element", "store", "dynamic", "array", "GPU", "embedded", "torus", "-lrb-", "figure", "-rrb-", "demonstrate", "complex", "caustic", "effect", "linear", "memory", "avoid", "high", "overhead", "repeat", "allocafrom", "cube", "global", "illumination", "effect", "torus", "inside", "tion", "memory", "we", "implement", "standard", "dynamic", "array", "managethe", "box", "second", "scene", "contain", "animated", "water", "surface", "ment", "routine", "which", "reserve", "initial", "amount", "memory", "-lrb-", "Figure", "-rrb-", "demonstrate", "both", "reflective", "refractive", "caustic", "efgpu", "double", "array", "size", "whenever", "space", "run", "out", "fect", "from", "water", "surface", "note", "illumination", "object", "structure", "many", "field", "k-means", "cluster", "we", "use", "below", "water", "come", "entirely", "from", "caustic", "type", "light", "structure", "array", "-lrb-", "soa", "-rrb-", "instead", "array", "structure", "-lrb-", "ao", "-rrb-", "path", "-lrb-", "-rrb-", "would", "very", "difficult", "simulate", "previous", "achieve", "global", "memory", "coalesce", "GPU", "interactive", "method", "both", "scene", "we", "show", "decomposition", "global", "illumination", "direct", "caustic", "component", "inalgorithm", "detail", "various", "parameter", "we", "use", "can", "find", "direct", "lighting", "component", "show", "left", "each", "image", "section", "3.1", "3.4", "clarity", "we", "have", "include", "pseudo-code", "we", "algorithm", "supplemental", "material", "attach", "paper", "third", "scene", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "show", "elephant", "model", "dynamically", "change", "material", "property", "scene", "demonstrate", "light", "path", "general", "we", "can", "handle", "all", "light", "path", "form", "capability", "we", "solution", "handle", "view-dependent", "indirect", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "stand", "lighting", "specular", "light", "final", "bounce", "glossy", "reflection", "enable", "prodiffuse", "-lrb-", "low-frequency", "-rrb-", "glossy", "respectively", "practice", "we", "ject", "both", "sample", "incident", "radiance", "field", "brdf", "onto", "4-th", "limit", "number", "indirect", "bounce", "therefore", "we", "compute", "order", "sh", "note", "color", "bleeding", "effect", "from", "elephant", "bounce", "altogether", "include", "final", "gather", "bounce", "we", "result", "wall", "floor", "because", "direct", "light", "source", "point", "away", "from", "show", "improvement", "quality", "beyond", "bounce", "small", "elephant", "color", "bleeding", "effect", "only", "enable", "through", "multi-bounce", "interreflection", "fourth", "scene", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "con4", "result", "tain", "animated", "elephant", "model", "rotate", "mirror", "demonstrate", "global", "illumination", "effect", "cause", "photon", "reflect", "from", "mirror", "bounce", "inside", "box", "follow", "we", "present", "we", "result", "compute", "pc", "Intel", "2.0", "GHz", "CPU", "NVIDIA", "GeForce", "280", "GTX", "graphic", "we", "final", "scene", "-lrb-", "figure", "-rrb-", "kitchen", "model", "move", "robot", "card", "since", "we", "compute", "everything", "from", "scratch", "each", "frame", "dine", "table", "note", "caustic", "effect", "cast", "from", "dining", "tauser", "can", "dynamically", "manipulate", "any", "element", "scene", "includble", "overall", "indirect", "illumination", "Figure", "we", "also", "ine", "lighting", "viewpoint", "material", "geometry", "unless", "mention", "clude", "four", "subimage", "show", "direct", "caustic", "component", "otherwise", "all", "image", "report", "render", "supersampled", "resindirect", "lighting", "component", "shade", "cluster", "visualizaolution", "1024", "1024", "downsample", "512", "512", "final", "tion", "cluster", "center", "all", "scene", "we", "achieve", "reasonable", "resolution", "direct", "light", "source", "point", "spot", "light", "frame", "rate", "range", "from", "1.5", "4.2", "fp", "-lrb-", "-rrb-", "16", "error", "image", "-lrb-", "-rrb-", "Reference", "image", "-lrb-", "-rrb-", "Ours", "-lrb-", "-rrb-", "Reference", "-lrb-", "-rrb-", "error", "image", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "efficient", "gpu-based", "approach", "interactive", "global", "illumination", "91:7", "figure", "left", "image", "show", "global", "illumination", "result", "kitchen", "scene", "four", "subimage", "right", "show", "direct", "lighting", "caustic", "indirect", "lighting", "cluster", "shade", "point", "distribution", "cluster", "center", "-lrb-", "i.e.", "irradiance", "sample", "point", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "show", "glossy", "elephant", "mirror", "user", "change", "material", "property", "elephant", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "show", "animated", "elephant", "two", "rotate", "mirror", "Cornell", "box", "scene", "note", "how", "reflect", "light", "from", "mirror", "illuminate", "object", "parameter", "Table", "list", "main", "render", "parameter", "we", "use", "illumination", "from", "weak", "source", "lighting", "get", "larger", "error", "each", "scene", "include", "number", "global/caustics", "photon", "which", "could", "improve", "increase", "illumination", "cut", "size", "number", "shade", "cluster", "illumination", "cut", "size", "simple", "scene", "contain", "low", "visibility", "complexity", "require", "only", "small", "note", "due", "limited", "number", "shade", "cluster", "number", "shade", "cluster", "more", "complicated", "scene", "granularity", "we", "adaptive", "seeding", "method", "we", "algorithm", "can", "unkitchen", "require", "larger", "number", "shade", "cluster", "more", "accudersample", "area", "small", "nearby", "geometric", "element", "produce", "rately", "represent", "underlie", "illumination", "change", "all", "scene", "occlusion", "one", "example", "contact", "shadow", "region", "botwe", "compute", "final", "gather", "use", "250", "500", "final", "gather", "ray", "tom", "chair", "table", "leg", "from", "magnify", "error", "image", "can", "see", "region", "compute", "highest", "error", "Accuracy", "we", "algorithm", "consist", "two", "main", "approximation", "ircompared", "other", "region", "practice", "however", "we", "find", "perradiance", "sampling", "interpolation", "approximation", "phoceived", "difference", "cause", "error", "relatively", "small", "can", "ton", "map", "illumination", "cut", "Figure", "-lrb-", "a-e", "-rrb-", "we", "examine", "acbe", "observe", "directly", "compare", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "curacy", "each", "approximation", "individually", "focus", "analysis", "Figure", "-lrb-", "f-k", "-rrb-", "we", "perform", "similar", "accuracy", "comparison", "two", "indirect", "illumination", "we", "have", "change", "all", "material", "scene", "additional", "scene", "where", "we", "result", "render", "both", "approxto", "entirely", "diffuse", "-lrb-", "-rrb-", "compute", "5k", "irradiance", "sample", "imation", "enable", "parameter", "specify", "Table", "while", "final", "gather", "compute", "accurate", "density", "estimation", "full", "photon", "map", "-lrb-", "-rrb-", "compute", "illumination", "cut", "size", "4k", "while", "final", "gather", "evaluate", "every", "shading", "point", "-lrb-", "-rrb-", "discussion", "future", "work", "show", "reference", "image", "compute", "disable", "both", "approximation", "thus", "perform", "accurate", "final", "gather", "-lrb-", "1024", "secondary", "summary", "we", "have", "present", "efficient", "gpu-based", "method", "ray", "-rrb-", "every", "shading", "point", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "show", "magnify", "interactive", "global", "illumination", "we", "partition", "shade", "point", "absolute", "error", "image", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "against", "-lrb-", "-rrb-", "coherent", "cluster", "use", "adaptive", "sample", "seeding", "k-means", "sample", "incident", "irradiance", "use", "final", "gather", "compute", "each", "both", "approximation", "we", "find", "render", "error", "relcluster", "center", "compare", "standard", "irradiance", "caching", "we", "elimiatively", "small", "error", "-lrb-", "-rrb-", "occur", "primarily", "place", "where", "nate", "need", "sequential", "computation", "sample", "point", "thereby", "irradiance", "change", "rapidly", "due", "occlusion", "nearby", "oballow", "we", "perform", "final", "gather", "parallel", "GPU", "we", "also", "ject", "region", "shadow", "adjacent", "geometry", "use", "present", "approach", "base", "approximate", "photon", "tree", "higher", "number", "shade", "cluster", "help", "because", "more", "cluster", "illumination", "cut", "reduce", "final", "gather", "cost", "allocate", "those", "region", "thereby", "improve", "sampling", "accuracy", "similarly", "error", "-lrb-", "-rrb-", "occur", "primarily", "occluded", "many", "interactive", "rendering", "technique", "we", "algorithm", "present", "region", "where", "incident", "radiance", "low", "mainly", "because", "tradeoff", "between", "render", "accuracy", "efficiency", "while", "we", "we", "illumination", "cut", "approximate", "strong", "source", "lighting", "-lrb-", "i.e.", "phomethod", "perform", "interactive", "rate", "modern", "gpus", "have", "sevton", "tree", "node", "high", "power", "-rrb-", "more", "accurately", "than", "weak", "source", "eral", "limitation", "first", "we", "use", "limited", "number", "irradiance", "lighting", "since", "occluded", "region", "image", "receive", "most", "sample", "we", "method", "can", "miss", "small", "geometric", "detail", "indirect", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009", "91:8", "R.", "Wang", "et", "al.", "reference", "rikan", "O.", "orsyth", "D.", "A.", "O?B", "RIEN", "J.", "F.", "2005", "fast", "detailed", "approximate", "global", "illumination", "irradiance", "decomposition", "ACM", "Trans", "graph", "24", "1108", "1114", "alum", "K.", "ORSEY", "J.", "eller", "S.", "1999", "radiance", "interpolant", "accelerate", "bounded-error", "ray", "trace", "ACM", "Trans", "graph", "18", "213", "256", "achsbacher", "C.", "TAMMINGER", "M.", "2005", "reflective", "shadow", "map", "Proc", "si3d", "05", "203", "231", "autron", "P.", "RIV", "ANEK", "J.", "OUATOUCH", "K.", "TANAIK", "S.", "N.", "2005", "radiance", "cache", "splatting", "gpu-friendly", "global", "illumination", "algorithm", "Proc", "egsr", "05", "55", "64", "achisuka", "t.", "2005", "GPU", "Gems", "high-quality", "global", "illumination", "render", "use", "rasterization", "615", "634", "arris", "M.", "engupta", "S.", "wen", "J.", "2007", "GPU", "Gems", "parallel", "prefix", "sum", "-lrb-", "scan", "-rrb-", "CUDA", "851", "876", "san", "M.", "ellacinus", "F.", "ALA", "K.", "2006", "direct-toindirect", "transfer", "cinematic", "relighting", "ACM", "Trans", "graph", "25", "1089", "1097", "san", "M.", "ellacinus", "F.", "ALA", "K.", "2007", "Matrix", "row-column", "sampling", "many-light", "problem", "ACM", "Trans", "graph", "26", "26:1", "10", "ou", "Q.", "HOU", "K.", "UO", "B.", "2008", "BSGP", "bulksynchronous", "GPU", "programming", "ACM", "Trans", "graph", "27", "12", "ENSEN", "H.", "W.", "2001", "realistic", "image", "synthesis", "use", "photon", "mapping", "a.", "K.", "Peters", "Ltd.", "AJIYA", "J.", "T.", "1986", "render", "equation", "Proc", "SIGGRAPH", "86", "143", "150", "ELLER", "A.", "1997", "instant", "radiosity", "Proc", "SIGGRAPH", "97", "49", "56", "RIV", "ANEK", "J.", "AUTRON", "P.", "2005", "radiance", "caching", "efficient", "global", "illumination", "computation", "IEEE", "Trans", "visualization", "computer", "graphic", "11", "550", "561", "ijasure", "M.", "attanaik", "S.", "N.", "OEL", "V.", "2005", "Realtime", "global", "illumination", "gpus", "Journal", "Graphics", "Tools", "10", "55", "71", "urcell", "T.", "J.", "ONNER", "C.", "AMMARANO", "M.", "ENSEN", "H.", "W.", "ANRAHAN", "P.", "2003", "photon", "mapping", "programmable", "graphic", "hardware", "Proc", "Graphics", "Hardware", "41", "50", "itschel", "T.", "ROSCH", "T.", "IM", "M.", "H.", "eidel", "h.-p.", "achsbacher", "C.", "AUTZ", "J.", "2008", "imperfect", "shadow", "map", "efficient", "computation", "indirect", "illumination", "ACM", "Trans", "graph", "27", "129:1", "itschel", "T.", "ROSCH", "T.", "EIDEL", "h.-p", "2009", "approximate", "dynamic", "global", "illumination", "image", "space", "Proc", "si3d", "09", "appear", "eiler", "L.", "ARMEAN", "D.", "prangle", "E.", "orsyth", "T.", "BRASH", "M.", "UBEY", "P.", "UNKINS", "S.", "AKE", "a.", "uger", "man", "J.", "AVIN", "R.", "SPASA", "R.", "ROCHOWSKI", "E.", "UAN", "T.", "ANRAHAN", "P.", "2008", "Larrabee", "many-core", "x86", "architecture", "visual", "computing", "ACM", "Trans", "graph", "27", "15", "hanmugam", "P.", "RIKAN", "O.", "2007", "hardware", "accelerate", "ambient", "occlusion", "technique", "gpus", "Proc", "si3d", "07", "73", "80", "LOAN", "P.-P.", "AUTZ", "J.", "NYDER", "J.", "2002", "precomputed", "radiance", "transfer", "real-time", "rendering", "dynamic", "lowfrequency", "lighting", "environment", "ACM", "Trans", "graph", "21", "527", "536", "ole", "P.", "ellacinus", "F.", "ALTER", "B.", "REENBERG", "D.", "P.", "2002", "interactive", "global", "illumination", "dynamic", "scene", "ACM", "Trans", "graph", "21", "537", "546", "ALD", "I.", "OLLIG", "T.", "ENTHIN", "C.", "ELLER", "a.", "lusallek", "P.", "2002", "interactive", "global", "illumination", "use", "fast", "ray", "trace", "Proc", "Eurographics", "Workshop", "Rendering", "15", "24", "ALTER", "B.", "RETTAKIS", "G.", "arker", "S.", "1999", "interactive", "render", "use", "render", "cache", "Proc", "Eurographics", "Workshop", "Rendering", "235", "246", "ALTER", "B.", "ernandez", "S.", "rbree", "a.", "alum", "K.", "ONIKIAN", "M.", "REENBERG", "D.", "P.", "2005", "Lightcuts", "scalable", "approach", "illumination", "ACM", "Trans", "graph", "24", "1098", "1107", "ARD", "G.", "J.", "UBINSTEIN", "F.", "M.", "lear", "R.", "D.", "1988", "ray", "trace", "solution", "diffuse", "interreflection", "Proc", "SIGGRAPH", "88", "85", "92", "YMAN", "C.", "AVIS", "S.", "2006", "interactive", "image-space", "technique", "approximate", "caustic", "Proc", "si3d", "06", "153", "160", "HOU", "K.", "OU", "Q.", "ang", "R.", "UO", "B.", "2008", "real-time", "kd-tree", "construction", "graphic", "hardware", "ACM", "Trans", "graph", "27", "126:1", "11", "ACM", "transaction", "Graphics", "Vol", "28", "no.", "Article", "91", "publication", "date", "August", "2009" ],
  "content" : "\n  \n    6352b89e134fb747befa74058cbb0a63682fa41a10f68206cd66e831cb6f9592\n    oxe\n    10.1145/1531326.1531397\n    Name identification was not possible. \n  \n  \n    \n      \n        An Efficient GPU-based Approach for Interactive Global Illumination\n      \n      Rui Wang ? Rui Wang ? Kun Zhou ? ? State Key Lab of CAD&CG, Zhejiang University\n      This paper presents a GPU-based method for interactive global illumination that integrates complex effects such as multi-bounce indirect lighting, glossy reflections, caustics, and arbitrary specular paths. Our method builds upon scattered data sampling and interpolation on the GPU. We start with raytraced shading points and partition them into coherent shading clusters using adaptive seeding followed by k-means. At each cluster center we apply final gather to evaluate its incident irradiance using GPU-based photon mapping. We approximate the entire photon tree as a compact illumination cut, thus reducing the final gather cost for each ray. The sampled irradiance values are then interpolated at all shading points to produce rendering. Our method exploits the spatial coherence of illumination to reduce sampling cost. We sample sparsely and the distribution of sample points conforms with the underlying illumination changes. Therefore our method is both fast and preserves high rendering quality. Although the same property has been exploited by previous caching and adaptive sampling methods, these methods typically require sequential computation of sample points, making them ill-suited for the GPU. In contrast, we select sample points adaptively in a single pass, enabling parallel computation. As a result, our algorithm runs entirely on the GPU, achieving interactive rates for scenes with complex illumination effects. Keywords: global illumination, GPU, photon mapping, final gather, k-means, illumination cut.\n    \n    \n      \n        1 Introduction\n      \n      Interactive computation of global illumination is a major challenge in computer graphics research today. Effects such as multi-bounce indirect lighting, caustics, and complex surface reflections are important visual cues for the perception of photorealism in synthesized images. However, with conventional CPU-based algorithms the simulation costs of such effects are often too high to permit dynamic interactions, where the user can simultaneously change the lighting, viewpoint, materials, and geometry, and expect accurate real-time feedbacks of such changes.  With the rapidly increasing computation power of modern GPUs, much attention has been directed to exploiting the GPU to achieve interactive global illumination. Existing methods, however, typically focus on a very limited set of illumination effects. For instance, GPU-based ambient occlusion [Shanmugam and Arikan bution of these points conforms with the actual irradiance changes. Next, at each cluster center, we perform final gather to sample its incident radiance field due to indirect lighting. This step uses a fast GPU-based photon mapping algorithm [Zhou et al. 2008]. To accelerate the density estimation in final gather, we approximate the entire photon tree as a compact illumination cut that is computed dynamically on the GPU. We then interpolate the sampled irradiance values at each shading point to produce the final rendering result. Our method also handles one-bounce of low-frequency glossy reflections by approximating both the sampled radiance fields and BRDFs onto a spherical harmonics (SH) basis set. By selecting irradiance sample points adaptively in a single pass, we eliminate the sequential computation required by standard caching based methods. As a result, our algorithm enables parallel computation and is implemented entirely on the GPU, achieving interactive frame rates for a variety of complex global illumination effects. Figure 1 shows an example. Our GPU-based solution can be easily adapted to other many-core platforms such as Intel?s upcoming Larrabee [Seiler et al. 2008]. As today?s chip design is quickly switching to streaming and massively parallel processor models, we believe that it is essential to develop new algorithms that exploit such architecture to achieve interactive global illumination.\n      ? kunzhou@acm.org , {rwang, panminghao, bao}@cad.zju.edu.cn ? ruiwang@cs.umass.edu ACM Reference Format Wang, R., Wang, R., Zhou, K., Pan, M., Bao, H. 2009. An Efficient GPU-based Approach for Interactive Global Illumination. ACM Trans. Graph. 28, 3, Article 91 (August 2009), 8 pages. DOI = 10.1145/1531326.1531397 http://doi.acm.org/10.1145/1531326.1531397. Copyright Notice Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the fi rst page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2009 ACM 0730-0301/2009/03-ART91 $10.00 DOI 10.1145/1531326.1531397 http://doi.acm.org/10.1145/1531326.1531397\n      Minghao Pan ? Hujun Bao ? ? University of Massachusetts Amherst\n      \n        \n        Figure 1: Global illumination result rendered using our algorithm. The user can dynamically manipulate any part of the scene, including lighting, viewpoint, materials, and geometry, at 1.5 fps. 2007] simulates global shadowing effects but ignores interreflections. Approaches based on instant radiosity and shadow mapping [Keller 1997; Dachsbacher and Stamminger 2005] compute single-bounce indirect lighting but ignore caustics and multibounce interreflections. Precomputed radiance transfer [Sloan et al. 2002] incorporates many illumination effects but entails a large amount of precomputed data and is inefficient for dynamic geometry and materials. The goal of our work is to study a GPU-based global illumination method that integrates a wide range of illumination effects in a single algorithm. To allow for sufficient flexibility, we build upon kdtree based photon mapping. Recent work has successfully implemented fast kd-trees on modern GPUs [Zhou et al. 2008], achieving interactive caustics and specular reflections. However, incorporating full global illumination effects remains challenging. The main difficulty resides in the final gather step, which involves computing a large number of secondary rays that can quickly saturate the GPU?s computation power. It is well-known that the final gather step can benefit greatly from exploiting the spatial coherence in illumination changes, such as by using irradiance caching [Ward et al. 1988; Tole et al. 2002]. Unfortunately, irradiance caching is not naturally amenable to the GPU?s data-parallel processing model because it requires sequential computation of spatial sample points and frequent updates to a spatial structure that stores these points. As a result, even though irradiance caching is a common practice in CPU-based ray tracing, very few GPU-based solutions have been able to utilize it; those that do typically have to re-formulate the algorithm and ignore indirect shadows [Gautron et al. 2005]. Similar to irradiance caching, our solution builds upon spatial data caching and interpolation to reduce sampling cost. However, to derive a practical GPU-based solution, our main contribution is a robust method that selects irradiance sample points before the final gather starts. This allows us to perform all steps of global illumination in parallel. To do so, we start by partitioning raytraced shading points into spatially coherent clusters. We introduce a method based on adaptive sample seeding and k-means to compute this partitioning efficiently on the GPU. Each cluster center now becomes a spatial irradiance sample point, and our results show that the distri-\n      \n      ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n      91:2 ? R. Wang et al.\n      \n        2 Related Work\n        CPU-based Global Illumination A fundamental difficulty in global illumination is the high computation cost incurred by indirect lighting, where all surfaces contribute illumination to the scene. Instant radiosity [Keller 1997] is a popular technique that converts indirect illumination to a small set of virtual point lights (VPLs). This approach drastically reduces the computation cost, but is limited to a small number of VPLs and is only suitable for primarily diffuse materials. Photon mapping [Jensen 2001] is another popular solution. It involves a photon scattering pass and a final gather pass to accurately simulate indirect lighting. For complex scenes, a large number of photons are needed, leading to high computation cost. In [2002], Wald et al. implemented interactive global illumination using a cluster of PCs. Recently, [Walter et al. 2005] presented LightCuts ? a scalable method that computes illumination from a large number of point lights at sublinear cost. Their work is aimed at high-quality rendering and runs offline. Caching and Interpolation Since global illumination involves computing many rays, it is common to exploit the coherence among rays to reduce radiance sampling cost. This is especially true for indirect illumination, which changes smoothly and makes a good candidate for sparse sampling. Irradiance caching (IC) [Ward et al. 1988] is a popular technique that progressively caches diffuse irradiance samples into an octree, and reuses them along the computation. Radiance caching [K riv? nek and Gautron 2005] extends IC by recording directional radiance using spherical harmonics. In [1999], Bala et al. presented a general approach to exploiting both spatial and temporal coherence of rays for radiance interpolation. Recently [Arikan et al. 2005] introduced a fast approximation to global illumination by decomposing radiance fields into farand near-field components, which are computed separately to improve efficiency. In general, these caching schemes require sequentially inserting spatial sample points into a data structure, which has to be frequently queried and updated during the computation. This makes them unsuitable for the GPU?s data-parallel computation model. The Render Cache [Walter et al. 1999] reuses radiance samples from previous frames by reprojecting them to the current frame, followed by the insertion of a small number of new samples. It  exploits temporal coherence but the rendering takes a long time to converge. The Shading Cache [Tole et al. 2002] performs caching and interpolation in object space, leading to faster convergence and improved rendering quality. However, it requires scene geometry to be subdivided into patches, which is unsuitable for complex models. Furthermore, lighting and geometry changes lead to noticeable temporal artifacts. GPU-based Global Illumination With the rapidly increasing computation power of modern GPUs, much recent work has focused on GPU-based solutions for global illumination. [Nijasure et al. 2005] sample incident radiance on the GPU at uniform 3D grid points. By using a low-resolution of fixed samples, this method does not provide high accuracy. Reflective shadow maps [Dachsbacher and Stamminger 2005] treat shadow map pixels projected from the direct light source as indirect sources illuminating the scene. Using image-space computation, this method enables fast one-bounce indirect lighting, but does not handle multi-bounce interreflections. Similarly, radiance cache splatting [Gautron et al. 2005] uses image-based final gathering to approximate irradiance caching. While fast, these methods ignore occlusions in the final gather step, which are important for producing indirect shadows. Matrix row-column sampling [Ha san et al. 2007] converts illumination to many point lights, then exploits GPU shadow mapping to cluster them into representative lights and compute shadowed illumination from each. This method does not yet perform at interactive rates. Imperfect shadow maps [Ritschel et al. 2008] evaluate approximate shadow maps for many point lights in a single pass on the GPU, dramatically improving the computation speed. Due to the lack of a ray tracing framework, these methods are only suitable for primarily diffuse surfaces, and cannot handle caustics or perfectly specular materials. Photon mapping was first implemented on the GPU in [Purcell et al. 2003] by using a uniform grid structure to store photons; their rendering takes several seconds to converge. [Hachisuka 2005] introduced a fast acceleration method for final gather by using GPU rasterization. This greatly improves offline rendering speed. [Wyman and Davis 2006] proposed an image-space caustics algorithm, capable of simulating plausible caustics effects in real-time. This method is not aimed to include other global illumination effects. Recently [Zhou et al. 2008] introduced a fast GPU-based kd-tree algorithm for real-time ray tracing and caustics. However, incorporating general illumination effects remains unsolved in their framework. Our method builds upon this algorithm, and we extend their work to include complex illumination effects such as multi-bounce interreflections and caustics-incurred indirect lighting.\n      \n      \n        3 Algorithms\n        This section provides an overview of our algorithm. We focus on scenes where the direct light source is a point light, so the direct illumination can be computed in real-time using GPU-based ray tracing. Incorporating area or environment lighting is possible but would require efficient methods to compute shadowed direct illumination from them. Therefore in the following we focus on discussing the computation of indirect illumination. We assume the scene materials to be either diffuse or perfectly specular. As in standard methods, we can extend diffuse reflections to one final bounce of glossy reflections using spherical harmonics. According to the rendering equation [Kajiya 1986], the outgoing radiance L o at a shading point x in view direction ? o is computed by the following integral:\n        \n          1\n          L o (x) = ?(x) L i (x, ? i ) (? i ? n) d? i = ?(x) ? E(x) H 2\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n        An Efficient GPU-based Approach for Interactive Global Illumination ? 91:3\n        \n          \n          Figure 2: A diagram showing our main building blocks. The shaded box marks the main contributions of this paper.\n        \n        where L i is the incident radiance due to indirect illumination, ? i is an incident direction, ? is the surface BRDF, H 2 is the hemisphere centered around the surface normal n, and E is the irradiance. Using photon mapping [Jensen 2001], we can evaluate E in two passes. The first pass emits and scatters photons from the main light source, building a global photon map and a caustics photon map. Each photon map is stored in a kd-tree for efficient access. The second pass performs final gather by sending many secondary rays at x to sample its incident radiance field L i . The radiance along each ray is evaluated using density estimation in the photon map, and then integrated with the cosine function according to Eq 1.  For accurate rendering, a large number of final gather rays needs to be computed. As a result, evaluating this integral at every shading point is impractical for interactive settings. Our goal is to reduce spatial sampling cost by evaluating incident radiance only at a small number of shading points. As indirect illumination changes smoothly over the scene, these sparse samples provide a good approximation for interpolation at the remaining shading points. While the idea of spatial caching has long been exploited in irradiance caching and adaptive sampling methods, these methods require sample points to be progressively inserted into a spatial structure (i.e. kd-tree), which is repeatedly updated during the computation. This computation model is unsuitable for a direct GPU mapping. To avoid the sequential computation, we select irradiance sample points ahead of time in a single pass, allowing us to perform the subsequent computation in parallel on the GPU. Even with spatial caching, the density estimation for each secondary ray is still quite expensive, due to the large number of photons stored in the kd-tree. To reduce this cost, we introduce an efficient approach that approximates the photon tree as an illumination cut which is dynamically constructed on the GPU. The center of each cut node represents an illumination cluster, and we use radial basis functions (RBFs) to smoothly interpolate between them. As the illumination cut size is much smaller than the total number of photons, we achieve significant speedup in density estimation.  Figure 2 shows the main building blocks of our algorithm. First, we build a kd-tree of the scene on the GPU, and utilize it for ray tracing and photon mapping. These steps follow the kd-tree algorithms presented in [Zhou et al. 2008]. Next, we take the shading points computed from ray tracing, and partition them into 1000 ? 6000 shading clusters based on each point?s geometric information. This clustering is computed using GPU-based adaptive sample seeding followed by k-means. We then perform final gather at each cluster center to sample its incident radiance field. In order to reduce the cost of density estimation, we approximate the global photon map as a compact illumination cut containing 4000 ? 8000 nodes. At each node?s center we evaluate and cache an irradiance value by using density estimation in the global photon map. As a result, performing density estimation with the illumination cut is signifi- cantly faster than with the full photon tree. Finally we interpolate the sampled irradiance values at all shading points to produce indirect lighting. The results are further combined with direct lighting and caustics to produce the final image.\n      \n      \n        3.1 GPU-based KD-Tree\n        Our algorithm requires the use of kd-tree in a number of steps, including ray tracing, photon mapping, k-means clustering, and radiance interpolation. Therefore an efficient kd-tree implementation is important. We follow the method in [Zhou et al. 2008] to build kdtrees in real-time using NVIDIA?s CUDA. This method constructs the kd-tree in breadth first order (BFS) using a greedy top-down approach, which recursively splits the current kd-tree node into two sub-nodes. For efficient GPU processing, nodes are classified as either large or small based on the number of geometric primitives belonging to them. For fast traversal in the kd-tree, a standard stackbased method is implemented by maintaining a local stack for each thread in the GPU?s shared memory. Using this algorithm, Zhou et al. achieved real-time performance for direct lighting and caustics. Direct Lighting Following [Zhou et al. 2008], we use ray tracing to compute direct lighting with the following steps: 1) build a kdtree of the scene, and trace eye rays in parallel; 2) collect rays that hit non-specular surfaces using a parallel list compaction [Harris et al. 2007]; 3) similarly, collect rays that hit specular surfaces, and then spawn reflected and refracted rays for them; 4) repeat steps 2 and 3 for additional bounces; 5) for all non-specular hit points, perform shadow tests and compute direct shading in parallel. Shading Points The collection of non-specular hit points in step 5) above defines our shading points: they represent all the points that are either directly visible, or are visible after specular paths. Note that in the absence of specular objects, we can directly produce shading points via rasterization. However, with specular objects, computing shading points requires ray tracing. Building Photon Maps We shoot photons from the direct light source, scatter them in the scene, and store them in photon maps when they hit non-specular surfaces. A photon is stored in the global photon map if its immediate previous hit is on a non-specular surface, otherwise we store it in the caustics photon map. We build a kd-tree for each photon map afterwards.\n      \n      \n        3.2 Selecting Irradiance Sample Points\n        Our next step is to select, among all shading points, a small set of representative points for sampling incident irradiance. Because these points will be used for interpolation at the remaining shading points, they need to be carefully selected to preserve the underlying illumination changes. In standard caching based schemes, this is achieved by progressively inserting sample points into an existing set; and the decision to insert more samples is based on the  local variations of irradiance samples already stored in the set. This reduces data parallelism since the insertion of samples and the irradiance evaluation are dependent upon each other. In [Ha san et al. 2006], an importance sampling method is introduced to distribute gather points for direct-to-indirect transfer computation. It uses a variation of photon mapping to estimate the importance of triangles in the scene. While not requiring progressive insertions, this method is unsuitable for on-the-fly sample generation due to the expensive computation. Our solution is to find an error metric that can reliably predict the actual irradiance changes based on the scene?s geometric information. This allows us to select sample points in advance, before the irradiance evaluation step begins. Using this metric, we can partition shading points into coherent shading clusters, and the center of each cluster then becomes an irradiance sample point. To do so, we use a modified version of the illumination change term introduced in irradiance caching [Ward et al. 1988] to define our error metric:\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n        91:4 ? R. Wang et al.\n        \n          2\n          ? = ? i x k + 2 2(n i n k )\n        \n        \n          2\n          ||x ? || ? ?\n        \n        where x i is a shading point to be classified, x k is the center position of a cluster C k , and n denotes a surface normal. ? is a weighting factor that determines the relative importance of position and normal incurred changes, and it typically varies between 0.1 ? 0.5 in our experiments (after the scene geometry scale is normalized). Similar to irradiance caching, this metric is computed purely from geometric properties. The intuition is that points that are geometrically close to each other are likely to receive similar incident illumination. Note that we have omitted the harmonic distance term R k in the original definition from [Ward et al. 1988]. This is because evaluating R k requires final gathering, which is what we would like to avoid computing at this stage. However, we introduce an adaptive sample seeding approach to account for the effect of the R k term, as explained below. Adaptive Seeding of Sample Points The R k term in the original irradiance cache formulation accounts for the effect that areas close to other surfaces are likely to experience rapid illumination changes, therefore more sample points should be distributed there. To account for this effect, we use an approximation that distributes initial sample points according to the local geometric variations in the scene. In order to seed K sample points, we use a hierarchical histogram-based method to evaluate the geometric variations in image space. We start by constructing a static, screen-space quadtree of all the shading points. This can be done trivially since the shading points have a one-to-one mapping to screen pixels. For each quadtree node q, we compute its geometric variation ? q according to Eq 2 by treating all shading points belonging to quadtree node q as a cluster. We initialize x k and n k to be the average position and normal at each node q. We compute this efficiently on the GPU by evaluating ? q for all quadtree nodes in parallel. Following this step, we seed K initial sample points hierarchically according to the magnitude of ? q . Specifically, we start from the root node of the quadtree, and at each node we distribute sample points to its four children nodes in proportion to the ? q of its child nodes. When a node has only one sample to distribute, we use jittered sampling to randomly select a sample point within the quad. We process each level of the quadtree in parallel. K-Means Clustering After the initial seeding, we refine the sample points by using k-means to partition all shading points into coherent clusters. To do so, we treat the seeded points as our initial cluster centers, and follow standard k-means to classify every shading point to its closest center using the metric defined in Eq 2. After every shading point is classified, we recompute the cluster center  Even on the GPU, the above algorithm is still quite expensive to run. The main bottleneck is in finding the nearest cluster center for every shading point, which incurs a computation cost linear to K using the brute-force approach. To reduce this cost, we need to avoid searching among all cluster centers. To do so, we build a kdtree of all cluster centers at the beginning of each k-means iteration; then for every shading point to be classified, we utilize the kd-tree to constrain the search within a small Euclidean distance to that shading point, thereby significantly reducing the search range.  Figure 3(a) shows our clustering result for a Cornell box scene computed with 1600 clusters; (b) shows the cluster centers on top of an accurate irradiance image computed using offline raytracing. Note that areas with rapid illumination changes are sampled densely with small clusters, while those with slow changes are sampled sparsely by large clusters. This example demonstrates that the samples we select conform with the underlying illumination changes. Temporal Coherence Since we recompute irradiance sample points among shading points at every frame, our method is viewdependent and is subject to temporal artifacts. For example, if the camera moves quickly, the selected irradiance sample points will differ from frame to frame, causing potential flickering artifacts. To reduce such artifacts, we attempt to preserve the temporal coherence among sample points. At the beginning of each new frame, we fix cluster centers x k computed from the previous frame, then estimate whether every shading point in the new frame can be classified into an existing cluster x k . To do so, we keep at each cluster the largest error (Eq 2) of its current members with the cluster center, then use this value as a threshold to check whether new shading points can be classified into this cluster. At the end of this estimation, we eliminate those clusters in x k that do not have any shading point associated with them. On the other hand, we create new clusters for all shading points that cannot be classified. The new clusters are generated using the same algorithm described above. Overall we maintain roughly the same number of shading clusters (hence irradiance sample points) at each frame.\n        \n          \n          Figure 3: (a) shows our clustering result for the Cornell box scene computed with 1600 clusters; (b) displays the cluster centers on top of a raytraced reference showing the actual irradiance values. by averaging the position and normal of all cluster members. We then repeat the these steps until either the clustering converges or a maximum number of iterations has been reached. Finally, in each cluster, we pick the shading point with the smallest error as our irradiance sample point.\n        \n      \n      \n        3.3 Reducing the Cost of Final Gather\n        Once the irradiance sample points are selected, we sample their incident radiance fields by sending 250 ? 500 final gather rays distributed according to the PDF of a cosine function. To evaluate the radiance for each final gather ray, standard photon mapping requires density estimation, which performs a KNN search in the photon tree to find nearby photons around a ray?s hit point. Due to the large number of photons, the search cost is typically quite high.  To reduce this cost, our goal is to use a smaller set of samples to approximate the illumination represented by the large number of photons. The idea is that performing KNN search with this reduced set of points significantly improves the search speed. We achieve the reduction by dynamically computing an illumination cut from the photon tree. Although [Walter et al. 2005] have introduced an efficient method for computing cuts from a set of diffuse point lights, here we present a new approach that computes an illumination cut directly from the photon map, and is more amenable to the GPU. To do so, we first estimate an approximate irradiance for each photon tree node p by computing its illumination density, defined as:\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n        An Efficient GPU-based Approach for Interactive Global Illumination ? 91:5\n        \n          3\n          i?p (? i ? n p ) ? i E p = r p 2\n        \n        where ? i is the power of a photon belonging to node p, ? i is the incoming direction of the photon, n p is the normal at the node center, and r p is the maximum side length of the node?s bounding box. This is equivalent to performing a density estimation but using all the photons in p and r p 2 as the area for estimation. This overestimates the search neighborhood but reduces the estimation cost. Note that E p is computed and stored when the kd-tree of the photon map is built, thus we do not have to compute it separately.  Our next step is to find a cut through the tree to approximate the illumination. Given the approximated irradiance at each node, a coarse tree-cut is selected from the photon tree in parallel: first, nodes with irradiance larger than a predefined threshold E min are selected and added in the cut. Then, different levels of the tree are traversed iteratively to ensure the construction of a valid and complete tree-cut. This is done by deleting nodes whose children are already in the cut, and adding nodes to cover leaf nodes that do not have parents representing them in the cut. We pick the threshold E min as the average E p of nodes at the 12?13-th level of the photon tree. This is based on the heuristic that the initial illumination cut should be close to its target size, which is approximately 4K?8K. Given the coarse tree cut, we perform an optimization to improve its accuracy. This is done by comparing the accurate irradiance, E p , evaluated at node p?s center using standard density estimation, with the approximated irradiance E p computed above. If the difference between the two is larger than a user defined threshold ? E (which we typically set to 1.2 E p ), the node is removed from the cut and replaced by its children nodes, thereby improving its accuracy. We perform 3?5 iterations of this refinement. During each iteration, nodes are independently computed in parallel. Once the cut is selected, each node of the cut becomes a sample point for illumination. We therefore cache the accurate irradiance value E p at the center of each node and use these values for smooth interpolation. We use a set of spatial radial basis functions (RBFs) centered at each cut node as an interpolation basis. Specifically, given a hit point y of a final gather ray, the radiance of the ray is evaluated by locating a set of nearby cut nodes p j , and interpolating from them using the following weight:\n        \n          4\n          p j ? y w j = K( ) ? max(0, n(p j ) ? n y ), r(p j )\n        \n        \n          5\n          1 ? r 2 , r ? 1 K(r) = 0, r > 1\n        \n        where r(p j ) is the maximum side length of node p j ?s bounding box. Note that the subtree defined from the root of the photon tree to the illumination cut can be used directly as a kd-tree for neighborhood search. Intuitively, each node p j influences its surrounding space, up to the size of its bounding box, by a quadratic falloff weight.\n        \n          \n        \n        Indirect lighting Global illumination\n        \n          Figure 4: Glass cube with embedded torus in a Cornel box scene.\n          \n        \n        Indirect lighting Global illumination\n        \n          Figure 5: Cornell box with an animated water surface.\n        \n      \n      \n        3.4 Interpolation and Rendering\n        Representing Radiance Fields using SH In order to allow for glossy BRDFs in the final bounce, similar to previous work, we approximate the directional information of the sampled radiance fields L i (x, ? i ) using a spherical harmonics (SH) basis Y l m (? i ), where l and m are the degree and order of an SH function respectively. We use 4-th order SH in our experiments, resulting in 16 projected l,m coefficients, represented as a vector L i (x). For diffuse materials, we can treat their sampled irradiance value as an SH vector with a non-zero DC term while all other terms are zero. Interpolation To render, we interpolate irradiance values stored at each irradiance sample point. For glossy materials, we interpolate the SH coefficients instead, and integrate the results with glossy BRDFs (also projected onto SH). This step requires scattered data interpolation, which involves finding the nearby irradiance sample points for each shading point, and performing smooth interpolation. As before, we use a kd-tree of the irradiance sample points for efficient neighborhood search. We then perform interpolation in the same way as irradiance caching [Ward et al. 1988]: l,m l,m j?S w(s j )L i (s j ) L i (x) = j?S w(s j ) where S is the set of nearby irradiance sample points located around l,m shading point x, s j is a sample in S, L i (s j ) denotes the SH coefficients, and w(s j ) is the interpolation weight, computed by: 1 w(s j ) = ||x?s R j j || + 2 ? 2 (n(x) ? n(s j )) where R j is the harmonic mean distance to objects visible from s i . It is evaluated during final gather, by keeping track of the intersection distance of each final gather ray, and performing a parallel reduction afterwards to compute the harmonic distance.  lighting in a complex scene. While we could increase the number of sample points, we believe a more appropriate approach would be to combine ours with an image-based occlusion method [Ritschel et al. 2009] or near-field illumination search [Arikan et al. 2005] to better compensate for the missing local details. Second, due to the use of low-order SH, our final gather step is limited to low-frequency glossy materials. In fact this happens to be the reason why a low-dimensional illumination cut suffices to provide high quality results. For semi to highly glossy materials, however, our current approach is inefficient as these materials would require a much longer illumination cut, causing reduced search speed. Note that since we keep the full global photon map in memory, we could use it to perform more accurate density estimations for these highly glossy materials. This remains a direction for our future work. In addition, as we recompute irradiance samples from scratch at each frame, our method is subject to temporal flickering artifacts. Although our clustering method has incorporated the temporal coherence of irradiance samples, such artifacts are still difficult to avoid completely. One possible solution is to introduce a temporal filter that blends new irradiance values across adjacent frames. Finally, in this work we encountered many engineering challenges in successfully implementing our algorithms onto the GPU. We believe they are not because such algorithms are unsuitable for the GPU, but rather because these are fundamental challenges in parallelizing existing sequential algorithms. Given the emerging trends of many-core architecture design, we believe that developing new algorithms to exploit such architecture is no longer a mere engineering practice, but a necessity for continued performance improvement on future generations of hardware. Acknowledgements We would like to thank the SIGGRAPH reviewers for their thoughtful comments. This work was supported in part by NSFC (No. 60825201), the 973 program of China (No. 2009CB320801), and NSF CAREER grant CCF-0746577. The authors would like to thank NVIDIA for their generous donations.\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n        91:6 ? R. Wang et al.\n        \n          \n        \n        (a) 5k Irradiance Samples (b) 16? Error Image (c) 4k Illumination Cut\n        \n          \n        \n        (f) Ours (g) Reference (h) 8? Error Image\n        \n          Figure 6: Comparison of indirect illumination results with reference images. The first row shows the kitchen scene: (a) is computed with 5k irr-adiance samples and the full photon map; (c) is computed at every shading point with an illumination cut size of 4k; (b) and (d) show magnified error images of (a) and (c) against reference (e). The second row shows the same comparison for two additional scenes where the results used for comparison are computed using parameters listed in Table 1 . 3.5 Implementation Scene Tris G/C photons S.C. I. cut FPS Box w/ torus 0.6K 239k/100k 1.6k 4k 4.2 We have implemented all our algorithms using BSGP [Hou et al. Box w/ water 17k 268k/277k 1.8k 8k 2.7 2008] ? a general-purpose C programming interface suitable for Elephant 1 87k 256k/24k 3k 4k 3.1 many-core architecture such as the GPU. BSGP builds on top of Elephant 2 84k 290k/107k 4k 4k 2.5 NVIDIA?s CUDA, but is easier to read, write, and maintain. Our alKitchen 21k 470k/109k 5k 8k 1.5 gorithms make frequent use of standard parallel computation prim Table 1 : This table reports for each scene the number of triangles, itives such as scan, reduction, list compaction, and segmented verglobal/caustics photons, shading clusters (i.e. irradiance sample sions of them. These are directly available in the BSGP library. In points), illumination cut size, and rendering fps. addition, we require an efficient GPU implementation of the kdtree, for which we follow [Zhou et al. 2008]. Demo Scenes Table 1 summarizes the 5 scenes used for demonstration. The first scene, a Cornell box with a glass cube and an Most of our data elements are stored as dynamic arrays in the GPU embedded torus ( Figure 4 ), demonstrates complex caustics effects linear memory. To avoid the high overheads of repeated allocafrom the cube and global illumination effects on the torus inside tion of memory, we implement a standard dynamic array managethe box. The second scene, containing an animated water surface ment routine, which reserves an initial amount of memory on the ( Figure 5 ), demonstrates both reflective and refractive caustics efGPU, and doubles the array size whenever the space runs out. For fects from the water surface. Note that the illumination of objects structures with many fields such as the k-means clusters, we use below the water comes entirely from caustics. This type of light structure of arrays (SoA) instead of array of structures (AoS) for paths (L S+ D+) would be very difficult to simulate with previous achieving global memory coalescing on the GPU. interactive methods. For both scenes we show the decomposition of global illumination into a direct+caustics component, and an inAlgorithm details and various parameters we use can be found in direct lighting component, shown on the left of each image. Sections 3.1 to 3.4. For clarity, we have included pseudo-code of our algorithms in the supplemental material attached to this paper. The third scene ( Figure 8(a ,b)) shows an elephant model with dynamically changing material properties. This scene demonstrates Light Paths In general we can handle all light paths in the form the capability of our solution to handle view-dependent indirect of L (S|D)* (S|D|G) where L, S, D, G stands for lighting, specular, lighting at the final bounce. Glossy reflections are enabled by prodiffuse, and (low-frequency) glossy respectively. In practice, we jecting both sampled incident radiance fields and BRDFs onto 4-th limit the number of indirect bounces to 2. Therefore we compute 3 order SH. Note the color bleeding effects from the elephant to the bounces altogether, including the final gather bounce. Our results wall and floor. Because the direct light source is pointing away from show that the improvement in quality beyond 3 bounces is small. the elephant, these color bleeding effects are only enabled through multi-bounce interreflections. The fourth scene ( Figure 8(c ,d)) con4 Results tains an animated elephant model with rotating mirrors. It demonstrates global illumination effects caused by photons reflected from the mirrors and bounced inside the box. In the following, we present our results computed on a PC with Intel 2.0 GHz CPU and an NVIDIA GeForce 280 GTX graphics Our final scene ( Figure 1 , 7) is a kitchen model with a moving robot card. Since we compute everything from scratch in each frame, the and dining table. Note the caustics effects cast from the dining tauser can dynamically manipulate any element in the scene, includble, and the overall indirect illumination. In Figure 7 we also ining lighting, viewpoint, material, and geometry. Unless mentioned clude four subimages showing the direct+caustics component, the otherwise, all images reported are rendered at a supersampled resindirect lighting component, the shading clusters, and a visualizaolution of 1024 ? 1024, and then downsampled to 512 ? 512 final tion of the cluster centers. For all scenes we achieve reasonable resolution. The direct light source is a point or spot light. frame rates, ranging from 1.5?4.2 fps.\n        \n        (d) 16? Error Image (e) Reference Image\n        (i) Ours (j) Reference (k) 8? Error Image\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n        An Efficient GPU-based Approach for Interactive Global Illumination ? 91:7\n        \n          \n          Figure 7: The left image shows the global illumination result of the kitchen scene; the four subimages on the right show: direct lighting+caustics, indirect lighting, clusters of the shading points, and the distribution of cluster centers (i.e. irradiance sample points).\n        \n        \n          \n        \n        (a) (b)\n        \n          Figure 8: (a) and (b) show a glossy elephant with a mirror as the user changes the material property of the elephant. (c) and (d) show an animated elephant with two rotating mirrors in a Cornell box scene; note how the reflected lights from the mirrors illuminate the objects. Parameters Table 1 lists the main rendering parameters we use their illumination from weak source lighting, they get larger errors for each scene, including the number of global/caustics photons, which could be improved by increasing the illumination cut size. number of shading clusters, and the illumination cut size. Simple scenes that contain low visibility complexity require only a small Note that due to the limited number of shading clusters and the number of shading clusters; more complicated scenes such as the granularity of our adaptive seeding method, our algorithm can unkitchen require a larger number of shading clusters to more accudersample areas with small nearby geometric elements that produce rately represent the underlying illumination changes. For all scenes occlusion. One example is the contact shadow regions at the botwe compute final gather using 250 ? 500 final gather rays. tom of the chair and table legs. From the magnified error images, it can be seen that these regions are computed with the highest errors Accuracy Our algorithm consists of two main approximations: ircompared to other regions. In practice, however, we found the perradiance sampling and interpolation, and the approximation of phoceived difference caused by such errors is relatively small, as can ton map as an illumination cut. In Figure 6 (a-e) we examine the acbe observed by directly comparing (a) and (e). curacy of each approximation individually. To focus on the analysis In Figure 6 (f-k) we perform similar accuracy comparisons for two of indirect illumination, we have changed all materials in this scene additional scenes, where our results are rendered with both approxto be entirely diffuse. (a) is computed with 5k irradiance samples imations enabled and with parameters specified in Table 1 . while the final gather is computed by accurate density estimation in the full photon map; (c) is computed with an illumination cut size of 4k while the final gather is evaluated at every shading point; (e) 5 Discussions and Future Work shows a reference image computed by disabling both approximations, thus performing accurate final gather (with 1024 secondary In summary, we have presented an efficient GPU-based method for rays) at every shading point. In (b) and (d) we show magnified interactive global illumination. We partition shading points into absolute error images of (a) and (c) against (e). coherent clusters using adaptive sample seeding and k-means, and then sample incident irradiance using final gather computed at each In both approximations we found the rendering errors to be relcluster center. Compared to standard irradiance caching, we elimiatively small. The errors in (b) occur primarily in places where nate the need for sequential computation of sample points, thereby the irradiance is changing rapidly due to occlusion by nearby oballowing us to perform final gather in parallel on the GPU. We also jects, such as in regions shadowed by adjacent geometry. Using a present an approach based on approximating the photon tree as a higher number of shading clusters will help because more clusters illumination cut to reduce the final gather cost. will be allocated to those regions, thereby improving the sampling accuracy. Similarly, the errors in (d) occur primarily in occluded As in many interactive rendering techniques, our algorithm presents regions where the incident radiance is low. This is mainly because a tradeoff between rendering accuracy and efficiency. While our our illumination cut approximates strong source lighting (i.e. phomethod performs at interactive rates on modern GPUs, it has sevton tree nodes with high powers) more accurately than weak source eral limitations. First, as we use a limited number of irradiance lighting. Since occluded regions in an image are receiving most of samples, our method can miss small geometric details in indirect\n        \n        (c) (d)\n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n        91:8 ? R. Wang et al.\n      \n      \n        References\n        \n          A RIKAN , O., F ORSYTH , D. A., AND O?B RIEN , J. F. 2005. Fast and detailed approximate global illumination by irradiance decomposition. ACM Trans. Graph. 24, 3, 1108?1114.\n          B ALA , K., D ORSEY , J., AND T ELLER , S. 1999. Radiance interpolants for accelerated bounded-error ray tracing. ACM Trans. Graph. 18, 3, 213?256.\n          D ACHSBACHER , C., AND S TAMMINGER , M. 2005. Reflective shadow maps. In Proc. SI3D ?05, 203?231.\n          G AUTRON , P., K RIV ? ANEK  ? , J., B OUATOUCH , K., AND P AT TANAIK , S. N. 2005. Radiance cache splatting: A GPU-friendly global illumination algorithm. In Proc. EGSR ?05, 55?64.\n          H ACHISUKA , T. 2005. GPU Gems 2 ? High-Quality Global Illumination Rendering Using Rasterization. 615?634.\n          H ARRIS , M., S ENGUPTA , S., AND O WENS , J. 2007. GPU Gems 3 ? Parallel Prefix Sum (Scan) with CUDA. 851?876.\n          H A SAN , M., P ELLACINI , F., AND B ALA , K. 2006. Direct-toindirect transfer for cinematic relighting. ACM Trans. Graph. 25, 3, 1089?1097.\n          H A SAN , M., P ELLACINI , F., AND B ALA , K. 2007. Matrix row-column sampling for the many-light problem. ACM Trans. Graph. 26, 3, 26:1?10.\n          H OU , Q., Z HOU , K., AND G UO , B. 2008. BSGP: bulksynchronous GPU programming. ACM Trans. Graph. 27, 3, 1? 12.\n          J ENSEN , H. W. 2001. Realistic image synthesis using photon mapping. A. K. Peters, Ltd.\n          K AJIYA , J. T. 1986. The rendering equation. In Proc. SIGGRAPH ?86, 143?150.\n          K ELLER , A. 1997. Instant radiosity. In Proc. SIGGRAPH ?97, 49?56.\n          K RIV ? ANEK  ? , J., AND G AUTRON , P. 2005. Radiance caching for efficient global illumination computation. IEEE Trans. Visualization and Computer Graphics 11, 5, 550?561.\n          N IJASURE , M., P ATTANAIK , S. N., AND G OEL , V. 2005. Realtime global illumination on GPUs. Journal of Graphics Tools 10, 2, 55?71.\n          P URCELL , T. J., D ONNER , C., C AMMARANO , M., J ENSEN , H. W., AND H ANRAHAN , P. 2003. Photon mapping on programmable graphics hardware. In Proc. Graphics Hardware, 41?50.\n          R ITSCHEL , T., G ROSCH , T., K IM , M. H., S EIDEL , H.-P., D ACHSBACHER , C., AND K AUTZ , J. 2008. Imperfect shadow maps for efficient computation of indirect illumination. ACM Trans. Graph. 27, 5, 129:1?8.\n          R ITSCHEL , T., G ROSCH , T., AND S EIDEL , H.-P. 2009. Approximating dynamic global illumination in image space. In Proc. SI3D ?09, to appear.\n          S EILER , L., C ARMEAN , D., S PRANGLE , E., F ORSYTH , T., A BRASH , M., D UBEY , P., J UNKINS , S., L AKE , A., S UGER MAN , J., C AVIN , R., E SPASA , R., G ROCHOWSKI , E., J UAN , T., AND H ANRAHAN , P. 2008. Larrabee: a many-core x86 architecture for visual computing. ACM Trans. Graph. 27, 3, 1?15.\n          S HANMUGAM , P., AND A RIKAN , O. 2007. Hardware accelerated ambient occlusion techniques on GPUs. In Proc. SI3D ?07, 73? 80.\n          S LOAN , P.-P., K AUTZ , J., AND S NYDER , J. 2002. Precomputed radiance transfer for real-time rendering in dynamic, lowfrequency lighting environments. ACM Trans. Graph. 21, 3, 527?536.\n          T OLE , P., P ELLACINI , F., W ALTER , B., AND G REENBERG , D. P. 2002. Interactive global illumination in dynamic scenes. ACM Trans. Graph. 21, 3, 537?546.\n          W ALD , I., K OLLIG , T., B ENTHIN , C., K ELLER , A., AND S LUSALLEK , P. 2002. Interactive global illumination using fast ray tracing. In Proc. Eurographics Workshop on Rendering, 15? 24.\n          W ALTER , B., D RETTAKIS , G., AND P ARKER , S. 1999. Interactive rendering using the render cache. In Proc. Eurographics Workshop on Rendering, 235?246.\n          W ALTER , B., F ERNANDEZ , S., A RBREE , A., B ALA , K., D ONIKIAN , M., AND G REENBERG , D. P. 2005. Lightcuts: a scalable approach to illumination. ACM Trans. Graph. 24, 3, 1098?1107.\n          W ARD , G. J., R UBINSTEIN , F. M., AND C LEAR , R. D. 1988. A ray tracing solution for diffuse interreflection. In Proc. SIGGRAPH ?88, 85?92.\n          W YMAN , C., AND D AVIS , S. 2006. Interactive image-space techniques for approximating caustics. In Proc. SI3D ?06, 153?160.\n          Z HOU , K., H OU , Q., W ANG , R., AND G UO , B. 2008. Real-time kd-tree construction on graphics hardware. ACM Trans. Graph. 27, 5, 126:1?11.\n        \n        ACM Transactions on Graphics, Vol. 28, No. 3, Article 91, Publication date: August 2009.\n      \n    \n  ",
  "resources" : [ ]
}