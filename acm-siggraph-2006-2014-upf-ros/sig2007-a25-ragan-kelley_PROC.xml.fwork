{
  "uri" : "sig2007-a25-ragan-kelley_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2007/a25-ragan-kelley_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "The Lightspeed Automatic Interactive Lighting Preview System",
    "published" : "2007",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Jonathan-Ragan-Kelley",
      "name" : "Jonathan",
      "surname" : "Ragan-Kelley"
    }, {
      "uri" : "http://drinventor/Charlie-Kilpatrick",
      "name" : "Charlie",
      "surname" : "Kilpatrick"
    }, {
      "uri" : "http://drinventor/Brian W.-Smith",
      "name" : "Brian W.",
      "surname" : "Smith"
    }, {
      "uri" : "http://drinventor/Doug-Epps",
      "name" : "Doug",
      "surname" : "Epps"
    }, {
      "uri" : "http://drinventor/Paul-Green",
      "name" : "Paul",
      "surname" : "Green"
    }, {
      "uri" : "http://drinventor/Christophe-Hery",
      "name" : "Christophe",
      "surname" : "Hery"
    }, {
      "uri" : "http://drinventor/Fr?do-Durand",
      "name" : "Fr?do",
      "surname" : "Durand"
    } ]
  },
  "bagOfWords" : [ "fast", "relighting", "have", "long", "be", "major", "area", "research", "-lsb-", "Dorsey", "et", "al.", "1995", "Ng", "et", "al.", "2003", "-rsb-", "also", "perform", "cache", "compression", "Gershbein", "Hanrahan", "create", "system", "lighting", "design", "-lsb-", "2000", "-rsb-", "which", "cache", "intermediate", "result", "deep-framebuffer", "inspire", "G-Buffers", "-lsb-", "Saito", "Takahashi", "1990", "-rsb-", "cache", "fix", "set", "datum", "approximate", "shade", "multitexturing", "Pellacini", "et", "al.", "perform", "shade", "programmable", "graphic", "hardware", "-lsb-", "2005", "-rsb-", "use", "manually-written", "shader", "emulate", "RenderMan", "shader", "while", "allow", "manual", "optimization", "maximize", "preview", "performance", "significant", "burden", "Wexler", "et", "al.", "implement", "high-quality", "supersampling", "GPU", "-lsb-", "2005", "-rsb-", "focus", "final", "rendering", "while", "we", "optimize", "static", "visibility", "result", "different", "datum", "structure", "we", "build", "recent", "work", "direct-to-indirect", "transfer", "which", "exploit", "linearity", "global", "illumination", "cinematic", "relighting", "-lsb-", "ha", "san", "et", "al.", "2006", "-rsb-", "Jones", "et", "al.", "segmented", "shader", "static", "dynamic", "subset", "cache", "shade", "information", "texture-space", "accelerate", "render", "same", "scene", "multiple", "time", "under", "similar", "configuration", "-lsb-", "2000", "-rsb-", "we", "goal", "can", "fully", "meet", "pre-computed", "radiance", "transfer", "-lrb-", "prt", "-rrb-", "technique", "-lsb-", "Sloan", "et", "al.", "2002", "Ng", "et", "al.", "2003", "-rsb-", "because", "usually", "make", "assumption", "reflectance", "lighting", "have", "significant", "precomputation", "cost", "configure", "light", "critical", "bottleneck", "modern", "production", "rendering", "recent", "advance", "have", "seek", "provide", "real-time", "preview", "use", "deep-framebuffer", "graphic", "hardware", "-lsb-", "gershbein", "Hanrahan", "2000", "Pellacini", "et", "al.", "2005", "-rsb-", "deep-framebuffer", "cache", "static", "value", "normal", "texture", "sample", "image", "space", "each", "time", "user", "update", "light", "parameter", "realtime", "shader", "interactively", "recompute", "image", "from", "cache", "unfortunately", "approach", "require", "substantial", "additional", "work", "from", "shader", "author", "similar", "RenderMan", "decouple", "shade", "from", "visibility", "also", "precompute", "final", "weight", "each", "shade", "sample", "relevant", "final", "pixel", "restriction", "light", "come", "first", "from", "current", "production", "workflow", "where", "light", "source", "placement", "separate", "step", "end", "pipeline", "after", "all", "other", "aspect", "have", "be", "freeze", "we", "be", "also", "motivate", "technical", "limitation", "surface", "shader", "tend", "have", "more", "complexity", "could", "prove", "harder", "fully", "map", "graphic", "hardware", "graph", "provide", "specification", "how", "re-shade", "image", "from", "cache", "under", "new", "lighting", "configuration", "-lrb-", "section", "-rrb-", "rsl", "instruction", "tend", "higher-level", "equivalent", "computation", "require", "larger", "number", "GPU", "instruction", "after", "cache", "we", "analyze", "all", "channel", "deep-framebuffer", "eliminate", "those", "whose", "value", "constant", "over", "frame", "non-varying", "term", "convert", "static", "constant", "code", "however", "because", "interpret", "pixel", "discrete", "surface", "shade", "sample", "can", "directly", "express", "effect", "where", "multiple", "shade", "sample", "contribute", "pixel", "antialiasing", "motion", "blur", "depth-of-field", "transparency", "RenderMan", "use", "three", "core", "datum", "structure", "encode", "shading", "visibility", "-lrb-", "fig.", "ii", "-rrb-", "shade", "perform", "object", "space", "surface", "shade", "sample", "call", "micropolygon", "each", "subpixel", "sample", "maintain", "depth-ordered", "visible", "point", "list", "pointer", "micropolygon", "visible", "along", "ray", "shader", "execute", "over", "all", "vertex", "micropolygon", "grid", "pro-" ],
  "content" : "Fast relighting has long been a major area of research [Dorsey et al. 1995; Ng et al. 2003]. They also perform cache compression. Gershbein and Hanrahan created a system for lighting design [2000] which cached intermediate results in a deep-framebuffer inspired by G-Buffers [Saito and Takahashi 1990]. They cached a fixed set of data, and approximated shading with multitexturing. Pellacini et al. performed shading on programmable graphics hardware [2005] using manually-written shaders that emulate RenderMan shaders. While this allows for manual optimization to maximize preview performance, it is a significant burden. Wexler, et al. implemented high-quality supersampling on the GPU [2005], but they focus on final rendering, while we optimize for static visibility, resulting in a different data structure. We build on recent work on direct-to-indirect transfer, which exploits linearity for global illumination in cinematic relighting [Ha san et al. 2006]. Jones et al. segmented shaders into static and dynamic subsets and cached shading information in texture-space to accelerate rendering the same scene multiple times under similar configurations [2000]. Our goals cannot be fully met by pre-computed radiance transfer (PRT) techniques [Sloan et al. 2002; Ng et al. 2003], because they usually make assumptions on the reflectance or lighting and have significant precomputation cost. Configuring lights is a critical bottleneck in modern production rendering, and recent advances have sought to provide real-time preview using deep-framebuffers and graphics hardware [Gershbein and Hanrahan 2000; Pellacini et al. 2005]. A deep-framebuffer caches static values such as normals and texture samples in image space, and each time the user updates light parameters, realtime shaders interactively recompute the image from the cache. Unfortunately, these approaches require substantial additional work from shader authors. Similar to RenderMan, it decouples shading from visibility, but also precomputes the final weight of each shading sample for the relevant final pixels. The restriction to lights came first from current production workflow where light source placement is a separate step at the end of the pipeline, after all other aspects have been frozen. We were also motivated by technical limitations: surface shaders tend to have more complexity and could prove harder to fully map to graphics hardware. The graph provides a specification of how to re-shade an image from the cache under new lighting configurations (Section 6). RSL instructions tend to be higher-level, and the equivalent computation requires a larger number of GPU instructions. After caching, we analyze all channels in the deep-framebuffer and eliminate those whose values are: ? Constant over the frame ? non-varying terms are converted to static constants in the code. However, because they interpret pixels as discrete surface shading samples, they cannot directly express effects where multiple shading samples contribute to a pixel, such as antialiasing, motion blur, depth-of-field, and transparency. For this, RenderMan uses three core data structures to encode shading and visibility ( Fig. 9.i ,ii): ? Shading is performed in object space on surface shading samples called micropolygons. ? Each subpixel sample maintains a depth-ordered visible point list of pointers to the micropolygons visible along that ?ray?. Shaders execute over all vertices of the micropolygon grids, pro-",
  "resources" : [ ]
}