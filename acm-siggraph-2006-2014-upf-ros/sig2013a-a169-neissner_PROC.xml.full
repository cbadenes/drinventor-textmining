{
  "uri" : "sig2013a-a169-neissner_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2013a/a169-neissner_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-time 3D Reconstruction at Scale using Voxel Hashing",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "c419119948f4bfbcb7a4c0e781b99bfa5d43bba3f7e6bb9b3f99e058a632b00b", "p2", "10.1145", "2508363.2508374", "name", "identification", "possible", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "Matthias", "Nie?ner", "1,3", "Michael", "Zollh?fer", "Shahram", "Izadi", "University", "Erlangen-Nuremberg", "Microsoft", "Research", "Cambridge", "Figure", "example", "output", "from", "we", "reconstruction", "system", "without", "any", "geometry", "post-processing", "scene", "about", "20m", "wide", "4m", "high", "capture", "online", "less", "than", "minute", "live", "feedback", "reconstruction", "online", "3d", "reconstruction", "gain", "newfound", "interest", "due", "availability", "real-time", "consumer", "depth", "camera", "basic", "problem", "take", "live", "overlap", "depth", "map", "input", "incrementally", "fuse", "single", "3d", "model", "challenging", "particularly", "when", "real-time", "performance", "desire", "without", "trade", "quality", "scale", "we", "contribute", "online", "system", "large", "fine", "scale", "volumetric", "reconstruction", "base", "memory", "speed", "efficient", "datum", "structure", "we", "system", "use", "simple", "spatial", "hash", "scheme", "compress", "space", "allow", "real-time", "access", "update", "implicit", "surface", "datum", "without", "need", "regular", "hierarchical", "grid", "datum", "structure", "surface", "datum", "only", "store", "densely", "where", "measurement", "observe", "additionally", "datum", "can", "stream", "efficiently", "out", "hash", "table", "allow", "further", "scalability", "during", "sensor", "motion", "we", "show", "interactive", "reconstruction", "variety", "scene", "reconstruct", "both", "fine-grained", "detail", "large", "scale", "environment", "we", "illustrate", "how", "all", "part", "we", "pipeline", "from", "depth", "map", "pre-processing", "camera", "pose", "estimation", "depth", "map", "fusion", "surface", "rendering", "perform", "real-time", "rate", "commodity", "graphic", "hardware", "we", "conclude", "comparison", "current", "state-of-the-art", "online", "system", "illustrate", "improved", "performance", "reconstruction", "quality", "picture/image", "cr", "category", "i.", "3.3", "-lsb-", "Computer", "Graphics", "-rsb-", "generation?digitizing", "scan", "keyword", "real-time", "reconstruction", "scalable", "datum", "structure", "GPU", "Links", "dl", "pdf", "acm", "Reference", "Format", "Nie?ner", "M.", "Zollh?fer", "M.", "Izadi", "S.", "Stamminger", "M.", "2013", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "ACM", "Trans", "graph", "32", "Article", "169", "-lrb-", "November", "2013", "-rrb-", "11", "page", "dous", "10.1145", "2508363.2508374", "http://doi.acm.org/10.1145/2508363.2508374", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "all", "part", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "pro", "commercial", "advantage", "copy", "bear", "notice", "full", "citation", "rst", "page", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "require", "prior", "specus", "permission", "and/or", "fee", "request", "permission", "from", "permissions@acm.org", "copyright", "ACM", "0730-0301/13", "11-art169", "15.00", "DOI", "http://doi.acm.org/10.1145/2508363.2508374", "Marc", "Stamminger", "Stanford", "University", "introduction", "while", "3d", "reconstruction", "established", "field", "computer", "vision", "graphic", "now", "gain", "newfound", "momentum", "due", "wide", "availability", "depth", "camera", "-lrb-", "Microsoft", "Kinect", "Asus", "Xtion", "-rrb-", "since", "device", "output", "live", "noisy", "depth", "map", "particular", "focus", "recent", "work", "online", "surface", "reconstruction", "use", "consumer", "depth", "camera", "ability", "obtain", "reconstruction", "real-time", "open", "up", "various", "interactive", "application", "include", "augmented", "reality", "-lrb-", "ar", "-rrb-", "where", "real-world", "geometry", "can", "fuse", "3d", "graphic", "render", "live", "user", "autonomous", "guidance", "robot", "reconstruct", "respond", "rapidly", "environment", "even", "provide", "immediate", "feedback", "user", "during", "3d", "scanning", "online", "reconstruction", "require", "incremental", "fusion", "many", "overlap", "depth", "map", "single", "3d", "representation", "continuously", "refine", "challenging", "particularly", "when", "real-time", "performance", "require", "without", "trading", "fine-quality", "reconstruction", "spatial", "scale", "many", "state-of-the-art", "online", "technique", "therefore", "employ", "different", "type", "underlie", "datum", "structure", "accelerate", "use", "graphic", "hardware", "however", "have", "particular", "trade-off", "term", "reconstruction", "speed", "scale", "quality", "point-based", "method", "-lrb-", "e.g.", "-lsb-", "Rusinkiewicz", "et", "al.", "2002", "Weise", "et", "al.", "2009", "-rsb-", "-rrb-", "use", "simple", "unstructured", "representation", "closely", "map", "range", "depth", "sensor", "input", "lack", "ability", "directly", "reconstruct", "connected", "surface", "high-quality", "online", "scanning", "small", "object", "have", "be", "demonstrate", "-lsb-", "Weise", "et", "al.", "2009", "-rsb-", "largerscale", "reconstruction", "clearly", "trade", "quality", "and/or", "speed", "-lsb-", "Henry", "et", "al.", "2012", "St?ckler", "Behnke", "2012", "-rsb-", "height-map", "base", "representation", "-lsb-", "pollefey", "et", "al.", "2008", "Gallup", "et", "al.", "2010", "-rsb-", "support", "efficient", "compression", "connected", "surface", "datum", "can", "scale", "efficiently", "larger", "scene", "fail", "reconstruct", "complex", "3d", "structure", "active", "sensor", "implicit", "volumetric", "approach", "particular", "method", "Curless", "Levoy", "-lsb-", "1996", "-rsb-", "have", "demonstrate", "compelling", "result", "-lsb-", "Curless", "Levoy", "1996", "Levoy", "et", "al.", "2000", "Zhou", "Koltun", "2013", "-rsb-", "even", "real-time", "rate", "-lsb-", "Izadi", "et", "al.", "2011", "Newcombe", "et", "al.", "2011", "-rsb-", "however", "rely", "memory", "inefficient", "regular", "voxel", "grid", "turn", "restrict", "scale", "have", "lead", "either", "move", "volume", "variant", "-lsb-", "Roth", "Vona", "2012", "Whelan", "et", "al.", "2012", "-rsb-", "which", "stream", "voxel", "datum", "out-of-core", "sensor", "move", "still", "constrain", "size", "active", "volume", "hierarchical", "datum", "structure", "subdivide", "space", "more", "effectively", "do", "parallelize", "efficiently", "give", "add", "computational", "complexity", "-lsb-", "Zeng", "et", "al.", "2012", "Chen", "et", "al.", "2013", "-rsb-", "we", "contribute", "new", "real-time", "surface", "reconstruction", "system", "which", "support", "fine-quality", "reconstruction", "scale", "we", "approach", "carry", "benefit", "volumetric", "approach", "do", "require", "either", "memory", "constrain", "voxel", "grid", "computational", "overhead", "hierarchical", "datum", "structure", "we", "method", "base", "simple", "memory", "speed", "efficient", "spatial", "hash", "technique", "compress", "space", "allow", "real-time", "fusion", "reference", "implicit", "surface", "datum", "without", "need", "hierarchical", "datum", "structure", "surface", "datum", "only", "store", "densely", "cell", "where", "measurement", "observe", "additionally", "datum", "can", "stream", "efficiently", "out", "hash", "table", "allow", "further", "scalability", "during", "sensor", "motion", "while", "type", "efficient", "spatial", "hash", "technique", "have", "be", "propose", "variety", "render", "collision", "detection", "task", "-lsb-", "Teschner", "et", "al.", "2003", "Lefebvre", "Hoppe", "2006", "Bastos", "Celes", "2008", "Alcantara", "et", "al.", "2009", "Pan", "Manocha", "2011", "Garc?a", "et", "al.", "2011", "-rsb-", "we", "describe", "use", "datum", "structure", "surface", "reconstruction", "where", "underlie", "datum", "need", "continuously", "update", "we", "show", "interactive", "reconstruction", "variety", "scene", "reconstruct", "both", "fine-grained", "large-scale", "environment", "we", "illustrate", "how", "all", "part", "we", "pipeline", "from", "depth", "map", "pre-processing", "sensor", "pose", "estimation", "depth", "map", "fusion", "surface", "rendering", "perform", "real-time", "rate", "commodity", "graphic", "hardware", "we", "conclude", "comparison", "current", "state-of-the-art", "system", "illustrate", "improved", "performance", "reconstruction", "quality", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "169:2", "M.", "Nei?ner", "et", "al.", "related", "work", "over", "three", "decade", "research", "3d", "reconstruction", "section", "we", "review", "relevant", "system", "focus", "online", "reconstruction", "method", "active", "sensor", "unlike", "system", "focus", "reconstruction", "from", "complete", "set", "3d", "point", "-lsb-", "Hoppe", "et", "al.", "1992", "Kazhdan", "et", "al.", "2006", "-rsb-", "online", "method", "require", "incremental", "fusion", "many", "overlap", "depth", "map", "single", "3d", "representation", "continuously", "refine", "typically", "method", "first", "register", "align", "sequential", "depth", "map", "use", "variant", "Iterative", "Closest", "point", "-lrb-", "icp", "-rrb-", "algorithm", "-lsb-", "besl", "McKay", "1992", "Chen", "Medioni", "1992", "-rsb-", "Parametric", "method", "-lsb-", "Chen", "Medioni", "1992", "Higuchi", "et", "al.", "1995", "-rsb-", "simply", "average", "overlap", "sample", "connect", "point", "assume", "simple", "surface", "topology", "-lrb-", "cylinder", "sphere", "-rrb-", "locally", "fit", "polygon", "extension", "mesh", "zippering", "-lsb-", "Turk", "Levoy", "1994", "-rsb-", "select", "one", "depth", "map", "per", "surface", "region", "remove", "redundant", "triangle", "overlap", "region", "stitch", "mesh", "method", "handle", "some", "denoising", "local", "averaging", "point", "fragile", "presence", "outlier", "area", "high", "curvature", "challenge", "associate", "work", "directly", "polygon", "mesh", "have", "lead", "many", "other", "reconstruction", "method", "point-based", "method", "perform", "reconstruction", "merge", "overlap", "point", "avoid", "infer", "connectivity", "render", "final", "model", "perform", "use", "point-based", "rendering", "technique", "-lsb-", "Gross", "Pfister", "2007", "-rsb-", "give", "output", "from", "most", "depth", "sensor", "3d", "point", "sample", "natural", "reconstruction", "method", "work", "directly", "datum", "example", "include", "in-hand", "scanning", "system", "-lsb-", "Rusinkiewicz", "et", "al.", "2002", "Weise", "et", "al.", "2009", "-rsb-", "which", "support", "reconstruction", "only", "single", "small", "object", "small", "scale", "high-quality", "-lsb-", "Weise", "et", "al.", "2009", "-rsb-", "reconstruction", "have", "be", "achieve", "larger", "scene", "have", "be", "reconstruct", "trade", "real-time", "speed", "quality", "-lsb-", "Henry", "et", "al.", "2012", "St?ckler", "Behnke", "2012", "-rsb-", "method", "lack", "ability", "directly", "model", "connected", "surface", "require", "additional", "expensive", "often", "offline", "step", "construct", "surface", "e.g.", "use", "volumetric", "datum", "structure", "-lsb-", "Rusinkiewicz", "et", "al.", "2002", "-rsb-", "height-map", "base", "representation", "explore", "use", "more", "compact", "2.5", "continuous", "surface", "representation", "reconstruction", "-lsb-", "Pollefeys", "et", "al.", "2008", "Gallup", "et", "al.", "2010", "-rsb-", "technique", "particularly", "useful", "modeling", "large", "building", "floor", "wall", "since", "appear", "clear", "discontinuity", "height-map", "multilayered", "height-map", "have", "be", "explore", "support", "reconstruction", "more", "complex", "3d", "shape", "balcony", "doorway", "arch", "-lsb-", "Gallup", "et", "al.", "2010", "-rsb-", "while", "method", "support", "more", "efficient", "compression", "surface", "datum", "2.5", "representation", "fail", "reconstruct", "many", "type", "complex", "3d", "structure", "alternative", "method", "use", "fully", "volumetric", "datum", "structure", "implicitly", "store", "sample", "continuous", "function", "-lsb-", "Hilton", "et", "al.", "1996", "Curless", "Levoy", "1996", "Wheeler", "et", "al.", "1998", "-rsb-", "method", "depth", "map", "convert", "sign", "distance", "field", "cumulatively", "average", "regular", "voxel", "grid", "final", "surface", "extract", "zero-level", "set", "implicit", "function", "use", "isosurface", "polygonisation", "-lrb-", "e.g.", "-lsb-", "Lorensen", "Cline", "1987", "-rsb-", "-rrb-", "raycasting", "well-known", "example", "method", "Curless", "Levoy", "-lsb-", "1996", "-rsb-", "which", "active", "triangulation-based", "sensor", "laser", "range", "scanner", "structured", "light", "camera", "can", "generate", "very", "high", "quality", "result", "-lsb-", "Curless", "Levoy", "1996", "Levoy", "et", "al.", "2000", "Zhou", "Koltun", "2013", "-rsb-", "kinectfusion", "-lsb-", "Newcombe", "et", "al.", "2011", "Izadi", "et", "al.", "2011", "-rsb-", "recently", "adopt", "volumetric", "method", "demonstrate", "compelling", "real-time", "reconstruction", "use", "commodity", "GPU", "while", "show", "high", "quality", "reconstruction", "method", "particularly", "give", "computational", "cost", "approach", "suffer", "from", "one", "major", "limitation", "use", "regular", "voxel", "grid", "impose", "large", "memory", "footprint", "represent", "both", "empty", "space", "surface", "densely", "thus", "fail", "reconstruct", "larger", "scene", "without", "compromise", "quality", "scaling-up", "Volumetric", "fusion", "recent", "work", "begin", "address", "spatial", "limitation", "volumetric", "method", "different", "way", "-lsb-", "Keller", "et", "al.", "2013", "-rsb-", "use", "point-based", "representation", "capture", "quality", "volumetric", "fusion", "remove", "need", "spatial", "datum", "structure", "while", "demonstrate", "compelling", "scalable", "real-time", "reconstruction", "quality", "on-par", "true", "volumetric", "method", "move", "volume", "method", "-lsb-", "Roth", "Vona", "2012", "Whelan", "et", "al.", "2012", "-rsb-", "extend", "gpu-based", "pipeline", "kinectfusion", "while", "still", "operate", "very", "restricted", "regular", "grid", "method", "stream", "out", "voxel", "from", "GPU", "base", "camera", "motion", "free", "space", "new", "datum", "store", "method", "streaming", "one-way", "lossy", "surface", "datum", "compress", "mesh", "once", "move", "host", "can", "stream", "back", "GPU", "while", "offer", "simple", "approach", "scalability", "core", "system", "still", "use", "regular", "grid", "structure", "which", "mean", "active", "volume", "must", "remain", "small", "ensure", "fine-quality", "reconstruction", "limit", "reconstruction", "scene", "close-by", "geometric", "structure", "can", "utilize", "full", "range", "datum", "active", "sensor", "Kinect", "limit", "regular", "grid", "have", "lead", "researcher", "investigate", "more", "efficient", "volumetric", "datum", "structure", "well", "study", "topic", "volume", "render", "literature", "efficient", "method", "base", "sparse", "voxel", "octree", "-lsb-", "laine", "Karras", "2011", "K?mpe", "et", "al.", "2013", "-rsb-", "simpler", "multi-level", "hierarchy", "adaptive", "datum", "structure", "-lsb-", "Kraus", "Ertl", "2002", "Lefebvre", "et", "al.", "2005", "Bastos", "Celes", "2008", "Reichl", "et", "al.", "2012", "-rsb-", "out-of-core", "streaming", "architecture", "large", "dataset", "-lsb-", "Hadwiger", "et", "al.", "2012", "Crassin", "et", "al.", "2009", "-rsb-", "approach", "have", "begin", "explore", "context", "online", "reconstruction", "where", "need", "support", "real-time", "update", "underlie", "datum", "add", "fundamentally", "new", "challenge", "example", "-lsb-", "Zhou", "et", "al.", "2011", "-rsb-", "demonstrate", "gpu-based", "octree", "which", "can", "perform", "Poisson", "surface", "reconstruction", "300k", "vertex", "interactive", "rate", "-lsb-", "Zeng", "et", "al.", "2012", "-rsb-", "implement", "9to", "10-level", "octree", "GPU", "which", "extend", "KinectFusion", "pipeline", "larger", "8m", "8m", "2m", "indoor", "office", "space", "method", "however", "require", "complex", "octree", "structure", "implement", "additional", "computational", "complexity", "pointer", "overhead", "only", "limited", "gain", "scale", "octree", "resolution", "each", "dimension", "increase", "factor", "two", "each", "subdivision", "level", "result", "need", "deep", "tree", "structure", "efficient", "subdivision", "which", "conversely", "impact", "performance", "particular", "gpus", "where", "tree", "traversal", "lead", "thread", "divergence", "render", "literature", "have", "propose", "many", "alternative", "hierarchical", "datum", "structure", "-lsb-", "Lefebvre", "et", "al.", "2005", "Kraus", "Ertl", "2002", "Laine", "Karras", "2011", "K?mpe", "et", "al.", "2013", "Reichl", "et", "al.", "2012", "-rsb-", "-lsb-", "Chen", "et", "al.", "2013", "-rsb-", "hierarchy", "-lsb-", "Lefebvre", "et", "al.", "2005", "-rsb-", "adopt", "3d", "reconstruction", "scale", "optimal", "tree", "depth", "branch", "factor", "be", "empirically", "derive", "-lrb-", "show", "large", "branch", "factor", "shallow", "tree", "optimize", "GPU", "performance", "-rrb-", "while", "avoid", "use", "octree", "system", "still", "carry", "computational", "overhead", "realize", "hierarchical", "datum", "structure", "GPU", "lead", "performance", "only", "real-time", "specific", "scene", "very", "high-end", "graphic", "hardware", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "169:3", "Algorithm", "Overview", "we", "extend", "volumetric", "method", "Curless", "Levoy", "-lsb-", "1996", "-rsb-", "reconstruct", "high-quality", "3d", "surface", "real-time", "scale", "incrementally", "fuse", "noisy", "depth", "map", "memory", "speed", "efficient", "datum", "structure", "Curless", "Levoy", "have", "prove", "produce", "compelling", "result", "give", "simple", "cumulative", "average", "sample", "method", "support", "incremental", "update", "make", "topological", "assumption", "regard", "surface", "approximate", "noise", "characteristic", "triangulation", "base", "sensor", "effectively", "further", "while", "implicit", "representation", "store", "isosurface", "can", "readily", "extract", "we", "method", "address", "main", "drawback", "Curless", "Levoy", "support", "efficient", "scalability", "next", "we", "review", "Curless", "Levoy", "method", "before", "description", "we", "new", "approach", "Implicit", "Volumetric", "fusion", "curless", "levoy?s", "method", "base", "store", "implicit", "sign", "distance", "field", "-lrb-", "sdf", "-rrb-", "within", "volumetric", "datum", "structure", "let", "we", "consider", "regular", "dense", "voxel", "grid", "assume", "input", "sequence", "depth", "map", "depth", "sensor", "initialize", "some", "origin", "relative", "grid", "-lrb-", "typically", "center", "grid", "-rrb-", "first", "rigid", "six", "degree-of-freedom", "-lrb-", "6dof", "-rrb-", "ego-motion", "sensor", "estimate", "typically", "use", "variant", "ICP", "-lsb-", "Besl", "McKay", "1992", "Chen", "Medioni", "1992", "-rsb-", "each", "voxel", "grid", "contain", "two", "value", "sign", "distance", "weight", "single", "depth", "map", "datum", "integrate", "grid", "uniformly", "sweep", "through", "volume", "cull", "voxel", "outside", "view", "frustum", "project", "all", "voxel", "center", "depth", "map", "update", "store", "sdf", "value", "all", "voxel", "project", "onto", "same", "pixel", "consider", "part", "depth", "sample?s", "footprint", "each", "voxel", "sign", "distance", "from", "voxel", "center", "observe", "surface", "measurement", "store", "positive", "distance", "front", "negative", "behind", "near", "zero", "surface", "interface", "reduce", "computational", "cost", "support", "sensor", "motion", "approximate", "sensor", "noise", "Curless", "Levoy", "introduce", "notion", "truncate", "sdf", "-lrb-", "tsdf", "-rrb-", "which", "only", "store", "sign", "distance", "region", "around", "observe", "surface", "region", "can", "adapt", "size", "approximate", "sensor", "noise", "gaussian", "variance", "base", "depth", "-lsb-", "Chang", "et", "al.", "1994", "Nguyen", "et", "al.", "2012", "-rsb-", "only", "tsdf", "value", "store", "voxel", "within", "region", "update", "use", "weighted", "average", "obtain", "estimate", "surface", "finally", "voxel", "-lrb-", "front", "surface", "-rrb-", "part", "each", "depth", "sample?s", "footprint", "outside", "truncation", "region", "explicitly", "mark", "free-space", "allow", "removal", "outlier", "base", "free-space", "violation", "Voxel", "Hashing", "give", "Curless", "Levoy", "truncate", "sdf", "around", "surface", "majority", "datum", "store", "regular", "voxel", "grid", "marked", "either", "free", "space", "unobserved", "space", "rather", "than", "surface", "datum", "key", "challenge", "become", "how", "design", "datum", "structure", "exploit", "underlie", "sparsity", "tsdf", "representation", "we", "approach", "specifically", "avoid", "use", "dense", "hierarchical", "datum", "structure", "remove", "need", "memory", "intensive", "regular", "grid", "computationally", "complex", "hierarchy", "volumetric", "fusion", "instead", "we", "use", "simple", "hash", "scheme", "compactly", "store", "access", "update", "implicit", "surface", "representation", "graphic", "community", "efficient", "spatial", "hash", "method", "have", "be", "explore", "context", "variety", "2d/3d", "rendering", "collision", "detection", "task", "-lsb-", "Teschner", "et", "al.", "2003", "Lefebvre", "Hoppe", "2006", "Bastos", "Celes", "2008", "Alcantara", "et", "al.", "2009", "Pan", "Manocha", "2011", "Garc?a", "et", "al.", "2011", "-rsb-", "sophisticated", "method", "have", "be", "propose", "efficient", "gpu-based", "hash", "greatly", "reduce", "number", "hash", "entry", "collision", "we", "goal", "build", "real-time", "system", "employ", "spatial", "hash", "scheme", "scalable", "volumetric", "reconstruction", "non-trivial", "3d", "reconstruction", "geometry", "unknown", "ahead", "time", "continually", "change", "therefore", "we", "hash", "technique", "must", "support", "dynamic", "allocation", "update", "while", "minimize", "resolve", "potential", "hash", "entry", "collision", "without", "require", "a-priori", "knowledge", "contain", "surface", "geometry", "approach", "design", "we", "datum", "structure", "we", "have", "purposefully", "choose", "extend", "simple", "hash", "scheme", "-lsb-", "Teschner", "et", "al.", "2003", "-rsb-", "while", "more", "sophisticated", "method", "exist", "we", "show", "empirically", "we", "method", "efficient", "term", "speed", "quality", "scalability", "hash", "table", "sparsely", "efficiently", "store", "update", "tsdf", "follow", "we", "describe", "datum", "structure", "more", "detail", "demonstrate", "how", "can", "efficiently", "implement", "GPU", "we", "highlight", "some", "core", "feature", "we", "datum", "structure", "include", "ability", "efficiently", "compress", "volumetric", "tsdf", "while", "maintain", "surface", "resolution", "without", "need", "hierarchical", "spatial", "datum", "structure", "fuse", "new", "tsdf", "sample", "efficiently", "hash", "table", "base", "insertion", "update", "while", "minimize", "collision", "removal", "garbage", "collection", "voxel", "block", "without", "require", "costly", "reorganization", "datum", "structure", "lightweight", "bidirectional", "streaming", "voxel", "block", "between", "host", "GPU", "allow", "unbounded", "reconstruction", "extraction", "isosurface", "from", "datum", "structure", "efficiently", "use", "standard", "raycasting", "polygonization", "operation", "render", "camera", "pose", "estimation", "System", "Pipeline", "we", "pipeline", "depict", "fig.", "Central", "hash", "table", "datum", "structure", "store", "sub-blocks", "contain", "sdf", "call", "voxel", "block", "each", "occupied", "entry", "we", "hash", "table", "refer", "allocate", "voxel", "block", "each", "voxel", "we", "store", "tsdf", "weight", "additional", "color", "value", "hash", "table", "unstructured", "i.e.", "neighbor", "voxel", "block", "store", "spatially", "can", "different", "part", "hash", "table", "we", "hash", "function", "allow", "efficient", "look-up", "voxel", "block", "use", "specify", "-lrb-", "integer", "round", "-rrb-", "world", "coordinate", "we", "hash", "function", "aim", "minimize", "number", "collision", "ensure", "duplicate", "exist", "table", "give", "new", "input", "depth", "map", "we", "begin", "perform", "fusion", "-lrb-", "also", "refer", "integration", "-rrb-", "we", "first", "allocate", "new", "voxel", "block", "insert", "block", "descriptor", "hash", "table", "base", "input", "depth", "map", "only", "occupy", "voxel", "allocate", "empty", "space", "store", "next", "we", "sweep", "each", "allocate", "voxel", "block", "update", "SDF", "color", "weight", "each", "contain", "voxel", "base", "input", "depth", "color", "sample", "addition", "we", "garbage", "collect", "voxel", "block", "which", "too", "far", "from", "isosurface", "contain", "weight", "involve", "free", "allocate", "memory", "well", "remove", "voxel", "block", "entry", "from", "hash", "table", "step", "ensure", "we", "datum", "structure", "remain", "sparse", "over", "time", "after", "integration", "we", "raycast", "implicit", "surface", "from", "current", "estimate", "camera", "pose", "extract", "isosurface", "include", "associate", "color", "extract", "depth", "color", "buffer", "use", "input", "camera", "pose", "estimation", "give", "next", "input", "depth", "map", "projective", "point-plane", "icp", "-lsb-", "Chen", "Medioni", "1992", "-rsb-", "perform", "estimate", "new", "6dof", "camera", "pose", "ensure", "pose", "estimation", "perform", "frame-to-model", "rather", "than", "frame-to-frame", "mitigate", "some", "issue", "drift", "-lrb-", "particularly", "small", "scene", "-rrb-", "-lsb-", "Newcombe", "et", "al.", "2011", "-rsb-", "finally", "we", "algorithm", "perform", "bidirectional", "streaming", "between", "GPU", "host", "hash", "entry", "-lrb-", "associate", "voxel", "block", "-rrb-", "stream", "host", "world", "position", "exit", "estimate", "camera", "view", "frustum", "previously", "stream", "out", "voxel", "block", "can", "also", "stream", "back", "GPU", "datum", "structure", "when", "revisit", "area", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "169:4", "M.", "Nei?ner", "et", "al.", "figure", "Pipeline", "overview", "datum", "structure", "fig.", "show", "we", "voxel", "hash", "datum", "structure", "conceptually", "infinite", "uniform", "grid", "subdivide", "world", "voxel", "block", "each", "block", "small", "regular", "voxel", "grid", "we", "current", "implementation", "voxel", "block", "compose", "voxel", "each", "voxel", "store", "tsdf", "color", "weight", "require", "byte", "memory", "struct", "Voxel", "-lcb-", "float", "sdf", "uchar", "colorrgb", "-lsb-", "-rsb-", "uchar", "weight", "-rcb-", "exploit", "sparsity", "voxel", "block", "only", "allocate", "around", "reconstructed", "surface", "geometry", "we", "use", "efficient", "GPU", "accelerate", "hash", "table", "manage", "allocation", "retrieval", "voxel", "block", "hash", "table", "store", "hash", "entry", "each", "contain", "pointer", "allocate", "voxel", "block", "Voxel", "block", "can", "retrieve", "from", "hash", "table", "use", "integer", "world", "coordinate", "-lrb-", "-rrb-", "find", "coordinate", "3d", "point", "world", "space", "achieve", "simple", "multiplication", "rounding", "we", "map", "from", "world", "coordinate", "-lrb-", "-rrb-", "hash", "value", "-lrb-", "-rrb-", "use", "follow", "hash", "function", "where", "large", "prime", "number", "-lrb-", "we", "case", "73856093", "19349669", "83492791", "respectively", "base", "-lsb-", "Teschner", "et", "al.", "2003", "-rsb-", "-rrb-", "hash", "table", "size", "addition", "store", "pointer", "voxel", "block", "each", "hash", "entry", "also", "contain", "associated", "world", "position", "offset", "pointer", "handle", "collision", "efficiently", "-lrb-", "describe", "next", "section", "-rrb-", "struct", "HashEntry", "-lcb-", "short", "position", "-lsb-", "-rsb-", "short", "offset", "int", "pointer", "-rcb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "mod", "figure", "we", "voxel", "hash", "datum", "structure", "conceptually", "infinite", "uniform", "grid", "partition", "world", "use", "we", "hash", "function", "we", "map", "from", "integer", "world", "coordinate", "hash", "bucket", "which", "store", "small", "array", "pointer", "regular", "grid", "voxel", "block", "each", "voxel", "block", "contain", "grid", "sdf", "value", "when", "information", "red", "block", "get", "add", "collision", "appear", "which", "resolve", "use", "second", "element", "hash", "bucket", "4.1", "Resolving", "Collisions", "Collisions", "appear", "multiple", "allocate", "block", "map", "same", "hash", "value", "-lrb-", "see", "red", "block", "Fig.", "-rrb-", "we", "handle", "collision", "uniformly", "organize", "hash", "table", "bucket", "one", "per", "unique", "hash", "value", "each", "bucket", "sequentially", "store", "small", "number", "hash", "entry", "when", "collision", "occur", "we", "store", "block", "pointer", "next", "available", "sequential", "entry", "bucket", "-lrb-", "see", "Fig.", "-rrb-", "find", "voxel", "block", "particular", "world", "position", "we", "first", "evaluate", "we", "hash", "function", "lookup", "traverse", "associate", "bucket", "until", "we", "block", "entry", "find", "achieve", "simply", "compare", "store", "hash", "entry", "world", "position", "query", "position", "reasonable", "selection", "hash", "table", "bucket", "size", "-lrb-", "see", "later", "-rrb-", "rarely", "bucket", "overflow", "however", "happen", "we", "append", "link", "list", "entry", "fill", "up", "other", "free", "spot", "next", "available", "bucket", "-lrb-", "relative", "-rrb-", "pointer", "link", "list", "store", "offset", "field", "hash", "table", "entry", "list", "append", "full", "bucket", "set", "offset", "pointer", "last", "entry", "bucket", "all", "follow", "entry", "chained", "use", "offset", "field", "order", "create", "additional", "link", "bucket", "we", "linearly", "search", "across", "hash", "table", "free", "slot", "store", "we", "entry", "append", "link", "list", "accordingly", "we", "avoid", "last", "entry", "each", "bucket", "locally", "reserve", "link", "list", "head", "show", "later", "we", "choose", "table", "bucket", "size", "keep", "number", "collision", "therefore", "append", "link", "list", "minimum", "most", "scene", "impact", "overall", "performance", "insertion", "insert", "new", "hash", "entry", "we", "first", "evaluate", "hash", "function", "determine", "target", "bucket", "we", "iterate", "over", "all", "bucket", "element", "include", "possible", "list", "attach", "last", "entry", "we", "find", "element", "same", "world", "space", "position", "we", "can", "immediately", "return", "reference", "otherwise", "we", "look", "first", "empty", "position", "within", "bucket", "position", "bucket", "available", "we", "insert", "new", "hash", "entry", "bucket", "full", "we", "append", "element", "its", "link", "list", "element", "-lrb-", "see", "Fig.", "-rrb-", "avoid", "race", "condition", "when", "insert", "hash", "entry", "parallel", "we", "lock", "bucket", "atomically", "write", "when", "suitable", "empty", "position", "find", "eliminate", "duplicate", "entry", "ensure", "link", "list", "consistency", "bucket", "lock", "write", "all", "other", "allocation", "same", "bucket", "stagger", "until", "next", "frame", "process", "may", "delay", "some", "allocation", "marginally", "however", "practice", "cause", "degradation", "reconstruction", "quality", "-lrb-", "observe", "result", "supplementary", "video", "-rrb-", "particularly", "Curless", "Levoy", "method", "support", "order", "independent", "update", "retrieval", "read", "hash", "entry", "query", "position", "we", "compute", "hash", "value", "perform", "linear", "search", "within", "corresponding", "bucket", "entry", "find", "bucket", "have", "link", "list", "associate", "-lrb-", "offset", "value", "last", "entry", "set", "-rrb-", "we", "also", "have", "traverse", "list", "note", "we", "do", "require", "bucket", "fill", "from", "leave", "right", "describe", "below", "remove", "value", "can", "lead", "fragmentation", "so", "traversal", "do", "stop", "when", "empty", "entry", "find", "bucket", "deletion", "delete", "hash", "entry", "similar", "insertion", "given", "world", "position", "we", "first", "compute", "hash", "linearly", "search", "corresponding", "hash", "bucket", "include", "list", "traversal", "we", "have", "find", "match", "entry", "without", "list", "traversal", "we", "can", "simply", "delete", "last", "element", "bucket", "non-zero", "offset", "store", "-lrb-", "i.e.", "element", "list", "head", "-rrb-", "we", "copy", "hash", "entry", "point", "offset", "last", "element", "bucket", "delete", "from", "its", "current", "position", "otherwise", "entry", "-lrb-", "non-head", "-rrb-", "element", "link", "list", "we", "delete", "correct", "list", "pointer", "accordingly", "-lrb-", "see", "Fig.", "-rrb-", "synchronization", "require", "deletion", "directly", "within", "bucket", "however", "case", "we", "need", "modify", "link", "list", "we", "lock", "bucket", "atomically", "stagger", "further", "list", "operation", "bucket", "until", "next", "frame", "4.2", "hash", "operation", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "169:5", "Figure", "hash", "table", "break", "down", "set", "bucket", "each", "slot", "either", "unallocated", "-lrb-", "white", "-rrb-", "contain", "entry", "-lrb-", "blue", "-rrb-", "store", "query", "world", "position", "pointer", "surface", "datum", "offset", "pointer", "deal", "bucket", "overflow", "example", "hash", "operation", "illustration", "we", "insert", "remove", "four", "entry", "all", "map", "hash", "update", "entry", "pointer", "accordingly", "Voxel", "Block", "Allocation", "before", "integration", "new", "tsdf", "voxel", "block", "must", "allocate", "fall", "within", "footprint", "each", "input", "depth", "sample", "also", "within", "truncation", "region", "surface", "measurement", "we", "process", "depth", "sample", "parallel", "insert", "hash", "entry", "allocate", "voxel", "block", "within", "truncation", "region", "around", "observe", "surface", "size", "truncation", "adapt", "base", "variance", "depth", "compensate", "larger", "uncertainty", "distant", "measurement", "-lsb-", "Chang", "et", "al.", "1994", "Nguyen", "et", "al.", "2012", "-rsb-", "each", "input", "depth", "sample", "we", "instantiate", "ray", "interval", "bind", "truncation", "region", "give", "predefined", "voxel", "resolution", "block", "size", "we", "use", "dda", "-lsb-", "Amanatides", "Woo", "1987", "-rsb-", "determine", "all", "voxel", "block", "intersect", "ray", "each", "candidate", "find", "we", "insert", "new", "voxel", "block", "entry", "hash", "table", "idealized", "case", "each", "depth", "sample", "would", "model", "entire", "frustum", "rather", "than", "single", "ray", "we", "would", "allocate", "all", "voxel", "block", "within", "truncation", "region", "intersect", "frustum", "practice", "however", "lead", "degradation", "performance", "-lrb-", "currently", "10-fold", "-rrb-", "we", "ray-based", "approximation", "provide", "balance", "between", "performance", "precision", "give", "continuous", "nature", "reconstruction", "frame", "rate", "sensor", "mobility", "user", "practice", "lead", "hole", "appear", "between", "voxel", "block", "larger", "distance", "-lrb-", "see", "result", "accompany", "video", "-rrb-", "once", "we", "have", "successfully", "insert", "entry", "hash", "table", "we", "allocate", "portion", "preallocated", "heap", "memory", "GPU", "store", "voxel", "block", "datum", "heap", "linear", "array", "memory", "allocate", "once", "upon", "initialization", "divide", "contiguous", "block", "-lrb-", "mapping", "size", "voxel", "block", "-rrb-", "manage", "maintain", "list", "available", "block", "list", "linear", "buffer", "index", "all", "unallocated", "block", "new", "block", "allocate", "use", "last", "index", "list", "voxel", "block", "subsequently", "free", "its", "index", "append", "end", "list", "since", "list", "access", "parallel", "synchronization", "necessary", "increment", "decrement", "end", "list", "pointer", "use", "atomic", "operation", "Voxel", "Block", "integration", "we", "update", "all", "allocate", "voxel", "block", "currently", "within", "camera", "view", "frustum", "after", "previous", "step", "-lrb-", "see", "section", "-rrb-", "all", "voxel", "block", "truncation", "region", "visible", "surface", "allocate", "however", "large", "fraction", "hash", "table", "empty", "-lrb-", "i.e.", "refer", "any", "voxel", "block", "-rrb-", "further", "significant", "amount", "voxel", "block", "outside", "view", "frustum", "under", "assumption", "tsdf", "integration", "can", "do", "very", "efficiently", "only", "select", "available", "block", "inside", "current", "camera", "frustum", "Voxel", "Block", "selection", "select", "voxel", "block", "integration", "we", "first", "parallel", "access", "all", "hash", "table", "entry", "store", "corresponding", "binary", "flag", "array", "occupied", "visible", "voxel", "block", "zero", "otherwise", "we", "scan", "array", "use", "parallel", "prefix", "sum", "technique", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "facilitate", "large", "scan", "size", "-lrb-", "we", "hash", "table", "can", "have", "million", "entry", "-rrb-", "we", "use", "three", "level", "up", "down", "sweep", "use", "scan", "result", "we", "compact", "hash", "table", "another", "buffer", "which", "contain", "all", "hash", "entry", "point", "voxel", "block", "within", "view", "frustum", "-lrb-", "see", "Fig.", "-rrb-", "note", "voxel", "block", "copy", "just", "associate", "hash", "entry", "Implicit", "surface", "Update", "generate", "list", "hash", "entry", "process", "parallel", "update", "tsdf", "value", "single", "GPGPU", "kernel", "execute", "each", "associate", "block", "one", "thread", "allocate", "per", "voxel", "mean", "voxel", "block", "process", "single", "GPU", "multiprocessor", "thus", "maximize", "cache", "hit", "minimize", "code", "divergence", "practice", "more", "efficient", "than", "assign", "single", "thread", "process", "entire", "voxel", "block", "update", "voxel", "block", "involve", "re-computation", "associate", "tsdf", "weight", "color", "Distance", "value", "integrate", "use", "run", "average", "Curless", "Levoy", "-lsb-", "Curless", "Levoy", "1996", "-rsb-", "we", "set", "integration", "weight", "accord", "depth", "value", "order", "incorporate", "noise", "characteristic", "sensor", "i.e.", "more", "weight", "give", "nearer", "depth", "measurement", "which", "we", "assume", "less", "noise", "color", "also", "update", "accord", "run", "average", "much", "more", "weight", "give", "recent", "color", "sample", "-lrb-", "reduce", "wash", "out", "color", "-rrb-", "one", "important", "part", "integration", "step", "update", "all", "voxel", "block", "fall", "current", "frustum", "irrespective", "whether", "reside", "current", "truncation", "region", "can", "due", "surface", "be", "physically", "move", "small", "outlier", "depth", "map", "be", "allocate", "previously", "which", "longer", "observe", "block", "treat", "any", "differently", "continuously", "update", "show", "next", "however", "we", "evaluate", "all", "voxel", "block", "after", "integration", "identify", "candidate", "potential", "garbage", "collection", "Garbage", "Collection", "Garbage", "collection", "remove", "voxel", "block", "allocate", "due", "noisy", "outlier", "move", "surface", "step", "operate", "compacted", "hash", "table", "we", "obtain", "previously", "each", "associate", "voxel", "block", "we", "perform", "summarization", "step", "obtain", "both", "minimum", "absolute", "tsdf", "value", "maximum", "weight", "maximum", "weight", "voxel", "block", "zero", "minimum", "tsdf", "larger", "than", "threshold", "we", "flag", "block", "deletion", "second", "pass", "parallel", "we", "delete", "all", "flag", "entry", "use", "hash", "table", "delete", "operation", "describe", "previously", "when", "hash", "entry", "get", "delete", "successfully", "we", "also", "free", "corresponding", "voxel", "block", "append", "voxel", "block", "pointer", "heap", "-lrb-", "cf.", "section", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "169:6", "M.", "Nei?ner", "et", "al.", "Figure", "Voxel", "Block", "selection", "first", "step", "all", "occupy", "visible", "hash", "entry", "identify", "use", "parallel", "prefix", "sum", "scan", "simple", "copy", "kernel", "copy", "much", "smaller", "contiguous", "array", "can", "efficiently", "traverse", "parallel", "subsequent", "operation", "surface", "extraction", "we", "perform", "raycast", "extract", "implicitly", "store", "isosurface", "first", "we", "compute", "end", "point", "each", "ray", "conservatively", "rasterize", "entire", "bound", "box", "all", "allocate", "voxel", "block", "current", "view", "frustum", "parallel", "we", "rasterize", "each", "voxel", "block", "-lrb-", "retrieve", "from", "compact", "hash", "table", "buffer", "compute", "during", "integration", "-rrb-", "two", "pass", "generate", "two", "z-buffer", "minimum", "maximum", "depth", "demonstrate", "another", "benefit", "we", "linear", "hash", "table", "datum", "structure", "-lrb-", "over", "hierarchical", "datum", "structure", "-rrb-", "allow", "fast", "parallel", "access", "all", "allocate", "block", "operation", "rasterization", "each", "output", "pixel", "we", "march", "ray", "from", "associate", "minimum", "maximum", "depth", "value", "during", "march", "we", "must", "evaluate", "tsdf", "neighboring", "world", "position", "along", "current", "ray", "step", "unallocated", "voxel", "block", "also", "consider", "empty", "space", "within", "occupy", "voxel", "block", "we", "apply", "tri-linear", "interpolation", "look", "up", "eight", "neighbor", "voxel", "one", "special", "case", "need", "consider", "sampling", "across", "voxel", "block", "boundary", "deal", "we", "retrieve", "neighbor", "voxel", "lookup", "via", "hash", "table", "rather", "than", "sampling", "voxel", "block", "directly", "practice", "we", "use", "hash", "table", "lookup", "irrespective", "whether", "voxel", "block", "boundary", "due", "caching", "reduce", "register", "count", "per", "thread", "non-divergent", "code", "increase", "performance", "over", "direct", "block", "sampling", "we", "have", "also", "try", "use", "one-voxel", "overlap", "region", "around", "block", "order", "simplify", "tri-linear", "read", "without", "need", "access", "multiple", "voxel", "block", "however", "approximately", "double", "memory", "footprint", "we", "find", "require", "overlap", "synchronization", "surface", "integration", "bear", "significant", "computational", "overhead", "locate", "surface", "interface", "-lrb-", "zero-crossing", "-rrb-", "we", "determine", "sign", "change", "current", "previous", "-lrb-", "tri-linearly-interpolated", "-rrb-", "tsdf", "value", "we", "ignore", "zero-crossing", "from", "negative", "positive", "refer", "back-facing", "surface", "geometry", "order", "speed", "up", "ray", "march", "we", "skip", "predefined", "interval", "-lrb-", "half", "minimum", "truncation", "value", "-rrb-", "avoid", "miss", "isosurface", "provide", "only", "coarse", "zero-crossing", "position", "refine", "further", "we", "use", "iterative", "line", "search", "once", "zero-crossing", "detect", "estimate", "true", "surface", "location", "Camera", "Tracking", "once", "surface", "extract", "via", "raycasting", "can", "shaded", "render", "use", "frame-to-model", "camera", "pose", "estimation", "-lsb-", "Newcombe", "et", "al.", "2011", "-rsb-", "we", "use", "next", "input", "frame", "along", "raycasted", "depth", "map", "estimate", "pose", "ensure", "new", "pose", "estimate", "prior", "depth", "map", "fusion", "pose", "estimate", "use", "point-plane", "variant", "icp", "-lsb-", "Chen", "Medioni", "1992", "-rsb-", "projective", "datum", "association", "point-plane", "energy", "function", "linearize", "-lsb-", "low", "2004", "-rsb-", "GPU", "matrix", "use", "parallel", "reduction", "solve", "via", "singular", "value", "decomposition", "CPU", "we", "datum", "structure", "also", "store", "associate", "color", "datum", "we", "incorporate", "weighting", "factor", "point-plane", "error-metric", "base", "color", "consistency", "between", "extract", "input", "rgb", "value", "-lsb-", "Johnson", "Bing", "Kang", "1999", "-rsb-", "Figure", "stream", "camera", "move", "from", "leave", "right", "Voxel", "block", "leave", "camera", "frustum", "stream", "out", "-lrb-", "green", "-rrb-", "stream", "happen", "chunk", "basis", "-lrb-", "red", "block", "-rrb-", "stream", "basic", "datum", "structure", "describe", "so", "far", "allow", "high-resolution", "voxel", "block", "model", "beyond", "resolution", "range", "current", "commodity", "depth", "camera", "-lrb-", "see", "section", "-rrb-", "however", "GPU", "memory", "performance", "become", "consideration", "when", "we", "attempt", "maintain", "surface", "datum", "far", "outside", "view", "frustum", "hash", "table", "deal", "issue", "allow", "unbounded", "reconstruction", "we", "utilize", "bidirectional", "gpu-host", "streaming", "scheme", "we", "unstructured", "datum", "structure", "well-suited", "purpose", "since", "streaming", "voxel", "block", "out", "do", "require", "any", "reorganization", "hash", "table", "we", "create", "active", "region", "define", "sphere", "contain", "current", "camera", "view", "frustum", "safety", "region", "around", "standard", "kinect", "we", "assume", "depth", "range", "up", "eight", "meter", "we", "locate", "center", "sphere", "four", "meter", "from", "camera", "position", "use", "radius", "eight", "meter", "-lrb-", "see", "Figure", "-rrb-", "bidirectional", "streaming", "voxel", "block", "happen", "every", "frame", "beginning", "pipeline", "directly", "after", "pose", "estimation", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "169:7", "8.1", "gpu-to-host", "stream", "stream", "voxel", "block", "out", "active", "region", "we", "first", "access", "hash", "table", "parallel", "mark", "voxel", "block", "which", "move", "out", "active", "region", "all", "candidate", "we", "delete", "corresponding", "hash", "entry", "append", "they", "efficiently", "intermediate", "buffer", "second", "pass", "all", "hash", "entry", "correspond", "voxel", "block", "copy", "another", "intermediate", "buffer", "original", "voxel", "block", "clear", "corresponding", "location", "append", "back", "heap", "so", "can", "reuse", "finally", "intermediate", "buffer", "copy", "back", "host", "access", "host", "voxel", "datum", "longer", "organize", "hash", "table", "instead", "we", "logically", "subdivide", "world", "space", "uniformly", "chunk", "-lrb-", "we", "current", "implementation", "each", "set", "1m", "-rrb-", "Voxel", "block", "append", "chunk", "use", "link", "list", "each", "voxel", "block", "we", "store", "voxel", "block", "descriptor", "which", "correspond", "hash", "entry", "datum", "well", "voxel", "datum", "8.2", "Host-to-GPU", "Streaming", "Host-to-GPU", "streaming", "we", "first", "identify", "chunk", "completely", "fall", "spherical", "active", "region", "again", "due", "user", "move", "back", "previously", "reconstruct", "region", "contrast", "gputo-cpu", "streaming", "which", "work", "per", "voxel", "block", "level", "cputo-gpu", "streaming", "operate", "per", "chunk", "basis", "so", "chunk", "identify", "streaming", "all", "voxel", "block", "chunk", "stream", "GPU", "enhance", "performance", "give", "high", "host-gpu", "bandwidth", "ability", "efficiently", "cull", "voxel", "block", "outside", "view", "frustum", "due", "limited", "CPU", "compute", "per", "frame", "streaming", "from", "host-togpu", "stagger", "one", "chunk", "per", "frame", "we", "select", "chunk", "tag", "streaming", "most", "near", "camera", "frustum", "center", "we", "copy", "chunk", "GPU", "via", "intermediate", "buffer", "create", "gpu-to-host", "streaming", "after", "copy", "GPU", "parallel", "we", "insert", "voxel", "block", "descriptor", "entry", "hash", "table", "allocate", "voxel", "block", "memory", "from", "heap", "copy", "voxel", "datum", "accordingly", "similar", "allocation", "phase", "-lrb-", "see", "section", "-rrb-", "however", "when", "streaming", "datum", "all", "hash", "entry", "must", "insert", "within", "single", "frame", "rather", "than", "stagger", "insertion", "stream", "voxel", "block", "we", "check", "descriptor", "atomically", "compare", "whether", "position", "occupy", "table", "entry", "exist", "we", "proceed", "search", "next", "available", "free", "position", "bucket", "-lrb-", "describe", "below", "we", "ensure", "duplicate", "-rrb-", "otherwise", "we", "write", "stream", "hash", "entry", "position", "hash", "table", "bucket", "full", "entry", "append", "end", "list", "both", "write", "free", "entry", "directly", "bucket", "append", "end", "link", "list", "must", "perform", "atomically", "one", "important", "consideration", "streaming", "ensure", "voxel", "block", "never", "duplicate", "host", "GPU", "lead", "potential", "memory", "leak", "give", "host-to-gpu", "streaming", "stagger", "rare", "case", "where", "voxel", "block", "wait", "stream", "may", "enter", "view", "frustum", "we", "must", "verify", "new", "allocation", "voxel", "block", "staggered", "region", "end", "we", "store", "binary", "occupancy", "grid", "GPU", "where", "each", "entry", "correspond", "particular", "chunk", "set", "bit", "indicate", "chunk", "reside", "GPU", "allocation", "can", "occur", "region", "otherwise", "chunk", "should", "assume", "host", "allocation", "should", "avoid", "binary", "grid", "carry", "little", "GPU", "memory", "overhead", "512kb", "256", "can", "easily", "re-allocated", "on-the-fly", "extend", "larger", "scene", "8.3", "Stream", "Allocation", "Synchronization", "result", "we", "have", "implement", "we", "datum", "structure", "use", "DirectX", "11", "Compute", "Shaders", "we", "use", "Asus", "Xtion", "scene", "Fig.", "10", "kinect", "Windows", "camera", "all", "other", "scene", "both", "provide", "rgb-d", "datum", "30Hz", "result", "live", "scene", "capture", "we", "test", "scene", "show", "figure", "11", "well", "supplementary", "material", "we", "capture", "variety", "indoor", "outdoor", "scene", "under", "variety", "lighting", "condition", "while", "quality", "active", "infrared", "sensor", "affect", "significantly", "outdoor", "scene", "we", "system", "still", "manage", "reconstruct", "large-scale", "outdoor", "scene", "fine", "quality", "statue", "fig.", "show", "result", "after", "online", "scan", "20m", "long", "corridor", "museum", "about", "4m", "high", "statue", "which", "capture", "reconstruct", "live", "under", "minute", "passageway", "-lrb-", "fig.", "11", "top", "-rrb-", "show", "pathway", "shop", "30m", "long", "reconstruct", "live", "QUEENS", "-lrb-", "Fig.", "11", "middle", "-rrb-", "show", "large", "courtyard", "-lrb-", "stretch", "16m", "12m", "2m", "-rrb-", "reconstruct", "approximately", "minute", "finally", "bookshop", "-lrb-", "fig.", "11", "bottom", "-rrb-", "show", "three", "level", "bookstore", "reconstruct", "under", "minute", "reconstruction", "demonstrate", "both", "scale", "quality", "be", "all", "reconstruct", "well", "above", "30hz", "frame", "rate", "kinect", "show", "figure", "allow", "potential", "increase", "voxel", "resolution", "additional", "icp", "step", "more", "robust", "camera", "tracking", "we", "use", "voxel", "size", "4mm", "fig.", "10", "10mm", "fig.", "11", "we", "also", "test", "we", "system", "2mm", "voxel", "without", "visible", "improvement", "overall", "reconstruction", "quality", "while", "highlight", "limit", "current", "depth", "sense", "technology", "we", "believe", "open", "up", "new", "possibility", "future", "depth", "acquisition", "hardware", "we", "measure", "performance", "we", "entire", "pipeline", "include", "run-time", "overhead", "-lrb-", "display", "rendering", "-rrb-", "Intel", "Core", "i7", "3.4", "GHz", "CPU", "16gb", "RAM", "single", "NVIDIA", "GeForce", "GTX", "Titan", "average", "timing", "among", "all", "test", "scene", "21.8", "m", "-lrb-", "46f", "p", "-rrb-", "8.0", "m", "-lrb-", "37", "overall", "pipeline", "-rrb-", "ICP", "pose", "estimation", "-lrb-", "15", "iteration", "-rrb-", "4.6", "m", "-lrb-", "21", "-rrb-", "surface", "integration", "4.8", "m", "-lrb-", "22", "-rrb-", "surface", "extraction", "shading", "-lrb-", "include", "color", "phong", "shade", "-rrb-", "4.4", "m", "-lrb-", "20", "-rrb-", "streaming", "input", "datum", "processing", "separate", "timing", "each", "test", "scene", "provide", "fig.", "we", "datum", "structure", "use", "total", "34mb", "hash", "table", "all", "auxiliary", "buffer", "allow", "hash", "table", "21", "entry", "each", "contain", "12", "byte", "we", "experiment", "show", "bucket", "size", "two", "provide", "best", "performance", "leave", "we", "about", "million", "bucket", "we", "pre-allocate", "1gb", "heap", "memory", "provide", "space", "voxel", "datum", "GPU", "voxel", "per", "block", "-lrb-", "byte", "per", "voxel", "-rrb-", "correspond", "18", "voxel", "block", "note", "21", "hash", "entry", "only", "index", "18", "voxel", "block", "result", "low", "hash", "occupancy", "thus", "minimize", "hash", "collision", "average", "we", "find", "about", "140k", "voxel", "block", "allocate", "when", "capture", "we", "test", "scene", "voxel", "size", "8mm", "-lrb-", "vary", "scene", "complexity", "-rrb-", "correspond", "equal", "amount", "occupied", "hash", "entry", "result", "hash", "table", "occupancy", "120k", "bucket", "single", "entry", "10k", "bucket", "two", "entry", "bucket", "size", "two", "hash", "table", "size", "21", "all", "test", "scene", "run", "only", "0.1", "bucket", "overflow", "handle", "link", "list", "across", "all", "scene", "largest", "list", "length", "three", "total", "700", "link", "list", "entry", "allocate", "across", "all", "scene", "which", "negligible", "compare", "hash", "table", "size", "average", "less", "than", "300mb", "memory", "allocate", "surface", "datum", "-lrb-", "less", "than", "600mb", "color", "-rrb-", "compare", "favorably", "regular", "grid", "would", "require", "well", "over", "5gb", "-lrb-", "include", "color", "-rrb-", "same", "voxel", "resolution", "-lrb-", "8mm", "-rrb-", "spatial", "extent", "-lrb-", "8m", "depth", "-rrb-", "also", "leave", "enough", "space", "encode", "RGB", "datum", "directly", "store", "voxel", "-lrb-", "see", "Fig.", "11", "-rrb-", "practice", "simple", "hash", "scheme", "small", "bucket", "size", "large", "hash", "table", "size", "work", "well", "we", "scenario", "we", "can", "tolerate", "larger", "sparser", "-lrb-", "21", "-rrb-", "hash", "table", "size", "because", "memory", "footprint", "hash", "table", "insignificant", "-lrb-", "34mb", "-rrb-", "compare", "voxel", "block", "buffer", "-lrb-", "which", "pre-allocated", "1gb", "-rrb-", "smaller", "hash", "table", "size", "cause", "higher", "occupancy", "decrease", "performance", "example", "statue", "scene", "we", "standard", "setting", "-lrb-", "21", "element", "-rrb-", "occupy", "6.4", "hash", "table", "run", "21m", "200k", "element", "occupancy", "rise", "65", "performance", "reduce", "24.8", "m", "160k", "element", "occupancy", "rise", "81", "performance", "further", "fall", "25.6", "ms.", "we", "live", "system", "we", "choose", "larger", "table", "size", "we", "favor", "performance", "over", "small", "memory", "gain", "we", "pipeline", "currently", "use", "atomic", "operation", "per", "hash", "bucket", "allocation", "streaming", "show", "we", "timing", "across", "all", "scene", "sequential", "operation", "cause", "negligible", "performance", "overhead", "due", "hash", "collision", "be", "minimal", "more", "sophisticated", "hash", "approach", "-lsb-", "Lefebvre", "Hoppe", "2006", "Bastos", "Celes", "2008", "Alcantara", "et", "al.", "2009", "Pan", "Manocha", "2011", "Garc?a", "et", "al.", "2011", "-rsb-", "could", "further", "reduce", "collision", "allow", "smaller", "hash", "table", "however", "how", "method", "deal", "high", "throughput", "datum", "fusion", "streaming", "unclear", "also", "important", "stress", "we", "simple", "hash", "method", "work", "well", "practice", "handle", "scalability", "quality", "framerate", "40fp", "across", "all", "scene", "Figure", "Performance", "comparison", "frame", "rate", "measurement", "across", "we", "test", "scene", "compare", "against", "two", "state-of-the-art", "reconstruction", "method", "extend", "-lrb-", "move", "volume", "-rrb-", "regular", "grid", "hierarchical", "approach", "-lsb-", "Chen", "et", "al.", "2013", "-rsb-", "9.1", "Performance", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "169:8", "M.", "Nei?ner", "et", "al.", "Figure", "Quality", "scale", "comparison", "related", "system", "bottom", "right", "we", "method", "maintain", "large", "work", "volume", "streaming", "frame-rate", "-lrb-", "example", "4mm", "voxel", "-rrb-", "top", "move", "volume", "base", "regular", "grid", "same", "physical", "extent", "voxel", "resolution", "coarse", "quality", "reduce", "-lrb-", "top", "left", "-rrb-", "maintain", "same", "voxel", "resolution", "size", "volume", "must", "decrease", "significantly", "-lrb-", "top", "right", "-rrb-", "bottom", "leave", "performance", "bottleneck", "hierarchical", "grid", "lead", "more", "tracking", "drift", "reduce", "overall", "quality", "Figure", "comparison", "camera", "tracking", "drift", "gray", "result", "hierarchical", "approach", "Chen", "et", "al.", "-lsb-", "2013", "-rsb-", "yellow", "we", "result", "note", "twist", "final", "model", "chen?s", "approach", "e.g.", "center", "UEENS", "leave", "hand", "side", "assageway", "reconstruction", "9.2", "comparison", "Fig.", "we", "show", "quality", "performance", "we", "method", "compare", "previous", "work", "all", "code", "test", "same", "hardware", "-lrb-", "see", "above", "-rrb-", "fixed", "number", "ICP", "iteration", "-lrb-", "15", "-rrb-", "we", "algorithm", "support", "real-time", "streaming", "we", "conduct", "comparison", "similar", "move", "volume", "approach", "first", "we", "compare", "against", "Extended", "fusion", "-lsb-", "Roth", "Vona", "2012", "Whelan", "et", "al.", "2012", "-rsb-", "use", "regular", "uniform", "grid", "include", "streaming", "scale-up", "volumetric", "fusion", "second", "we", "compare", "against", "hierarchical", "fusion", "-lsb-", "Chen", "et", "al.", "2013", "-rsb-", "support", "larger", "move", "volume", "than", "other", "approach", "correspond", "timing", "show", "fig.", "most", "significant", "limitation", "hierarchy", "datum", "structure", "overhead", "cause", "performance", "drop", "particularly", "complex", "scene", "we", "test", "scene", "entire", "hierarchy", "pipeline", "-lrb-", "include", "pose", "estimation", "fusion", "streaming", "-rrb-", "run", "15hz", "which", "lower", "than", "input", "frame", "rate", "note", "measurement", "base", "reference", "implementation", "Chen", "et", "al.", "-lsb-", "2013", "-rsb-", "we", "system", "also", "perform", "favorably", "compare", "streaming", "regular", "grid", "term", "frame-rate", "-lrb-", "label", "Extended", "Fig.", "-rrb-", "we", "attribute", "processing", "empty", "voxel", "regular", "grid", "-lrb-", "particularly", "during", "random", "GPU", "memory", "access", "e.g.", "raycast", "-rrb-", "streaming", "overhead", "further", "show", "fig.", "we", "reconstruction", "quality", "higher", "than", "approach", "quality", "Extended", "fusion", "limit", "small", "spatial", "extent", "move", "volume", "which", "mean", "much", "Kinect", "datum", "out", "range", "integrate", "hierarchical", "fusion", "suffer", "from", "poor", "frame", "rate", "cause", "input", "datum", "skip", "severely", "affect", "pose", "estimation", "quality", "result", "inaccurate", "surface", "integration", "drift", "large-scale", "scene", "type", "drift", "might", "cause", "unnaturally", "twisted", "model", "show", "Fig.", "give", "we", "more", "efficient", "datum", "structure", "which", "run", "faster", "than", "Kinect", "camera", "frame", "rate", "additional", "time", "can", "spend", "improve", "accuracy", "pose", "estimation", "increase", "number", "ICP", "iteration", "we", "find", "we", "result", "encourage", "particularly", "give", "drift", "correction", "explicitly", "handle", "fig.", "10", "scene", "capture", "process", "offline", "use", "method", "-lsb-", "Zhou", "Koltun", "2013", "-rsb-", "which", "use", "multi-pass", "global", "optimization", "mitigate", "drift", "compare", "we", "online", "method", "while", "we", "method", "do", "suffer", "from", "small", "drift", "we", "system", "produce", "comparable", "result", "can", "use", "real-time", "application", "we", "online", "method", "can", "also", "use", "live", "preview", "combine", "approach", "higher-quality", "offline", "reconstruction", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "169:9", "Figure", "10", "comparison", "output", "mesh", "from", "we", "online", "method", "-lrb-", "top", "-rrb-", "offline", "method", "-lsb-", "Zhou", "Koltun", "2013", "-rsb-", "-lrb-", "bottom", "-rrb-", "10", "conclusion", "we", "have", "present", "new", "datum", "structure", "design", "specifically", "online", "reconstruction", "use", "widely-available", "consumer", "depth", "camera", "we", "approach", "leverage", "power", "implicit", "surface", "volumetric", "fusion", "reconstruction", "do", "so", "use", "compact", "spatial", "hash", "scheme", "which", "remove", "both", "overhead", "regular", "grid", "hierarchical", "datum", "structure", "we", "hash", "scheme", "support", "real-time", "performance", "without", "forgo", "scale", "finer", "quality", "reconstruction", "all", "operation", "design", "efficient", "parallel", "graphic", "hardware", "inherent", "unstructured", "nature", "we", "method", "remove", "overhead", "hierarchical", "spatial", "datum", "structure", "capture", "key", "quality", "volumetric", "fusion", "further", "extend", "bound", "reconstruction", "we", "method", "support", "lightweight", "streaming", "without", "major", "datum", "structure", "reorganization", "we", "have", "demonstrate", "performance", "increase", "over", "state-of-theart", "even", "regular", "grid", "implementation", "datum", "structure", "memory", "efficient", "can", "allow", "color", "datum", "directly", "incorporate", "reconstruction", "which", "can", "also", "use", "improve", "robustness", "registration", "due", "high", "performance", "we", "datum", "structure", "available", "time", "budget", "can", "utilize", "further", "improve", "camera", "pose", "estimation", "which", "directly", "improve", "reconstruction", "quality", "over", "exist", "online", "approach", "we", "believe", "advantage", "we", "method", "even", "more", "evident", "when", "future", "depth", "camera", "higher", "resolution", "sense", "emerge", "we", "datum", "structure", "already", "capable", "reconstruct", "surface", "beyond", "resolution", "exist", "depth", "sensor", "kinect", "acknowledgement", "we", "thank", "Dennis", "Bautembach", "Jiawen", "Chen", "Vladlen", "Koltun", "Qian-Yi", "Zhou", "code/data", "Christoph", "Buchenau", "mesh", "rendering", "university", "Cambridge", "Erlangen-Nuremberg", "film", "access", "work", "part", "fund", "German", "Research", "Foundation", "-lrb-", "DFG", "-rrb-", "grant", "grk-1773", "heterogeneous", "image", "Systems", "reference", "lcantara", "D.", "A.", "harf", "a.", "bbasinejad", "F.", "engupta", "S.", "ITZENMACHER", "M.", "WENS", "J.", "D.", "MENTA", "N.", "2009", "real-time", "parallel", "hash", "GPU", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "28", "154", "MANATIDES", "J.", "OO", "A.", "1987", "fast", "voxel", "traversal", "algorithm", "ray", "trace", "Proc", "eurographic", "vol", "87", "10", "asto", "t.", "ele", "W.", "2008", "gpu-accelerated", "adaptively", "sample", "distance", "field", "shape", "modeling", "application", "2008", "SMI", "2008", "IEEE", "International", "Conference", "IEEE", "171", "178", "ESL", "P.", "ay", "N.", "1992", "method", "registration", "3-d", "shape", "IEEE", "Trans", "pattern", "Anal", "Mach", "Intell", "14", "239", "256", "hang", "C.", "HATTERJEE", "S.", "UBE", "P.", "R.", "1994", "quantization", "error", "analysis", "convergent", "stereo", "Proc", "icip", "94", "vol", "IEEE", "735", "739", "hen", "Y.", "edionus", "G.", "1992", "object", "modelling", "registration", "multiple", "range", "image", "image", "Vision", "Computing", "10", "145", "155", "hen", "J.", "AUTEMBACH", "D.", "ZADI", "S.", "2013", "scalable", "real-time", "volumetric", "surface", "reconstruction", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "32", "113", "rassin", "C.", "EYRET", "F.", "EFEBVRE", "S.", "ISEMANN", "E.", "2009", "Gigavoxels", "ray-guided", "streaming", "efficient", "detailed", "voxel", "rendering", "Proc", "Symp", "interactive", "3d", "graphic", "Games", "ACM", "15", "22", "urless", "B.", "EVOY", "M.", "1996", "volumetric", "method", "building", "complex", "model", "from", "range", "image", "Proc", "computer", "graphic", "interactive", "technique", "ACM", "303", "312", "allup", "D.", "ollefey", "m.", "rahm", "j.-m", "2010", "3d", "reconstruction", "use", "n-layer", "heightmap", "Pattern", "recognition", "Springer", "10", "arc", "i.", "efebvre", "S.", "ORNUS", "S.", "asram", "a.", "2011", "coherent", "parallel", "hash", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "30", "161", "ross", "m.", "fister", "H.", "2007", "point-based", "graphic", "Morgan", "Kaufmann", "adwiger", "m.", "eyer", "J.", "EONG", "W.-K.", "fister", "H.", "2012", "interactive", "volume", "exploration", "petascale", "microscopy", "datum", "stream", "use", "visualization-driven", "virtual", "memory", "approach", "visualization", "computer", "graphic", "IEEE", "transaction", "18", "12", "2285", "2294", "arris", "M.", "engupta", "S.", "wen", "J.", "D.", "2007", "parallel", "prefix", "sum", "-lrb-", "scan", "-rrb-", "cuda", "GPU", "gem", "39", "851", "876", "enry", "P.", "RAININ", "M.", "ERBST", "E.", "EN", "X.", "ox", "D.", "2012", "rgb-d", "mapping", "use", "kinect-style", "depth", "camera", "dense", "3d", "modeling", "indoor", "environment", "int", "J.", "Robotics", "Research", "31", "-lrb-", "apr.", "-rrb-", "647", "663", "iguchus", "K.", "EBERT", "M.", "keuchi", "K.", "1995", "building", "3-d", "model", "from", "unregistered", "range", "image", "Graphical", "model", "image", "processing", "57", "315", "333", "ilton", "a.", "toddart", "a.", "llingworth", "J.", "INDEATT", "T.", "1996", "reliable", "surface", "reconstruction", "from", "multiple", "range", "image", "J.", "Computer", "Vision", "-lrb-", "Proc", "eccv", "-rrb-", "117", "126", "OPPE", "H.", "OSE", "T.", "UCHAMP", "T.", "onald", "J.", "TUETZLE", "W.", "1992", "surface", "reconstruction", "from", "unorganized", "point", "ACM", "SIGGRAPH", "Computer", "Graphics", "26", "71", "78", "zadi", "S.", "IM", "D.", "ILLIGES", "O.", "OLYNEAUX", "D.", "EW", "COMBE", "R.", "OHLI", "P.", "HOTTON", "J.", "ODGES", "S.", "reeman", "D.", "AVISON", "a.", "itzgibbon", "a.", "2011", "KinectFusion", "real-time", "3d", "reconstruction", "interaction", "use", "move", "depth", "camera", "Proc", "ACM", "Symp", "user", "Interface", "Software", "Technology", "559", "568", "OHNSON", "A.", "E.", "ING", "ang", "S.", "1999", "registration", "integration", "textured", "3d", "datum", "image", "vision", "computing", "17", "135", "147", "AMPE", "V.", "intorn", "E.", "SSARSSON", "U.", "2013", "high", "resolution", "sparse", "voxel", "dag", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "32", "101", "AZHDAN", "M.", "OLITHO", "M.", "OPPE", "H.", "2006", "Poisson", "surface", "reconstruction", "Proc", "eg", "symp", "geometry", "processing", "ELLER", "M.", "EFLOCH", "D.", "AMBERS", "M.", "ZADI", "S.", "EYRICH", "T.", "OLB", "A.", "2013", "real-time", "3d", "reconstruction", "dynamic", "scene", "use", "point-based", "fusion", "Proc", "Joint", "3DIM/3DPVT", "Conference", "-lrb-", "3dv", "-rrb-", "IEEE", "RAUS", "M.", "RTL", "T.", "2002", "adaptive", "texture", "map", "Proc", "ACM", "siggraph/eurographics", "conference", "Graphics", "hardware", "Eurographics", "Association", "15", "aine", "S.", "ARRAS", "T.", "2011", "efficient", "sparse", "voxel", "octree", "visualization", "computer", "graphic", "IEEE", "transaction", "17", "1048", "1059", "efebvre", "S.", "OPPE", "H.", "2006", "Perfect", "spatial", "hash", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "25", "579", "588", "efebvre", "S.", "ORNUS", "S.", "EYRET", "F.", "2005", "Gpu", "gem", "chapter", "37", "Octree", "texture", "gpu", "evoy", "M.", "ULLI", "K.", "URLESS", "B.", "USINKIEWICZ", "S.", "OLLER", "D.", "ereira", "L.", "INZTON", "M.", "NDERSON", "S.", "AVIS", "J.", "INSBERG", "J.", "ET", "AL", "2000", "digital", "michelangelo", "project", "3d", "scanning", "large", "statue", "Proc", "computer", "graphic", "interactive", "technique", "ACM", "Press/Addison-Wesley", "Publishing", "Co.", "131", "144", "orensen", "W.", "LINE", "H.", "1987", "march", "cube", "high", "resolution", "3d", "surface", "construction", "algorithm", "Computer", "Graphics", "21", "163", "169", "ow", "k.-l", "2004", "linear", "least-square", "optimization", "point-toplane", "icp", "surface", "registration", "Tech", "rep.", "chapel", "Hill", "University", "North", "Carolina", "ewcombe", "R.", "A.", "ZADI", "S.", "ILLIGES", "O.", "OLYNEAUX", "D.", "IM", "D.", "AVISON", "A.", "J.", "OHLI", "P.", "HOTTON", "J.", "ODGES", "S.", "itzgibbon", "a.", "2011", "KinectFusion", "real-time", "dense", "surface", "mapping", "tracking", "Proc", "IEEE", "Int", "Symp", "mixed", "augmented", "reality", "127", "136", "guyen", "C.", "ZADI", "S.", "ovell", "D.", "2012", "model", "kinect", "sensor", "noise", "improve", "3d", "reconstruction", "tracking", "Proc", "int", "Conf", "3d", "Imaging", "Modeling", "Processing", "visualization", "Transmission", "524", "530", "J.", "anocha", "D.", "2011", "fast", "gpu-based", "locality", "sensitive", "hash", "k-nearest", "neighbor", "computation", "Proc", "19th", "acm", "SIGSPATIAL", "International", "Conference", "advance", "Geographic", "Information", "Systems", "ACM", "211", "220", "ollefey", "M.", "IST", "D.", "rahm", "J.", "kbarzadeh", "a.", "ordohaus", "P.", "LIPP", "B.", "NGELS", "C.", "ALLUP", "D.", "IM", "S.", "ERRELL", "P.", "ET", "AL", "2008", "detailed", "real-time", "urban", "3d", "reconstruction", "from", "video", "int", "J.", "Comp", "Vision", "78", "143", "167", "eichl", "F.", "HAJDAS", "M.", "G.", "URGER", "K.", "ESTERMANN", "R.", "2012", "hybrid", "sample-based", "surface", "rendering", "Vision", "Modeling", "visualization", "Eurographics", "Association", "47", "54", "oth", "H.", "ONA", "M.", "2012", "move", "volume", "kinectfusion", "british", "machine", "Vision", "Conf", "usinkiewicz", "S.", "all", "olt", "O.", "EVOY", "M.", "2002", "real-time", "3d", "model", "acquisition", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "21", "438", "446", "uckler", "J.", "EHNKE", "S.", "2012", "integrate", "depth", "color", "cue", "dense", "multi-resolution", "scene", "mapping", "use", "rgb-d", "camera", "Proc", "IEEE", "Int", "Conf", "Multisensor", "fusion", "information", "integration", "-lrb-", "mfus", "-rrb-", "-lrb-", "Hamburg", "Germany", "-rrb-", "eschner", "M.", "EIDELBERGER", "B.", "ULLER", "M.", "omer", "anet", "D.", "ross", "M.", "2003", "optimize", "spatial", "hash", "collision", "detection", "deformable", "object", "Proc.of", "Vision", "Modeling", "visualization", "vmv03", "47", "54", "urk", "G.", "EVOY", "M.", "1994", "zippered", "polygon", "mesh", "from", "range", "image", "Proc", "computer", "graphic", "interactive", "technique", "311", "318", "EISE", "T.", "ISMER", "T.", "EIBE", "B.", "ool", "L.", "2009", "in-hand", "scanning", "online", "loop", "closure", "Proc", "IEEE", "Int", "Conf", "computer", "Vision", "Workshops", "1630", "1637", "HEELER", "M.", "ato", "Y.", "keuchi", "K.", "1998", "consensus", "surface", "modeling", "3d", "object", "from", "multiple", "range", "image", "Proc", "IEEE", "Int", "Conf", "computer", "Vision", "917", "924", "HELAN", "T.", "OHANNSSON", "H.", "AESS", "M.", "EONARD", "J.", "onald", "J.", "2012", "robust", "tracking", "real-time", "dense", "rgb-d", "mapping", "kintinuous", "Tech", "rep.", "Query", "date", "2012-10-25", "ENG", "M.", "HAO", "F.", "HENG", "J.", "iu", "X.", "2012", "octree-based", "fusion", "realtime", "3d", "reconstruction", "Graphical", "model", "HOU", "Q.-Y.", "OLTUN", "V.", "2013", "dense", "scene", "reconstruction", "point", "interest", "ACM", "transaction", "graphic", "-lrb-", "tog", "-rrb-", "32", "112", "HOU", "K.", "ONG", "M.", "UANG", "X.", "UO", "B.", "2011", "dataparallel", "octree", "surface", "reconstruction", "IEEE", "Trans", "Vis", "Comp", "graph", "17", "669", "681", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "169:10", "M.", "Nei?ner", "et", "al.", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013", "real-time", "3d", "reconstruction", "Scale", "use", "Voxel", "Hashing", "169:11", "figure", "11", "reconstruction", "capture", "test", "scene", "pathway", "shop", "-lrb-", "passageway", "-rrb-", "large", "courtyard", "-lrb-", "queen", "-rrb-", "three", "level", "bookstore", "-lrb-", "bookshop", "-rrb-", "show", "left", "input", "datum", "from", "Kinect", "sensor", "-lrb-", "depth", "color", "-rrb-", "live", "raycasted", "view", "we", "system", "-lrb-", "shaded", "shaded", "color", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "32", "no.", "Article", "169", "publication", "date", "November", "2013" ],
  "content" : "\n  \n    c419119948f4bfbcb7a4c0e781b99bfa5d43bba3f7e6bb9b3f99e058a632b00b\n    p2s\n    10.1145/2508363.2508374\n    Name identification was not possible. \n  \n  \n    \n      \n        Real-time 3D Reconstruction at Scale using Voxel Hashing\n      \n      Matthias Nie?ner 1,3 Michael Zollh?fer 1 Shahram Izadi 2 1 University of Erlangen-Nuremberg 2 Microsoft Research Cambridge\n      \n        \n        Figure 1: Example output from our reconstruction system without any geometry post-processing. Scene is about 20m wide and 4m high and captured online in less than 5 minutes with live feedback of the reconstruction.\n      \n      Online 3D reconstruction is gaining newfound interest due to the availability of real-time consumer depth cameras. The basic problem takes live overlapping depth maps as input and incrementally fuses these into a single 3D model. This is challenging particularly when real-time performance is desired without trading quality or scale. We contribute an online system for large and fine scale volumetric reconstruction based on a memory and speed efficient data structure. Our system uses a simple spatial hashing scheme that compresses space, and allows for real-time access and updates of implicit surface data, without the need for a regular or hierarchical grid data structure. Surface data is only stored densely where measurements are observed. Additionally, data can be streamed efficiently in or out of the hash table, allowing for further scalability during sensor motion. We show interactive reconstructions of a variety of scenes, reconstructing both fine-grained details and large scale environments. We illustrate how all parts of our pipeline from depth map pre-processing, camera pose estimation, depth map fusion, and surface rendering are performed at real-time rates on commodity graphics hardware. We conclude with a comparison to current state-of-the-art online systems, illustrating improved performance and reconstruction quality.\n      Picture/Image\n      CR Categories: I.3.3 [Computer Graphics]: Generation?Digitizing and Scanning  Keywords: real-time reconstruction, scalable, data structure, GPU\n      Links:\n      \n        \n      \n      DL PDF\n      \n        \n      \n    \n    \n      \n        ACM Reference Format\n        Nie?ner, M., Zollh?fer, M., Izadi, S., Stamminger, M. 2013. Real-time 3D Reconstruction at Scale using Voxel Hashing. ACM Trans. Graph. 32, 6, Article 169 (November 2013), 11 pages. DOI = 10.1145/2508363.2508374 http://doi.acm.org/10.1145/2508363.2508374.\n      \n      \n        Copyright Notice\n        Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speci c permission and/or a fee. Request permissions from permissions@acm.org . Copyright ? ACM 0730-0301/13/11-ART169 $15.00. DOI: http://doi.acm.org/10.1145/2508363.2508374\n        Marc Stamminger 1 3 Stanford University\n      \n      \n        1 Introduction\n      \n      While 3D reconstruction is an established field in computer vision and graphics, it is now gaining newfound momentum due to the wide availability of depth cameras (such as the Microsoft Kinect and Asus Xtion). Since these devices output live but noisy depth maps, a particular focus of recent work is online surface reconstruction using such consumer depth cameras. The ability to obtain reconstructions in real-time opens up various interactive applications including: augmented reality (AR) where real-world geometry can be fused with 3D graphics and rendered live to the user; autonomous guidance for robots to reconstruct and respond rapidly to their environment; or even to provide immediate feedback to users during 3D scanning. Online reconstruction requires incremental fusion of many overlapping depth maps into a single 3D representation that is continuously refined. This is challenging particularly when real-time performance is required without trading fine-quality reconstructions and spatial scale. Many state-of-the-art online techniques therefore employ different types of underlying data structures accelerated using graphics hardware. These however have particular trade-offs in terms of reconstruction speed, scale, and quality. Point-based methods (e.g., [Rusinkiewicz et al. 2002; Weise et al. 2009]) use simple unstructured representations that closely map to range and depth sensor input, but lack the ability to directly reconstruct connected surfaces. High-quality online scanning of small objects has been demonstrated [Weise et al. 2009], but largerscale reconstructions clearly trade quality and/or speed [Henry et al. 2012; St?ckler and Behnke 2012]. Height-map based representations [Pollefeys et al. 2008; Gallup et al. 2010] support efficient compression of connected surface data, and can scale efficiently to larger scenes, but fail to reconstruct complex 3D structures. For active sensors, implicit volumetric approaches, in particular the method of Curless and Levoy [1996], have demonstrated compelling results [Curless and Levoy 1996; Levoy et al. 2000; Zhou and Koltun 2013], even at real-time rates [Izadi et al. 2011; Newcombe et al. 2011]. However, these rely on memory inefficient regular voxel grids, in turn restricting scale. This has led to either moving volume variants [Roth and Vona 2012; Whelan et al. 2012], which stream voxel data out-of-core as the sensor moves, but still constrain the size of the active volume. Or hierarchical data structures that subdivide space more effectively, but do not parallelize efficiently given added computational complexity [Zeng et al. 2012; Chen et al. 2013].  We contribute a new real-time surface reconstruction system which supports fine-quality reconstructions at scale. Our approach carries the benefits of volumetric approaches, but does not require either a memory constrained voxel grid or the computational overheads of a hierarchical data structure. Our method is based on a simple memory and speed efficient spatial hashing technique that compresses space, and allows for real-time fusion of referenced implicit surface data, without the need for a hierarchical data structure. Surface data is only stored densely in cells where measurements are observed. Additionally, data can be streamed efficiently in or out of the hash table, allowing for further scalability during sensor motion. While these types of efficient spatial hashing techniques have been proposed for a variety of rendering and collision detection tasks [Teschner et al. 2003; Lefebvre and Hoppe 2006; Bastos and Celes 2008; Alcantara et al. 2009; Pan and Manocha 2011; Garc?a et al. 2011], we describe the use of such data structures for surface reconstruction, where the underlying data needs to be continuously updated. We show interactive reconstructions of a variety of scenes, reconstructing both fine-grained and large-scale environments. We illustrate how all parts of our pipeline from depth map pre-processing, sensor pose estimation, depth map fusion, and surface rendering are performed at real-time rates on commodity graphics hardware. We conclude with a comparison to current state-of-the-art systems, illustrating improved performance and reconstruction quality.\n      ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n      169:2\n      ?\n      M. Nei?ner et al.\n      \n        2 Related work\n        There is over three decades of research on 3D reconstruction. In this section we review relevant systems, with a focus on online reconstruction methods and active sensors. Unlike systems that focus on reconstruction from a complete set of 3D points [Hoppe et al. 1992; Kazhdan et al. 2006], online methods require incremental fusion of many overlapping depth maps into a single 3D representation that is continuously refined. Typically methods first register or align sequential depth maps using variants of the Iterative Closest Point (ICP) algorithm [Besl and McKay 1992; Chen and Medioni 1992]. Parametric methods [Chen and Medioni 1992; Higuchi et al. 1995] simply average overlapping samples, and connect points by assuming a simple surface topology (such as a cylinder or a sphere) to locally fit polygons. Extensions such as mesh zippering [Turk and Levoy 1994] select one depth map per surface region, remove redundant triangles in overlapping regions, and stitch meshes. These methods handle some denoising by local averaging of points, but are fragile in the presence of outliers and areas with high curvature. These challenges associated with working directly with polygon meshes have led to many other reconstruction methods. Point-based methods perform reconstruction by merging overlapping points, and avoid inferring connectivity. Rendering the final model is performed using point-based rendering techniques [Gross and Pfister 2007]. Given the output from most depth sensors are 3D point samples, it is natural for reconstruction methods to work directly with such data. Examples include in-hand scanning systems [Rusinkiewicz et al. 2002; Weise et al. 2009], which support reconstruction of only single small objects. At this small scale, high-quality [Weise et al. 2009] reconstructions have been achieved. Larger scenes have been reconstructed by trading real-time speed and quality [Henry et al. 2012; St?ckler and Behnke 2012]. These methods lack the ability to directly model connected surfaces, requiring additional expensive and often offline steps to construct surfaces; e.g., using volumetric data structures [Rusinkiewicz et al. 2002]. Height-map based representations explore the use of more compact 2.5D continuous surface representations for reconstruction [Pollefeys et al. 2008; Gallup et al. 2010]. These techniques are particularly useful for modeling large buildings with floors and walls,  since these appear as clear discontinuities in the height-map. Multilayered height-maps have been explored to support reconstruction of more complex 3D shapes such as balconies, doorways, and arches [Gallup et al. 2010]. While these methods support more efficient compression of surface data, the 2.5D representation fails to reconstruct many types of complex 3D structures. An alternative method is to use a fully volumetric data structure to implicitly store samples of a continuous function [Hilton et al. 1996; Curless and Levoy 1996; Wheeler et al. 1998]. In these methods, depth maps are converted into signed distance fields and cumulatively averaged into a regular voxel grid. The final surface is extracted as the zero-level set of the implicit function using isosurface polygonisation (e.g., [Lorensen and Cline 1987]) or raycasting. A well-known example is the method of Curless and Levoy [1996], which for active triangulation-based sensors such as laser range scanners and structured light cameras, can generate very high quality results [Curless and Levoy 1996; Levoy et al. 2000; Zhou and Koltun 2013]. KinectFusion [Newcombe et al. 2011; Izadi et al. 2011] recently adopted this volumetric method and demonstrated compelling real-time reconstructions using a commodity GPU. While shown to be a high quality reconstruction method, particularly given the computational cost, this approach suffers from one major limitation: the use of a regular voxel grid imposes a large memory footprint, representing both empty space and surfaces densely, and thus fails to reconstruct larger scenes without compromising quality. Scaling-up Volumetric Fusion Recent work begins to address this spatial limitation of volumetric methods in different ways. [Keller et al. 2013] use a point-based representation that captures qualities of volumetric fusion but removes the need for a spatial data structure. While demonstrating compelling scalable real-time reconstructions, the quality is not on-par with true volumetric methods. Moving volume methods [Roth and Vona 2012; Whelan et al. 2012] extend the GPU-based pipeline of KinectFusion. While still operating on a very restricted regular grid, these methods stream out voxels from the GPU based on camera motion, freeing space for new data to be stored. In these methods the streaming is one-way and lossy. Surface data is compressed to a mesh, and once moved to host cannot be streamed back to the GPU. While offering a simple approach for scalability, at their core these systems still use a regular grid structure, which means that the active volume must remain small to ensure fine-quality reconstructions. This limits reconstructions to scenes with close-by geometric structures, and cannot utilize the full range of data for active sensors such as the Kinect. This limit of regular grids has led researcher to investigate more efficient volumetric data structures. This is a well studied topic in the volume rendering literature, with efficient methods based on sparse voxel octrees [Laine and Karras 2011; K?mpe et al. 2013], simpler multi-level hierarchies and adaptive data structures [Kraus and Ertl 2002; Lefebvre et al. 2005; Bastos and Celes 2008; Reichl et al. 2012] and out-of-core streaming architectures for large datasets [Hadwiger et al. 2012; Crassin et al. 2009]. These approaches have begun to be explored in the context of online reconstruction, where the need to support real-time updates of the underlying data adds a fundamentally new challenge. For example, [Zhou et al. 2011] demonstrate a GPU-based octree which can perform Poisson surface reconstruction on 300K vertices at interactive rates. [Zeng et al. 2012] implement a 9to 10-level octree on the GPU, which extends the KinectFusion pipeline to a larger 8m ? 8m ? 2m indoor office space. The method however requires a complex octree structure to be implemented, with additional computational complexity and pointer overhead, with only limited gains in scale. In an octree, the resolution in each dimension increases by a factor of two at each subdivision level. This results in the need for a deep tree structure for efficient subdivision, which conversely impacts performance, in particular on GPUs where tree traversal leads to thread divergence. The rendering literature has proposed many alternative hierarchical data structures [Lefebvre et al. 2005; Kraus and Ertl 2002; Laine and Karras 2011; K?mpe et al. 2013; Reichl et al. 2012]. In [Chen et al. 2013] an N 3 hierarchy [Lefebvre et al. 2005] was adopted for 3D reconstruction at scale, and the optimal tree depth and branching factor were empirically derived (showing large branching factors and a shallow tree optimizes GPU performance). While avoiding the use of an octree, the system still carries computational overheads in realizing such a hierarchical data structure on the GPU. As such this leads to performance that is only real-time on specific scenes, and on very high-end graphics hardware.\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        Real-time 3D Reconstruction at Scale using Voxel Hashing\n        ?\n        169:3\n      \n      \n        3 Algorithm Overview\n        We extend the volumetric method of Curless and Levoy [1996] to reconstruct high-quality 3D surfaces in real-time and at scale, by incrementally fusing noisy depth maps into a memory and speed efficient data structure. Curless and Levoy have proven to produce compelling results given a simple cumulative average of samples. The method supports incremental updates, makes no topological assumptions regarding surfaces, and approximates the noise characteristics of triangulation based sensors effectively. Further, while an implicit representation, stored isosurfaces can be readily extracted. Our method addresses the main drawback of Curless and Levoy: supporting efficient scalability. Next, we review the Curless and Levoy method, before the description of our new approach.  Implicit Volumetric Fusion Curless and Levoy?s method is based on storing an implicit signed distance field (SDF) within a volumetric data structure. Let us consider a regular dense voxel grid, and assume the input is a sequence of depth maps. The depth sensor is initialized at some origin relative to this grid (typically the center of the grid). First, the rigid six degree-of-freedom (6DoF) ego-motion of the sensor is estimated, typically using variants of ICP [Besl and McKay 1992; Chen and Medioni 1992]. Each voxel in the grid contains two values: a signed distance and weight. For a single depth map, data is integrated into the grid by uniformly sweeping through the volume, culling voxels outside of the view frustum, projecting all voxel centers into the depth map, and updating stored SDF values. All voxels that project onto the same pixel are considered part of the depth sample?s footprint. At each of these voxels a signed distance from the voxel center to the observed surface measurement is stored, with positive distances in front, negative behind, and nearing zero at the surface interface. To reduce computational cost, support sensor motion, and approximate sensor noise, Curless and Levoy introduce the notion of a truncated SDF (TSDF) which only stores the signed distance in a region around the observed surface. This region can be adapted in size, approximating sensor noise as a Gaussian with variance based on depth [Chang et al. 1994; Nguyen et al. 2012]. Only TSDF values stored in voxels within these regions are updated using a weighted average to obtain an estimate of the surface. Finally, voxels (in front of the surface) that are part of each depth sample?s footprint, but outside of the truncation region are explicitly marked as free-space. This allows removal of outliers based on free-space violations. Voxel Hashing Given Curless and Levoy truncate SDFs around the surface, the majority of data stored in the regular voxel grid is marked either as free space or as unobserved space rather than surface data. The key challenge becomes how to design a data structure that exploits this underlying sparsity in the TSDF representation. Our approach specifically avoids the use of a dense or hierarchical data structure, removing the need for a memory intensive regular grid or computationally complex hierarchy for volumetric fusion. Instead, we use a simple hashing scheme to compactly store, access and update an implicit surface representation. In the graphics community, efficient spatial hashing methods have been explored in the context of a variety of 2D/3D rendering and collision detection tasks [Teschner et al. 2003; Lefebvre and Hoppe 2006; Bastos and Celes 2008; Alcantara et al. 2009; Pan and Manocha 2011; Garc?a et al. 2011]. Sophisticated methods have been proposed for efficient GPU-based hashing that greatly reduce the number of hash entry collisions. Our goal is to build a real-time system that employs a spatial hashing scheme for scalable volumetric reconstruction. This is non-trivial for 3D reconstruction as the geometry is unknown ahead of time and continually changing. Therefore, our hashing technique must support dynamic allocations and updates, while minimizing and resolving potential hash entry collisions, without requiring a-priori knowledge of the contained surface geometry. In approaching the design of our data structure, we have purposefully chosen and extended a simple hashing scheme [Teschner et al. 2003], and while more sophisticated methods exist, we show empirically that our method is efficient in terms of speed, quality, and scalability. The hash table sparsely and efficiently stores and updates TSDFs. In the following we describe the data structure in more detail, and demonstrate how it can be efficiently implemented on the GPU. We highlight some of the core features of our data structure, including: ? The ability to efficiently compress volumetric TSDFs, while maintaining surface resolution, without the need for a hierarchical spatial data structure. ? Fusing new TSDF samples efficiently into the hash table, based on insertions and updates, while minimizing collisions. ? Removal and garbage collection of voxel blocks, without requiring costly reorganization of the data structure. ? Lightweight bidirectional streaming of voxel blocks between host and GPU, allowing unbounded reconstructions. ? Extraction of isosurfaces from the data structure efficiently using standard raycasting or polygonization operations, for rendering and camera pose estimation. System Pipeline Our pipeline is depicted in Fig. 2 . Central is a hash table data structure that stores sub-blocks containing SDFs, called voxel blocks. Each occupied entry in our hash table refers to an allocated voxel block. At each voxel we store a TSDF, weight, and an additional color value. The hash table is unstructured; i.e., neighboring voxel blocks are not stored spatially, but can be in different parts of the hash table. Our hashing function allows an efficient look-up of voxel blocks, using specified (integer rounded) world coordinates. Our hash function aims to minimize the number of collisions and ensures no duplicates exist in the table. Given a new input depth map, we begin by performing fusion (also referred to as integration). We first allocate new voxel blocks and insert block descriptors into the hash table, based on an input depth map. Only occupied voxels are allocated and empty space is not stored. Next we sweep each allocated voxel block to update the SDF, color and weight of each contained voxel, based on the input depth and color samples. In addition, we garbage collect voxel blocks which are too far from the isosurface and contain no weight. This involves freeing allocated memory as well as removing the voxel block entry from the hash table. These steps ensure that our data structure remains sparse over time. After integration, we raycast the implicit surface from the current estimated camera pose to extract the isosurface, including associated colors. This extracted depth and color buffer is used as input for camera pose estimation: given the next input depth map, a projective point-plane ICP [Chen and Medioni 1992] is performed to estimate the new 6DoF camera pose. This ensures that pose estimation is performed frame-to-model rather than frame-to-frame mitigating some of the issues of drift (particularly for small scenes) [Newcombe et al. 2011]. Finally, our algorithm performs bidirectional streaming between GPU and host. Hash entries (and associated voxel blocks) are streamed to the host as their world positions exit the estimated camera view frustum. Previously streamed out voxel blocks can also be streamed back to the GPU data structure when revisiting areas.\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        169:4\n        ?\n        M. Nei?ner et al.\n        \n          \n          Figure 2: Pipeline overview.\n        \n      \n      \n        4 Data Structure\n         Fig. 3 shows our voxel hashing data structure. Conceptually, an infinite uniform grid subdivides the world into voxel blocks. Each block is a small regular voxel grid. In our current implementation a voxel block is composed of 8 3 voxels. Each voxel stores a TSDF, color, and weight and requires 8 bytes of memory: struct Voxel { float sdf; uchar colorRGB[3]; uchar weight; }; To exploit sparsity, voxel blocks are only allocated around reconstructed surface geometry. We use an efficient GPU accelerated hash table to manage allocation and retrieval of voxel blocks. The hash table stores hash entries, each containing a pointer to an allocated voxel block. Voxel blocks can be retrieved from the hash table using integer world coordinates (x, y, z). Finding the coordinates for a 3D point in world space is achieved by simple multiplication and rounding. We map from a world coordinate (x, y, z) to hash value H(x, y, z) using the following hashing function: where p 1 , p 2 , and p 3 are large prime numbers (in our case 73856093, 19349669, 83492791 respectively, based on [Teschner et al. 2003]), and n is the hash table size. In addition to storing a pointer to the voxel block, each hash entry also contains the associated world position, and an offset pointer to handle collisions efficiently (described in the next section). struct HashEntry { short position[3]; short offset; int pointer; };\n        H(x, y, z) = (x ? p 1 ? y ? p 2 ? z ? p 3 ) mod n\n        \n          \n          Figure 3: Our voxel hashing data structure.\n        \n        Conceptually, an infinite uniform grid partitions the world. Using our hash function, we map from integer world coordinates to hash buckets, which store a small array of pointers to regular grid voxel blocks. Each voxel block contains an 8 3 grid of SDF values. When information for the red block gets added, a collision appears which is resolved by using the second element in the hash bucket.\n        \n          4.1 Resolving Collisions\n          Collisions appear if multiple allocated blocks are mapped to the same hash value (see red block in Fig. 3 ). We handle collisions by uniformly organizing the hash table into buckets, one per unique hash value. Each bucket sequentially stores a small number of hash entries. When a collision occurs, we store the block pointer in the next available sequential entry in the bucket (see Fig. 4 ). To find the voxel block for a particular world position, we first evaluate our hash function, and lookup and traverse the associated bucket until our block entry is found. This is achieved by simply comparing the stored hash entry world position with the query position. With a reasonable selection of the hash table and bucket size (see later), rarely will a bucket overflow. However, if this happens, we append a linked list entry, filling up other free spots in the next available buckets. The (relative) pointers for the linked lists are stored in the offset field of the hash table entries. Such a list is appended to a full bucket by setting the offset pointer for the last entry in the bucket. All following entries are then chained using the offset field. In order to create additional links for a bucket, we linearly search across the hash table for a free slot to store our entry, appending to the link list accordingly. We avoid the last entry in each bucket, as this is locally reserved for the link list head. As shown later, we choose a table and bucket size that keeps the number of collisions and therefore appended linked lists to a minimum for most scenes, as to not impact overall performance. Insertion To insert new hash entries, we first evaluate the hash function and determine the target bucket. We then iterate over all bucket elements including possible lists attached to the last entry. If we find an element with the same world space position we can immediately return a reference. Otherwise, we look for the first empty position within the bucket. If a position in the bucket is available, we insert the new hash entry. If the bucket is full, we append an element to its linked list element (see Fig. 4 ). To avoid race conditions when inserting hash entries in parallel, we lock a bucket atomically for writing when a suitable empty position is found. This eliminates duplicate entries and ensures linked list consistency. If a bucket is locked for writing, all other allocations for the same bucket are staggered until the next frame is processed. This may delay some allocations marginally. However, in practice this causes no degradation in reconstruction quality (as observed in the results and supplementary video), particularly as the Curless and Levoy method supports order independent updates. Retrieval To read the hash entry for a query position, we compute the hash value and perform a linear search within the corresponding bucket. If no entry is found, and the bucket has a linked list associated (the offset value of the last entry is set), we also have to traverse this list. Note that we do not require a bucket to be filled from left to right. As described below, removing values can lead to fragmentation, so traversal does not stop when empty entries are found in the bucket. Deletion Deleting a hash entry is similar to insertion. For a given world position we first compute the hash and then linearly search the corresponding hash bucket including list traversal. If we have found the matching entry without list traversal we can simply delete it. If it is the last element of the bucket and there was a non-zero offset stored (i.e., the element is a list head), we copy the hash entry pointed to by the offset into the last element of the bucket, and delete it from its current position. Otherwise if the entry is a (non-head) element in the linked list, we delete it and correct list pointers accordingly (see Fig. 4 ). Synchronization is not required for deletion directly within the bucket. However, in the case we need to modify the linked list, we lock the bucket atomically and stagger further list operations for this bucket until the next frame.\n          4.2 Hashing operations\n          ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n          Real-time 3D Reconstruction at Scale using Voxel Hashing\n          ?\n          169:5\n          \n            Figure 4: The hash table is broken down into a set of buckets. Each slot is either unallocated (white) or contains an entry (blue) storing the query world position, pointer to surface data, and an offset pointer for dealing with bucket overflow. Example hashing operations: for illustration, we insert and remove four entries that all map to hash = 1 and update entries and pointers accordingly.\n          \n        \n      \n      \n        5 Voxel Block Allocation\n        Before integration of new TSDFs, voxel blocks must be allocated that fall within the footprint of each input depth sample, and are also within the truncation region of the surface measurement. We process  depth samples in parallel, inserting hash entries and allocating voxel blocks within the truncation region around the observed surface. The size of the truncation is adapted based on the variance of depth to compensate for larger uncertainty in distant measurements [Chang et al. 1994; Nguyen et al. 2012]. For each input depth sample, we instantiate a ray with an interval bound to the truncation region. Given the predefined voxel resolution and block size, we use DDA [Amanatides and Woo 1987] to determine all the voxel blocks that intersect with the ray. For each candidate found, we insert a new voxel block entry into the hash table. In an idealized case, each depth sample would be modeled as an entire frustum rather than a single ray. We would then allocate all voxel blocks within the truncation region that intersect with this frustum. In practice however, this leads to degradation in performance (currently 10-fold). Our ray-based approximation provides a balance between performance and precision. Given the continuous nature of the reconstruction, the frame rate of the sensor, and the mobility of the user, this in practice leads to no holes appearing between voxel blocks at larger distances (see results and accompanying video). Once we have successfully inserted an entry into the hash table, we allocate a portion of preallocated heap memory on the GPU to store voxel block data. The heap is a linear array of memory, allocated once upon initialization. It is divided into contiguous blocks (mapping to the size of voxel blocks), and managed by maintaining a list of available blocks. This list is a linear buffer with indices to all unallocated blocks. A new block is allocated using the last index in the list. If a voxel block is subsequently freed, its index is appended to the end of the list. Since the list is accessed in parallel, synchronization is necessary, by incrementing or decrementing the end of list pointer using an atomic operation.\n      \n      \n        6 Voxel Block Integration\n        We update all allocated voxel blocks that are currently within the camera view frustum. After the previous step (see Section 5), all voxel blocks in the truncation region of the visible surface are allocated. However, a large fraction of the hash table will be empty (i.e., not refer to any voxel blocks). Further, a significant amount of voxel blocks will be outside the viewing frustum. Under these assumptions, TSDF integration can be done very efficiently by only selecting available blocks inside the current camera frustum.  Voxel Block Selection To select voxel blocks for integration, we first in parallel access all hash table entries, and store a corresponding binary flag in an array for an occupied and visible voxel block, or zero otherwise. We then scan this array using a parallel prefix sum technique [Harris et al. 2007]. To facilitate large scan sizes (our hash table can have millions of entries) we use a three level up and down sweep. Using the scan results we compact the hash table into another buffer, which contains all hash entries that point to voxel blocks within the view frustum (see Fig. 5 ). Note that voxel blocks are not copied, just their associated hash entries. Implicit Surface Update The generated list of hash entries is then processed in parallel to update TSDF values. A single GPGPU kernel is executed for each of the associated blocks, with one thread allocated per voxel. That means that a voxel block will be processed on a single GPU multiprocessor, thus maximizing cache hits and minimizing code divergence. In practice, this is more efficient than assigning a single thread to process an entire voxel block. Updating voxel blocks involves re-computation of the associated TSDFs, weights and colors. Distance values are integrated using a running average as in Curless and Levoy [Curless and Levoy 1996]. We set the integration weights according to the depth values in order to incorporate the noise characteristics of the sensor; i.e., more weight is given to nearer depth measurements for which we assume less noise. Colors are also updated according to a running average, but with much more weight given to recent color samples (to reduce washing out colors). One important part of the integration step is to update all voxel blocks that fall into the current frustum, irrespective of whether they reside in the current truncation region. This can be due to surfaces being physically moved, or small outliers in the depth map being allocated previously, which are no longer observed. These blocks are not treated any differently, and continuously updated. As shown next however, we evaluate all voxel blocks after integration to identify such candidates for potential garbage collection. Garbage Collection Garbage collection removes voxel blocks allocated due to noisy outliers and moved surfaces. This step operates on the compacted hash table we obtained previously. For each associated voxel block we perform a summarization step to obtain both the minimum absolute TSDF value and the maximum weight. If the maximum weight of a voxel block is zero or the minimum TSDF is larger than a threshold we flag the block for deletion. In a second pass, in parallel we delete all flagged entries using the hash table delete operation described previously. When a hash entry gets deleted successfully, we also free the corresponding voxel block by appending the voxel block pointer to the heap (cf. Section 5).\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        169:6\n        ?\n        M. Nei?ner et al.\n        \n          Figure 5: Voxel Block Selection: in a first step, all occupied and visible hash entries are identified. By using a parallel prefix sum scan and a simple copy kernel, these are copied to a much smaller, contiguous array that can be efficiently traversed in parallel in subsequent operations.\n        \n      \n      \n        7 Surface Extraction\n        We perform raycasting to extract the implicitly stored isosurface. First, we compute the start and end points for each ray by conservatively rasterizing the entire bounding box of all allocated voxel blocks in the current view frustum. In parallel, we rasterize each voxel block (retrieved from the compact hash table buffer computed during integration) in two passes, and generate two z-buffers for the minimum and maximum depth. This demonstrates another benefit for our linear hash table data structure (over hierarchical data structures), allowing fast parallel access to all allocated blocks for operations such as rasterization. For each output pixel, we march a ray from the associated minimum to the maximum depth values. During marching we must evaluate the TSDF at neighboring world positions along the current ray. In this step, unallocated voxel blocks are also considered as empty space. Within occupied voxel blocks, we apply tri-linear interpolation by looking up the eight neighboring voxels. One special case  that needs to be considered is sampling across voxel block boundaries. To deal with this, we retrieve neighboring voxels by lookup via the hash table rather than sampling the voxel block directly. In practice, we use hash table lookups irrespective of whether the voxel is on a block boundary. Due to caching, reduced register count per thread, and non-divergent code, this increases performance over direct block sampling. We have also tried using a one-voxel overlap region around blocks in order to simplify tri-linear reads without the need of accessing multiple voxel blocks. However, that approximately doubled the memory footprint and we found that required overlap synchronization for surface integration bears significant computational overhead. To locate the surface interface (zero-crossing) we determine sign changes for current and previous (tri-linearly-interpolated) TSDF values. We ignore zero-crossings from negative to positive as this refers to back-facing surface geometry. In order to speed up ray marching, we skip a predefined interval (half the minimum truncation value). This avoids missing isosurfaces but provides only coarse zero-crossing positions. To refine further, we use iterative line search once a zero-crossing is detected to estimate the true surface location. Camera Tracking Once the surface is extracted via raycasting, it can be shaded for rendering, or used for frame-to-model camera pose estimation [Newcombe et al. 2011]. We use the next input frame along with the raycasted depth map to estimate pose. This ensures that the new pose is estimated prior to depth map fusion. Pose is estimated using the point-plane variant of ICP [Chen and Medioni 1992] with projective data association. The point-plane energy function is linearized [Low 2004] on the GPU to a 6 ? 6 matrix using a parallel reduction and solved via Singular Value Decomposition on the CPU. As our data structure also stores associated color data, we incorporate a weighting factor in the point-plane error-metric based on color consistency between extracted and input RGB values [Johnson and Bing Kang 1999].\n        \n          Figure 6: Streaming: camera moves from left to right. Voxel blocks leaving the camera frustum are streamed out (green). Streaming in happens on a chunk basis (red blocks).\n        \n      \n      \n        8 Streaming\n        The basic data structure described so far allows for high-resolution voxel blocks to be modeled beyond the resolution and range of current commodity depth cameras (see Section 9). However, GPU memory and performance become a consideration when we attempt to maintain surface data far outside of the view frustum in the hash table. To deal with this issue and allow unbounded reconstructions, we utilize a bidirectional GPU-Host streaming scheme.  Our unstructured data structure is well-suited for this purpose, since streaming voxel blocks in or out does not require any reorganization of the hash table. We create an active region defined as a sphere containing the current camera view frustum and a safety region around it. For a standard Kinect, we assume a depth range up to eight meters. We locate the center of the sphere four meters from the camera position and use a radius of eight meters (see Figure 6 ). Bidirectional streaming of voxel blocks happens every frame at the beginning of the pipeline directly after pose estimation.\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        Real-time 3D Reconstruction at Scale using Voxel Hashing\n        ?\n        169:7\n        \n          8.1 GPU-to-Host Streaming\n          To stream voxel blocks out of the active region, we first access the hash table in parallel and mark voxel blocks which moved out of the active region. For all these candidates we delete corresponding hash entries, and append them efficiently to an intermediate buffer. In a second pass, for all these hash entries, corresponding voxel blocks are copied to another intermediate buffer. The original voxel blocks are then cleared and corresponding locations are appended back to the heap, so they can be reused. Finally, these intermediate buffers are copied back to the host for access. On the host, voxel data is no longer organized into a hash table. Instead, we logically subdivide the world space uniformly into chunks (in our current implementation each set to 1m 3 ). Voxel blocks are appended to these chunks using a linked list. For each voxel block we store the voxel block descriptor which corresponds to hash entry data, as well as the voxel data.\n        \n        \n          8.2 Host-to-GPU Streaming\n          For Host-to-GPU streaming we first identify chunks that completely fall into the spherical active region again, due to the user moving back to a previously reconstructed region. In contrast to GPUto-CPU streaming which works on a per voxel block level, CPUto-GPU streaming operates on a per chunk basis. So if a chunk is identified for streaming all voxel blocks in that chunk will be streamed to the GPU. This enhances performance, given the high host-GPU bandwidth and ability to efficiently cull voxel blocks outside of the view frustum. Due to limited CPU compute per frame, streaming from host-toGPU is staggered, one chunk per frame. We select the chunk tagged for streaming that is most near to the camera frustum center. We then copy the chunk to the GPU via the intermediate buffers created for GPU-to-Host streaming. After copying to the GPU, in parallel we insert voxel block descriptors as entries into the hash table, allocating voxel block memory from the heap, and copy voxel data accordingly. This is similar to the allocation phase (see Section 5), however, when streaming data, all hash entries must be inserted within a single frame, rather than staggering the insertions. For a streamed voxel block we check the descriptor and atomically compare whether the position is occupied in the table. If an entry exists, we proceed to search for the next available free position in the bucket (as described below, we ensure that there are no duplicates). Otherwise we write the streamed hash entry at that position into the hash table. If the bucket is full, the entry is appended at the end of the list. Both writing a free entry directly in the bucket or appending it to the end of a linked list must be performed atomically.  One important consideration for streaming is to ensure that voxel blocks are never duplicated on host or GPU, leading to potential memory leaks. Given that Host-to-GPU streaming is staggered, there are rare cases where voxel blocks waiting to be streamed may enter the view frustum. We must verify that there is no new allocation of these voxel blocks in these staggered regions. To this end we store a binary occupancy grid on the GPU, where each entry corresponds to a particular chunk. Setting the bit indicates that the chunk resides on the GPU and allocations can occur in this region. Otherwise the chunk should be assumed to be on the host and allocations should be avoided. This binary grid carries little GPU memory overhead 512KB for 256 3 m 3 , and can be easily re-allocated on-the-fly to extend to larger scenes.\n          8.3 Stream and Allocation Synchronization\n        \n      \n      \n        9 Results\n        We have implemented our data structure using DirectX 11 Compute Shaders. We use an Asus Xtion for scenes in Fig. 10 and a Kinect for Windows camera for all other scenes, both providing RGB-D data at 30Hz. Results of live scene captures for our test scenes are shown in Figures 1 and 11 as well as supplementary material. We captured a variety of indoor and outdoor scenes under a variety of lighting conditions. While the quality of active infrared sensors is affected significantly in outdoor scenes, our system still manages to reconstruct large-scale outdoor scenes with fine quality. STATUES in Fig. 1 shows the result after an online scan of a ? 20m long corridor in a museum with about 4m high statues, which was captured and reconstructed live in under 5 minutes. PASSAGEWAY ( Fig. 11 top) shows a pathway of shops ? 30m long reconstructed live. QUEENS ( Fig. 11 middle) shows a large courtyard (stretching ? 16m ? 12m ? 2m) reconstructed in approximately 4 minutes. Finally, BOOKSHOP ( Fig. 11 bottom) shows three levels of a bookstore reconstructed in under 6 minutes. These reconstructions demonstrate both scale and quality, and were all reconstructed well above the 30Hz frame rate of the Kinect as shown in Figure 7 . This allows for potential increase of voxel resolution and additional ICP steps for more robust camera tracking. We use a voxel size of 4mm for Fig. 8 , 10 and 10mm for Fig. 1 , 9, 11. We also tested our system with < 2mm voxels without visible improvements in overall reconstruction quality. While this highlights limits of current depth sensing technology, we believe that this opens up new possibilities for future depth acquisition hardware. We measured performance of our entire pipeline including run-time overhead (such as display rendering) on an Intel Core i7 3.4GHz CPU, 16GB of RAM, and a single NVIDIA GeForce GTX Titan. Average timings among all test scenes is 21.8ms (?46f ps) with 8.0ms (37% of the overall pipeline) for ICP pose estimation (15 iterations), 4.6ms (21%) for surface integration, 4.8ms (22%) for surface extraction and shading (including colored phong shading), and 4.4ms (20%) for streaming and input data processing. Separate timings for each test scene are provided in Fig. 7 . Our data structure uses a total of 34MB for the hash table and all auxiliary buffers. This allows a hash table with 2 21 entries, each containing 12 bytes. Our experiments show that a bucket size of two provides best performance leaving us with about 1 million buckets. We pre-allocate 1GB of heap memory to provide space for voxel data on the GPU. With 8 3 voxels per block (8 byte per voxel) this corresponds to 2 18 voxel blocks. Note that 2 21 hash entries only index to 2 18 voxel blocks resulting in a low hash occupancy, thus minimizing hash collisions. On average we found that about 140K voxel blocks are allocated when capturing our test scenes at a voxel size of 8mm (varying with scene complexity). This corresponds to an equal amount of occupied hash entries, resulting in a hash table occupancy with 120K buckets with a single entry, and 10K buckets with two entries. With a bucket size of two and hash table size of 2 21 , all test scenes run with only 0.1% bucket overflow. These are handled by linked lists and across all scenes the largest list length is three. In total ?700 linked list entries are allocated across all scenes, which is negligible compared to the hash table size. On average less than 300MB memory is allocated for surface data (less than 600MB with color). This compares favorably to a regular grid that would require well over 5GB (including color) at the same voxel resolution (8mm) and spatial extent (8m in depth). This also leaves enough space to encode RGB data directly into the stored voxels (see Fig. 11 ). In practice this simple hashing scheme with small bucket size and large hash table size works well. In our scenario we can tolerate larger and sparser (2 21 ) hash table sizes, because the memory footprint of the hash table is insignificant (?34MB) compared to the voxel block buffer (which is pre-allocated to 1GB). Smaller hash table sizes cause higher occupancy and decrease performance. For example, in the STATUES scene our standard settings (2 21 elements) occupies ?6.4% of the hash table and runs at ?21ms, with 200K elements occupancy rises to ?65% and performance is reduced to ?24.8ms, and with 160K elements occupancy rises to ?81% with performance further falling to 25.6ms. In our live system, we chose larger table sizes as we favored performance over the small memory gains. Our pipeline currently uses atomic operations per hash bucket for allocation and streaming. As shown by our timings across all scenes, these sequential operations cause negligible performance overheads, due to hash collisions being minimal. More sophisticated hashing approaches [Lefebvre and Hoppe 2006; Bastos and Celes 2008; Alcantara et al. 2009; Pan and Manocha 2011; Garc?a et al. 2011] could further reduce collisions and allow smaller hash tables. However, how these methods deal with the high throughput of data, fusion and streaming is unclear. It is also important to stress that our simple hashing method works well in practice, handling scalability and quality at framerates >40fps across all scenes.\n        \n          Figure 7: Performance Comparison: frame rate measurements across our test scenes compared against two state-of-the-art reconstruction methods. Extended (or moving volume) regular grids and the hierarchical approach of [Chen et al. 2013].\n        \n        9.1 Performance\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        169:8\n        ?\n        M. Nei?ner et al.\n        \n          \n          Figure 8: Quality and scale comparison with related systems. Bottom right: Our method maintains a large working volume with streaming at frame-rate (in this example 4mm voxels). Top: moving volumes based on regular grids. With the same physical extent, the voxel resolution is coarse and quality is reduced (top left), but to maintain the same voxel resolution, the size of the volume must be decreased significantly (top right). Bottom left: the performance bottleneck of hierarchical grids leads to more tracking drift, and reduces overall quality.\n        \n        \n          \n          Figure 9: Comparison of camera tracking drift: in gray the results of the hierarchical approach of Chen et al. [2013] and in yellow our results. Note the twisting in the final models for Chen?s approach; e.g., the center of the Q UEENS and left hand side of the\n        \n        P ASSAGEWAY reconstruction.\n        \n          9.2 Comparison\n          In Fig. 9 we show the quality and performance of our method compared to previous work. All code was tested on the same hardware (see above) with a fixed number of ICP iterations (15). As our algorithm supports real-time streaming, we conducted comparisons with similar moving volume approaches. First, we compare against Extended Fusion [Roth and Vona 2012; Whelan et al. 2012] that use a regular uniform grid including streaming to scale-up volumetric fusion. Second, we compare against Hierarchical Fusion [Chen et al. 2013] that supports larger moving volumes than other approaches. Corresponding timings are shown in Fig. 7 . The most significant limitation of the hierarchy is the data structure overhead causing a performance drop, particularly in complex scenes. In our test scenes the entire hierarchy pipeline (including pose estimation, fusion, and streaming) runs at ? 15Hz, which is lower than the input frame rate. Note that these measurements are based on the reference implementation by Chen et al. [2013]. Our system also performs favorably compared to streaming regular grids in terms of frame-rate (labeled Extended in Fig. 7 ). We attribute this to processing of empty voxels in the regular grid (particularly during random GPU memory access; e.g., raycasting) and streaming overhead. Further, as shown in Fig. 8 , our reconstruction quality is higher than these approaches. The quality of Extended Fusion is limited by the small spatial extent of the moving volume, which means much of the Kinect data is out of range and not integrated. Hierarchical Fusion suffers from the poor frame rate causing input data to be skipped. This severely affects pose estimation quality resulting in inaccurate surface integration and drift. In large-scale scenes this type of drift might cause unnaturally twisted models as shown in Fig. 9 . Given our more efficient data structure, which runs faster than the Kinect camera frame rate, additional time can be spent improving the accuracy of the pose estimation by increasing the number of ICP iterations. We find our results encouraging, particularly given no drift correction is explicitly handled. In Fig. 10 scenes captured and processed offline using the method of [Zhou and Koltun 2013], which uses a multi-pass global optimization to mitigate drift, are compared to our online method. While our method does suffer from small drifts, our system produces comparable results, and can be used for real-time applications. Our online method can also be used as a live preview, and combined with such approaches for higher-quality offline reconstruction.\n          ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n          Real-time 3D Reconstruction at Scale using Voxel Hashing\n          ?\n          169:9\n          \n            \n            Figure 10: Comparison of output meshes from our online method (top) with the offline method of [Zhou and Koltun 2013] (bottom).\n          \n        \n      \n      \n        10 Conclusion\n        We have presented a new data structure designed specifically for online reconstruction using widely-available consumer depth cameras. Our approach leverages the power of implicit surfaces and volumetric fusion for reconstruction, but does so using a compact spatial hashing scheme, which removes both the overhead of regular grids and hierarchical data structures. Our hashing scheme supports real-time performance without forgoing scale or finer quality reconstruction. All operations are designed to be efficient for parallel graphics hardware. The inherent unstructured nature of our method removes the overhead of hierarchical spatial data structures, but captures the key qualities of volumetric fusion. To further extend the bounds of reconstruction, our method supports lightweight streaming without major data structure reorganization. We have demonstrated performance increases over the state-of-theart, even regular grid implementations. The data structure is memory  efficient and can allow color data to be directly incorporated in the reconstruction, which can also be used to improve the robustness of registration. Due to the high performance of our data structure, the available time budget can be utilized for further improving camera pose estimation, which directly improves reconstruction quality over existing online approaches. We believe the advantages of our method will be even more evident when future depth cameras with higher resolution sensing emerge, as our data structure is already capable of reconstructing surfaces beyond the resolution of existing depth sensors such as Kinect.\n      \n      \n        Acknowledgements\n        We thank Dennis Bautembach, Jiawen Chen, Vladlen Koltun and Qian-Yi Zhou for code/data, Christoph Buchenau for mesh rendering, and Universities of Cambridge and Erlangen-Nuremberg for filming access. This work was part funded by the German Research Foundation (DFG), grant GRK-1773 Heterogeneous Image Systems.\n      \n      \n        References\n        \n          A LCANTARA , D. A., S HARF , A., A BBASINEJAD , F., S ENGUPTA , S., M ITZENMACHER , M., O WENS , J. D., AND A MENTA , N. 2009. Real-time parallel hashing on the GPU. ACM Transactions on Graphics (TOG) 28, 5, 154.\n          A MANATIDES , J., AND W OO , A. 1987. A fast voxel traversal algorithm for ray tracing. In Proc. Eurographics, vol. 87, 3?10.\n          B ASTOS , T., AND C ELES , W. 2008. Gpu-accelerated adaptively sampled distance fields. In Shape Modeling and Applications, 2008. SMI 2008. IEEE International Conference on, IEEE, 171? 178.\n          B ESL , P., AND M C K AY , N. 1992. A method for registration of 3-D shapes. IEEE Trans. Pattern Anal. and Mach. Intell. 14, 2, 239?256.\n          C HANG , C., C HATTERJEE , S., AND K UBE , P. R. 1994. A quantization error analysis for convergent stereo. In Proc. ICIP 94, vol. 2, IEEE, 735?739.\n          C HEN , Y., AND M EDIONI , G. 1992. Object modelling by registration of multiple range images. Image and Vision Computing 10, 3, 145?155.\n          C HEN , J., B AUTEMBACH , D., AND I ZADI , S. 2013. Scalable real-time volumetric surface reconstruction. ACM Transactions on Graphics (TOG) 32, 4, 113.\n          C RASSIN , C., N EYRET , F., L EFEBVRE , S., AND E ISEMANN , E. 2009. Gigavoxels: Ray-guided streaming for efficient and detailed voxel rendering. In Proc. Symp. Interactive 3D Graphics and Games, ACM, 15?22.\n          C URLESS , B., AND L EVOY , M. 1996. A volumetric method for building complex models from range images. In In Proc. Computer graphics and interactive techniques, ACM, 303?312.\n          G ALLUP , D., P OLLEFEYS , M., AND F RAHM , J.-M. 2010. 3D reconstruction using an n-layer heightmap. In Pattern Recognition. Springer, 1?10.\n          G ARC ? A , I., L EFEBVRE , S., H ORNUS , S., AND L ASRAM , A. 2011. Coherent parallel hashing. ACM Transactions on Graphics (TOG) 30, 6, 161.\n          G ROSS , M., AND P FISTER , H. 2007. Point-based graphics. Morgan Kaufmann.\n          H ADWIGER , M., B EYER , J., J EONG , W.-K., AND P FISTER , H. 2012. Interactive volume exploration of petascale microscopy data streams using a visualization-driven virtual memory approach. Visualization and Computer Graphics, IEEE Transactions on 18, 12, 2285?2294.\n          H ARRIS , M., S ENGUPTA , S., AND O WENS , J. D. 2007. Parallel prefix sum (scan) with cuda. GPU gems 3, 39, 851?876.\n          H ENRY , P., K RAININ , M., H ERBST , E., R EN , X., AND F OX , D. 2012. RGB-D mapping: Using Kinect-style depth cameras for dense 3D modeling of indoor environments. Int. J. Robotics Research 31 (Apr.), 647?663.\n          H IGUCHI , K., H EBERT , M., AND I KEUCHI , K. 1995. Building 3-D models from unregistered range images. Graphical Models and Image Processing 57, 4, 315?333.\n          H ILTON , A., S TODDART , A., I LLINGWORTH , J., AND W INDEATT , T. 1996. Reliable surface reconstruction from multiple range images. J. Computer Vision (Proc. ECCV), 117?126.\n          H OPPE , H., D E R OSE , T., D UCHAMP , T., M C D ONALD , J., AND S TUETZLE , W. 1992. Surface reconstruction from unorganized points. ACM SIGGRAPH Computer Graphics 26, 2, 71?78.\n          I ZADI , S., K IM , D., H ILLIGES , O., M OLYNEAUX , D., N EW COMBE , R., K OHLI , P., S HOTTON , J., H ODGES , S., F REEMAN , D., D AVISON , A., AND F ITZGIBBON , A. 2011. KinectFusion: Real-time 3D reconstruction and interaction using a moving depth camera. In Proc. ACM Symp. User Interface Software and Technology, 559?568.\n          J OHNSON , A. E., AND B ING K ANG , S. 1999. Registration and integration of textured 3d data. Image and vision computing 17, 2, 135?147.\n          K AMPE  ? , V., S INTORN , E., AND A SSARSSON , U. 2013. High resolution sparse voxel dags. ACM Transactions on Graphics (TOG) 32, 4, 101.\n          K AZHDAN , M., B OLITHO , M., AND H OPPE , H. 2006. Poisson surface reconstruction. In Proc. EG Symp. Geometry Processing.\n          K ELLER , M., L EFLOCH , D., L AMBERS , M., I ZADI , S., W EYRICH , T., AND K OLB , A. 2013. Real-time 3d reconstruction in dynamic scenes using point-based fusion. In Proc. of Joint 3DIM/3DPVT Conference (3DV), IEEE, 1?8.\n          K RAUS , M., AND E RTL , T. 2002. Adaptive texture maps. In Proc. of the ACM SIGGRAPH/EUROGRAPHICS conference on Graphics hardware, Eurographics Association, 7?15.\n          L AINE , S., AND K ARRAS , T. 2011. Efficient sparse voxel octrees. Visualization and Computer Graphics, IEEE Transactions on 17, 8, 1048?1059.\n          L EFEBVRE , S., AND H OPPE , H. 2006. Perfect spatial hashing. ACM Transactions on Graphics (TOG) 25, 3, 579?588.\n          L EFEBVRE , S., H ORNUS , S., AND N EYRET , F., 2005. Gpu gems 2. chapter 37: Octree textures on the gpu.\n          L EVOY , M., P ULLI , K., C URLESS , B., R USINKIEWICZ , S., K OLLER , D., P EREIRA , L., G INZTON , M., A NDERSON , S., D AVIS , J., G INSBERG , J., ET AL . 2000. The digital michelangelo project: 3D scanning of large statues. In In Proc. Computer graphics and interactive techniques, ACM Press/Addison-Wesley Publishing Co., 131?144.\n          L ORENSEN , W., AND C LINE , H. 1987. Marching cubes: A high resolution 3D surface construction algorithm. Computer Graphics 21, 4, 163?169.\n          L OW , K.-L. 2004. Linear least-squares optimization for point-toplane icp surface registration. Tech. rep., Chapel Hill, University of North Carolina.\n          N EWCOMBE , R. A., I ZADI , S., H ILLIGES , O., M OLYNEAUX , D., K IM , D., D AVISON , A. J., K OHLI , P., S HOTTON , J., H ODGES , S., AND F ITZGIBBON , A. 2011. KinectFusion: Real-time dense surface mapping and tracking. In Proc. IEEE Int. Symp. Mixed and Augmented Reality, 127?136.\n          N GUYEN , C., I ZADI , S., AND L OVELL , D. 2012. Modeling Kinect sensor noise for improved 3D reconstruction and tracking. In Proc. Int. Conf. 3D Imaging, Modeling, Processing, Visualization and Transmission, 524?530.\n          P AN , J., AND M ANOCHA , D. 2011. Fast gpu-based locality sensitive hashing for k-nearest neighbor computation. In Proc. of the 19th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems, ACM, 211?220.\n          P OLLEFEYS , M., N IST ? R , D., F RAHM , J., A KBARZADEH , A., M ORDOHAI , P., C LIPP , B., E NGELS , C., G ALLUP , D., K IM , S., M ERRELL , P., ET AL . 2008. Detailed real-time urban 3D reconstruction from video. Int. J. Comp. Vision 78, 2, 143?167.\n          R EICHL , F., C HAJDAS , M. G., B URGER  ? , K., AND W ESTERMANN , R. 2012. Hybrid sample-based surface rendering. In Vision, Modeling & Visualization, The Eurographics Association, 47?54.\n          R OTH , H., AND V ONA , M. 2012. Moving volume KinectFusion. In British Machine Vision Conf.\n          R USINKIEWICZ , S., H ALL -H OLT , O., AND L EVOY , M. 2002. Real-time 3D model acquisition. ACM Transactions on Graphics (TOG) 21, 3, 438?446.\n          S T UCKLER  ? , J., AND B EHNKE , S. 2012. Integrating depth and color cues for dense multi-resolution scene mapping using rgb-d cameras. In Proc. of the IEEE Int. Conf. on Multisensor Fusion and Information Integration (MFI),(Hamburg, Germany).\n          T ESCHNER , M., H EIDELBERGER , B., M ULLER  ? , M., P OMER ANETS , D., AND G ROSS , M. 2003. Optimized spatial hashing for collision detection of deformable objects. In Proc.of Vision, Modeling, Visualization VMV03, 47?54.\n          T URK , G., AND L EVOY , M. 1994. Zippered polygon meshes from range images. In In Proc. Computer graphics and interactive techniques, 311?318.\n          W EISE , T., W ISMER , T., L EIBE , B., AND V AN G OOL , L. 2009. In-hand scanning with online loop closure. In Proc. IEEE Int. Conf. Computer Vision Workshops, 1630?1637.\n          W HEELER , M., S ATO , Y., AND I KEUCHI , K. 1998. Consensus surfaces for modeling 3D objects from multiple range images. In Proc. IEEE Int. Conf. Computer Vision, 917?924.\n          W HELAN , T., J OHANNSSON , H., K AESS , M., L EONARD , J., AND M C D ONALD , J. 2012. Robust tracking for real-time dense rgb-d mapping with kintinuous. Tech. rep. Query date: 2012-10-25.\n          Z ENG , M., Z HAO , F., Z HENG , J., AND L IU , X. 2012. Octree-based fusion for realtime 3D reconstruction. Graphical Models.\n          Z HOU , Q.-Y., AND K OLTUN , V. 2013. Dense scene reconstruction with points of interest. ACM Transactions on Graphics (TOG) 32, 4, 112.\n          Z HOU , K., G ONG , M., H UANG , X., AND G UO , B. 2011. Dataparallel octrees for surface reconstruction. IEEE Trans. Vis. and Comp. Graph. 17, 5, 669?681.\n        \n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        169:10\n        ?\n        M. Nei?ner et al.\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n        Real-time 3D Reconstruction at Scale using Voxel Hashing\n        ?\n        169:11\n        \n          \n          Figure 11: Reconstructions of the captured test scenes: a pathway of shops ( PASSAGEWAY ), a large courtyard ( QUEENS ) and a three level bookstore ( BOOKSHOP ). Shown left: the input data from the Kinect sensor (depth and color) and the live raycasted view of our system (shaded\n        \n        and shaded color).\n        ACM Transactions on Graphics, Vol. 32, No. 6, Article 169, Publication Date: November 2013\n      \n    \n  ",
  "resources" : [ ]
}