{
  "uri" : "sig2009-a21-adams_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a21-adams_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Gaussian KD-Trees for Fast High-Dimensional Filtering",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "gaussian", "kd-tree", "can", "use", "accelerate", "non-local", "means", "exactly", "same", "way", "accelerate", "bilateral", "filter", "use", "same", "kd-tree", "implementation", "facilitate", "query", "we", "propose", "new", "type", "kd-tree", "which", "we", "term", "gaussian", "kd-tree", "describe", "section", "gaussian", "kd-tree", "we", "now", "apply", "gaussian", "kd-tree", "describe", "section", "task", "once", "value", "position", "compute", "we", "blur", "use", "gaussian", "kd-tree", "produce", "smooth", "detail", "vector", "which", "add", "back", "offset", "base", "layer", "produce", "final", "denoised", "result", "finally", "gaussian", "kd-tree", "do", "require", "any", "particular", "order", "structure", "value", "store", "goal", "when", "build", "kd-tree", "usually", "minimize", "expected", "time", "take", "query", "gaussian", "kd-tree", "fast", "high-dimensional", "filtering", "section", "we", "show", "since", "gaussian", "kd-tree", "do", "place", "any", "structural", "constraint", "input", "datum", "can", "use", "filter", "geometry", "suggest", "place", "point", "kd-tree", "-lrb-", "grid", "small", "-rrb-", "filter", "vertex", "move", "along", "its", "normal", "average", "height", "compute", "bilateral", "filter" ],
  "content" : "The Gaussian kd-tree can be used to accelerate non-local means in exactly the same way it accelerates bilateral filtering, using the same kd-tree implementation. To facilitate such queries, we propose a new type of kd-tree, which we term a Gaussian kd-tree, described in Section 2. The Gaussian kd-tree We now apply the Gaussian kd-tree described in Section 2 to this task. Once the values are positions are computed, we blur using the Gaussian kd-tree to produce the smoothed detail vectors, which are then added back as offsets to the base layer to produce the final denoised result. Finally, the Gaussian kd-tree does not require any particular ordering or structure to the values it stores. The goal when building a kd-tree is usually to minimize the expected time taken by a query. Gaussian KD-Trees for Fast High-Dimensional Filtering. In this section, we will show that, since the Gaussian kd-tree does not place any structural constraints on input data, it can be used for filtering of geometry. This suggests placing the points in a kd-tree (or a grid if d is small). The filtered vertex is then moved along its normal by the averaged height computed by the bilateral filter.",
  "resources" : [ ]
}