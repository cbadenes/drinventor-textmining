{
  "uri" : "sig2008a-a126-zhou_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a126-zhou_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-Time KD-Tree Construction on Graphics Hardware",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Qiming-Hou",
      "name" : "Qiming",
      "surname" : "Hou"
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Baining-Guo",
      "name" : "Baining",
      "surname" : "Guo"
    } ]
  },
  "bagOfWords" : [ "unlike", "previous", "parallel", "kd-tree", "algorithm", "we", "method", "build", "tree", "node", "completely", "BFS", "-lrb-", "breadth-first", "search", "-rrb-", "order", "kd-tree", "build", "we", "algorithm", "comparable", "quality", "those", "construct", "off-line", "CPU", "algorithm", "we", "algorithm", "provide", "general", "way", "handle", "dynamic", "scene", "GPU", "we", "demonstrate", "potential", "we", "algorithm", "application", "involve", "dynamic", "scene", "include", "GPU", "ray", "trace", "interactive", "photon", "mapping", "point", "cloud", "modeling", "specifically", "we", "algorithm", "build", "tree", "node", "BFS", "-lrb-", "breadth-first", "search", "-rrb-", "order", "fully", "exploit", "fine-grained", "parallelism", "modern", "gpus", "all", "stage", "kd-tree", "construction", "GPU", "ray", "trace", "photon", "mapping", "dynamic", "scene", "where", "both", "scene", "geometry", "light", "source", "can", "change", "we", "algorithm", "build", "kd-tree", "comparable", "quality", "those", "construct", "off-line", "CPU", "algorithm", "term", "speed", "we", "algorithm", "time", "faster", "than", "well-optimized", "single-core", "CPU", "algorithm", "-lsb-", "Hunt", "et", "al.", "2006", "-rsb-", "competitive", "multi-core", "CPU", "algorithm", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "small", "node", "near", "bottom", "tree", "where", "exact", "evaluation", "cost", "necessary", "we", "introduce", "novel", "datum", "structure", "store", "geometry", "primitive", "node", "bit", "mask", "which", "allow", "we", "efficiently", "evaluate", "exact", "cost", "sort", "primitive", "use", "bitwise", "operation", "we", "real-time", "kd-tree", "construction", "provide", "general", "way", "deal", "dynamic", "scene", "GPU", "we", "demonstrate", "potential", "we", "kd-tree", "algorithm", "few", "application", "GPU", "Ray", "Tracing", "we", "implement", "GPU", "ray", "tracer", "arbitrary", "dynamic", "scene", "use", "we", "real-time", "kd-tree", "construction", "-lrb-", "section", "-rrb-", "we", "GPU", "ray", "tracer", "can", "handle", "general", "dynamic", "scene", "outperform", "state-of-the-art", "multicore", "CPU", "ray", "tracer", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "unique", "feature", "we", "ray", "tracer", "can", "efficiently", "handle", "dynamic", "geometry", "directly", "evaluate", "GPU", "subdivision", "surface", "-lsb-", "Shiue", "et", "al.", "2005", "-rsb-", "skin", "mesh", "-lsb-", "Wang", "et", "al.", "2007", "-rsb-", "combine", "we", "GPU", "ray", "tracer", "photon", "mapping", "capable", "render", "shadow", "reflection/refraction", "well", "realistic", "caustic", "dynamic", "scene", "lighting", "interactive", "rate", "single", "pc", "although", "-lrb-", "log", "-rrb-", "construction", "algorithm", "exist", "-lsb-", "Wald", "Havran", "2006", "-rsb-", "time", "need", "large", "animated", "scene", "still", "too", "high", "base", "report", "timing", "multi-core", "algorithm", "-lsb-", "Popov", "et", "al.", "2006", "-rsb-", "about", "order", "magnitude", "slower", "than", "we", "kd-tree", "algorithm", "tree", "comparable", "quality", "algorithm", "-lsb-", "Hunt", "et", "al.", "2006", "-rsb-", "about", "time", "slower", "than", "we", "algorithm", "another", "problem", "method", "note", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "kd-tree", "construct", "approximately", "half", "quality", "those", "produce", "off-line", "kd-tree", "builder", "ray-tracing", "identical", "dynamic", "scene", "performance", "lower", "than", "we", "GPU", "ray", "tracer", "-lsb-", "Purcell", "et", "al.", "2002", "-rsb-", "design", "first", "ray", "tracer", "run", "entirely", "GPU", "employ", "uniform", "grid", "acceleration", "recently", "two", "technique", "-lsb-", "Horn", "et", "al.", "2007", "Popov", "et", "al.", "2007", "-rsb-", "achieve", "better", "performance", "than", "CPU", "ray", "tracer", "dynamic", "scene", "most", "exist", "method", "cpu-based", "-lrb-", "e.g.", "-lsb-", "Wald", "et", "al.", "2006", "Yoon", "et", "al.", "2007", "-rsb-", "-rrb-", "we", "work", "lead", "GPU", "ray", "tracer", "general", "dynamic", "scene", "outperform", "state-of-the-art", "multi-core", "CPU", "ray", "tracer", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "uniform", "grid", "instead", "kd-tree", "use", "store", "photon", "greatly", "degrade", "performance", "nearest", "photon", "query", "-lsb-", "g?nther", "et", "al.", "2004", "-rsb-", "present", "framework", "real-time", "distribute", "photon", "mapping", "far", "we", "know", "kd-tree", "base", "photon", "mapping", "algorithm", "have", "be", "implement", "GPU", "adaption", "we", "algorithm", "other", "kind", "kd-tree", "straightforward", "explain", "later", "section", "follow", "conventional", "kd-tree", "construction", "algorithm", "-lsb-", "Pharr", "Humpreys", "2004", "-rsb-", "we", "technique", "build", "kd-tree", "greedy", "topdown", "manner", "recursively", "splitting", "current", "node", "two", "subnode", "follow", "evaluate", "SAH", "cost", "all", "splitting", "plane", "candidate", "SAH", "cost", "function", "define", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "sah", "-lrb-", "-rrb-", "t", "where", "t", "constant", "cost", "traverse", "node", "itself", "-lrb-", "-rrb-", "cost", "left", "child", "give", "split", "position", "-lrb-", "-rrb-", "cost", "right", "child", "give", "same", "split", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "surface", "area", "left", "right", "child", "respectively", "surface", "area", "node", "note", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "can", "only", "evaluate", "after", "entire", "sub-tree", "have", "be", "build", "Algorithm", "Overview", "algorithm", "take", "triangle", "soup", "input", "follow", "construction", "pipeline", "show", "algorithm", "after", "initialization", "step", "algorithm", "build", "tree", "BFS", "manner", "both", "large", "node", "small", "node", "finally", "all", "node", "tree", "reorganize", "store", "pipeline", "consist", "set", "stream", "processing", "step", "together", "minimal", "coordination", "work", "we", "current", "implementation", "user-specified", "threshold", "large/small", "node", "set", "64", "mention", "SAH", "evaluation", "conventional", "greedy", "optimization", "algorithm", "assume", "current", "split", "produce", "two", "leaf", "node", "large", "node", "assumption", "almost", "always", "untrue", "result", "estimation", "far", "from", "accurate", "we", "splitting", "scheme", "large", "node", "combination", "spatial", "median", "splitting", "empty", "space", "maximize", "which", "highly", "effective", "upper", "level", "tree", "note", "-lsb-", "havran", "2001", "-rsb-", "empty", "space", "contain", "current", "node", "larger", "than", "predefined", "ratio", "along", "one", "axis", "empty", "space", "cut", "off", "next", "split", "otherwise", "split", "plane", "choose", "spatial", "median", "node?s", "longest", "axis", "-lrb-", "see", "fig.", "-rrb-", "currently", "we", "take", "25", "note", "apply", "splitting", "scheme", "tight", "bound", "box", "all", "triangle", "contain", "node", "have", "compute", "large", "node", "processing", "procedure", "rocess", "arge", "ode", "elaborate", "algorithm", "procedure", "take", "activelist", "input", "update", "smalllist", "nextlist", "output", "note", "we", "also", "maintain", "triangle-node", "association", "list", "each", "node", "list", "each", "node", "node", "list", "record", "index", "its", "first", "triangle", "triangle-node", "association", "list", "number", "triangle", "contain", "scene", "space", "occupy", "pointer", "its", "child", "node", "first", "step", "procedure", "group", "all", "triangle", "each", "node", "fixed-sized", "chunk", "currently", "we", "set", "chunk", "size", "256", "large", "fraction", "subsequent", "computation", "parallelize", "over", "all", "triangle", "chunk", "second", "step", "bound", "box", "all", "triangle", "each", "node", "compute", "do", "first", "compute", "bound", "box", "all", "triangles?s", "aabb", "each", "chunk", "use", "reduction", "algorithm", "describe", "Algorithm", "-lsb-", "Popov", "et", "al.", "2007", "-rsb-", "compute", "bound", "box", "all", "node", "perform", "segmented", "reduction", "-lsb-", "Gropp", "et", "al.", "1994", "-rsb-", "sequence", "all", "chunk", "reduction", "result", "segmented", "reduction", "perform", "reduction", "arbitrary", "segment", "input", "sequence", "we", "GPU", "algorithm", "segmented", "reduction", "describe", "Algorithm", "input", "list", "datum", "all", "datum", "element", "belong", "same", "segment", "located", "contiguously", "another", "input", "list", "owner", "owner", "-lsb-", "-rsb-", "indicate", "segment", "index", "datum", "-lsb-", "-rsb-", "reduction", "operator", "op", "associate", "identity", "value", "list", "Table", "algorithm", "take", "multi-pass", "approach", "each", "thread", "take", "two", "element", "otherwise", "one", "element", "accumulate", "result", "other", "retain", "note", "chunk", "datum", "structure", "critical", "optimal", "performance", "within", "each", "chunk", "we", "only", "need", "perform", "unsegmented", "reduction", "all", "triangle", "aabb", "greatly", "reduce", "element", "number", "subsequent", "segmented", "reduction", "third", "step", "compute", "node", "bound", "box", "large", "node", "split", "parallel", "use", "splitting", "scheme", "describe", "earlier", "note", "we", "repeatedly", "split", "node", "use", "empty", "space", "splitting", "until", "spatial", "median", "split", "reach", "allow", "we", "reuse", "bound", "box", "avoid", "unnecessary", "computation", "after", "empty", "space", "splitting", "fourth", "step", "triangle", "sort", "clip", "child", "node", "Triangle", "sorting", "essentially", "list", "splitting", "triangle", "divide", "two", "group", "all", "triangle", "mark", "true", "left", "side", "output", "vector", "all", "triangle", "mark", "false", "right", "side", "those", "triangle", "contain", "both", "child", "node", "another", "pass", "need", "clip", "they", "node", "final", "step", "we", "count", "triangle", "number", "all", "child", "node", "use", "segmented", "reduction", "way", "similar", "bound", "box", "computation", "reduction", "operator", "use", "here", "triangle", "number", "node", "less", "threshold", "add", "smalllist", "delete", "from", "nextlist", "compare", "large", "node", "stage", "small", "node", "stage", "relatively", "simple", "first", "computation", "parallelize", "over", "node", "rather", "than", "triangle", "workload", "among", "small", "node", "naturally", "balanced", "because", "triangle", "number", "small", "node", "do", "vary", "significantly", "-lrb-", "from", "-rrb-", "second", "unlike", "large", "node", "stage", "we", "choose", "clip", "triangle", "when", "splitting", "small", "node", "although", "clipping", "triangle", "owner", "node", "reduce", "false", "positive", "triangle-in-node", "test", "always", "reduce", "SAH", "cost", "clipping", "may", "also", "cause", "undesirable", "excessive", "split", "because", "SAH", "do", "take", "memory", "cost", "account", "while", "clipping", "effective", "large", "node", "prevent", "false", "positive", "from", "accumulate", "over", "future", "split", "small", "node", "we", "experiment", "indicate", "clipping", "rarely", "improve", "ray", "trace", "performance", "thus", "we", "do", "clip", "triangle", "small", "node", "splitting", "plane", "candidate", "restricted", "those", "determine", "face", "aabb", "triangle", "contain", "initial", "small", "node", "show", "Algorithm", "small", "node", "stage", "consist", "two", "procedure", "reprocess", "mall", "ode", "rocess", "mall", "ode", "first", "procedure", "collect", "all", "split", "candidate", "also", "generate", "triangle", "set", "contain", "both", "side", "each", "splitting", "plane", "candidate", "single", "pass", "over", "triangle", "node", "second", "procedure", "rocess", "mall", "ode", "split", "small", "node", "process", "parallel", "each", "node", "procedure", "first", "get", "its", "triangle", "set", "triangleset", "its", "uppermost", "ancestor", "smallroot", "-lrb-", "also", "small", "node", "-rrb-", "tree", "SAH", "cost", "all", "splitting", "plane", "candidate", "located", "inside", "node", "compute", "finally", "node", "split", "use", "optimal", "split", "plane", "minimal", "cost", "triangle", "sort", "child", "node", "algorithm", "small", "Node", "Stage", "procedure", "reprocess", "mall", "ode", "-lrb-", "smalllist", "list", ";-rrb-_NN", "begin", "each", "node", "smalllist", "parallel", "i.splitlist", "list", "all", "split", "candidate", "each", "split", "candidate", "parallel", "leave", "represent", "smaller", "coordinate", "j.lef", "triangle", "set", "left", "j.right", "triangle", "set", "right", "end", "procedure", "rocess", "mall", "ode", "-lrb-", "activelist", "list", "out", "nextlist", "list", "-rrb-", "begin", "each", "node", "activelist", "parallel", "compute", "SAH", "determine", "split", "plane", "i.triangleset", "i.smallroot", "area", "node", "sah", "where", "r.splitlist", "j.triangle", "j.lef", "j.right", "area", "left", "child", "after", "split", "area", "right", "child", "after", "split", "sah", "-lrb-", "-rrb-", "t", "split", "candidate", "yield", "minimal", "SAH", "split", "small", "node", "SAH", "SAH", "Mark", "leaf", "node", "else", "Split", "use", "add", "new", "node", "nextlist", "Sort", "triangle", "new", "node", "end", "triangle", "set", "each", "split", "candidate", "j.lef", "j.right", "also", "store", "bit", "mask", "bit", "mask", "representation", "triangle", "sorting", "sah", "evaluation", "any", "split", "candidate", "can", "efficiently", "do", "use", "bitwise", "operation", "parallel", "bit", "count", "routine", "-lsb-", "manku", "2002", "-rsb-", "perform", "result", "bit", "mask", "get", "number", "triangle", "left", "child", "bit", "mask", "representation", "allow", "we", "compute", "optimal", "split", "plane", "-lrb-", "-rrb-", "time", "sort", "triangle", "-lrb-", "-rrb-", "time", "cost", "function", "all", "split", "candidate", "optimal", "splitting", "plane", "can", "compute", "only", "single", "pass", "over", "sort", "datum", "cost", "-lrb-", "-rrb-", "however", "since", "sort", "order", "can", "represent", "bit", "mask", "triangle", "sorting", "can", "only", "do", "cost", "-lrb-", "-rrb-", "describe", "section", "we", "GPU", "ray", "tracer", "stack-based", "require", "kd-tree", "final", "layout", "preorder", "traversal", "node", "optimal", "cache", "performance", "we", "compute", "preorder", "traversal", "use", "two", "parallel", "bf", "traversal", "-lrb-", "see", "Algorithm", "-rrb-", "first", "pass", "traverse", "tree", "bottom-up", "compute", "require", "memory", "size", "each", "subtree", "second", "pass", "algorithm", "Preorder", "Traversal", "procedure", "reorder", "raversal", "-lrb-", "nodelist", "list", "-rrb-", "begin", "each", "tree", "level", "nodelist", "from", "bottom-up", "ass", "-lrb-", "-rrb-", "allocate", "tree", "use", "root", "node?s", "size", "each", "tree", "level", "nodelist", "from", "top-down", "own", "ass", "-lrb-", "-rrb-", "end", "procedure", "ass", "-lrb-", "activelist", "list", "-rrb-", "begin", "each", "node", "activelist", "parallel", "leaf", "i.size", "i.lef", "t.size", "i.right.size", "else", "i.size", "i.trianglecount", "end", "procedure", "own", "ass", "-lrb-", "activelist", "list", "-rrb-", "begin", "each", "node", "activelist", "parallel", "leaf", "i.lef", "t.address", "i.address", "i.right.address", "i.address", "i.lef", "t.size", "store", "node", "final", "format", "i.address", "end", "-lrb-", "-rrb-", "node", "-lrb-", "-rrb-", "large", "node", "small", "node", "triangle", "set", "node", "split", "plane", "analogous", "parallel", "scan", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "note", "procedure", "reorder", "raversal", "we", "need", "collect", "node", "located", "same", "tree", "level", "fortunately", "information", "already", "available", "each", "while-loop", "algorithm", "after", "preorder", "traversal", "each", "node", "result", "node", "list", "record", "number", "index", "triangle", "contain", "its", "splitting", "plane", "link", "its", "child", "we", "implement", "above", "kd-tree", "builder", "use", "nvidia?s", "CUDA", "framework", "-lsb-", "NVIDIA", "2007", "-rsb-", "CUDA", "provide", "general-purpose", "language", "interface", "GPU", "programming", "also", "expose", "some", "important", "new", "hardware", "feature", "which", "useful", "data-parallel", "computation", "example", "allow", "arbitrary", "gather", "scatter", "memory", "access", "from", "GPU", "program", "we", "GPU", "implementation", "heavily", "make", "use", "new", "feature", "all", "algorithm", "listing", "above", "parallel", "primitive", "-lrb-", "e.g.", "segmented", "reduction", "-rrb-", "code", "fragment", "mark", "paral", "-lrb-", "-rrb-", "Toys", "-lrb-", "-rrb-", "museum", "-lrb-", "-rrb-", "robot", "-lrb-", "-rrb-", "kitchen", "-lrb-", "-rrb-", "Fairy", "Forest", "-lrb-", "-rrb-", "Dragon", "compare", "kd-tree", "construction", "time", "tree", "ray", "trace", "time", "trace", "sah", "cost", "between", "offline", "CPU", "builder", "we", "GPU", "builder", "all", "render", "time", "1024", "1024", "image", "lel", "GPU", "code", "other", "CPU", "code", "we", "also", "need", "specify", "number", "thread", "block", "thread", "per", "block", "parallel", "primitive", "code", "fragment", "mark", "parallel", "we", "current", "implementation", "we", "use", "256", "thread", "each", "block", "block", "number", "compute", "divide", "total", "number", "parallel", "thread", "number", "thread", "per", "block", "during", "kd-tree", "construction", "we", "store", "all", "datum", "dynamic", "list", "linear", "device", "memory", "allocate", "via", "CUDA", "list", "size", "double", "whenever", "more", "memory", "require", "allow", "we", "avoid", "high", "overhead", "CUDA", "memory", "management", "after", "initial", "run", "cost", "more", "memory", "consumption", "from", "its", "description", "reader", "may", "have", "notice", "we", "algorithm", "also", "frequently", "call", "certain", "parallel", "primitive", "reduce", "scan", "many", "primitive", "have", "be", "efficiently", "implement", "expose", "cudpp", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "most", "conditional", "program", "flow", "pseudo", "code", "handle", "use", "list", "splitting", "which", "also", "standard", "GPU", "primitive", "optimize", "implementation", "-lsb-", "sengupta", "et", "al.", "2007", "-rsb-", "conditional", "program", "Algorithm", "-lrb-", "line", "12", "15", "-rrb-", "serialize", "result", "performance", "penalty", "chunk", "structure", "use", "perform", "most", "computation", "per-chunk", "standard", "reduction", "algorithm", "avoid", "conditional", "program", "flow", "compare", "per-chunk", "standard", "reduction", "segmented", "reduction", "Algorithm", "do", "consume", "any", "significant", "processing", "time", "its", "performance", "issue", "can", "thus", "safely", "ignore", "scalability", "we", "kd-tree", "construction", "algorithm", "GeForce", "8800", "ULTRA", "graphic", "card", "bottom", "row", "show", "speedup", "go", "from", "16", "128", "processor", "note", "we", "algorithm", "scale", "better", "large", "scene", "however", "scalability", "still", "sublinear", "mainly", "because", "total", "run", "time", "contain", "constant", "portion", "due", "overheard", "CUDA", "API", "describe", "algorithm", "have", "be", "test", "Intel", "Xeon", "3.7", "GHz", "CPU", "NVIDIA", "GeForce", "8800", "ULTRA", "-lrb-", "768MB", "-rrb-", "graphic", "card", "parameter", "-lrb-", "e.g.", "-rrb-", "use", "during", "tree", "construction", "intentionally", "keep", "same", "all", "scene", "we", "compare", "we", "GPU", "algorithm", "off-line", "CPU", "algorithm", "which", "always", "use", "greedy", "SAH", "cost", "calculate", "optimal", "split", "plane", "clip", "triangle", "child", "node", "-lsb-", "Wald", "Havran", "2006", "-rsb-", "Table", "summarize", "comparison", "result", "several", "publicly", "available", "scene", "show", "fig.", "show", "we", "kd-tree", "construction", "algorithm", "15", "time", "faster", "all", "scene", "quality", "tree", "assess", "two", "way", "first", "we", "compute", "SAH", "cost", "second", "we", "evaluate", "practical", "effect", "tree", "quality", "render", "time", "use", "construct", "tree", "ray", "tracer", "describe", "section", "show", "table", "we", "algorithm", "generate", "lower", "sah", "cost", "Toys", "Museum", "Robots", "higher", "SAH", "cost", "kitchen", "Fairy", "Forest", "Dragon", "all", "case", "we", "tree", "always", "offer", "better", "render", "performance", "which", "attest", "high", "quality", "we", "tree", "practical", "application", "note", "SAH", "cost", "expect", "cost", "ray", "traverse", "entire", "tree", "whereas", "actual", "kdtree", "traversal", "terminate", "first", "node", "intersection", "therefore", "strict", "correlation", "between", "SAH", "cost", "actual", "ray", "trace", "time", "SAH", "cost", "only", "one", "way", "measure", "quality", "kd-tree", "most", "important", "metric", "how", "well", "result", "tree", "accelerate", "ray", "traversal", "which", "ultimate", "goal", "SAH", "tree", "construction", "strategy", "we", "kd-tree", "construction", "algorithm", "also", "scale", "well", "number", "GPU", "processor", "run", "time", "contain", "scalable", "portion", "small", "non-scalable", "portion", "due", "overhead", "CUDA", "API", "driver", "theoretically", "run", "time", "linear", "respect", "reciprocal", "number", "processor", "show", "Table", "Fig.", "we", "run", "algorithm", "GeForce", "8800", "ULTRA", "graphic", "card", "16", "32", "48", "64", "80", "96", "112", "128", "processor", "respectively", "nvstrap", "driver", "RivaTuner", "-lsb-", "Nicolaychuk", "2008", "-rsb-", "use", "disable", "process", "unit", "adjust", "hardware", "mask", "although", "we", "technique", "capable", "construct", "high", "quality", "kdtree", "real-time", "have", "its", "limitation", "small", "scene", "less", "than", "5k", "triangle", "CUDA?s", "API", "overhead", "become", "major", "bottleneck", "case", "more", "efficient", "switch", "complete", "CPU", "method", "also", "we", "method", "consume", "much", "more", "memory", "than", "CPU", "method", "mainly", "due", "use", "double", "list", "extra", "bookkeeping", "BFS", "order", "construction", "we", "system", "support", "scene", "up", "600k", "triangle", "GeForce", "8800", "Ultra", "-lrb-", "768MB", "-rrb-", "graphic", "card", "six", "test", "scene", "peak", "memory", "we", "build", "around", "8mb", "18mb", "50mb", "90mb", "123mb", "178mb", "respectively", "problem", "however", "can", "reduce", "better", "memory", "management", "scheme", "example", "currently", "we", "keep", "many", "temporary", "datum", "structure", "memory", "all", "stage", "avoid", "costly", "CUDA", "API", "call", "free", "temporary", "datum", "we", "implement", "set", "efficient", "CUDA", "memory", "allocation/free", "routine", "we", "able", "free", "temporary", "datum", "reduce", "memory", "consumption", "considerably", "other", "technique", "reduce", "memory", "certainly", "possible", "investigate", "future", "work", "memory", "consumption", "issue", "also", "alleviate", "rapid", "advancement", "graphic", "hardware", "NVIDIA", "recently", "release", "Quadro", "FX", "5600", "which", "support", "CUDA", "have", "1.5", "gb", "memory", "we", "have", "incorporate", "we", "kd-tree", "builder", "GPU", "ray", "tracer", "arbitrary", "dynamic", "scene", "each", "frame", "ray", "tracer", "first", "build", "kd-tree", "from", "scratch", "each", "ray", "trace", "ray", "tracer", "walk", "through", "kd-tree", "until", "reach", "leaf", "node", "associate", "triangle", "front", "back", "order", "while", "exist", "GPU", "ray", "tracer", "-lsb-", "Foley", "Sugerman", "2005", "Horn", "et", "al.", "2007", "Popov", "et", "al.", "2007", "-rsb-", "adopt", "stackless", "scheme", "kdtree", "traversal", "require", "additional", "information", "precompute", "store", "during", "tree", "construction", "extra", "computation", "during", "tree", "traversal", "avoid", "overhead", "we", "choose", "implement", "conventional", "stack-based", "scheme", "GPU", "point", "out", "-lsb-", "Horn", "et", "al.", "2007", "-rsb-", "when", "ray", "pass", "through", "both", "side", "splitting", "plane", "far", "subtree", "push", "stack", "near", "subtree", "traverse", "first", "reason", "stack-based", "scheme", "require", "local", "stack", "each", "thread", "fortunately", "can", "efficiently", "implement", "CUDA", "allocate", "fixed-sized", "array", "thread-local", "memory", "although", "kd-tree", "depth", "unbounded", "theory", "we", "find", "stack", "depth", "50", "enough", "all", "test", "GPU", "ray", "trace", "dynamic", "subdivision", "surface", "scene", "consist", "47k", "triangle", "armadillo", "model", "directly", "evaluate", "GPU", "through", "subdivision", "displacement", "mapping", "from", "coarse", "control", "mesh", "we", "can", "achieve", "22", "fp", "800", "600", "image", "scene", "paper", "order", "handle", "reflection/refraction", "we", "ray", "tracer", "perform", "follow", "multiple", "pass", "after", "build", "kd-tree", "scene", "spawn", "trace", "eye", "ray", "generate", "list", "hit", "specular", "refractive", "surface", "perform", "list", "compaction", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "eye", "ray", "hit", "point", "spawn", "trace", "reflective", "refractive", "ray", "repeat", "step", "step", "more", "bounce", "handle", "spawn", "trace", "shadow", "ray", "compute", "shade", "after", "shading", "compute", "each", "ray?s", "contribution", "final", "image", "send", "opengl", "pixel", "buffer", "object", "-lrb-", "pbo", "-rrb-", "PBO", "accumulate", "final", "image", "use", "alpha", "blending", "experimental", "result", "we", "test", "we", "GPU", "ray", "tracer", "use", "dynamic", "scene", "show", "fig.", "Table", "compare", "we", "frame", "rate", "those", "report", "two", "recent", "work", "one", "algorithm", "base", "bound", "volume", "hierarchy", "-lrb-", "bvh", "-rrb-", "-lsb-", "Wald", "et", "al.", "2007", "-rsb-", "other", "multi-core", "CPU", "algorithm", "use", "kd-trees", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "performance", "take", "account", "both", "tree", "-lrb-", "bvh", "-rrb-", "construction", "render", "time", "can", "see", "we", "algorithm", "run", "interactively", "shadow", "multi-bounce", "reflection/refraction", "outperform", "other", "two", "algorithm", "result", "suggest", "dynamic", "scene", "GPU", "ray", "trace", "accelerate", "we", "kd-tree", "provide", "competitive", "alternative", "CPU", "ray", "trace", "multi-core", "cpus", "note", "here", "we", "do", "claim", "we", "GPU", "ray", "tracer", "faster", "than", "all", "CPU", "ray", "tracer", "indeed", "implement", "fastest", "CPU", "ray", "tracer", "like", "chase", "move", "target", "because", "various", "optimization", "could", "use", "higher", "performance", "some", "optimization", "hardware", "dependent", "better", "performance", "can", "achieve", "add", "more", "CPU", "core", "example", "-lsb-", "Wald", "2007", "-rsb-", "report", "13", "21", "frame", "per", "second", "explode", "dragon", "scene", "-lrb-", "fig.", "-lrb-", "-rrb-", "-rrb-", "2.6", "GHz", "Clovertown", "system", "core", "note", "Toys", "Fairy", "Forest", "scene", "we", "frame", "rate", "higher", "than", "4-core", "CPU", "algorithm", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "both", "scene", "actually", "do", "reveal", "we", "method?s", "advantage", "tree", "quality", "due", "lack", "divergent", "secondary", "ray", "from", "reflection/refraction", "however", "already", "demonstrate", "potential", "ray", "trace", "dynamic", "scene", "gpus", "unique", "feature", "we", "ray", "tracer", "can", "efficiently", "handle", "dynamic", "geometry", "directly", "evaluate", "GPU", "skinned", "mesh", "-lsb-", "Wang", "et", "al.", "2007", "-rsb-", "subdivision", "surface", "-lsb-", "Shiue", "et", "al.", "2005", "-rsb-", "armadillo", "Fig.", "example", "input", "geometry", "sequence", "coarse", "control", "mesh", "provide", "author", "-lsb-", "Zhou", "et", "al.", "2007", "-rsb-", "two", "level", "Loop", "subdivision", "displacement", "mapping", "perform", "GPU", "generate", "detailed", "mesh", "output", "GPU", "subdivision", "displacement", "mapping", "immediately", "send", "we", "GPU", "kd-tree", "builder", "ray", "trace", "directly", "without", "copy", "back", "CPU", "please", "see", "accompany", "video", "live", "demo", "section", "we", "first", "show", "how", "adapt", "we", "kd-tree", "builder", "photon", "mapping", "we", "describe", "how", "perform", "k-nearestneighbor", "-lrb-", "knn", "-rrb-", "search", "use", "kd-tree", "GPU", "finally", "we", "show", "how", "use", "kd-tree", "builder", "knn", "search", "render", "caustic", "present", "some", "experimental", "result", "algorithm", "can", "use", "build", "photon", "kd-tree", "after", "several", "modification", "first", "we", "use", "vvh", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "instead", "SAH", "evaluate", "split", "cost", "function", "give", "node", "split", "position", "VVH", "cost", "function", "define", "where", "definition", "t", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "similar", "those", "SAH", "estimate", "KNN", "query", "radius", "describe", "more", "detail", "Appendix", "A.", "-lrb-", "-rrb-", "represent", "volume", "node", "d?s", "cell", "extend", "radius", "three", "axis", "direction", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "left", "right", "child", "node", "respectively", "give", "split", "position", "x.", "large", "node", "hybrid", "scheme", "spatial", "median", "splitting", "empty", "space", "splitting", "still", "employ", "however", "different", "switch", "threshold", "10", "use", "we", "also", "use", "smaller", "threshold", "large/small", "node", "classification", "32", "since", "exact", "vvh", "cost", "evaluation", "more", "expensive", "than", "SAH", "cost", "evaluation", "we", "discover", "through", "experiment", "second", "modification", "unlike", "ray", "trace", "photon", "kdtree", "build", "point", "instead", "triangle", "thus", "we", "do", "need", "compute", "aabb", "initialization", "stage", "clip", "split", "plane", "longer", "require", "large", "node", "split", "plane", "restricted", "initial", "point", "position", "small", "node", "most", "computation", "can", "directly", "parallelize", "over", "all", "point", "large", "node", "chunk", "datum", "structure", "longer", "necessary", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "initialization", "stage", "each", "three", "axis", "dimension", "we", "compute", "maintain", "sort", "order", "all", "point", "use", "sort", "primitive", "cudppsort", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "sort", "order", "tight", "bound", "box", "large", "node", "can", "compute", "-lrb-", "-rrb-", "time", "avoid", "use", "segmented", "reduction", "compensate", "overhead", "computing", "maintain", "sort", "order", "also", "sort", "point", "child", "node", "count", "point", "number", "child", "node", "can", "do", "-lrb-", "-rrb-", "time", "single", "pass", "over", "sort", "datum", "we", "store", "point-sorted", "order", "all", "node", "three", "concatenate", "point", "id", "list", "one", "each", "axis", "allow", "efficient", "per-node", "access", "list", "we", "enforce", "two", "property", "-rrb-", "point", "same", "node", "contiguous", "list", "-rrb-", "point", "same", "node", "same", "offset", "three", "list", "property", "allow", "arbitrary", "sub-list", "each", "individual", "node", "index", "use", "head", "pointer", "tail", "pointer", "after", "node", "splitting", "we", "perform", "split", "operation", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "concatenate", "list", "separate", "point", "left", "child", "node", "point", "right", "child", "node", "easy", "verify", "result", "new", "list", "inherit", "two", "aforementioned", "property", "algorithm", "KNN", "search", "function", "NN", "earch", "-lrb-", "point", "-rrb-", "begin", "min", "max", "hist", "new", "array", "-lsb-", "hist", "-rsb-", "iter", "max", "max", "min", "set", "all", "element", "hist", "zero", "each", "photon", "via", "range", "search", "increment", "hist", "-lsb-", "max", "-lcb-", "p?q", "min", ",0", "-rcb-", "hist", "-rsb-", "find", "hist", "-lsb-", "-rsb-", "hist", "-lsb-", "-rsb-", "-lrb-", "min", "max", "-rrb-", "-lrb-", "min", "hist", "min", "+1", "hist", "-rrb-", "max", "return", "all", "photon", "via", "range", "search", "end", "sort", "order", "also", "use", "accelerate", "computation", "reprocess", "mall", "ode", "small", "node", "stage", "however", "bit", "mask", "representation", "bitwise", "operation", "small", "node", "still", "employ", "both", "performance", "storage", "efficiency", "section", "3.3", "we", "reorganize", "all", "node", "use", "preorder", "traversal", "each", "node", "result", "node", "list", "record", "number", "index", "photon", "contain", "its", "splitting", "plane", "link", "its", "child", "its", "bound", "box", "describe", "-lsb-", "Jensen", "2001", "-rsb-", "estimate", "radiance", "surface", "point", "k-nearest", "photon", "need", "located", "filter", "efficiently", "locate", "nearest", "photon", "critical", "good", "performance", "photon", "mapping", "photon", "kd-tree", "build", "last", "subsection", "can", "use", "speed", "up", "nearest", "neighbor", "query", "natural", "choice", "locate", "nearest", "neighbor", "kd-tree", "priority", "queue", "method", "describe", "-lsb-", "Jensen", "2001", "-rsb-", "although", "possible", "implement", "priority", "queue", "use", "cuda?s", "threadlocal", "memory", "implementation", "would", "inefficient", "because", "cuda?s", "local", "memory", "require", "both", "pipeline", "sufficient", "amount", "independent", "arithmetic", "efficient", "latency", "hiding", "thread-wise", "coherent", "access", "pattern", "-lsb-", "NVIDIA", "2007", "-rsb-", "priority", "queue", "operation", "almost", "all", "memory", "access", "arithmetic", "inter-dependent", "difficult", "hardware", "hide", "memory", "latency", "thread-wise", "coherence", "also", "problematic", "since", "photon", "distribution", "usually", "highly", "irregular", "we", "instead", "propose", "iterative", "knn", "search", "algorithm", "base", "range", "search", "-lsb-", "Preparata", "Shamos", "1985", "-rsb-", "show", "Algorithm", "algorithm", "from", "initial", "conservative", "search", "radius", "try", "find", "KNN", "query", "radius", "through", "few", "iteration", "during", "each", "iteration", "fixed-radius", "range", "search", "perform", "construct", "hist", "histogram", "photon", "number", "over", "radius", "range", "search", "radius", "reduce", "accord", "histogram", "finally", "all", "photon", "within", "radius", "return", "three", "parameter", "Algorithm", "hist", "iter", "initial", "search", "radius", "one", "hand", "should", "conservative", "least", "photon", "within", "radius", "other", "hand", "should", "tight", "possible", "limit", "search", "range", "good", "estimation", "critical", "performance", "knn", "search", "appendix", "we", "elaborate", "detail", "estimation", "hist", "size", "histogram", "array", "control", "precision", "gain", "each", "iteration", "hist", "require", "frequent", "random", "update", "we", "store", "cuda?s", "share", "memory", "larger", "hist", "increase", "precision", "each", "iteration", "while", "decrease", "GPU", "occupancy", "we", "find", "hist", "32", "reasonable", "balance", "point", "iter", "number", "iteration", "currently", "we", "take", "iter", "result", "error", "final", "knn", "radius", "less", "than", "0.1", "Range", "search", "perform", "use", "standard", "df", "kd-tree", "traversal", "algorithm", "-lsb-", "Preparata", "Shamos", "1985", "-rsb-", "like", "stack-based", "kd-tree", "traversal", "GPU", "ray", "trace", "algorithm", "can", "efficiently", "implement", "use", "cuda?s", "local", "memory", "sample", "application", "photon", "kd-tree", "knn", "search", "we", "develop", "photon", "mapping", "system", "render", "realistic", "caustic", "GPU", "before", "build", "tree", "photon", "must", "emit", "scene", "process", "trace", "eye", "ray", "trace", "photon", "from", "light", "source", "very", "similar", "GPU", "ray", "tracer", "describe", "section", "can", "easily", "adapt", "photon", "trace", "main", "difference", "interaction", "photon", "surface", "material", "different", "from", "ray", "when", "photon", "hit", "surface", "can", "either", "reflect", "transmit", "absorb", "base", "surface", "material", "since", "we", "only", "trace", "caustic", "photon", "photon", "terminate", "store", "once", "hit", "diffuse", "surface", "we", "current", "system", "support", "only", "point", "light", "source", "photon", "emit", "randomly", "use", "projection", "map", "-lsb-", "Jensen", "2001", "-rsb-", "caustic", "render", "only", "specular", "refractive", "object", "identify", "projection", "map", "once", "photon", "trace", "do", "kd-tree", "build", "all", "store", "photon", "caustic", "render", "trace", "eye", "ray", "each", "ray", "its", "first", "intersection", "diffuse", "surface", "knn", "search", "perform", "locate", "nearest", "photon", "which", "filter", "get", "radiance", "value", "experimental", "result", "fig.", "-lrb-", "-rrb-", "show", "cardioid-shaped", "caustic", "form", "table", "due", "light", "reflect", "inside", "metal", "ring", "we", "trace", "200k", "photon", "total", "50", "nearest", "photon", "be", "query", "radiance", "estimate", "both", "lighting", "surface", "material", "can", "change", "fly", "please", "see", "accompany", "video", "live", "demo", "combine", "we", "GPU", "ray", "tracer", "section", "we", "even", "allow", "user", "change", "scene", "geometry", "case", "two", "kd-tree", "need", "build", "fly", "one", "scene", "geometry", "other", "photon", "fig.", "-lrb-", "-rrb-", "demonstrate", "caustic", "from", "glass", "champagne", "caustic", "form", "light", "refract", "through", "several", "layer", "glass", "champagne", "we", "use", "six", "bounce", "refraction", "photon", "trace", "total", "400k", "photon", "be", "trace", "set", "40", "KNN", "search", "again", "both", "lighting", "scene", "geometry", "can", "change", "Table", "summarize", "time", "photon", "kd-tree", "construction", "knn", "search", "use", "both", "CPU", "GPU", "algorithm", "CPU", "KNN", "search", "base", "priority", "queue", "method", "describe", "-lsb-", "Jensen", "2001", "-rsb-", "overall", "both", "we", "GPU", "kd-tree", "builder", "knn", "search", "around", "10", "time", "faster", "than", "CPU", "algorithm", "we", "have", "present", "kd-tree", "algorithm", "capable", "achieve", "realtime", "performance", "GPU", "algorithm", "build", "kd-tree", "BFS", "order", "exploit", "large", "scale", "parallelism", "modern", "gpus", "construct", "kd-tree", "comparable", "quality", "those", "build", "off-line", "CPU", "algorithm", "we", "also", "demonstrate", "potential", "we", "kd-tree", "algorithm", "three", "application", "involve", "dynamic", "scene", "GPU", "ray", "trace", "GPU", "photon", "mapping", "point", "cloud", "modeling", "several", "direction", "future", "investigation", "we", "plan", "incorporate", "packet", "-lsb-", "Wald", "et", "al.", "2001", "-rsb-", "GPU", "ray", "tracer", "further", "performance", "enhancement", "we", "also", "intend", "implement", "-lrb-", "-rrb-", "metal", "ring", "-lrb-", "-rrb-", "glass", "champagne", "caustic", "render", "use", "photon", "mapping", "both", "scene", "light", "point", "light", "source", "render", "image", "resolution", "800", "600", "-lrb-", "-rrb-", "cardioid-shaped", "caustic", "cause", "light", "reflection", "inside", "metal", "ring", "scene", "consist", "3k", "triangle", "render", "performance", "12.2", "fp", "-lrb-", "-rrb-", "caustic", "due", "light", "refraction", "through", "several", "layer", "glass", "champagne", "scene", "have", "19k", "triangle", "performance", "about", "7.5", "fp", "CPU", "algorithm", "GPU", "algorithm", "kd-tree", "knn", "kd-tree", "knn", "0.081", "0.508", "0.009", "0.044", "0.237", "0.371", "0.017", "0.050", "compare", "photon", "kd-tree", "construction", "time", "knn", "time", "between", "CPU", "algorithm", "we", "GPU", "algorithm", "global", "photon", "map", "GPU", "use", "general", "photon", "scattering", "scheme", "base", "russian", "roulette", "photon", "map", "would", "allow", "we", "render", "indirect", "illumination", "finally", "we", "interested", "extend", "we", "kd-tree", "algorithm", "higher", "dimension", "application", "texture", "synthesis", "author", "would", "like", "thank", "Eric", "Stollnitz", "he", "help", "video", "production", "we", "also", "grateful", "reviewer", "helpful", "comment", "mention", "section", "5.2", "good", "estimation", "critical", "performance", "knn", "search", "due", "irregularity", "photon", "distribution", "need", "estimate", "each", "knn", "query", "point", "show", "algorithm", "we", "take", "two-stage", "approach", "first", "each", "render", "frame", "recompute", "adius", "carry", "out", "compute", "KNN", "query", "radius", "set", "node", "center", "do", "run", "knn", "search", "algorithm", "Algorithm", "parameter", "R.", "each", "knn", "query", "point", "stimate", "adius", "perform", "compute", "p?s", "initial", "query", "radius", "from", "KNN", "query", "radius", "node", "contain", "can", "easily", "prove", "result", "query", "radius", "guarantee", "conservative", "conservative", "estimation", "note", "photon", "density", "inversely", "proportional", "square", "knn", "query", "radius", "define", "minimal", "physically", "meaningful", "density", "reasonably", "tight", "estimation", "can", "compute", "from", "also", "use", "estimate", "query", "radius", "VVH", "center", "node", "i?s", "bound", "box", "node", "radius", "compute", "half", "length", "bound", "box", "diagonal", "level", "two", "user-specified", "constant", "which", "determine", "node", "use", "radius", "estimation", "we", "find", "0.5", "level", "work", "well", "all", "example", "show", "paper", "kd-tree", "builder", "knn", "search", "algorithm", "describe", "section", "can", "directly", "use", "estimate", "local", "sampling", "density", "normal", "dynamic", "point", "cloud", "well", "update", "deformation", "strength", "field", "free-form", "deformation", "give", "set", "point", "input", "we", "first", "build", "kd-tree", "unlike", "photon", "mapping", "we", "do", "have", "good", "estimate", "initial", "knn", "query", "radius", "we", "thus", "let", "user", "specify", "parameter", "parallel", "each", "point", "we", "find", "k-nearest", "neighbor", "use", "knn", "search", "final", "query", "radius", "can", "use", "determine", "local", "kernel", "size", "surface", "splatting", "-lsb-", "Zwicker", "et", "al.", "2001", "-rsb-", "local", "sampling", "density", "can", "compute", "k/r", "compute", "normal", "-lsb-", "Hoppe", "et", "al.", "1992", "-rsb-", "we", "first", "perform", "principal", "component", "analysis", "-lrb-", "pca", "-rrb-", "covariance", "matrix", "its", "k-nearest", "neighbor", "unit", "eigenvector", "minimal", "eigenvalue", "regard", "normal", "minimum", "span", "tree", "-lrb-", "mst", "-rrb-", "base", "approach", "-lsb-", "Hoppe", "et", "al.", "1992", "-rsb-", "use", "make", "all", "point", "normal", "consistently", "orient", "both", "knn", "search", "pca", "perform", "GPU", "minimum", "span", "tree", "however", "currently", "build", "CPU", "point", "cloud", "deformation", "tool", "-lsb-", "Pauly", "et", "al.", "2003", "-rsb-", "scalar", "value", "range", "from", "compute", "each", "point", "indicate", "deformation", "strength", "point", "each", "point?s", "scalar", "value", "decide", "its", "distance", "current", "active", "handle", "other", "static", "handle", "closer", "point", "active", "handle", "stronger", "deformation", "point", "each", "handle", "consist", "set", "point", "point?s", "distance", "handle", "define", "minimal", "distance", "between", "point", "all", "point", "handle", "efficiently", "calculate", "distance", "two", "kd-tree", "build", "one", "active", "handle", "one", "all", "static", "handle", "each", "point", "its", "nearest", "neighbor", "each", "tree", "search", "distance", "compute", "therefore", "when", "user", "define", "new", "handle", "remove", "old", "handle", "we", "need", "rebuild", "kd-tree", "recompute", "distance", "which", "can", "do", "efficiently", "use", "we", "GPU", "kd-tree", "builder", "knn", "search", "sample", "density", "normal", "estimation", "point", "cloud", "from", "leave", "right", "input", "point", "cloud", "-lrb-", "127k", "point", "-rrb-", "render", "use", "surface", "splatting", "sampling", "density", "map", "rest", "pose", "sampling", "density", "map", "deform", "pose", "-lrb-", "blue", "small", "red", "large", "-rrb-", "experimental", "result", "we", "have", "implement", "describe", "algorithm", "develop", "point", "cloud", "deformation", "tool", "-lsb-", "Pauly", "et", "al.", "2003", "-rsb-", "point", "cloud", "render", "use", "GPU", "implementation", "surface", "splat", "algorithm", "-lsb-", "Zwicker", "et", "al.", "2001", "-rsb-", "please", "see", "accompany", "video", "live", "demo", "fig.", "sampling", "density", "normal", "compute", "dynamic", "point", "cloud", "fly", "we", "GPU", "algorithm", "kdtree", "build", "about", "21", "millisecond", "knn", "search", "-lrb-", "10", "-rrb-", "take", "about", "14", "millisecond", "CPU", "algorithm", "pointshop3d", "-lsb-", "Zwicker", "et", "al.", "2002", "-rsb-", "use", "simple", "midpoint", "splitting", "build", "kdtree", "quickly", "however", "tree", "quality", "poor", "result", "very", "slow", "knn", "search", "same", "datum", "take", "about", "32", "millisecond", "6.5", "seconds", "tree", "construction", "knn", "search", "respectively", "we", "also", "compare", "we", "algorithm", "kd-tree", "algorithm", "ANN", "library", "-lsb-", "Mount", "Arya", "2006", "-rsb-", "same", "datum", "take", "98", "millisecond", "828", "millisecond", "tree", "construction", "knn", "search", "respectively", "overall", "we", "approach", "over", "20", "time", "faster", "than", "ANN", "algorithm", "note", "achieve", "consistent", "normal", "orientation", "minimum", "span", "tree", "build", "initial", "pose", "point", "cloud", "CPU", "less", "than", "30", "millisecond", "Minimum", "span", "tree", "need", "build", "again", "during", "deformation", "since", "we", "make", "use", "temporal", "coherence", "force", "point", "normal", "current", "pose", "consistently", "orient", "those", "precede", "pose", "deformation", "example", "show", "Fig.", "we", "allow", "user", "manipulate", "point", "cloud", "define", "new", "handle", "drag", "they", "we", "algorithm", "can", "provide", "immediate", "response", "user", "since", "deformation", "strength", "field", "compute", "about", "310", "millisecond", "while", "CPU", "algorithm", "base", "ANN", "take", "about", "seconds", "thus", "provide", "better", "user", "experience" ],
  "content" : "Unlike previous parallel kd-tree algorithms, our method builds tree nodes completely in BFS (breadth-first search) order. The kd-trees built by our algorithm are of comparable quality as those constructed by off-line CPU algorithms. Our algorithm provides a general way for handling dynamic scenes on the GPU. We demonstrate the potential of our algorithm in applications involving dynamic scenes, including GPU ray tracing, interactive photon mapping, and point cloud modeling. Specifically, our algorithm builds tree nodes in BFS (breadth-first search) order to fully exploit the fine-grained parallelism of modern GPUs at all stages of kd-tree construction. GPU ray tracing and photon mapping for a dynamic scene, where both the scene geometry and the light source can be changed. Our algorithm builds kd-trees of comparable quality as those constructed by off-line CPU algorithms. In terms of speed, our algorithm is 4 ? 7 times faster than well-optimized single-core CPU algorithms [Hunt et al. 2006] and competitive with multi-core CPU algorithms [Shevtsov et al. 2007]. For small nodes near the bottom of the tree, where exact evaluation of the costs is necessary, we introduce a novel data structure for storing the geometry primitives in these nodes as bit masks, which allows us to efficiently evaluate the exact costs and sort these primitives using bitwise operations. Our real-time kd-tree construction provides a general way of dealing with dynamic scenes on the GPU. We demonstrate the potential of our kd-tree algorithm with a few applications: GPU Ray Tracing We implemented a GPU ray tracer for arbitrary dynamic scenes using our real-time kd-tree construction (Section 4). Our GPU ray tracer can handle general dynamic scenes and outperforms a state-of-the-art multicore CPU ray tracer [Shevtsov et al. 2007]. A unique feature of our ray tracer is that it can efficiently handle dynamic geometries that are directly evaluated on the GPU, such as subdivision surfaces [Shiue et al. 2005] and skinned meshes [Wang et al. 2007]. Combined with our GPU ray tracer, the photon mapping is capable of rendering shadows, reflection/refraction, as well as realistic caustics for dynamic scenes and lighting at interactive rates on a single PC. Although an O(n log n) construction algorithm exists [Wald and Havran 2006], the time needed for large animated scenes is still too high. Based on reported timings, the multi-core algorithm in [Popov et al. 2006] is about an order of magnitude slower than our kd-tree algorithm. For trees of comparable quality, the algorithm in [Hunt et al. 2006] is about 4 ? 7 times slower than our algorithm. Another problem with this method is that, as noted in [Shevtsov et al. 2007], the kd-trees constructed are of approximately half the quality of those produced by off-line kd-tree builders. For ray-tracing identical dynamic scenes, their performance is lower than our GPU ray tracer. [Purcell et al. 2002] designed the first ray tracer that runs entirely on the GPU, employing a uniform grid for acceleration. Recently, two techniques [Horn et al. 2007; Popov et al. 2007] achieved better performance than CPU ray tracers. For dynamic scenes, most existing methods are CPU-based (e.g., [Wald et al. 2006; Yoon et al. 2007]). Our work leads to a GPU ray tracer for general dynamic scenes that outperforms a state-of-the-art multi-core CPU ray tracer [Shevtsov et al. 2007]. A uniform grid, instead of a kd-tree, is used to store the photons, greatly degrading the performance of nearest photon queries. [G?nther et al. 2004] presented a framework for real-time distributed photon mapping. As far as we know, kd-tree based photon mapping algorithms have not been implemented on the GPU. The adaption of our algorithm to other kinds of kd-trees is straightforward and will be explained in later sections. Following conventional kd-tree construction algorithms [Pharr and Humpreys 2004], our technique builds a kd-tree in a greedy, topdown manner by recursively splitting the current node into two subnodes as follows:\n        1. Evaluate the SAH costs for all splitting plane candidates; 2. The SAH cost function is defined as: C L (x)A L (x) C R (x)A R (x) SAH(x) = C ts + + , A A where C ts is the constant cost of traversing the node itself, C L (x) is the cost of the left child given a split position x, and C R (x) is the cost of the right child given the same split. A L (x) and A R (x) are the surface areas of the left and right child respectively. A is the surface area of the node. Note that C L (x) and C R (x) can only be evaluated after the entire sub-tree has been built. Algorithm Overview The algorithm takes a triangle soup as input and follows the construction pipeline as shown in Algorithm 1. After an initialization step, the algorithm builds the tree in a BFS manner, for both large nodes and small nodes. Finally, all nodes of the tree are reorganized and stored. The pipeline consists of a set of stream processing steps together with minimal coordination work. In our current implementation, the user-specified threshold for large/small node is set as T = 64. As mentioned, the SAH evaluation in the conventional greedy optimization algorithm assumes that the current split produces two leaf nodes. For large nodes, this assumption is almost always untrue. The resulting estimation is far from accurate. Our splitting scheme for large nodes is a combination of spatial median splitting and ?empty space maximizing?, which is highly effective for the upper levels of the tree as noted in [Havran 2001]. the empty space contained in the current node is larger than a predefined ratio C e along one axis, the empty space is cut off in the next split; otherwise, the split plane is chosen at the spatial median of the node?s longest axis (see Fig. 2 ). Currently, we take C e = 25%. Note that, to apply this splitting scheme, a tight bounding box of all triangles contained in the node has to be computed. The large node processing procedure, P ROCESS L ARGE N ODES , is elaborated in Algorithm 2. This procedure takes activelist as input, and updates smalllist and nextlist as output. Note that we also maintain a triangle-node association list for each node list. Each node in the node list records the index of its first triangle in the triangle-node association list and the number of triangles it contains, the scene space it occupies, and the pointers to its child nodes. The first step of the procedure is to group all triangles in each node into fixed-sized chunks. Currently we set the chunk size to N = 256. A large fraction of the subsequent computations are parallelized over all triangles in these chunks. In the second step, the bounding box of all triangles in each node is computed. This is done by first computing the bounding box of all triangles?s AABBs in each chunk using the reduction algorithm described in Algorithm 4 of [Popov et al. 2007], and then computing the bounding boxes of all nodes by performing segmented reduction [Gropp et al. 1994] on the sequence of all chunk reduction results. Segmented reduction performs reduction on arbitrary segments of an input sequence. Our GPU algorithm for segmented reduction is described in Algorithm 3. In the input list data, all data elements belonging to the same segment are located contiguously. In another input list owner, owner[i] indicates the segment index of data[i]. The reduction operator op is associated with an identity value, as listed in Table 1 . The algorithm takes a multi-pass approach. Each thread takes two elements. Otherwise, one element is accumulated into result and the other is retained. Note that the chunk data structure is critical for optimal performance. Within each chunk, we only need to perform unsegmented reduction on all triangles? AABBs, greatly reducing the element number in the subsequent segmented reduction. In the third step, with computed node bounding boxes, large nodes are split in parallel using the splitting scheme described earlier. Note that we repeatedly split a node using empty space splitting until a spatial median split is reached. This allows us to reuse the bounding box and avoid unnecessary computations after empty space splitting. In the fourth step, triangles are sorted and clipped into child nodes. Triangle sorting is essentially list splitting. Then the triangles are divided into two groups, with all the triangles marked true on the left side of the output vector and all the triangles marked false on the right side. For those triangles contained in both child nodes, another pass is needed to clip them into the nodes. In the final step, we count the triangle numbers for all child nodes using segmented reduction in a way similar to bounding box computation. The reduction operator used here is +. If the triangle number of a node is less then the threshold T , it is added to smalllist and deleted from nextlist. Compared to the large node stage, the small node stage is relatively simple. First, the computation is parallelized over nodes rather than triangles. The workload among small nodes is naturally balanced because the triangle numbers of small nodes do not vary significantly (from 0 to T ). Second, unlike in the large node stage, we choose not to clip triangles when splitting small nodes. Although clipping triangles to owner nodes reduces false positives of the triangle-in-node test and always reduces the SAH cost, clipping may also cause undesirable excessive splits because SAH does not take memory costs into account. While clipping is effective for large nodes by preventing false positives from accumulating over future splits, for small nodes our experiments indicate that clipping rarely improves ray tracing performance. Thus we do not clip triangles for small nodes, and the splitting plane candidates are restricted to those determined by the faces of the AABBs of triangles contained in the initial small nodes. As shown in Algorithm 4, the small node stage consists of two procedures, P REPROCESS S MALL N ODES and P ROCESS S MALL N ODES . The first procedure collects all split candidates. It also generates the triangle sets contained in both sides of each splitting plane candidate with a single pass over the triangles in a node. The second procedure P ROCESS S MALL N ODES splits small nodes. Processed in parallel for each node i, the procedure first gets its triangle set triangleSet and its uppermost ancestor smallRoot (also a small node) in the tree. Then the SAH costs for all splitting plane candidates located inside the node are computed. Finally the node is split using the optimal split plane with minimal cost, and triangles are sorted into child nodes. Algorithm 4 Small Node Stage procedure P REPROCESS S MALL N ODES (smalllist:list;) begin for each node i in smalllist in parallel i.splitList ? list of all split candidates in i for each split candidate j in i in parallel /* ?left? represents smaller coordinate */ j.lef t ? triangle set on the left of j j.right ? triangle set on the right of j end procedure P ROCESS S MALL N ODES ( in activelist:list; out nextlist:list) begin for each node i in activelist in parallel // compute SAH and determine the split plane s ? i.triangleSet r ? i.smallRoot A 0 ? area of node i SAH 0 ? s for j where j ? r.splitList and j.triangle ? s C L ? s ? j.lef t C R ? s ? j.right A L ? area of left child after split j A R ? area of right child after split j SAH j ? (C L A L + C R A R )/A 0 + C ts p ? The split candidate that yields minimal SAH // split small nodes if SAH p ? SAH 0 then Mark i as leaf node else Split i using p, add new nodes to nextlist Sort triangles to new nodes end that the triangle sets of each split candidate j, j.lef t and j.right, are also stored as bit masks. With this bit mask representation, triangle sorting and SAH evaluation for any split candidate can be efficiently done using bitwise operations. Then a parallel bit counting routine [Manku 2002] is performed on the resulting bit mask to get the number of triangles in the left child. The bit mask representation allows us to compute the optimal split plane in O(n) time and sort triangles in O(1) time. Then the cost functions of all split candidates and the optimal splitting plane can be computed by only a single pass over the sorted data, at the cost of O(n). However, since the sorted order cannot be represented as a bit mask, triangle sorting can only be done at the cost of O(n). As described in Section 4, our GPU ray tracer is stack-based and it requires the kd-tree?s final layout to be a preorder traversal of nodes for optimal cache performance. We compute the preorder traversal using two parallel BFS traversals (see Algorithm 5). The first pass traverses the tree bottom-up to compute required memory size for each subtree. The second pass\n        Algorithm 5 Preorder Traversal procedure P REORDER T RAVERSAL (nodelist:list) begin for each tree level l of nodelist from bottom-up U P P ASS (l) Allocate tree using root node?s size for each tree level l of nodelist from top-down D OWN P ASS (l) end procedure U P P ASS (activelist:list) begin for each node i in activelist in parallel if i is not a leaf then i.size ? i.lef t.size + i.right.size + 1 else i.size ? i.triangleCount + 1 end procedure D OWN P ASS (activelist:list) begin for each node i in activelist in parallel if i is not a leaf then i.lef t.address ? i.address + 1 i.right.address ? i.address + 1 + i.lef t.size Store node i in final format to i.address end (a) Node A (b) R R Large node A Small node A triangle set in node A B C B C Split Plane 1 0 0 1 0 1 1 1 This is analogous to the parallel scan in [Sengupta et al. 2007]. Note that, in procedure P REORDER T RAVERSAL , we need to collect nodes located at the same tree level. Fortunately this information is already available in each while-loop in Algorithm 1. After preorder traversal, each node in the resulting node list records the number and indices of the triangles it contains, its splitting plane, and the links to its children. We implemented the above kd-tree builder using NVIDIA?s CUDA framework [ NVIDIA 2007 ]. CUDA provides a general-purpose C language interface for GPU programming. It also exposes some important new hardware features which are useful for data-parallel computations. For example, it allows arbitrary gather and scatter memory access from GPU programs. Our GPU implementation heavily makes use of these new features. In all the algorithm listings above, the parallel primitives (e.g., segmented reduction) and the code fragments marked by in paral- (a) Toys (b) Museum (c) Robots (d) Kitchen (e) Fairy Forest (f) Dragon Comparing kd-tree construction time T tree , ray tracing time T trace and SAH costs between an offline CPU builder and our GPU builder. All rendering times are for 1024 ? 1024 images. lel are GPU code; others are CPU code. We also need to specify the number of thread blocks and threads per block for the parallel primitives and the code fragments marked by in parallel. In our current implementation, we use 256 threads for each block. The block number is computed by dividing the total number of parallel threads by the number of threads per block. During kd-tree construction, we store all data as dynamic lists in linear device memory allocated via CUDA. List size is doubled whenever more memory is required. This allows us to avoid high overhead in CUDA memory management after an initial run, at the cost of more memory consumption. From its description, the reader may have noticed that our algorithm also frequently calls certain parallel primitives such as reduce and scan. Many of these primitives have been efficiently implemented and exposed in CUDPP [Harris et al. 2007]. Most conditional program flows in the pseudo code are handled using list splitting, which is also a standard GPU primitive with optimized implementation [Sengupta et al. 2007]. The conditional programs in Algorithm 3 (lines 12 ? 15) will be serialized and result in performance penalty, but the chunk structure used to perform most computations in the per-chunk standard reduction in Algorithm 2 avoid these conditional program flows. Compared to per-chunk standard reductions, the segmented reduction in Algorithm 3 does not consume any significant processing time, and its performance issues can thus be safely ignored. Scalability of our kd-tree construction algorithm on a GeForce 8800 ULTRA graphics card. The bottom row shows the speedup going from 16 to 128 processors. Note that our algorithm scales better with large scenes. However, the scalability is still sublinear mainly because the total running time contains a constant portion due to the overheard of CUDA API. The described algorithm has been tested on an Intel Xeon 3.7GHz CPU with an NVIDIA GeForce 8800 ULTRA (768MB) graphics card. Parameters (e.g., T and N ) used during tree construction are intentionally kept the same for all scenes. We compare our GPU algorithm with an off-line CPU algorithm which always uses the greedy SAH cost to calculate optimal split planes and clips triangles into child nodes [Wald and Havran 2006]. Table 2 summarizes the comparison results for several publicly available scenes as shown in Fig. 4 . As shown, our kd-tree construction algorithm is 6 ? 15 times faster for all scenes. The quality of the trees is assessed in two ways. First, we compute the SAH costs. Second, we evaluate the practical effect of tree quality on render time by using the constructed trees in a ray tracer as described in Section 4. As shown in the table, our algorithm generates lower SAH costs for Toys, Museum and Robots, but higher SAH costs for Kitchen, Fairy Forest and Dragon. In all cases, our trees always offer better rendering performance, which attests to the high quality of our trees in practical applications. Note that SAH cost is the expected cost for a ray to traverse the entire tree, whereas actual kdtree traversal terminates at the first node of intersection. Therefore there is no strict correlation between the SAH costs and the actual ray trace time. SAH cost is only one way to measure the quality of kd-trees. The most important metric is how well the resulting tree accelerates ray traversals, which is the ultimate goal of an SAH tree construction strategy. Our kd-tree construction algorithm also scales well with the number of GPU processors. The running time contains a scalable portion and a small non-scalable portion due to the overhead of CUDA API and driver. Theoretically, the running time is linear with respect to the reciprocal of the number of processors. As shown in Table 3 and Fig. 5 , we ran the algorithm on a GeForce 8800 ULTRA graphics card with 16, 32, 48, 64, 80, 96, 112, and 128 processors respectively. The NVStrap driver in RivaTuner [Nicolaychuk 2008] is used to disable processing units by adjusting hardware masks. Although our technique is capable of constructing high quality kdtrees in real-time, it has its limitations. For small scenes with less than 5K triangles, CUDA?s API overhead becomes a major bottleneck. In this case, it is more efficient to switch to a complete CPU method. Also, our method consumes much more memory than a CPU method. This is mainly due to the use of doubling lists and extra bookkeeping for BFS order construction. Our system supports scenes with up to 600K triangles on the GeForce 8800 Ultra (768MB) graphics card. For the six tested scenes, the peak memory in our build is around 8MB, 18MB, 50MB, 90MB, 123MB and 178MB respectively. This problem, however, can be reduced with a better memory management scheme. For example, currently we keep many temporary data structures in memory at all stages to avoid costly CUDA API calls to free these temporary data. If we implement a set of efficient CUDA memory allocation/free routines, we will be able to free temporary data and reduce memory consumption considerably. Other techniques for reducing memory are certainly possible and are to be investigated in future work. The memory consumption issue is also alleviated with the rapid advancements in graphics hardware. NVIDIA recently released Quadro FX 5600 which supports CUDA and has 1.5GB memory. We have incorporated our kd-tree builder into a GPU ray tracer for arbitrary dynamic scenes. For each frame, the ray tracer first builds a kd-tree from scratch. For each ray to be traced, the ray tracer walks through the kd-tree until it reaches leaf nodes and the associated triangles, in front to back order. While existing GPU ray tracers [Foley and Sugerman 2005; Horn et al. 2007; Popov et al. 2007] adopt a stackless scheme for kdtree traversal, they require additional information to be precomputed and stored during tree construction, and extra computation during tree traversal. To avoid such overhead we chose to implement a conventional stack-based scheme on the GPU. As pointed out in [Horn et al. 2007], when a ray passes through both sides of a splitting plane, the ?far? subtree is pushed into the stack and the ?near? subtree is traversed first. For this reason a stack-based scheme requires a local stack for each thread. Fortunately, this can be efficiently implemented in CUDA by allocating a fixed-sized array in thread-local memory. Although kd-tree depth is unbounded in theory, we found that a stack depth of 50 is enough for all test GPU ray tracing of a dynamic subdivision surface. The scene consists of 47K triangles. The armadillo model is directly evaluated on the GPU through subdivision and displacement mapping from a coarse control mesh. We can achieve 22 fps for 800 ? 600 images. scenes in this paper. In order to handle reflection/refraction, our ray tracer performs the following multiple passes after building a kd-tree for the scene: 1. Spawn and trace eye rays; 2. Generate a list of hits on specular and refractive surfaces by performing a list compaction [Harris et al. 2007] on eye ray hit points; 3. Spawn and trace reflective and refractive rays; 4. Repeat Step 2 and Step 3 if there are more bounces to handle; 5. Spawn and trace shadow rays; 6. Compute shading; After the shading is computed, each ray?s contribution to the final image is sent to an OpenGL pixel buffer object (PBO). The PBO is then accumulated to the final image using alpha blending. Experimental Results We tested our GPU ray tracer using the dynamic scenes shown in Fig. 4 . Table 4 compares our frame rates with those reported in two recent works. One is an algorithm based on bounding volume hierarchies (BVHs) [Wald et al. 2007], and the other is the multi-core CPU algorithm using kd-trees [Shevtsov et al. 2007]. The performance takes into account both the tree (or BVH) construction and rendering time. It can be seen that our algorithm runs interactively with shadow and multi-bounce reflection/refraction, and outperforms the other two algorithms. These results suggest that for dynamic scenes GPU ray tracing accelerated by our kd-trees provides a competitive alternative to CPU ray tracing on multi-core CPUs. Note that here we do not claim that our GPU ray tracer is faster than all CPU ray tracers. Indeed, implementing the fastest CPU ray tracer is like chasing a moving target because various optimizations could be used for higher performance and some optimizations are hardware dependent, and better performance can be achieved by adding more CPU cores. For example, [Wald 2007] reported 13 ? 21 frames per second for the exploding dragon scene ( Fig. 4(f) ) on a 2.6GHz Clovertown system with 8 cores. Note that for the Toys and Fairy Forest scenes, our frame rates are higher than the 4-core CPU algorithm [Shevtsov et al. 2007]. Both scenes actually do not reveal our method?s advantage in tree quality, due to the lack of divergent secondary rays from reflection/refraction. However, this already demonstrates the potential of ray tracing dynamic scenes on GPUs. A unique feature of our ray tracer is that it can efficiently handle dynamic geometries that are directly evaluated on the GPU, such as skinned meshes [Wang et al. 2007] and subdivision surfaces [Shiue et al. 2005]. The armadillo in Fig. 6 is such an example. The input geometry is a sequence of coarse control meshes provided by the authors of [Zhou et al. 2007]. Two levels of Loop subdivision and displacement mapping are performed on the GPU to generate the detailed meshes. The output of GPU subdivision and displacement mapping is immediately sent to our GPU kd-tree builder and then ray traced directly without copying back to the CPU. Please see the accompanying video for live demos. In this section we first show how to adapt our kd-tree builder for photon mapping. Then we describe how to perform k-nearestneighbor (KNN) search using kd-trees on the GPU. Finally we show how to use the kd-tree builder and KNN search to render caustics, and present some experimental results. Algorithm 1 can be used to build photon kd-trees after several modifications. First, we use VVH [Wald et al. 2004] instead of SAH to evaluate the split cost function. Given a node d and a split position x, the VVH cost function is defined as:  where the definitions of C ts , C L (x) and C R (x) are similar to those in SAH. R is an estimated KNN query radius described in more details in Appendix A. V (d ? R) represents the volume of node d?s cell extended by radius R in the three axis directions. d L (x) and d R (x) are the left and right child nodes, respectively, for the given split position x. For large nodes, the hybrid scheme of spatial median splitting and empty space splitting is still employed. However, a different switch threshold C e = 10% is used. We also use a smaller threshold for large/small node classification, T = 32, since exact VVH cost evaluation is more expensive than SAH cost evaluation as we discovered through experiments. The second modification is that, unlike in ray tracing, photon kdtrees are built for points instead of triangles. Thus we do not need to compute AABBs in the initialization stage. Clipping to split planes is no longer required for large nodes. Splitting planes are restricted to initial point positions for small nodes. Most computation can be directly parallelized over all points in large nodes, and the chunk data structure is no longer necessary. As in [Wald et al. 2004], in the initialization stage, for each of the three axis dimensions, we compute and maintain a sorted order for all points using a sort primitive cudppSort [Harris et al. 2007]. With the sorted order, tight bounding boxes of large nodes can be computed in O(1) time, avoiding the use of segmented reductions. This compensates for the overhead of computing and maintaining the sorted order. Also sorting points to child nodes and counting point numbers for child nodes can be done in O(n) time with a single pass over the sorted data. We store point-sorted order for all nodes in three concatenated point ID lists, one for each axis. To allow efficient per-node access of these lists, we enforce two properties: 1) points in the same node are contiguous in the lists; 2) points in the same node start at the same offset in three lists. Such properties allow an arbitrary sub-list for each individual node to be indexed using a head pointer and a tail pointer. After node splitting, we perform the split operation of [Sengupta et al. 2007] on the concatenated lists to separate points of left child nodes and points of right child nodes. It is easy to verify that the resulting new lists inherit the two aforementioned properties. Algorithm 6 KNN Search function K NN S EARCH (in q:point) begin r min ? 0 r max ? r 0 hist ?new array[0.. n hist ? 1] for i = 1 to n iter r ? r max ? r ? r max ? r min Set all elements in hist to zero for each photon p, p ? q < r, via range search Increment hist[? max{ p?q ? r ?r min ,0} n hist ?] Find j, such that hist[j] < k ? hist[j + 1] (r min , r max ) ? (r min + n hist j ? r , r min + n j+1 hist ? r ) r k ? r max return all photons p, p ? q < r k , via range search end\n        The sorted order is also used to accelerate the computation in P REPROCESS S MALL N ODES in the small node stage. However, the bit mask representation and bitwise operations for small nodes are still employed for both performance and storage efficiency. As in Section 3.3, we reorganize all nodes using a preorder traversal. Each node in the resulting node lists records the number and indices of the photons it contains, its splitting plane, the links to its children, and its bounding box. As described in [Jensen 2001], to estimate the radiance at a surface point, the k-nearest photons need to be located and filtered. Efficiently locating the nearest photons is critical for good performance of photon mapping. The photon kd-tree built in the last subsection can be used to speed up nearest neighbor queries. A natural choice to locate the nearest neighbors in a kd-tree is the priority queue method described in [Jensen 2001]. Although it is possible to implement a priority queue using CUDA?s threadlocal memory, such an implementation would be inefficient because CUDA?s local memory requires both pipelining with sufficient amount of independent arithmetic for efficient latency hiding and a thread-wise coherent access pattern [ NVIDIA 2007 ]. In priority queue operations, almost all memory accesses and arithmetic are inter-dependent. It is difficult for the hardware to hide memory latency. Thread-wise coherence is also problematic since photon distribution is usually highly irregular. We instead propose an iterative KNN search algorithm based on range searching [Preparata and Shamos 1985]. As shown in Algorithm 6, the algorithm starts from an initial conservative search radius r 0 , and tries to find the KNN query radius r k through a few iterations. During each iteration, a fixed-radius range search is performed to construct hist, a histogram of photon numbers over radius ranges. The search radius is then reduced according to the histogram. Finally, all photons within radius r k are returned. There are three parameters in Algorithm 6: r 0 , n hist and n iter . r 0 is an initial search radius. On the one hand, it should be conservative such that there are at least k photons within this radius. On the other hand, it should be as tight as possible to limit the search range. A good estimation of r 0 is critical to the performance of KNN search. In Appendix A, we elaborate on the details of r 0 estimation. n hist is the size of the histogram array. It controls the precision gain in each iteration. As hist requires frequent random updates, we store it in CUDA?s shared memory. A larger n hist increases the precision of each iteration while decreasing GPU occupancy. We find n hist = 32 to be a reasonable balance point. n iter is the number of iterations. Currently, we take n iter = 2. The resulting error in the final KNN radius is less than 0.1%. Range searching is performed using the standard DFS kd-tree traversal algorithm [Preparata and Shamos 1985]. Like stack-based kd-tree traversal in GPU ray tracing, this algorithm can be efficiently implemented using CUDA?s local memory. As a sample application of the photon kd-tree and KNN search, we develop a photon mapping system for rendering realistic caustics on the GPU. Before building the tree, photons must be emitted into the scene. The process of tracing eye rays and tracing photons from a light source is very similar. The GPU ray tracer described in Section 4 can be easily adapted for photon tracing. The main difference is that the interaction of a photon with a surface material is different from that of a ray. When a photon hits a surface, it can either be reflected, transmitted, or absorbed based on the surface material. Since we only trace caustic photons, a photon will be terminated and stored once it hits a diffuse surface. Our current system supports only point light sources. Photons are emitted randomly using a projection map [Jensen 2001]. For caustic rendering, only specular and refractive objects are identified in the projection map. Once photon tracing is done, a kd-tree is built for all stored photons. Caustics are then rendered by tracing eye rays. For each ray, at its first intersection with a diffuse surface, KNN search is performed to locate the nearest photons, which are then filtered to get the radiance value. Experimental Results Fig. 7(a) shows a cardioid-shaped caustic formed on the table due to light reflected inside a metal ring. We traced 200K photons in total and the 50 nearest photons were queried in the radiance estimate. Both the lighting and the surface material can be changed on the fly. Please see the accompanying video for live demos. Combined with our GPU ray tracer in Section 4, we even allow the user to change the scene geometry. In this case, two kd-trees need to be built on the fly: one for the scene geometry and the other for the photons. Fig. 7(b) demonstrates the caustic from a glass of champagne. The caustic is formed as light is refracted through several layers of glass and champagne. We use six bounces of refraction in photon tracing. In total 400K photons were traced and k is set to 40 in KNN search. Again, both the lighting and scene geometry can be changed. Table 5 summarizes the times for photon kd-tree construction and KNN search, using both CPU and GPU algorithms. The CPU KNN search is based on the priority queue method described in [Jensen 2001]. Overall, both our GPU kd-tree builder and KNN search are around 10 times faster than the CPU algorithms. We have presented a kd-tree algorithm capable of achieving realtime performance on the GPU. The algorithm builds kd-trees in BFS order to exploit the large scale parallelism of modern GPUs. The constructed kd-trees are of comparable quality as those built by off-line CPU algorithms. We also demonstrated the potential of our kd-tree algorithm in three applications involving dynamic scenes: GPU ray tracing, GPU photon mapping, and point cloud modeling. There are several directions for future investigation. We plan to incorporate packets [Wald et al. 2001] into the GPU ray tracer for further performance enhancements. We also intend to implement (a) A metal ring (b) A glass of champagne Caustic rendering using photon mapping. Both scenes are lit by a point light source and rendered at image resolution 800 ? 600. (a) Cardioid-shaped caustic caused by light reflection inside a metal ring. The scene consists of 3K triangles and the rendering performance is 12.2 fps. (b) Caustics due to light refraction through several layers of glass and champagne. The scene has 19K triangles and the performance is about 7.5 fps. CPU algorithm GPU algorithm kd-tree KNN kd-tree KNN 0.081s 0.508s 0.009s 0.044s 0.237s 0.371s 0.017s 0.050s Comparing photon kd-tree construction time and KNN time between a CPU algorithm and our GPU algorithm. global photon maps on the GPU using a general photon scattering scheme based on Russian roulette. Such photon maps would allow us to render indirect illumination. Finally, we are interested in extending our kd-tree algorithm to higher dimensions for applications such as texture synthesis. The authors would like to thank Eric Stollnitz for his help with video production. We are also grateful to the reviewers for their helpful comments. As mentioned in Section 5.2, a good estimation of r 0 is critical to the performance of KNN search. Due to the irregularity of photon distributions, r 0 needs to be estimated for each KNN query point. As shown in Algorithm 7, we take a two-stage approach. First, for each rendering frame, P RECOMPUTE R ADIUS is carried out to compute KNN query radiuses for a set of node centers. This is done by running the KNN search algorithm in Algorithm 6 with parameter r 0 = R. Then, for each KNN query point p, E STIMATE R ADIUS is performed to compute p?s initial query radius from the KNN query radiuses of the nodes containing p. It can be easily proven that the resulting query radius is guaranteed to be conservative. R is a conservative estimation for r 0 . Note that photon density ? is inversely proportional to the square of KNN query radius r k . By defining a minimal physically meaningful density ? ? , a reasonably tight estimation can be be computed from R ? 1 . R is also ? ? used as the estimated query radius in VVH. C i is the center of node i?s bounding box. The node radius is computed as half of the length of the bounding box diagonal. ? and n level are two user-specified constants which determine the nodes used for radius estimation. We find that ? = 0.5 and n level = 3 work well for all examples shown in the paper. The kd-tree builder and KNN search algorithm described in Section 5 can be directly used to estimate local sampling density and normals for dynamic point clouds, as well as to update the deformation strength field in free-form deformation. Given a set of points as input, we first build a kd-tree. Unlike in photon mapping, we do not have a good estimate for the initial KNN query radiuses, R and r 0 . We thus let the user specify these parameters. Then in parallel, for each point x i , we find the k-nearest neighbors for x i using KNN search. The final query radius r i can be used to determine the local kernel size in surface splatting [Zwicker et al. 2001]. The local sampling density can be computed as ? i = k/r i 2 . To compute the normal at x i , as in [Hoppe et al. 1992], we first perform principal component analysis (PCA) on the covariance matrix of its k-nearest neighbors. The unit eigenvector n i with minimal eigenvalue is regarded as x i ?s normal. A minimum spanning tree (MST) based approach [Hoppe et al. 1992] is then used to make all point normals consistently oriented. Both the KNN search and PCA are performed on the GPU. The minimum spanning tree, however, is currently built on the CPU. In point cloud deformation tools [Pauly et al. 2003], a scalar value ranging from 0 to 1 is computed for each point to indicate the deformation strength at that point. Each point?s scalar value is decided by its distances to the current ?active? handle and other static handles. The closer a point is to the active handle, the stronger will the deformation be for that point. Each handle consists of a set of points. A point?s distance to a handle is defined as the minimal distance between the point and all points of that handle. To efficiently calculate these distances, two kd-trees are built, one for the active handle and one for all static handles. Then, for each point, its nearest neighbor in each tree is searched and the distance is computed. Therefore, when the user defines new handles or removes old handles, we need to rebuild the kd-trees and recompute the distances, which can be done efficiently using our GPU kd-tree builder and KNN search. Sampling density and normal estimation of a point cloud. From left to right: the input point cloud (127K points) rendered using surface splatting, sampling density map for the rest pose and sampling density map for a deformed pose (blue: small; red: large). Experimental Results We have implemented the described algorithm and developed a point cloud deformation tool as in [Pauly et al. 2003]. Point clouds are rendered using a GPU implementation of the surface splatting algorithm [Zwicker et al. 2001]. Please see the accompanying video for live demos. In Fig. 8 , the sampling density and normals are computed for a dynamic point cloud on the fly. With our GPU algorithm, the kdtree is built in about 21 milliseconds and KNN search (k = 10) takes about 14 milliseconds. The CPU algorithm in Pointshop3D [Zwicker et al. 2002] uses simple midpoint splitting to build kdtrees quickly. However, the tree quality is poor, resulting in very slow KNN search. For the same data, it takes about 32 milliseconds and 6.5 seconds for tree construction and KNN search respectively. We also compare our algorithm with the kd-tree algorithm in the ANN library [Mount and Arya 2006]. For the same data, it takes 98 milliseconds and 828 milliseconds for tree construction and KNN search respectively. Overall, our approach is over 20 times faster than the ANN algorithm. Note that to achieve a consistent normal orientation, a minimum spanning tree is built for the initial pose of the point cloud, on the CPU in less than 30 milliseconds. Minimum spanning trees need not be built again during deformation since we make use of temporal coherence to force the point normals of the current pose to be consistently oriented to those of the preceding pose. In the deformation example shown in Fig. 9 , we allow the user to manipulate the point cloud by defining new handles and dragging them. Our algorithm can provide immediate response to the user since the deformation strength field is computed in about 310 milliseconds, while the CPU algorithm based on ANN takes about 3 seconds, and thus provides better user experience.",
  "resources" : [ ]
}