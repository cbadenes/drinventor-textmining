{
  "uri" : "sig2008a-a126-zhou_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a126-zhou_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-Time KD-Tree Construction on Graphics Hardware",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Qiming-Hou",
      "name" : "Qiming",
      "surname" : "Hou"
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Baining-Guo",
      "name" : "Baining",
      "surname" : "Guo"
    } ]
  },
  "bagOfWords" : [ "kd-tree", "well-known", "space-partitioning", "datum", "structure", "organize", "point", "k-dimensional", "space", "acceleration", "structure", "have", "be", "use", "variety", "graphic", "application", "include", "triangle", "culling", "ray-triangle", "intersection", "test", "ray", "trace", "nearest", "photon", "query", "photon", "mapping", "nearest", "neighbor", "search", "point", "cloud", "modeling", "particle-based", "fluid", "simulation", "due", "its", "fundamental", "importance", "graphic", "fast", "kd-tree", "construction", "have", "be", "subject", "much", "interest", "recent", "year", "several", "CPU", "algorithm", "propose", "-lsb-", "Popov", "et", "al.", "2006", "Hunt", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "however", "real-time", "construction", "kd-tree", "GPU", "remain", "unsolved", "problem", "paper", "we", "present", "kd-tree", "construction", "algorithm", "GPU", "achieve", "real-time", "performance", "heavily", "exploit", "hardware", "specifically", "we", "algorithm", "build", "tree", "node", "BFS", "-lrb-", "breadth-first", "search", "-rrb-", "order", "fully", "exploit", "fine-grained", "parallelism", "modern", "gpus", "all", "stage", "kd-tree", "construction", "important", "feature", "distinguish", "we", "work", "from", "previous", "parallel", "kd-tree", "algorithm", "include", "-lsb-", "Popov", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "which", "resort", "df", "-lrb-", "depth-first", "search", "-rrb-", "node", "near", "GPU", "ray", "trace", "photon", "mapping", "dynamic", "scene", "where", "both", "scene", "geometry", "light", "source", "can", "change", "two", "kd-tree", "build", "from", "scratch", "each", "frame", "one", "scene", "geometry", "other", "photon", "shadow", "reflection/refraction", "well", "caustic", "cause", "glass", "champagne", "render", "around", "fp", "800", "600", "image", "bottom", "kd-tree", "we", "algorithm", "build", "kd-tree", "comparable", "quality", "those", "construct", "off-line", "CPU", "algorithm", "term", "speed", "we", "algorithm", "time", "faster", "than", "well-optimized", "single-core", "CPU", "algorithm", "-lsb-", "Hunt", "et", "al.", "2006", "-rsb-", "competitive", "multi-core", "CPU", "algorithm", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "design", "kd-tree", "algorithm", "GPU", "we", "must", "address", "two", "challenging", "issue", "first", "how", "maximally", "exploit", "gpu?s", "streaming", "architecture", "when", "parallelize", "kd-tree", "construction", "modern", "GPU", "massively", "parallel", "require", "10", "10", "thread", "optimal", "performance", "-lsb-", "NVIDIA", "2007", "-rsb-", "follow", "BFS", "order", "we", "well", "poise", "take", "advantage", "architecture", "because", "each", "bf", "step", "every", "node", "same", "tree", "level", "spawn", "new", "thread", "total", "number", "thread", "double", "from", "preceding", "step", "addition", "follow", "BFS", "order", "we", "also", "develop", "special", "strategy", "large", "node", "upper", "tree", "level", "so", "further", "exploit", "large", "scale", "parallelism", "gpus", "node", "we", "parallelize", "computation", "over", "all", "geometric", "primitive", "instead", "node", "each", "level", "strategy", "effective", "because", "only", "relatively", "small", "number", "large", "node", "upper", "level", "especially", "near", "top", "tree", "which", "make", "parallelizing", "over", "node", "inefficient", "leave", "massive", "parallelism", "gpus", "underexploit", "moreover", "workload", "among", "thread", "likely", "unbalanced", "because", "number", "primitive", "may", "vary", "significantly", "from", "node", "node", "another", "issue", "efficient", "calculation", "node", "split", "cost", "surface", "area", "heuristic", "-lrb-", "sah", "-rrb-", "-lsb-", "Goldsmith", "Salmon", "1987", "-rsb-", "voxel", "volume", "heuristic", "-lrb-", "vvh", "-rrb-", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "cost", "critical", "maintain", "kd-tree", "quality", "standard", "practice", "precisely", "evaluate", "cost", "all", "tree", "node", "prohibitively", "expensive", "real-time", "technique", "address", "issue", "we", "derive", "novel", "scheme", "so-called", "large", "small", "node", "node", "deem", "large", "number", "triangle", "node", "greater", "than", "user-specified", "threshold", "otherwise", "small", "-lsb-", "Popov", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "large", "node", "upper", "tree", "level", "we", "use", "two", "simple", "inexpensive", "heuristic", "median", "splitting", "empty", "space", "maximize", "-lsb-", "havran", "2001", "Wald", "Havran", "2006", "-rsb-", "estimate", "cost", "small", "node", "near", "bottom", "tree", "where", "exact", "evaluation", "cost", "necessary", "we", "introduce", "novel", "datum", "structure", "store", "geometry", "primitive", "node", "bit", "mask", "which", "allow", "we", "efficiently", "evaluate", "exact", "cost", "sort", "primitive", "use", "bitwise", "operation", "we", "real-time", "kd-tree", "construction", "provide", "general", "way", "deal", "dynamic", "scene", "GPU", "we", "demonstrate", "potential", "we", "kd-tree", "algorithm", "few", "application", "GPU", "Ray", "Tracing", "we", "implement", "GPU", "ray", "tracer", "arbitrary", "dynamic", "scene", "use", "we", "real-time", "kd-tree", "construction", "-lrb-", "section", "-rrb-", "ray", "tracer", "achieve", "interactive", "rate", "shadow", "multi-bounce", "reflection/refraction", "we", "GPU", "ray", "tracer", "can", "handle", "general", "dynamic", "scene", "outperform", "state-of-the-art", "multicore", "CPU", "ray", "tracer", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "unique", "feature", "we", "ray", "tracer", "can", "efficiently", "handle", "dynamic", "geometry", "directly", "evaluate", "GPU", "subdivision", "surface", "-lsb-", "Shiue", "et", "al.", "2005", "-rsb-", "skin", "mesh", "-lsb-", "Wang", "et", "al.", "2007", "-rsb-", "GPU", "Photon", "mapping", "we", "implement", "GPU", "photon", "mapping", "which", "photon", "trace", "photon", "kd-tree", "construction", "nearest", "photon", "query", "all", "perform", "GPU", "fly", "-lrb-", "section", "-rrb-", "combine", "we", "GPU", "ray", "tracer", "photon", "mapping", "capable", "render", "shadow", "reflection/refraction", "well", "realistic", "caustic", "dynamic", "scene", "lighting", "interactive", "rate", "single", "pc", "performance", "have", "be", "achieve", "previous", "work", "point", "cloud", "model", "we", "real-time", "kd-tree", "construction", "can", "also", "use", "dynamic", "point", "cloud", "accelerate", "nearest", "neighbor", "query", "-lrb-", "appendix", "-rrb-", "query", "neighbor", "use", "estimate", "local", "sampling", "density", "calculate", "normal", "update", "deformation", "strength", "field", "free-form", "deformation", "optimize", "Kd-trees", "Early", "research", "mainly", "focus", "optimize", "kd-tree", "triangle", "culling", "ray-triangle", "intersection", "key", "optimization", "determine", "splitting", "plane", "simple", "often-used", "method", "spatial", "median", "splitting", "which", "plane", "position", "spatial", "median", "longest", "axis", "tree", "node", "volume", "improve", "effectiveness", "researcher", "propose", "SAH", "kd-tree", "-lsb-", "Goldsmith", "Salmon", "1987", "MacDonald", "Booth", "1990", "Havran", "2001", "-rsb-", "fact", "appearance", "kd-tree", "base", "packet", "trace", "-lsb-", "Wald", "et", "al.", "2001", "-rsb-", "frustum", "traversal", "-lsb-", "Reshetov", "et", "al.", "2005", "-rsb-", "SAH", "kd-tree", "have", "become", "best", "know", "acceleration", "structure", "ray", "trace", "static", "scene", "-lsb-", "Stoll", "2005", "-rsb-", "other", "application", "photon", "mapping", "kd-tree", "mainly", "use", "accelerate", "nearest", "neighbor", "query", "which", "different", "heuristic", "employ", "achieve", "better", "efficiency", "example", "vvh", "kd-tree", "can", "better", "accelerate", "photon", "gathering", "process", "than", "left-balanced", "tree", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "fast", "kd-tree", "construction", "construction", "high", "quality", "kd-tree", "expensive", "due", "evaluation", "SAH", "cost", "function", "although", "-lrb-", "log", "-rrb-", "construction", "algorithm", "exist", "-lsb-", "Wald", "Havran", "2006", "-rsb-", "time", "need", "large", "animated", "scene", "still", "too", "high", "allow", "tradeoff", "between", "tree", "quality", "construction", "speed", "fast", "kd-tree", "algorithm", "-lsb-", "Popov", "et", "al.", "2006", "Hunt", "et", "al.", "2006", "-rsb-", "approximate", "SAH", "use", "piecewise", "linear", "-lrb-", "quadric", "-rrb-", "function", "-lsb-", "Popov", "et", "al.", "2006", "-rsb-", "also", "propose", "parallel", "algorithm", "construct", "tree", "BFS", "order", "up", "certain", "tree", "level", "however", "goal", "increase", "coherence", "memory", "access", "during", "tree", "construction", "target", "small", "scale", "parallel", "architecture", "like", "multi-core", "cpus", "node", "near", "bottom", "tree", "df", "order", "use", "which", "difficult", "parallelize", "consume", "90", "construction", "time", "base", "report", "timing", "multi-core", "algorithm", "-lsb-", "Popov", "et", "al.", "2006", "-rsb-", "about", "order", "magnitude", "slower", "than", "we", "kd-tree", "algorithm", "tree", "comparable", "quality", "algorithm", "-lsb-", "Hunt", "et", "al.", "2006", "-rsb-", "about", "time", "slower", "than", "we", "algorithm", "Shevstov", "et", "al.", "-lsb-", "2007", "-rsb-", "propose", "parallel", "kd-tree", "algorithm", "share", "memory", "architecture", "multi-core", "cpus", "algorithm", "first", "partition", "space", "several", "balanced", "sub-region", "build", "sub-tree", "each", "sub-region", "parallel", "df", "order", "algorithm", "can", "map", "well", "GPU", "architecture", "because", "modern", "gpus", "require", "10", "10", "thread", "optimal", "performance", "-lsb-", "NVIDIA", "2007", "-rsb-", "order", "magnitude", "greater", "than", "possible", "thread", "number", "multi-core", "cpus", "-lrb-", "e.g.", "four", "thread", "test", "paper", "-rrb-", "another", "problem", "method", "note", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "kd-tree", "construct", "approximately", "half", "quality", "those", "produce", "off-line", "kd-tree", "builder", "ray-tracing", "identical", "dynamic", "scene", "performance", "lower", "than", "we", "GPU", "ray", "tracer", "Ray", "Tracing", "GPUs", "Ray", "trace", "gpus", "have", "stimulate", "much", "interest", "recently", "-lsb-", "Carr", "et", "al.", "2002", "-rsb-", "implement", "ray-triangle", "intersection", "GPU", "-lsb-", "Purcell", "et", "al.", "2002", "-rsb-", "design", "first", "ray", "tracer", "run", "entirely", "GPU", "employ", "uniform", "grid", "acceleration", "-lsb-", "Foley", "Sugerman", "2005", "-rsb-", "introduce", "two", "stackless", "kd-tree", "traversal", "algorithm", "which", "outperform", "uniform", "grid", "approach", "-lsb-", "Carr", "et", "al.", "2006", "-rsb-", "implement", "limited", "GPU", "ray", "tracer", "dynamic", "geometry", "base", "bounding-volume", "hierarchy", "geometry", "image", "none", "above", "GPU", "ray", "tracer", "outperform", "well-optimized", "CPU", "ray", "tracer", "recently", "two", "technique", "-lsb-", "Horn", "et", "al.", "2007", "Popov", "et", "al.", "2007", "-rsb-", "achieve", "better", "performance", "than", "CPU", "ray", "tracer", "both", "technique", "use", "stackless", "kd-tree", "traversal", "packet", "trace", "unfortunately", "two", "technique", "work", "static", "scene", "only", "dynamic", "scene", "most", "exist", "method", "cpu-based", "-lrb-", "e.g.", "-lsb-", "Wald", "et", "al.", "2006", "Yoon", "et", "al.", "2007", "-rsb-", "-rrb-", "we", "work", "lead", "GPU", "ray", "tracer", "general", "dynamic", "scene", "outperform", "state-of-the-art", "multi-core", "CPU", "ray", "tracer", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "Photon", "mapping", "have", "be", "implement", "gpus", "-lsb-", "Purcell", "et", "al.", "2003", "-rsb-", "uniform", "grid", "instead", "kd-tree", "use", "store", "photon", "greatly", "degrade", "performance", "nearest", "photon", "query", "-lsb-", "g?nther", "et", "al.", "2004", "-rsb-", "present", "framework", "real-time", "distribute", "photon", "mapping", "use", "36", "cpus", "achieve", "frame", "rate", "up", "22", "fp", "image", "resolution", "640", "480", "far", "we", "know", "kd-tree", "base", "photon", "mapping", "algorithm", "have", "be", "implement", "GPU" ],
  "content" : "The kd-tree is a well-known space-partitioning data structure for organizing points in k-dimensional space. As an acceleration structure, it has been used in a variety of graphics applications, including triangle culling for ray-triangle intersection tests in ray tracing, nearest photon queries in photon mapping, and nearest neighbor search in point cloud modeling and particle-based fluid simulation. Due to its fundamental importance in graphics, fast kd-tree construction has been a subject of much interest in recent years, with several CPU algorithms proposed [Popov et al. 2006; Hunt et al. 2006; Shevtsov et al. 2007]. However, real-time construction of kd-trees on the GPU remains an unsolved problem. In this paper, we present a kd-tree construction algorithm for the GPU that achieves real-time performance by heavily exploiting the hardware. Specifically, our algorithm builds tree nodes in BFS (breadth-first search) order to fully exploit the fine-grained parallelism of modern GPUs at all stages of kd-tree construction. This is an important feature that distinguishes our work from previous parallel kd-tree algorithms including [Popov et al. 2006; Shevtsov et al. 2007], which resort to DFS (depth-first search) for nodes near the GPU ray tracing and photon mapping for a dynamic scene, where both the scene geometry and the light source can be changed. Two kd-trees are built from scratch for each frame, one for the scene geometry and the other for the photons. Shadows, reflection/refraction, as well as caustics caused by the glass and champagne are rendered at around 8 fps for 800 ? 600 images. bottom of the kd-tree. Our algorithm builds kd-trees of comparable quality as those constructed by off-line CPU algorithms. In terms of speed, our algorithm is 4 ? 7 times faster than well-optimized single-core CPU algorithms [Hunt et al. 2006] and competitive with multi-core CPU algorithms [Shevtsov et al. 2007]. In designing a kd-tree algorithm for the GPU, we must address two challenging issues. The first is how to maximally exploit the GPU?s streaming architecture when parallelizing kd-tree construction. The modern GPU is massively parallel and requires 10 3 ? 10 4 threads for optimal performance [ NVIDIA 2007 ]. By following BFS order, we are well poised to take advantage of this architecture because at each BFS step, every node at the same tree level spawns a new thread and the total number of threads doubles from the preceding step. In addition to following BFS order, we also develop a special strategy for large nodes at upper tree levels so as to further exploit the the large scale parallelism of GPUs. For these nodes, we parallelize the computation over all geometric primitives instead of nodes at each level. This strategy is effective because there are only a relatively small number of large nodes at the upper levels, especially near the top of the tree, which makes parallelizing over nodes inefficient and leaves the massive parallelism of GPUs underexploited. Moreover, the workload among threads is likely to be unbalanced because the number of primitives may vary significantly from node to node. Another issue is the efficient calculation of node split costs, such as the surface area heuristic (SAH) [Goldsmith and Salmon 1987] and voxel volume heuristic (VVH) [Wald et al. 2004] costs. This is critical for maintaining kd-tree quality. The standard practice of precisely evaluating the costs for all tree nodes is prohibitively expensive for real-time techniques. To address this issue, we derive novel schemes for the so-called large and small nodes. A node is deemed as large if the number of triangles in the node is greater than a user-specified threshold; otherwise it is small [Popov et al. 2006; Shevtsov et al. 2007]. For large nodes at upper tree levels, we use two simple and inexpensive heuristics, median splitting and ?empty space maximizing? [Havran 2001; Wald and Havran 2006], to estimate the costs. For small nodes near the bottom of the tree, where exact evaluation of the costs is necessary, we introduce a novel data structure for storing the geometry primitives in these nodes as bit masks, which allows us to efficiently evaluate the exact costs and sort these primitives using bitwise operations. Our real-time kd-tree construction provides a general way of dealing with dynamic scenes on the GPU. We demonstrate the potential of our kd-tree algorithm with a few applications: GPU Ray Tracing We implemented a GPU ray tracer for arbitrary dynamic scenes using our real-time kd-tree construction (Section 4). The ray tracer achieves interactive rates with shadow and multi-bounce reflection/refraction. Our GPU ray tracer can handle general dynamic scenes and outperforms a state-of-the-art multicore CPU ray tracer [Shevtsov et al. 2007]. A unique feature of our ray tracer is that it can efficiently handle dynamic geometries that are directly evaluated on the GPU, such as subdivision surfaces [Shiue et al. 2005] and skinned meshes [Wang et al. 2007]. GPU Photon Mapping We implemented GPU photon mapping, in which photon tracing, photon kd-tree construction and nearest photon query are all performed on the GPU on the fly (Section 5). Combined with our GPU ray tracer, the photon mapping is capable of rendering shadows, reflection/refraction, as well as realistic caustics for dynamic scenes and lighting at interactive rates on a single PC. Such performance has not been achieved in previous work. Point Cloud Modeling Our real-time kd-tree construction can also be used for dynamic point clouds to accelerate nearest neighbor queries (Appendix B). The queried neighbors are used for estimating local sampling densities, calculating the normals and updating the deformation strength field in free-form deformation. Optimized Kd-trees Early research mainly focused on optimizing kd-trees for triangle culling in ray-triangle intersection. The key for this optimization is determining the splitting plane. A simple but often-used method is spatial median splitting, in which the plane is positioned at the spatial median of the longest axis of the tree node volume. To improve effectiveness, researchers proposed SAH kd-trees [Goldsmith and Salmon 1987; MacDonald and Booth 1990; Havran 2001]. In fact, with the appearance of kd-tree based packet tracing [Wald et al. 2001] and frustum traversal [Reshetov et al. 2005], SAH kd-trees have become the best known acceleration structures for ray tracing of static scenes [Stoll 2005]. In other applications such as photon mapping, kd-trees are mainly used to accelerate nearest neighbor queries, for which different heuristics are employed to achieve better efficiency. For example, VVH kd-trees can better accelerate the photon gathering process than left-balanced trees [Wald et al. 2004]. Fast Kd-tree Construction Construction of high quality kd-trees is expensive due to the evaluation of the SAH cost function. Although an O(n log n) construction algorithm exists [Wald and Havran 2006], the time needed for large animated scenes is still too high. To allow a tradeoff between tree quality and construction speed, fast kd-tree algorithms [Popov et al. 2006; Hunt et al. 2006] approximate SAH using a piecewise linear (or quadric) function. [Popov et al. 2006] also proposed a parallel algorithm by constructing the tree in BFS order up to a certain tree level. However, their goal is to increase the coherence of memory accesses during tree construction and targets small scale parallel architectures like multi-core CPUs. For nodes near the bottom of the tree, DFS order  is used, which is difficult to parallelize and consumes 90% of the construction time. Based on reported timings, the multi-core algorithm in [Popov et al. 2006] is about an order of magnitude slower than our kd-tree algorithm. For trees of comparable quality, the algorithm in [Hunt et al. 2006] is about 4 ? 7 times slower than our algorithm. Shevstov et al. [2007] proposed a parallel kd-tree algorithm for a shared memory architecture with multi-core CPUs. The algorithm first partitions the space into several balanced sub-regions and then builds a sub-tree for each sub-region in parallel and in DFS order. The algorithm cannot be mapped well to GPU architecture because modern GPUs require 10 3 ? 10 4 threads for optimal performance [ NVIDIA 2007 ], orders of magnitude greater than the possible thread number on multi-core CPUs (e.g., four threads tested in the paper). Another problem with this method is that, as noted in [Shevtsov et al. 2007], the kd-trees constructed are of approximately half the quality of those produced by off-line kd-tree builders. For ray-tracing identical dynamic scenes, their performance is lower than our GPU ray tracer. Ray Tracing on GPUs Ray tracing on GPUs has stimulated much interest recently. [Carr et al. 2002] implemented ray-triangle intersection on the GPU. [Purcell et al. 2002] designed the first ray tracer that runs entirely on the GPU, employing a uniform grid for acceleration. [Foley and Sugerman 2005] introduced two stackless kd-tree traversal algorithms, which outperform the uniform grid approach. [Carr et al. 2006] implemented a limited GPU ray tracer for dynamic geometry based on bounding-volume hierarchies and geometry images. None of the above GPU ray tracers outperforms a well-optimized CPU ray tracer. Recently, two techniques [Horn et al. 2007; Popov et al. 2007] achieved better performance than CPU ray tracers. Both techniques use stackless kd-tree traversal and packet tracing. Unfortunately these two techniques work for static scenes only. For dynamic scenes, most existing methods are CPU-based (e.g., [Wald et al. 2006; Yoon et al. 2007]). Our work leads to a GPU ray tracer for general dynamic scenes that outperforms a state-of-the-art multi-core CPU ray tracer [Shevtsov et al. 2007]. Photon mapping has been implemented on GPUs [Purcell et al. 2003]. A uniform grid, instead of a kd-tree, is used to store the photons, greatly degrading the performance of nearest photon queries. [G?nther et al. 2004] presented a framework for real-time distributed photon mapping. Using 9 to 36 CPUs, they achieved frame rates of up to 22 fps at the image resolution of 640 ? 480. As far as we know, kd-tree based photon mapping algorithms have not been implemented on the GPU.",
  "resources" : [ ]
}