{
  "uri" : "sig2008a-a144-sander_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a144-sander_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Efficient Traversal of Mesh Edges using Adjacency Primitives",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Eden-Chlamtac",
      "name" : "Eden",
      "surname" : "Chlamtac"
    }, {
      "uri" : "http://drinventor/Hugues-Hoppe",
      "name" : "Hugues",
      "surname" : "Hoppe"
    } ]
  },
  "bagOfWords" : [ "triangle", "widespread", "rasterization", "primitive", "so", "large", "body", "work", "optimize", "traversal", "triangle", "mesh", "efficient", "render", "e.g.", "use", "triangle", "strip", "-lsb-", "Evans", "et", "al.", "1996", "Xiang", "et", "al.", "1999", "Estkowski", "et", "al.", "2002", "-rsb-", "manage", "vertex", "buffer", "-lsb-", "deer", "1995", "Chow", "1997", "-rsb-", "index", "strip", "vertex", "caching", "-lsb-", "hoppe", "1999", "Lin", "Yu", "2006", "Sander", "et", "al.", "2007", "Chhugani", "Kumar", "2007", "-rsb-", "most", "technique", "process", "edge", "require", "access", "its", "two", "adjacent", "face", "have", "motivate", "introduction", "adjacency", "primitive", "latest", "graphic", "system", "-lsb-", "Blythe", "2006", "-rsb-", "primitive", "process", "new", "programmable", "unit", "graphic", "pipeline", "geometry", "shader", "which", "read", "primitive", "perform", "computation", "emit", "variable", "number", "new", "primitive", "approach", "we", "basic", "strategy", "traverse", "mesh", "use", "list", "triangle-with-adjacency", "primitive", "nevertheless", "because", "most", "triangles-with-adjacency", "primitive", "encode", "two", "face", "index", "buffer", "contain", "only", "about", "index", "per", "mesh", "triangle", "-lrb-", "one", "primitive", "every", "mesh", "triangle", "index", "per", "primitive", "-rrb-", "therefore", "have", "approximately", "same", "memory", "cost", "widely", "use", "index", "triangle", "list", "representation", "contribution", "construction", "minimize", "number", "adjacency", "primitive", "need", "processing", "mesh", "-lrb-", "section", "-rrb-", "accurate", "lower", "bind", "algorithm", "confirm", "quality", "minimization", "-lrb-", "appendix", "-rrb-", "construction", "allow", "reduce", "set", "primitive", "process", "all", "mesh", "retain", "simd", "efficiency", "-lrb-", "section", "-rrb-", "first", "modify", "algorithm", "perform", "vertex", "cache", "optimization", "list", "triangles-with-adjacency", "-lrb-", "section", "-rrb-", "some", "related", "technique", "GPU", "rendering", "silhouette", "fin", "also", "introduce", "degenerate", "quadrilateral", "edge", "-lsb-", "card", "Mitchell", "2002", "McGuire", "Hughes", "2004", "-rsb-", "therefore", "also", "require", "memory", "buffer", "many", "additional", "vertex", "face", "triangle", "mesh", "-lrb-", "-rrb-", "define", "set", "vertex", "edge", "triangle", "set", "contain", "all", "edge", "define", "triangle", "general", "set", "vertex", "may", "adjacent", "mesh", "boundary", "must", "therefore", "part", "cover", "note", "cover", "also", "minimal", "since", "every", "need", "cover", "corresponding", "boundary", "edge", "minimality", "can", "remove", "without", "expose", "internal", "edge", "several", "recent", "stochastic", "algorithm", "address", "related", "problem", "compute", "approximation", "minimal", "vertex", "cover", "maximum", "clique", "maximum", "independent", "set", "large", "graph", "-lsb-", "Grosso", "et", "al.", "2007", "Andrade", "et", "al.", "2008", "-rsb-", "fact", "since", "lower", "bind", "tight", "cover", "may", "closer", "optimal", "than", "suggest", "number", "note", "however", "whenever", "-lcb-", "-rcb-", "boundary", "edge", "face", "-lcb-", "-rcb-", "make", "degenerate", "edge", "-lcb-", "-rcb-", "also", "become", "degenerate", "can", "process", "current", "primitive", "idea", "reordering", "primitive", "efficient", "GPU", "traversal", "new", "have", "previously", "be", "limit", "triangle", "primitive", "Motion", "blur", "Wloka", "Zeleznik", "-lsb-", "1996", "-rsb-", "describe", "real-time", "technique", "approximate", "blur", "cause", "motion", "object", "relative", "viewer" ],
  "content" : "Triangles are a widespread rasterization primitive, so there is a large body of work on optimizing the traversal of triangle meshes for efficient rendering, e.g. using triangle strips [Evans et al. 1996; Xiang et al. 1999; Estkowski et al. 2002], managed vertex buffers [Deering 1995; Chow 1997], and indexed strips with vertex caching [Hoppe 1999; Lin and Yu 2006; Sander et al. 2007; Chhugani and Kumar 2007]. In most techniques, processing an edge requires access to its two adjacent faces. This has motivated the introduction of adjacency primitives in the latest graphics systems [Blythe 2006]. The primitives are processed in a new programmable unit of the graphics pipeline, the geometry shader, which reads a primitive, performs computation, and emits a variable number of new primitives. Approach Our basic strategy is to traverse the mesh using a list of triangle-with-adjacency primitives. Nevertheless, because most triangles-with-adjacency primitives encode two faces, the index buffer contains only about 3 indices per mesh triangle (one primitive for every 2 mesh triangles, 6 indices per primitive), and therefore has approximately the same memory cost as the widely used indexed triangle list representation. Contributions: ? A construction that minimizes the number of adjacency primitives needed for the processing of mesh (Section 4); ? An accurate lower bound algorithm that confirms the quality of this minimization (Appendix); ? A construction that allows this reduced set of primitives to process all mesh retaining SIMD efficiency (Section 5); ? The first modified algorithms that perform vertex cache optimization on lists of triangles-with-adjacency (Section 6). Some related techniques for GPU rendering of silhouettes or fins also introduce degenerate quadrilaterals on edges [Card and Mitchell 2002; McGuire and Hughes 2004], and therefore also require memory buffers with many additional vertices and faces. A triangle mesh M (V, E, T ) is defined by a set of vertices V , edges E, and triangles T . The set E contains all edges defined by the triangles in T . In general, a set of vertices B ? V may be adjacent to the mesh boundary, and must therefore be part of the cover. Note that the cover C is also minimal, since every v ? B is needed to cover a corresponding boundary edge, and by minimality of C ? , no v ? C ? can be removed without exposing an internal edge in G ? . Several recent stochastic algorithms address the related problems of computing approximations to minimal vertex covers, maximum cliques, or maximum independent sets on large graphs [Grosso et al. 2007; Andrade et al. 2008]. In fact, since the lower bound is not tight, the covers may be closer to optimal than suggested by these numbers. Note, however, that whenever {0, 2} is not a boundary edge and face {0, 1, 2} is made degenerate, edge {0, 2} also becomes degenerate and cannot be processed by the current primitive. The idea of reordering primitives for efficient GPU traversal is not new, but has previously been limited to triangle primitives. Motion blur Wloka and Zeleznik [1996] describe a real-time technique to approximate the blur caused by the motion of an object relative to the viewer.",
  "resources" : [ ]
}