{
  "uri" : "sig2009a-a107-rosenberger_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009a/a107-rosenberger_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Layered Shape Synthesis: Automatic Generation of Control Maps for Non-Stationary Textures",
    "published" : "2009",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Amir-Rosenberger",
      "name" : "Amir",
      "surname" : "Rosenberger"
    }, {
      "uri" : "http://drinventor/Daniel-Cohen-Or",
      "name" : "Daniel",
      "surname" : "Cohen-Or"
    }, {
      "uri" : "http://drinventor/Dani-Lischinski",
      "name" : "Dani",
      "surname" : "Lischinski"
    } ]
  },
  "bagOfWords" : [ "we", "approach", "begin", "decompose", "input", "exemplar", "number", "layer", "which", "we", "order", "bottom", "top", "once", "new", "layer", "available", "texture", "transfer", "process", "base", "texture-by-number", "-lsb-", "Hertzmann", "et", "al.", "2001", "-rsb-", "invoke", "result", "final", "output", "texture", "result", "show", "Figure", "non-parametric", "method", "have", "demonstrate", "ability", "handle", "wider", "variety", "texture", "grow", "texture", "one", "pixel/patch", "time", "optimization-based", "method", "evolve", "texture", "whole", "further", "improve", "quality", "result", "make", "synthesis", "more", "controllable", "texture-by-numbers", "-lsb-", "Hertzmann", "et", "al.", "2001", "-rsb-", "extend", "idea", "further", "augment", "input", "exemplar", "label", "map", "where", "region", "distinct", "texture", "distinguish", "different", "label", "suitable", "label", "map", "may", "paint", "manually", "user", "create", "automatically", "use", "unsupervised", "image", "segmentation", "synthesize", "new", "image", "target", "label", "map", "provide", "which", "indicate", "how", "different", "texture", "should", "arrange", "result", "image", "many", "other", "work", "since", "make", "use", "control", "map", "when", "synthesize", "non-stationary", "texture", "example", "-lsb-", "Zhang", "et", "al.", "2003", "Wang", "et", "al.", "2006", "Gu", "et", "al.", "2006", "Lu", "et", "al.", "2007", "Wei", "et", "al.", "2008", "-rsb-", "however", "all", "work", "control", "map", "target", "texture", "either", "provide", "user", "derive", "from", "specific", "model", "texture", "formation", "across", "3d", "surface", "-lrb-", "e.g.", "-lsb-", "Lu", "et", "al.", "2007", "-rsb-", "-rrb-", "we", "aware", "any", "previous", "attempt", "example-based", "control", "map", "generation", "we", "shape", "synthesis", "approach", "relate", "texture", "optimization", "technique", "-lsb-", "Wexler", "et", "al.", "2004", "Kwatra", "et", "al.", "2005", "-rsb-", "which", "synthe", "size", "texture", "minimize", "texture", "energy", "function", "contrast", "we", "perform", "shape", "synthesis", "bidirectional", "similarity", "measure", "-lrb-", "inspire", "Simakov", "et", "al.", "-lsb-", "2008", "-rsb-", "Wei", "et", "al.", "-lsb-", "Wei", "et", "al.", "2008", "-rsb-", "-rrb-", "demonstrate", "more", "faithful", "reproduction", "appearance", "comparison", "we", "present", "section", "appearance-space", "texture", "synthesis", "-lsb-", "Lefebvre", "Hoppe", "2006", "-rsb-", "another", "optimization", "method", "operate", "feature", "space", "rather", "than", "use", "value", "pixel", "small", "patch", "directly", "layer", "map", "we", "associate", "input", "exemplar", "we", "approach", "could", "view", "feature", "space", "custom-tailored", "synthesis", "layered", "inhomogeneous", "texture", "variety", "method", "generate", "texture", "weathered", "surface", "assume", "simulate", "physical", "model", "-lsb-", "dorsey", "Hanrahan", "1996", "Dorsey", "et", "al.", "1999", "Merillou", "et", "al.", "2001", "Bosch", "et", "al.", "2004", "Desbenoit", "et", "al.", "2004", "Dorsey", "et", "al.", "2008", "-rsb-", "contrast", "we", "approach", "example-based", "rather", "than", "physicallybased", "we", "approach", "synthesize", "boundary", "layer", "shape", "example", "thus", "related", "Curve", "Analogies", "work", "Hertzmann", "et", "al.", "-lsb-", "2002", "-rsb-", "where", "similar", "framework", "apply", "reproduce", "style", "curved", "shape", "however", "we", "work", "use", "different", "similarity", "measure", "operate", "discrete", "patch-based", "representation", "shape?s", "boundary", "rather", "than", "vector-based", "representation", "layer", "map", "image", "where", "different", "pixel", "value", "indicate", "different", "layer", "let", "value", "layer", "map", "pixel", "sort", "ascend", "order", "note", "pixel", "value", "actually", "belong", "all", "layer", "...", "each", "layer", "have", "associated", "foreground", "shape", "which", "we", "encode", "binary", "image", "same", "dimension", "layer", "map", "note", "shape", "+1", "always", "contain", "may", "see", "figure", "boundary", "nested", "shape", "highly", "correlate", "align", "give", "set", "shape", "we", "goal", "synthesize", "new", "set", "shape", "while", "maintain", "both", "global", "local", "similarity", "original", "one", "purpose", "important", "each", "shape", "occupy", "same", "relative", "amount", "pixel", "synthesize", "map", "do", "exemplar", "boundary", "synthesize", "shape", "locally", "resemble", "those", "exemplar", "we", "find", "represent", "shape", "means", "its", "boundary", "curve", "fail", "capture", "all", "relevant", "information", "instead", "we", "represent", "binary", "shape", "collection", "patch", "center", "shape?s", "boundary", "pixel", "-lrb-", "multiple", "resolution", "-rrb-", "order", "capture", "necessary", "shape", "property", "we", "shape", "synthesis", "approach", "employ", "optimization", "similarly", "-lsb-", "Wexler", "et", "al.", "2004", "Kwatra", "et", "al.", "2005", "-rsb-", "where", "synthesize", "result", "iteratively", "optimize", "respect", "some", "measure", "its", "similarity", "exemplar", "we", "begin", "derive", "suitable", "bidirectional", "shape", "similarity", "measure", "similarly", "Simakov", "et", "al.", "-lsb-", "2008", "-rsb-", "Wei", "et", "al.", "-lsb-", "2008", "-rsb-", "next", "we", "describe", "novel", "greedy", "optimization", "scheme", "iteratively", "modify", "initial", "shape", "so", "increase", "its", "similarity", "give", "exemplar", "shape", "finally", "we", "discuss", "how", "mechanism", "use", "create", "entire", "new", "layer", "map", "which", "sequence", "nested", "shape", "from", "layer", "map", "produce", "layer", "decomposition", "phase", "describe", "previous", "section", "let", "set", "boundary", "pixel", "shape", "respectfully", "boundary", "pixel", "pixel", "inside", "shape", "least", "one", "its", "4-neighbor", "outside", "shape", "let", "two", "boundary", "pixel", "let", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "neighborhood", "center", "around", "they", "rotate", "-lcb-", "90", "180", "270", "-rcb-", "we", "refer", "neighborhood", "boundary", "patch", "we", "define", "similarity", "between", "two", "boundary", "pixel", "distance", "between", "neighborhood", "-lrb-", "rotate", "distance", "minimize", "-rrb-", "since", "we", "deal", "binary", "image", "norm", "above", "simply", "number", "different", "pixel", "between", "two", "patch", "next", "we", "define", "local", "similarity", "between", "boundary", "pixel", "boundary", "-lrb-", "another", "-rrb-", "shape", "similarity", "between", "pixel", "most", "similar", "boundary", "note", "similarity", "measure", "symmetric", "while", "ensure", "every", "boundary", "patch", "similar", "boundary", "patch", "discard", "assign", "another", "patch", "future", "iteration", "-lrb-", "yellow", "arrow", "-rrb-", "may", "boundary", "patch", "well", "represent", "example", "simple", "shape", "may", "deem", "similar", "more", "complex", "one", "also", "happen", "contain", "some", "simple", "feature", "thus", "we", "require", "bidirectional", "similarity", "measure", "define", "which", "average", "number", "different", "pixel", "between", "boundary", "patch", "one", "shape", "its", "nearest", "neighbor", "other", "figure", "show", "several", "different", "shape", "report", "pairwise", "bidirectional", "similarity", "arm", "similarity", "measure", "above", "we", "use", "optimization", "procedure", "iteratively", "modify", "boundary", "synthesize", "shape", "make", "more", "similar", "exemplar", "shape", "optimization", "proceed", "from", "coarse", "fine", "resolution", "each", "resolution", "we", "alternate", "between", "two", "main", "step", "-lrb-", "-rrb-", "match", "each", "boundary", "patch", "boundary", "patch", "-lrb-", "ii", "-rrb-", "modify", "add", "remove", "pixel", "base", "result", "match", "achieve", "previous", "step", "iterative", "optimization", "procedure", "resemble", "Kwatra", "et", "al.", "-lsb-", "2005", "-rsb-", "each", "two", "main", "step", "differ", "significantly", "from", "its", "counterpart", "because", "we", "minimize", "different", "-lrb-", "bidirectional", "-rrb-", "energy", "function", "work", "binary", "image", "rather", "than", "texture", "two", "step", "discuss", "more", "detail", "below", "boundary", "patch", "matching", "solve", "problem", "exactly", "too", "expensive", "we", "purpose", "-lrb-", "-lrb-", "-rrb-", "where", "number", "patch", "-rrb-", "so", "we", "resort", "approximate", "solution", "use", "iterative", "greedy", "approach", "describe", "below", "each", "patch", "initially", "assign", "its", "nearest", "neighbor", "former", "case", "we", "keep", "only", "assignment", "smallest", "difference", "discard", "rest", "all", "pair", "leave", "shape", "adjustment", "boundary", "exemplar", "patch", "superimpose", "over", "assign", "position", "right", "match", "patch", "from", "previous", "shape", "-lrb-", "gold", "-rrb-", "superimpose", "again", "seed", "new", "shape", "-lrb-", "blue", "-rrb-", "patch", "which", "have", "be", "assign", "remove", "from", "further", "consideration", "process", "repeat", "until", "every", "patch", "have", "be", "assign", "general", "differ", "size", "typically", "synthesize", "shape", "larger", "than", "exemplar", "thus", "assume", "we", "construct", "set", "exemplar", "patch", "size", "include", "each", "exemplar", "patch", "time", "randomly", "select", "additional", "patch", "from", "way", "we", "ensure", "all", "boundary", "feature", "exemplar", "shape", "get", "equal", "chance", "represent", "synthesize", "shape", "shape", "adjustment", "achieve", "we", "superimpose", "each", "exemplar", "patch", "over", "its", "counterpart", "consider", "pixel", "outside", "which", "cover", "several", "overlap", "super", "impose", "patch", "from", "informally", "patch", "agree", "should", "part", "shape", "add", "S.", "similarly", "pixel", "inside", "might", "remove", "overlap", "patch", "agree", "should", "belong", "shape", "illustrate", "Figure", "-lrb-", "left", "-rrb-", "more", "specifically", "consider", "pixel", "vicinity", "boundary", "cover", "two", "group", "overlap", "superimpose", "exemplar", "patch", "one", "group", "predict", "belong", "shape", "while", "other", "one", "predict", "outside", "shape", "each", "two", "prediction", "we", "compute", "score", "sum", "up", "weight", "corresponding", "group?s", "patch", "x.", "let", "boundary", "pixel", "exemplar", "pixel", "assign", "entire", "exemplar", "patch", "assign", "follow", "weight", "which", "further", "multiply", "gaussian", "falloff", "function", "-lrb-", "thus", "weight", "decrease", "away", "from", "center", "patch", "-rrb-", "sigma", "value", "function", "choose", "half", "patch", "size", "when", "sum", "weight", "accumulate", "each", "pixel", "below", "threshold", "its", "value", "remain", "unchanged", "because", "patch", "weight", "reflect", "degree", "certainty", "so", "area", "low", "weight", "more", "sensitive", "randomness", "generate", "we", "approximate", "nearest", "neighbor", "search", "greedy", "assignment", "use", "new", "value", "may", "produce", "noise", "threshold", "also", "determine", "final", "amount", "pixel", "shape", "after", "iteration", "do", "therefore", "set", "dynamically", "so", "-lrb-", "relative", "-rrb-", "amount", "pixel", "inside", "shape", "same", "exemplar", "candidate", "from", "interval", "-lsb-", "10", "10", "-rsb-", "test", "one", "which", "result", "nearest", "amount", "choose", "after", "update", "complete", "optimization", "procedure", "repeat", "until", "convergence", "convergence", "reach", "when", "number", "change", "pixel", "fall", "below", "threshold", "mention", "earlier", "optimization", "proceed", "from", "coarse", "fine", "resolution", "result", "compute", "each", "resolution", "level", "upsample", "serve", "start", "point", "next", "-lrb-", "finer", "-rrb-", "level", "we", "example", "we", "use", "resolution", "level", "Figure", "show", "how", "different", "initialization", "lead", "different", "global", "shape", "however", "all", "example", "synthesize", "shape", "contain", "boundary", "feature", "very", "similar", "those", "present", "exemplar", "result", "close", "overall", "resemblance", "shape", "optimization", "procedure", "present", "previous", "section", "may", "use", "directly", "synthesize", "first", "-lrb-", "bottom", "-rrb-", "layer", "first", "shape", "each", "layer", "nested", "inside", "shape", "layer", "beneath", "second", "boundary", "two", "successive", "layer", "typically", "highly", "correlate", "preserve", "correlation", "important", "instrumental", "faithfully", "reproduce", "appearance", "exemplar", "synthesize", "result", "address", "requirement", "we", "begin", "synthesis", "each", "layer", "+1", "create", "mask", "define", "area", "-lrb-", "contain", "inside", "shape", "previous", "layer", "-rrb-", "where", "current", "shape", "allow", "evolve", "initially", "mask", "set", "entire", "shape", "we", "use", "most", "recent", "boundary", "patch", "assignment", "-lrb-", "from", "last", "shape", "optimization", "iteration", "-rrb-", "shrink", "mask", "down", "better", "initial", "guess", "region", "contain", "+1", "more", "specifically", "we", "again", "superimpose", "boundary", "patch", "from", "exemplar", "over", "assign", "location", "boundary", "time", "we", "try", "predict", "which", "pixel", "inside", "should", "belong", "mask", "+1", "illustrate", "Figure", "-lrb-", "right", "-rrb-", "thus", "interior", "seed", "pixel", "which", "predict", "belong", "+1", "sufficiently", "large", "weight", "mask", "shrink", "include", "only", "seed", "pixel", "seed", "pixel", "high", "weight", "form", "initial", "guess", "+1", "while", "those", "somewhat", "smaller", "weight", "define", "remain", "region", "mask", "within", "which", "shape", "allow", "evolve", "course", "optimization", "initialization", "each", "new", "layer", "do", "via", "seeding", "mechanism", "coarsest", "resolution", "where", "boundary", "patch", "large", "enough", "fully", "cover", "interior", "previous", "shape", "similar", "step", "repeat", "beginning", "each", "resolution", "level", "recreate", "accurate", "mask", "current", "level", "new", "resolution", "refine", "shape", "boundary", "after", "step", "shape", "optimization", "proceed", "describe", "before", "continuous", "control", "map", "we", "experiment", "we", "find", "subsequent", "texture", "synthesis", "process", "can", "sometimes", "improve", "switch", "from", "discrete", "layer", "map", "continuous", "control", "map", "specifically", "each", "pixel", "inside", "shape", "its", "continuous", "map", "where", "-lrb-", "-rrb-", "+1", "-lrb-", "-rrb-", "distance", "from", "+1", "respectively", "-lrb-", "see", "Figure", "-rrb-", "distance", "obtain", "perform", "distance", "transform", "over", "layer", "decomposition", "phase", "take", "inhomogeneous", "texture", "sample", "input", "generate", "layer", "map", "which", "encode", "distinct", "homogeneous", "texture", "region", "-lrb-", "layer", "-rrb-", "present", "input", "assign", "unique", "label", "all", "pixel", "belong", "same", "layer", "follow", "texture", "classification", "approach", "advocate", "Varma", "Zisserman", "-lsb-", "2003", "-rsb-", "we", "first", "segment", "exemplar?s", "pixel", "perform", "k-means", "clustering", "dimensional", "feature", "vector", "form", "concatenate", "value", "each", "pixel?s", "neighborhood", "we", "currently", "rely", "user", "specify", "number", "distinct", "texture", "visible", "exemplar", "typically", "between", "set", "15", "all", "we", "example", "result", "cluster", "should", "roughly", "correspond", "distinct", "texture", "present", "exemplar", "point", "closer", "cluster", "center", "due", "pixel", "more", "typical", "representative", "corresponding", "texture", "while", "point", "far", "away", "from", "center", "come", "from", "area", "transition", "between", "texture", "let", "...", "result", "cluster", "order", "user", "bottom", "layer", "-lrb-", "original", "clean", "surface", "-rrb-", "top", "layer", "-lrb-", "most", "weather", "surface", "-rrb-", "layer", "map", "we", "set", "foreground", "pixel", "+1", "cluster", "have", "be", "order", "properly", "sequence", "...", "express", "possible", "natural", "evolution", "spread", "over", "time", "weather", "phenomenon", "capture", "exemplar", "last", "phase", "we", "use", "new", "layer", "map", "obtain", "shape", "synthesis", "phase", "-lrb-", "section", "-rrb-", "synthesize", "new", "inhomogeneous", "texture", "do", "apply", "texture-by-number", "framework", "-lsb-", "Hertzmann", "et", "al.", "2001", "-rsb-", "while", "apply", "texture-by-number", "directly", "layer", "map", "often", "produce", "satisfactory", "result", "visual", "quality", "may", "further", "improve", "switch", "from", "discrete", "layer", "map", "continuous", "one", "describe", "previous", "section", "continuous", "map", "may", "see", "heuristic", "analogue", "input", "we", "result", "weather", "degree", "map", "-lsb-", "Wang", "et", "al.", "2006", "-rsb-", "we", "experiment", "we", "method", "variety", "natural", "inhomogeneous", "texture", "some", "result", "show", "figure", "example", "quite", "varied", "showcase", "phenomenon", "corrosion", "rust", "lichen", "peel", "paint", "differ", "significantly", "only", "appearance", "also", "underlie", "layer", "structure", "may", "see", "from", "layer", "map", "extract", "we", "method", "we", "method", "successfully", "reproduce", "global", "layer", "structure", "local", "fine", "detail", "shape", "boundary", "final", "appearance", "texture", "-lsb-", "Kopf", "et", "al.", "2007", "-rsb-", "-lsb-", "Kwatra", "et", "al.", "2005", "-rsb-", "other", "inhomogeneous", "texture", "exhibit", "layered", "structure", "nested", "shape", "may", "synthesize", "well", "example", "we", "have", "synthesize", "plausible", "fictional", "satellite", "image", "from", "one", "Earth", "-lrb-", "bottom", "row", "Figure", "-rrb-", "since", "we", "use", "patch-based", "shape", "synthesis", "some", "repetition", "do", "occur", "mostly", "difficult", "spot", "explicitly", "limit", "we", "approach", "we", "fair", "boundary", "sampling", "assignment", "mechanism", "another", "application", "we", "approach", "example-based", "terrain", "synthesis", "demonstrate", "Figure", "height", "map", "use", "represent", "terrain", "may", "also", "consider", "non-stationary", "texture", "which", "we", "layered", "shape", "synthesis", "approach", "fit", "perfectly", "generation", "layer", "map", "simple", "quantization", "height", "map", "use", "boundary", "layer", "resemble", "contour", "line", "topographic", "map", "application", "which", "similar", "texture", "synthesis", "describe", "before", "shape", "synthesis", "phase", "generate", "new", "topographic", "layout", "synthesize", "terrain", "texture", "synthesis", "phase", "add", "fine", "detail", "computation", "time", "we", "method", "dominate", "texture", "number", "phase", "which", "take", "up", "five", "hour", "800", "600", "image", "use", "neighborhood", "time", "take", "synthesize", "new", "layer", "map", "depend", "total", "length", "shape", "boundary", "complexity", "optimization", "step", "linear", "number", "nearest", "neighbor", "call", "each", "boundary", "patch", "we", "use", "approximate", "nearest", "neighbor", "search", "via", "locally", "sensitive", "hash", "-lsb-", "Datar", "Indyk", "2004", "-rsb-", "take", "we", "unoptimized", "code", "20", "30", "seconds", "average", "complete", "one", "optimization", "iteration", "800", "600", "image", "typically", "10", "iteration", "use", "each", "resolution", "level", "so", "execution", "time", "per", "layer", "up", "30", "minute", "we", "compare", "we", "method", "two", "previous", "example-based", "texture", "synthesis", "method", "texture", "optimization", "-lsb-", "Kwatra", "et", "al.", "2005", "-rsb-", "texture", "optimization", "color", "histogram", "match", "-lsb-", "Kopf", "et", "al.", "2007", "-rsb-", "Figure", "10", "show", "result", "three", "method", "side-byside", "top", "row", "show", "final", "synthesis", "result", "texture", "rusting", "surface", "kwatra?s", "method", "suit", "stationary", "texture", "exhibit", "multiple", "obvious", "repetition", "make", "result", "quite", "dissimilar", "from", "exemplar", "also", "interesting", "examine", "whether", "previous", "method", "able", "synthesize", "layer", "map", "rather", "than", "synthesize", "texture", "directly", "do", "two", "example", "show", "two", "bottom", "row", "Figure", "10", "middle", "row", "layer", "map", "extract", "from", "cloudy", "sky", "texture", "while", "bottom", "row", "layer", "map", "from", "terrain", "Figure", "both", "example", "previous", "method", "generate", "more", "repetition", "entire", "region", "layer", "map", "several", "place", "direct", "transition", "between", "non-adjacent", "layer", "which", "present", "input", "map", "Figure", "11", "show", "inpainting", "example", "where", "hole", "fill", "inside", "inhomogeneous", "texture", "while", "result", "obviously", "identical", "original", "image", "quite", "plausible", "fill", "region", "blend", "well", "original", "part", "layer", "map", "inside", "hole", "initialize", "randomly", "since", "we", "method", "modify", "entire", "layer", "map", "after", "each", "optimization", "step", "we", "reset", "layer", "map", "outside", "hole", "back", "original", "one", "Figure", "12", "demonstrate", "feasibility", "control", "result", "synthesis", "via", "painting", "interface", "exemplar", "its", "layer", "map", "show", "third", "row", "figure", "user", "sketch", "yellow", "approximate", "position", "where", "rust", "should", "result", "sketch", "serve", "initialization", "shape", "synthesis", "phase", "thin", "strip", "blue", "green", "pixel", "automatically", "add", "system", "since", "yellow", "layer", "shape", "suppose", "nested", "inside", "blue", "green", "layer", "shape", "order", "avoid", "change", "user", "sketch", "shape", "too", "much", "fewer", "resolution", "level", "use", "shape", "synthesis", "method", "result", "middle", "image", "Figure", "12", "while", "rightmost", "image", "synthesize", "texture", "Limitations", "we", "approach", "make", "two", "basic", "assumption", "-lrb-", "-rrb-", "control", "map", "consist", "order", "set", "layer", "nested", "within", "each", "other", "-lrb-", "-rrb-", "propose", "shape", "similarity", "measure", "capture", "all", "shape", "characteristic", "one", "aim", "reproduce", "violation", "either", "assumption", "may", "lead", "failure", "discuss", "below", "-lrb-", "-rrb-", "first", "type", "failure", "demonstrate", "synthetic", "example", "top", "row", "Figure", "13", "here", "we", "green", "blue", "region", "independent", "each", "other", "input", "-lrb-", "e.g.", "natural", "texture", "whose", "appearance", "result", "from", "two", "independent", "process", "-rrb-", "we", "approach", "assume", "layered", "model", "generate", "green", "layer", "first", "follow", "blue", "layer", "result", "relation", "between", "green", "blue", "region", "preserve", "several", "blue", "region", "synthesize", "inside", "green", "one", "-lrb-", "-rrb-", "propose", "similarity", "measure", "characterize", "shape", "local", "appearance", "boundary", "without", "consider", "shape", "whole", "thus", "better", "suit", "fine-scale", "unstructured", "shape", "fractal-like", "boundary", "more", "structured", "element", "might", "better", "handle", "other", "model", "example", "location", "desert", "bottom", "row", "figure", "might", "have", "be", "reproduce", "better", "use", "context-aware", "texture", "framework", "-lsb-", "Lu", "et", "al.", "2007", "-rsb-", "bottom", "row", "Figure", "13", "show", "another", "synthetic", "example", "where", "easily", "recognizable", "distinct", "shape", "input", "map", "appear", "mix", "map", "generate", "we", "method", "we", "have", "present", "novel", "example-based", "method", "synthesis", "control", "map", "suitable", "non", "stationary", "texture", "those", "result", "from", "weather", "end", "we", "have", "develop", "new", "powerful", "example-based", "shape", "synthesis", "algorithm", "represent", "shape", "collection", "boundary", "patch", "multiple", "resolution", "synthesize", "new", "shape", "from", "example", "optimize", "bidirectional", "similarity", "function", "application", "we", "method", "include", "synthesis", "natural", "texture", "terrain", "generation", "we", "current", "measure", "emphasize", "boundary", "similarity", "over", "other", "property", "area", "boundary", "length", "ratio", "which", "maintain", "only", "implicitly", "acknowledgment", "work", "support", "part", "grant", "from", "Israel", "Ministry", "Science", "from", "Israel", "Science", "Foundation", "found", "Israel", "Academy", "Sciences", "Humanities", "author", "would", "also", "like", "thank", "anonymous", "reviewer", "whose", "suggestion", "be", "greatly", "helpful" ],
  "content" : "Our approach begins by decomposing the input exemplar into a number of layers, which we order bottom to top. Once the new layers are available, a texture transfer process based on ?texture-by-numbers? [Hertzmann et al. 2001] is invoked, resulting in the final output texture, such as the result shown in Figure 1 . Non-parametric methods have demonstrated the ability to handle a wider variety of textures, by growing the texture one pixel/patch at a time. Optimization-based methods evolve the texture as a whole, further improving the quality of the results and making the synthesis more controllable. Texture-by-Numbers [Hertzmann et al. 2001] extends this idea further by augmenting the input exemplar with a label map, where regions with distinct texture are distinguished by different labels. A suitable label map may be painted manually by the user, or created automatically using unsupervised image segmentation. To synthesize a new image, a target label map is provided, which indicates how the different textures should be arranged in the resulting image. Many other works since made use of control maps when synthesizing non-stationary textures, for example [Zhang et al. 2003; Wang et al. 2006; Gu et al. 2006; Lu et al. 2007; Wei et al. 2008]. However, in all of these works the control map for the target texture is either provided by the user, or derived from a specific model of texture formation across a 3D surface (e.g., [Lu et al. 2007]), and we are not aware of any previous attempts of example-based control map generation. Our shape synthesis approach is related to texture optimization techniques [Wexler et al. 2004; Kwatra et al. 2005], which synthe size textures by minimizing a texture energy function. In contrast, we perform shape synthesis with a bidirectional similarity measure (inspired by Simakov et al. [2008] and Wei et al. [Wei et al. 2008]), and demonstrate more faithful reproduction of appearance in the comparisons we present in Section 4. Appearance-space texture synthesis [Lefebvre and Hoppe 2006] is another optimization method that operates in a feature space, rather than using the values of pixels or small patches directly. The layer map that we associate with the input exemplar in our approach could be viewed as a feature space custom-tailored for synthesis of layered inhomogeneous textures. A variety of methods generate textures of weathered surfaces by assuming and simulating a physical model [Dorsey and Hanrahan 1996; Dorsey et al. 1999; Merillou et al. 2001; Bosch et al. 2004; Desbenoit et al. 2004; Dorsey et al. 2008]. In contrast, our approach is example-based, rather than physicallybased. Our approach synthesizes the boundaries of the layer shapes by example. Thus, it is related to the Curve Analogies work of Hertzmann et al. [2002], where a similar framework was applied to reproduce the style of curved shapes. However, our work uses a different similarity measure and operates on a discrete patch-based representation of a shape?s boundary, rather than a vector-based representation. A layer map is an image where different pixel values indicate to different layers. Let v 1 < v 2 < . < v K be the values of layer map pixels, sorted in ascending order. Note that a pixel with value v j actually belongs to all layers L 1 , . . . , L j . Each layer has an associated foreground shape S i , which we encode as a binary image of the same dimensions as the layer map. Note that the shape S i+1 is always contained in S i . As may be seen in Figures 1 and 6, the boundaries of these nested shapes are highly correlated, but not aligned. Given a set of such shapes, our goal is to synthesize a new set of shapes, while maintaining both global and local similarity to the original ones. For this purpose, it is important that each shape occupies the same relative amount of pixels in the synthesized map as it did in the exemplar, and that the boundaries of the synthesized shapes locally resemble those in the exemplar. We found that representing the shape by means of its boundary curve fails to capture all of the relevant information. Instead, we represent a binary shape by a collection of patches centered on the shape?s boundary pixels (at multiple resolutions) in order to captures the necessary shape properties. Our shape synthesis approach employs optimization similarly to [Wexler et al. 2004; Kwatra et al. 2005], where the synthesized result is iteratively optimized with respect to some measure of its similarity with the exemplar. We begin by deriving a suitable bidirectional shape similarity measure, similarly to Simakov et al. [2008] and Wei et al. [2008]. Next, we describe a novel greedy optimization scheme that iteratively modifies an initial shape, so as to increase its similarity to a given exemplar shape. Finally, we discuss how this mechanism is used to create an entire new layer map, which is a sequence of nested shapes, from the layer map produced in the layer decomposition phase described in the previous section. Let B 1 and B 2 be the sets of boundary pixels of shapes S 1 and S 2 , respectfully. A boundary pixel is a pixel inside a shape with at least one of its 4-neighbors outside the shape. Let x 1 ? B 1 and x 2 ? B 2 be two boundary pixels, and let N ? (x 1 ) and N ? (x 2 ) be the neighborhoods centered around them and rotated by ?, ? ? {0 ? , 90 ? , 180 ? , 270 ? }. We refer to such neighborhoods as boundary patches. We define the similarity, D, between two boundary pixels as the L 2 distance between their neighborhoods (rotated such that the distance is minimized). Since we deal with binary images, the L 2 norm above is simply the number of different pixels between two patches. Next, we define the local similarity between a boundary pixel x 1 ? B 1 and the boundary of (another) shape S 2 as the similarity between x 1 and the pixel most similar to it on the boundary B 2 : Note that this similarity measure is not symmetric. While it ensures that every boundary patch of S 1 is similar to a boundary patch in S 2 , is discarded and will be assigned to another patch in a future iteration (yellow arrow). there may be boundary patches in S 2 that are not well represented in S 1 . For example, a simple shape may be deemed similar to a more complex one that also happens to contain some simple features. Thus, we require a bidirectional similarity measure, defined as which is the average number of different pixels between a boundary patch of one shape to its nearest neighbor on the other. Figure 2 shows several different shapes and reports their pairwise bidirectional similarities. Armed with the similarity measure above, we use an optimization procedure that iteratively modifies the boundary of a synthesized shape S to make it more similar to that of the exemplar shape E. The optimization proceeds from coarse to fine resolution. At each resolution we alternate between two main steps: (i) matching each boundary patch of S to a boundary patch of E, and (ii) modifying S by adding or removing pixels based on the results of the matching achieved in the previous step. This iterative optimization procedure resembles that of Kwatra et al. [2005], but each of the two main steps differs significantly from its counterpart, because we minimize a different (bidirectional) energy function, and work with binary images, rather than textures. These two steps are discussed in more detail below. Boundary patch matching. Solving this problem exactly is too expensive for our purposes (O(n 3 ), where n is the number of patches), so we resort to an approximate solution using the iterative greedy approach described below. Each patch in B E is initially assigned to its nearest neighbor in B S . In the former case, we keep only the assignment with the smallest L 2 difference, and discard the rest. All of the pairs of Left: Shape adjustment. Boundary exemplar patches are superimposed over their assigned positions. Right: Matching patches from the previous shape (gold) are superimposed again to seed the new shape (blue). patches which have been assigned are then removed from further consideration, and the process is repeated until every patch in B S has been assigned. In general, B E and B S differ in size. Typically, the synthesized shape is larger than the exemplar. Thus, assuming that |B S | = Q|B E | + R, we construct a set of exemplar patches of size |B S | by including each exemplar patch Q times, and randomly selecting R additional patches from B E . In this way we ensure that all the boundary features in the exemplar shape get an equal chance to be represented in the synthesized shape. Shape adjustment. To achieve this, we superimpose each exemplar patch over its counterpart in B S . Consider a pixel x outside S, which is covered by several overlapping super- imposed patches from B E . Informally, if these patches agree that x should be part of the shape, it is added to S. Similarly, a pixel inside S might be removed if the overlapping patches agree that it should not belong to the shape. This is illustrated in Figure 4 (left). More specifically, consider a pixel x in the vicinity of the boundary of S. It is covered by two groups of overlapping superimposed exemplar patches: one group predicts that x belongs to the shape, while the other one predicts that x is outside the shape. For each of these two predictions we compute a score by summing up the weights of the corresponding group?s patches at x. Let x S be a boundary pixel of S and x E the exemplar pixel assigned to it. Then the entire exemplar patch is assigned the following weight which is further multiplied by a Gaussian falloff function (thus the weight decreases away from the center of the patch). The sigma value for this function was chosen to be half of the patches size. When the sum of weights accumulated at each pixel x is below a threshold, its value remains unchanged. This is because patch weights reflect a degree of certainty, so areas of low weight are more sensitive to randomness generated by our approximated nearest neighbor search and the greedy assignment, such that using the new values may produce noise. This threshold also determines the final amount of pixels in the shape after the iteration is done. Therefore, it is set dynamically so that the (relative) amount of the pixels inside the shape is the same as in the exemplar. Candidates from the interval [10 ?2 , 10 ?7 ] are tested and the one which results in the nearest amount is chosen. After the update is complete, the optimization procedure is repeated until convergence. Convergence is reached when the number of changed pixels falls below a threshold. As mentioned earlier, the optimization proceeds from coarse to fine resolution. The result computed at each resolution level is upsampled to serve as a starting point for the next (finer) level. In our examples, we use 5 to 6 resolution levels. Figure 5 shows how different initializations lead to different global shapes. However, in all of the examples the synthesized shape contains boundary features that are very similar to those present in the exemplar, resulting in close overall resemblance. The shape optimization procedure presented in the previous section may be used directly to synthesize the first (bottom) layer. First, the shape of each layer is nested inside the shape of the layer beneath it. Second, the boundaries of two successive layers are typically highly correlated. Preserving this correlation is important, as it is instrumental for faithfully reproducing the appearance of the exemplar in the synthesized result. To address these requirements we begin the synthesis of each layer L i+1 by creating a mask that defines the area (contained inside the shape of the previous layer S i ), where the current shape is allowed to evolve. Initially, this mask is set to the entire shape S i , but we use the most recent boundary patch assignments (from the last shape optimization iteration) to shrink this mask down to a better initial guess for the region containing S i+1 . More specifically, we again superimpose boundary patches from the exemplar over their assigned locations on the boundary of S i , but this time we try to predict which of the pixels inside S i should belong to the mask of S i+1 , as illustrated in Figure 4 (right). Thus, the interior of S i is seeded with pixels which are predicted to belong to S i+1 with a sufficiently large weight. The mask is then shrunk to include only these seeded pixels. Seeded pixels with high weights form the initial guess for S i+1 , while those with somewhat smaller weights define the remaining region of the mask, within which the shape is allowed to evolve in the course of the optimization. The initialization of each new layer is done via this seeding mechanism in the coarsest resolution, where boundary patches are large enough to fully cover the interior of the previous shape. A similar step is repeated at the beginning of each resolution level to recreate an accurate mask for the current level at the new resolution, and to refine the shape boundary. After this step, shape optimization proceeds as described before. Continuous control maps. In our experiments we found that the subsequent texture synthesis process can sometimes be improved by switching from a discrete layer map to a continuous control map. Specifically, for each pixel x inside the shape S i its continuous map where d i?1 (x) and d i+1 (x) are the distances from x to S i?1 and S i+1 , respectively (see Figure 7 ). The distances are obtained by performing distance transforms over S i . The layer decomposition phase takes an inhomogeneous texture sample as input, and generates a layer map which encodes the distinct homogeneous texture regions (layers) present in the input, by assigning a unique label to all of the pixels belonging to the same layer. Following the texture classification approach advocated by Varma and Zisserman [2003], we first segment the exemplar?s pixels by performing K-Means clustering on the N 2 dimensional feature vectors formed by concatenating the values of each pixel?s N ? N neighborhood. We currently rely on the user to specify K as the number of distinct textures visible in the exemplar, typically between 3 and 5. N is set to 15 in all of our examples. The resulting clusters should roughly correspond to the distinct textures present in the exemplar. Points closer to the cluster centers are due to pixels that are the more typical representatives of the corresponding textures, while points far away from the center come from areas of transition between textures. Let C 1 ,C 2 , . . . ,C K be the resulting clusters, ordered by the user such that C 1 is the bottom layer (original ?clean? surface), and C K is the top layer (most ?weathered? surface). For the layer map, we set the foreground pixels of L i to be C i ?C i+1 ? . If the clusters have been ordered properly, the sequence L 1 , L 2 , . . . , L K expresses a possible natural evolution and spread over time of the weathering phenomenon captured by the exemplar. In the last phase we use the new layer map obtained in the shape synthesis phase (Section 3) to synthesize a new inhomogeneous texture. This is done by applying the ?texture-by-numbers? framework [Hertzmann et al. 2001]. While applying texture-by-numbers directly on the layer map often produces satisfactory results, their visual quality may be further improved by switching from a discrete layer map to a continuous one, as described in the previous section. The continuous map may be seen as a heuristic analogue for the input our result weathering degree map of [Wang et al. 2006]. We experimented with our method on a variety of natural inhomogeneous textures. Some results are shown in Figures 1, 6, and 8. The examples are quite varied, showcasing phenomena such as corrosion, rust, lichen, and peeling paint. They differ significantly not only in their appearance, but also in their underlying layer structure, as may be seen from the layer maps extracted by our method. Our method successfully reproduces the global layer structures, the local fine details of the shape boundaries, and the final appearance of these textures. [Kopf et al. 2007] [Kwatra et al. 2005]\n        Other inhomogeneous textures that exhibits a layered structure with nested shapes may be synthesized as well. For example, we have synthesized a plausible fictional satellite image from one of Earth (bottom row in Figure 8 ). Since we use patch-based shape synthesis, some repetitions do occur, but they are mostly difficult to spot, as they are explicitly limited in our approach by our fair boundary sampling and assignment mechanisms. Another application of our approach is example-based terrain synthesis, as demonstrated in Figure 9 . Height maps used to represent terrains may also be considered as non-stationary textures for which our layered shape synthesis approach fits perfectly. For the generation of the layer map, a simple quantization of the height map is used. The boundaries of layers resemble contour lines in a topographic map. In this application, which is similar to texture synthesis described before, the shape synthesis phase generates a new topographic layout for the synthesized terrain and the texture synthesis phase adds the fine details. The computation time of our method is dominated by the ?texture by numbers? phase, which takes up to five hours for a 800 ? 600 image using 5 ? 5 neighborhoods. The time it takes to synthesize a new layer map depends on the total length of the shape boundaries. The complexity of the optimization step is linear in the number of nearest neighbor calls for each boundary patch. We use approximate nearest neighbor search via locally sensitive hashing [Datar and Indyk 2004]. It takes our unoptimized code 20?30 seconds on average to complete one optimization iteration for an 800 ? 600 image. Typically, 5?10 iterations are used at each resolution level, so the execution time per layer is up to 30 minutes. We compare our method to two previous example-based texture synthesis methods: texture optimization [Kwatra et al. 2005] and texture optimization with color histogram matching [Kopf et al. 2007]. Figure 10 shows the results of the three methods side-byside. The top row shows the final synthesis result on a texture of a rusting surface. Kwatra?s method is suited for stationary textures, and exhibits multiple obvious repetitions making the result quite dissimilar from the exemplar. It is also interesting to examine whether these previous methods are able to synthesize the layer map, rather than synthesizing the texture directly, and this is done on two examples shown in the two bottom rows of Figure 10 . The middle row is a layer map extracted from a cloudy sky texture, while in the bottom row the layer map is from the terrain in Figure 9 . In both of these examples, the previous methods generate more repetitions of entire regions of the layer map, and in several places there are direct transitions between non-adjacent layers, which are not present in the input map. Figure 11 shows an inpainting example, where a hole is filled inside an inhomogeneous texture. While the result is obviously not identical to the original image, it is quite plausible, and the filled region blends well with the original parts. The layer map inside the hole is initialized randomly. Since our method modifies the entire layer map, after each optimization step we reset the layer map outside the hole back to the original one. Figure 12 demonstrates the feasibility of controlling the result of the synthesis via a painting interface. The exemplar and its layer map are shown in the third row of Figure 8 . The user sketches in yellow the approximate position where rust should be, and the resulting sketch serves as the initialization for the shape synthesis phase. Thin strips of blue and green pixels are automatically added by the system, since the yellow layer shape is supposed to be nested inside the blue and the green layer shapes. In order to avoid changing the user sketched shape too much, fewer resolution levels are used by the shape synthesis method, resulting in the middle image in Figure 12 , while the rightmost image is the synthesized texture. Limitations: Our approach makes two basic assumptions: (1) the control map consists of an ordered set layers, nested within each other; (2) the proposed shape similarity measure captures all the shape characteristics that one aims to reproduce. Violation of either of these assumptions may lead to a failure, as discussed below. (1) The first type of failure is demonstrated by the synthetic example in the top row of Figure 13. Here we green and blue regions that are independent of each other in the input (e.g., a natural texture whose appearance results from two independent processes). Our approach assumes a layered model and generates the green layer first, followed by the blue layer. As a result, the relations between the green and blue regions are not preserved, and several blue regions are synthesized inside green ones. (2) The proposed similarity measure characterizes shapes by the local appearance of their boundaries, without considering the shape as a whole. Thus, it is better suited for fine-scale unstructured shapes and fractal-like boundaries. More structured elements might be better handled by other models. For example, the locations of the deserts in the bottom row of Figure 8 might have been reproduced better using the context-aware textures framework [Lu et al. 2007]. The bottom row of Figure 13 shows another synthetic example where the easily recognizable distinct shapes in the input map appear mixed in the map generated by our method. We have presented a novel example-based method for synthesis of control maps suitable for non stationary textures, such as those resulting from weathering. To that end, we have developed a new  powerful example-based shape synthesis algorithm that represents shapes as a collection of boundary patches at multiple resolution, and synthesizes a new shape from an example by optimizing a bidirectional similarity function. Applications of our method include synthesis of natural textures and terrain generation. Our current measure emphasizes boundary similarity over other properties, such as area to boundary length ratio, which is maintained only implicitly. Acknowledgments: This work was supported in part by grants from the Israel Ministry of Science, and from the Israel Science Foundation founded by the Israel Academy of Sciences and Humanities. The authors would also like to thank the anonymous reviewers whose suggestions were greatly helpful.",
  "resources" : [ ]
}