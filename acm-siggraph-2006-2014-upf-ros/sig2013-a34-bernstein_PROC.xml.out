{
  "uri" : "sig2013-a34-bernstein_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2013/a34-bernstein_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Putting Holes in Holey Geometry: Topology Change for Arbitrary Surfaces",
    "published" : "2013",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Gilbert Louis-Bernstein",
      "name" : "Gilbert Louis",
      "surname" : "Bernstein"
    }, {
      "uri" : "http://drinventor/Chris-Wojtan",
      "name" : "Chris",
      "surname" : "Wojtan"
    } ]
  },
  "bagOfWords" : [ "we", "prove", "new", "method", "topology", "change", "produce", "expected", "conventional", "result", "when", "apply", "solid", "-lrb-", "closed", "manifold", "non-self-intersecting", "-rrb-", "surfaces?that", "we", "prove", "backwardscompatibility", "property", "relative", "prior", "work", "finally", "we", "demonstrate", "how", "topology", "change", "apply", "non-solid", "object", "enable", "wholly", "new", "useful", "behavior", "contribution", "we", "provide", "first", "method", "topology", "change", "applicable", "arbitrary", "non-solid", "non-manifold", "non-closed", "selfintersecting", "surface", "we", "prove", "new", "method", "produce", "expect", "conventional", "result", "when", "apply", "solid", "-lrb-", "closed", "manifold", "non-self-intersecting", "-rrb-", "surfaces?that", "we", "prove", "backwards-compatibility", "property", "relative", "prior", "work", "beyond", "solid", "surface", "we", "present", "empirical", "evidence", "we", "method", "remain", "tolerant", "variety", "surface", "aberration", "through", "incorporation", "novel", "error", "correction", "scheme", "finally", "we", "demonstrate", "how", "topology", "change", "apply", "non-solid", "object", "enable", "wholly", "new", "useful", "behavior", "edge", "mesh", "manifold", "have", "we", "prefer", "use", "solid", "since", "definition", "watertight", "inconsistent", "imprecise", "across", "literature", "outside", "class", "solid", "mesh", "we", "say", "mesh", "unoriented", "any", "pair", "triangle", "share", "manifold", "edge", "orient", "face", "opposite", "direction", "some", "mesh", "which", "inherently", "non-orientable", "most", "famous", "example", "be", "M?bius", "band", "2.2", "why", "Aren?t", "All", "mesh", "solid", "demonstrate", "fact", "we", "run", "statistics", "brown", "mesh", "set", "-lsb-", "McGuire", "2004", "-rsb-", "less", "than", "25", "-lrb-", "263/1136", "-rrb-", "mesh", "be", "close", "manifold", "over", "40", "-lrb-", "472/1136", "-rrb-", "be", "neither", "manifold", "nor", "close", "over", "90", "-lrb-", "1046/1136", "-rrb-", "be", "self-intersecting", "can", "accomplish", "through", "convert", "surface", "implicit", "function", "representation", "-lsb-", "Wojtan", "et", "al.", "2009", "Wojtan", "et", "al.", "2010", "-rsb-", "bsp-based", "volume", "representation", "-lsb-", "Campen", "Kobbelt", "2010", "-rsb-", "march", "around", "outside", "mesh", "use", "normal", "-lsb-", "Zaharescu", "et", "al.", "2011", "-rsb-", "all", "technique", "use", "infer", "volumetric", "interpretation", "-lrb-", "inside", "vs.", "outside", "-rrb-", "mesh", "discard", "those", "part", "surface", "which", "necessary", "enclose", "infer", "volume", "Brochu", "Bridson", "use", "combination", "collision", "detection", "local", "remeshing", "time-step", "control", "get", "surface", "mesh", "close", "touch", "allow", "tunnel", "stitch", "similarly", "St", "anculescu", "et", "al.", "tightly", "control", "size", "both", "mesh", "element", "time-step", "order", "create", "safe", "condition", "tunnel", "stitching", "however", "nei", "ther", "constraint", "necessarily", "true", "modeling", "system", "evidence", "we", "grab", "brush", "-lrb-", "-rrb-", "contrast", "prior", "work", "we", "make", "special", "assumption", "about", "what", "kind", "mesh", "we", "algorithm", "present", "we", "approach", "topology", "change", "rely", "exist", "well", "understand", "computation", "component", "collision", "detection", "static", "intersection", "identification", "triangulation", "we", "string", "component", "together", "order", "compute", "parity", "field", "over", "mesh", "record", "parity", "number", "time", "point", "collide", "surface", "during", "give", "motion", "throughout", "process", "we", "store", "approximation", "-lrb-", "conceptually", "-rrb-", "continuous", "field", "sampling", "its", "value", "mesh", "vertex", "input", "we", "algorithm", "we", "require", "triangle", "mesh", "initial", "time/frame", "linear", "displacement", "vertex", "transport", "mesh", "its", "position", "final", "time/frame", "we", "only", "work", "solid", "surface", "raw", "field", "would", "suffice", "because", "we", "expect", "we", "mesh", "exhibit", "aberration", "other", "shortcoming", "we", "treat", "raw", "parity", "field", "have", "some", "-lrb-", "relatively", "-rrb-", "small", "number", "corrupted", "entry", "result", "we", "final", "output", "mesh", "suitably", "altered", "topology", "we", "method", "topology", "change", "rely", "know", "parity", "number", "collision", "each", "vertex", "make", "rest", "surface", "every", "vertex", "mesh", "every", "triangle", "contain", "vertex", "we", "compute", "root", "usual", "cubic", "equation", "-lrb-", "appendix", "-rrb-", "associate", "barycentric", "coordinate", "we", "use", "they", "determine", "whether", "any", "collision", "occur", "we", "arrive", "desire", "collision", "parity", "value", "accumulate", "result", "computation", "each", "vertex", "across", "all", "potentially", "intersecting", "triangle", "we", "build", "aabvh", "over", "line", "segment", "trace", "out", "move", "vertex", "each", "node", "dimension", "-lrb-", "-rrb-", "select", "geometry", "rearrange", "via", "quick", "select", "search", "median", "build", "recurse", "two", "half", "result", "build", "algorithm", "take", "time", "comparable", "quick", "sort", "geometry", "consume", "small", "fraction", "-lrb-", "10", "-rrb-", "total", "time", "spend", "perform", "collision", "detection", "since", "heuristic", "use", "ensure", "quality", "acceleration", "structure", "since", "we", "don?t", "make", "use", "narrow-phase", "collision", "culling", "technique", "we", "expect", "overall", "cost", "collision", "detection", "could", "significantly", "improve", "just", "apply", "exist", "method", "-lsb-", "Teschner", "et", "al.", "2005", "-rsb-", "nonetheless", "simple", "strategy", "suffice", "demonstrate", "we", "prototype", "when", "use", "application", "like", "cloth", "simulation", "accurate", "collision", "detection", "become", "critical", "keep", "surface", "from", "snag", "themselves", "here", "we", "only", "need", "approximation", "parity", "field", "we", "compute", "from", "collision", "detection", "unless", "we", "present", "highly", "degenerate", "motion", "-lrb-", "e.g.", "collision", "two", "perfectly", "align", "grid", "-rrb-", "numeric", "error", "rare", "help", "ensure", "remain", "rare", "we", "apply", "slight", "perturbation", "-lrb-", "similar", "perturbation", "intersection", "computation", "follow", "section", "-rrb-", "once", "mesh", "have", "reach", "its", "final", "position", "end", "frame", "movement", "we", "determine", "region", "where", "final", "mesh", "statically", "intersect", "itself", "we", "find", "static", "intersection", "curve", "two", "reason", "First", "information", "use", "guide", "error", "correction", "procedure", "secondly", "intersection", "curve", "use", "cleanly", "segment", "mesh", "preserved", "deleted", "portion", "we", "find", "intersection", "curve", "three", "step", "first", "we", "identify", "all", "edge-triangle", "intersection", "point", "present", "second", "we", "infer", "set", "all", "intersection", "edge", "from", "point", "efficiently", "find", "edge-triangle", "intersection", "we", "use", "second", "aabvh", "like", "one", "compute", "collision", "detection", "time", "build", "over", "edge", "mesh", "triangle", "stream", "over", "structure", "test", "intersection", "edge", "encounter", "each", "intersect", "edge-triangle", "pair", "-lrb-", "-rrb-", "we", "collect", "set", "triangle", "edge", "emanate", "from", "point", "where", "intersect", "must", "exactly", "one", "intersection", "edge", "each", "triangle", "which", "uniquely", "identify", "pair", "-lcb-", "-rcb-", "we", "accumulate", "all", "pair", "identify", "via", "combinatorial", "generation", "procedure", "eliminate", "duplicate", "form", "set", "triangle-triangle", "intersection", "edge", "triangle-triangle-triangle", "intersection", "candidate", "rare", "so", "step", "take", "negligible", "amount", "time", "geometric", "robustness", "unfortunately", "unlike", "collision", "we", "rely", "robustly", "compute", "intersection", "curve", "reveal", "any", "inconsistency", "subdivision", "algorithm", "could", "segmentation", "fault", "produce", "non-sensical", "output", "ensure", "consistent", "result", "from", "we", "intersection", "computation", "reasonable", "overhead", "we", "use", "variety", "technique", "from", "robust", "geometric", "computation", "first", "we", "use", "float", "point", "filter", "-lsb-", "Shewchuk", "1997", "-rsb-", "efficiently", "decide", "result", "most", "intersection", "predicate", "when", "filter", "fail", "we", "fallback", "exact", "big", "number", "arithmetic", "ensure", "all", "predicate", "correctly", "compute", "we", "test", "case", "highly", "degenerate", "geometry", "strategy", "suffice", "eliminate", "degeneracy", "after", "single", "perturbation", "one", "strategy", "suppress", "outlier", "parity", "field", "through", "majority", "voting", "we", "split", "they", "surface", "connected", "component", "use", "static", "intersection", "curve", "-lrb-", "compute", "mesh?s", "final", "position", "-rrb-", "vote", "within", "each", "component", "independently", "concretely", "we", "take", "vertex-edge", "graph", "give", "triangle", "mesh", "remove", "all", "edge", "which", "cut", "some", "intersection", "curve", "within", "each", "component", "vertex", "get", "one", "vote", "weight", "proportional", "area", "surface", "represent", "Majority", "voting", "work", "well", "when", "intersection", "curve", "neatly", "partition", "surface", "primarily", "odd", "even", "component", "however", "when", "user", "manipulate", "open", "surface", "near", "its", "boundary", "-lrb-", "figure", "-rrb-", "result", "intersection", "rarely", "partition", "surface", "nicely", "graph", "partitioning", "algorithm", "label", "vertex", "graph", "one", "two", "possible", "label", "splitting", "graph", "image", "segmentation", "label", "foreground/background", "use", "here", "we", "compute", "even/odd", "parity", "label", "desire", "labeling", "find", "solve", "optimization", "problem", "both", "binary", "smoothness", "term", "-lrb-", "minimize", "size", "cut", "between", "two", "region", "-rrb-", "unary", "accuracy", "term", "-lrb-", "deviation", "from", "raw", "parity", "field", "-rrb-", "Vision", "researcher", "have", "ex", "plored", "range", "different", "formulation", "algorithm", "graph", "partitioning", "-lsb-", "Boykov", "et", "al.", "2001", "Grady", "Schwartz", "2006", "-rsb-", "follow", "previous", "example", "we", "can", "formulate", "we", "graph", "partition", "problem", "follow", "-lrb-", "here", "remainder", "section", "we", "let", "denote", "value", "raw", "parity", "field", "vertex", "denote", "continuous", "error", "correct", "value", "which", "we", "solve", "denote", "only", "those", "edge", "triangle", "mesh", "which", "already", "cut", "intersection", "edge", "Edge", "vertex", "weight", "-lrb-", "ij", "-rrb-", "explain", "end", "section", "-rrb-", "energy", "equation", "3.1", "can", "optimize", "solve", "linear", "system", "round", "all", "alternatively", "energy", "can", "optimize", "use", "min-cut", "algorithm", "-lsb-", "Boykov", "et", "al.", "2001", "-rsb-", "we", "try", "both", "approach", "one", "hand", "we", "want", "ensure", "solution", "boundary", "between", "even", "odd", "portion", "surface", "smooth", "-lrb-", "low", "-rrb-", "however", "when", "set", "too", "low", "accuracy", "ignore", "every", "setting", "would", "break", "some", "test", "case", "further", "complication", "arise", "when", "we", "try", "apply", "min-cut", "algorithm", "although", "we", "be", "able", "get", "reasonable", "result", "most", "test", "case", "ignore", "edge", "cut", "intersection", "lead", "fail", "case", "follow", "we", "see", "how", "both", "prying", "apart", "value", "near", "intersection", "-lrb-", "eq", "3.2", "-rrb-", "penalize", "unused", "intersection", "-lrb-", "eq", "result", "field", "encode", "constrain", "set", "possible", "cut", "form", "its", "isocontour", "re-introduce", "stronger", "accuracy", "term", "only", "after", "we", "reach", "second", "stage", "we", "ensure", "reasonable", "degree", "accuracy", "while", "simultaneously", "guarantee", "smoothness", "stage", "we", "minimize", "follow", "quadratic", "energy", "within", "each", "connected-component", "-lrb-", "appendix", "explain", "how", "problem", "solve", "more", "detail", "-rrb-", "unfortunately", "since", "we", "make", "small", "-lrb-", "10", "-rrb-", "solve", "value", "unreliably", "small", "avoid", "problem", "we", "introduce", "few", "extra", "binary", "term", "extra", "term", "pry", "apart", "value", "opposite", "side", "intersection", "curve", "use", "observe", "difference", "raw", "parity", "field", "aside", "from", "we", "dependence", "unfortunately", "heuristic", "term", "necessarily", "asymmetric", "allow", "compromise", "when", "sizable", "number", "raw", "parity", "error", "near", "intersection", "curve", "stage", "we", "sort", "vertex", "value", "perform", "sweep", "cut", "determine", "round", "threshold", "we", "begin", "below", "all", "sweep", "upward", "until", "greater", "than", "all", "we", "select", "whichever", "minimize", "cut", "energy", "i?v", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ij", "-lrb-", "-rrb-", "-lrb-", "3.3", "-rrb-", "-lrb-", "where", "round", "value", "-lsb-", "-rsb-", "indicator", "function", "-rrb-", "note", "we", "penalize", "both", "newly", "introduce", "boundary", "-lrb-", "-rrb-", "well", "unused", "intersection", "-lrb-", "-rrb-", "result", "geometrically", "nice", "scale-free", "energy", "Edge", "vertex", "weight", "Edge", "weight", "ij", "vertex", "weight", "should", "set", "suitably", "encode", "geometry", "mesh", "accomplish", "we", "use", "follow", "scheme", "Conceptually", "we", "can", "think", "each", "triangle", "be", "divide", "quadrilateral", "edge", "which", "connect", "midpoint", "each", "edge", "barycenter", "triangle", "once", "we", "have", "successfully", "compute", "intersection", "curve", "correct", "parity", "field", "we", "have", "all", "datum", "necessary", "actually", "change", "topology", "surface", "we", "complete", "change", "four", "step", "decide", "which", "curve", "resolve", "when", "begin", "step", "we", "have", "all", "intersection", "curve", "already", "detect", "first", "we", "group", "intersection", "curve", "connected", "component", "any", "connected", "component", "intersection", "which", "adjacent", "only", "even", "only", "odd", "parity", "region", "remove", "from", "consideration", "-lrb-", "i.e.", "leave", "un-subdivided", "-rrb-", "intersection", "vertex", "insert", "midway", "along", "each", "edge", "we", "examine", "all", "triangle", "untouch", "intersection", "curve", "both", "even", "odd", "parity", "vertex", "we", "introduce", "false", "intersection", "edge", "connect", "vertex", "-lrb-", "note", "result", "false", "intersection", "curve", "terminate", "just", "before", "enter", "triangle", "contain", "actual", "intersection", "curve", "produce", "slight", "gap", "curve", "separate", "even", "odd", "parity", "closing", "gap", "explicitly", "involve", "more", "complex", "geometric", "reasoning", "instead", "we", "fix", "up", "minor", "shortcoming", "post-process", "after", "subdivide", "-rrb-", "subdivide", "mesh", "we", "solve", "constrain", "triangulation", "problem", "triangle-by-triangle", "basis", "we", "accumulate", "all", "point", "edge", "intersection", "lie", "each", "triangle", "run", "Shewchuk?s", "Triangle", "-lsb-", "1996", "-rsb-", "produce", "constrain", "triangulation", "except", "false", "intersection", "curve", "insert", "during", "step", "intersection", "necessarily", "lie", "two", "different", "part", "surface", "delete", "triangle", "odd", "parity", "finally", "we", "back", "normal", "mesh", "without", "intersection", "curve", "occur", "two", "sub-step", "first", "observe", "triangle", "subdivision", "can", "have", "both", "odd", "even", "parity", "vertex", "after", "subdivision", "because", "we", "insert", "some", "kind", "intersection", "vertex", "every", "edge", "original", "mesh", "opposite", "parity", "endpoint", "take", "advantage", "observation", "we", "decide", "parity", "majority", "triangle", "simply", "copy", "value", "from", "vertex", "triangle", "still", "undecided", "end", "process", "mark", "even", "parity", "finally", "odd", "parity", "triangle", "delete", "demonstrate", "we", "method", "topology", "change", "we", "construct", "rudimentary", "surface", "deformation", "modeler", "-lrb-", "see", "supplementary", "material", "-rrb-", "modeler", "equip", "four", "brush", "inflate/deflate", "paint", "cause", "instantaneous", "displacement", "direction", "surface", "normal", "smooth", "paint", "cause", "instantaneous", "explicit", "laplacian", "smooth", "Grab", "hold", "onto", "part", "surface", "-lrb-", "distance-based", "falloff", "influence", "-rrb-", "drag", "around", "move", "hold", "onto", "entire", "connected", "component", "surface", "rigidly", "drag", "around", "between", "every", "pair", "frame", "we", "run", "edge-based", "-lrb-", "split/collapse", "-rrb-", "remeshing", "algorithm", "dynamically", "adapt", "mesh", "resolution", "inflate", "smooth", "brush", "we", "incorporate", "topology", "change", "obvious", "manner", "between", "every", "pair", "frame", "-lrb-", "before", "remesh", "-rrb-", "we", "run", "we", "algorithm", "do", "so", "produce", "instantaneous", "topology", "change", "grab", "move", "brush", "user", "interaction", "often", "involve", "exploration", "different", "option", "drag", "through", "they", "while", "mouse", "depress", "we", "run", "collision", "detection", "each", "frame", "accumulate", "new", "collision", "run", "tally", "keep", "raw", "parity", "field", "only", "when", "mouse", "release", "do", "we", "execute", "full", "topology", "change", "algorithm", "-lrb-", "use", "accumulate", "raw", "parity", "-rrb-", "commit", "result", "sense", "we", "can", "think", "parity", "be", "backwards-compatible", "semantically?with", "prior", "work", "order", "allow", "more", "formal", "exploration", "claim", "we", "restrict", "we", "attention", "case", "solid", "surface", "where", "all", "method", "behavior", "well", "define", "give", "restricted", "setting", "we", "can", "make", "follow", "claim", "proposition", "5.3", "-lrb-", "informal", "-rrb-", "appendix", "we", "formalize", "final", "proposition", "more", "precise", "claim", "from", "which", "first", "two", "claim", "follow", "corollary", "total", "argument", "serve", "establish", "notion", "soundness", "we", "method", "solid", "surface", "handle", "expect", "addition", "formal", "argument", "we", "also", "measure", "time", "space", "usage", "we", "prototype", "system", "code", "system", "be", "make", "available", "under", "LGPL", "we", "able", "operate", "mesh", "up", "10", "000", "triangle", "interactive", "rate", "use", "less", "than", "120mb", "RAM", "majority", "time", "spend", "compute", "intersection", "collision", "detection", "so", "we", "expect", "method", "can", "scale", "larger", "mesh", "through", "use", "more", "aggressive", "acceleration", "structure", "point", "comparison", "grid-based", "method", "use", "Wojtan", "et", "al.", "-lsb-", "2009", "-rsb-", "can", "use", "interactive", "sculpting", "solid", "surface", "up", "40", "000", "triangle", "Mr.", "potato", "head", "modeling", "part", "assembly", "-lrb-", "figure", "-rrb-", "very", "easy", "use", "modeler", "can", "build", "around", "idea", "assemble", "model", "from", "exist", "part", "-lsb-", "Chaudhuri", "et", "al.", "2011", "Schmidt", "Singh", "2010", "Hecker", "et", "al.", "2008", "-rsb-", "modeler", "depend", "some", "algorithm", "allow", "user", "join", "various", "part", "together", "method", "like", "one", "use", "Mesh", "Mixer", "-lsb-", "Schmidt", "Singh", "2010", "-rsb-", "require", "target", "surface", "patch", "manifold", "disk-like", "-lrb-", "i.e.", "simply", "connect", "-rrb-", "part/surface", "be", "attach", "have", "single", "loop", "boundary", "which", "can", "stitch", "disk", "contrast", "method", "present", "here", "enable", "attachment", "part", "side", "effect", "when", "use", "we", "move", "tool", "unlike", "more", "specialized", "algorithm", "ours", "universally", "applicable", "allow", "any", "two", "surface", "become", "attach", "wherever", "user", "desire", "pinch", "closing", "-lrb-", "figure", "10", "-rrb-", "many", "brush", "mesh", "sculpting", "program", "may", "cause", "surface", "become", "pinch", "instance", "paint", "crease", "surface", "displacement", "along", "normal", "-lrb-", "inflate", "-rrb-", "brush", "often", "cause", "surface", "pinch", "when", "topology", "change", "add", "system", "pinch", "correctly", "delete", "close", "up", "ensure", "surface", "remain", "well", "behave", "successive", "operation", "apply", "near", "crease", "Paper", "mache", "-lrb-", "figure", "11", "-rrb-", "while", "design", "purpose", "topology", "change", "can", "use", "join", "two", "surface", "slot", "one", "other", "conjunction", "laplacian", "smoothing", "brush", "surface", "can", "join", "smooth", "together", "one", "be", "paper", "mache-ing", "object", "more", "complex", "example", "-lrb-", "figure", "12", "-rrb-", "example", "exhibit", "model", "cow", "two", "wing", "consist", "about", "25,000", "triangle", "total", "cow", "model", "purchase", "colleague", "part", "mesh", "set", "provide", "cow", "model", "compose", "hundred", "disconnect", "mesh", "component", "many", "which", "intersect", "each", "other", "needless", "say", "present", "challenging", "case", "topology", "change", "representative", "issue", "which", "arise", "practice", "nevertheless", "we", "method", "able", "successfully", "join", "wing", "cow", "body", "formal", "property", "we", "method", "prove", "continuous", "setting", "however", "discretization", "parity", "field", "which", "we", "use", "-lrb-", "sampling", "only", "mesh", "vertex", "-rrb-", "can", "miss", "important", "collision", "instance", "when", "cylinder", "plunge", "single", "large", "triangle", "-lrb-", "figure", "13", "-rrb-", "parity", "sample", "lie", "triangle", "within", "cylinder", "result", "incorrect", "topology", "change", "shortcoming", "can", "eliminate", "adaptively", "refine", "mesh", "response", "collision", "particular", "scenario", "we", "give", "add", "single", "vertex", "large", "triangle", "-lrb-", "place", "inside", "cylinder", "-rrb-", "would", "result", "correct", "topology", "change", "order", "keep", "we", "prototype", "implementation", "simpler", "we", "choose", "address", "issue", "we", "have", "show", "some", "example", "we", "method", "deal", "multiple", "disconnect", "mesh", "component", "-lrb-", "figure", "12", "-rrb-", "we", "method", "able", "successfully", "handle", "some", "case", "arbitrary", "triangle", "soup", "may", "still", "pose", "problem", "because", "error", "correction", "algorithm", "section", "3.4", "assume", "connected", "graph", "we", "method", "design", "general", "purpose", "use", "tailor", "specific", "application", "unfortunately", "choice", "also", "lead", "unexpected", "behavior", "some", "more", "specific", "context", "instance", "when", "assemble", "model", "from", "exist", "part", "some", "those", "part", "have", "open", "boundary", "side", "where", "attach", "take", "another", "example", "when", "mimic", "paper", "mache", "process", "bring", "two", "sheet", "together", "often", "create", "tunnels/holes", "process", "connect", "two", "surface", "another", "issue", "arrise", "when", "self-intersecting", "geometry", "begin", "move", "currently", "we", "do", "resolve", "self-intersection", "so", "long", "remain", "static", "however", "once", "intersect", "portion", "surface", "begin", "move", "result", "raw", "parity", "field", "may", "overwhelm", "suppressing", "effect", "error", "correction", "cause", "hole", "open", "mesh", "result", "when", "discuss", "system", "other", "we", "repeatedly", "receive", "opinion", "we", "system", "-lrb-", "variant", "-rrb-", "produce", "intuitive", "unintuitive", "behavior", "frequently", "we", "would", "receive", "both", "opinion", "about", "same", "example", "when", "we", "restrict", "ourselves", "case", "solid", "object", "disagreement", "disappear", "non-solid", "case", "disagreement", "common", "some", "shortcoming", "could", "probably", "address", "-lrb-", "least", "particular", "case", "-rrb-", "specialize", "hack", "however", "from", "we", "experience", "experiment", "error", "correction", "scheme", "we", "observe", "fix", "one", "problem", "generate", "host", "other", "interest", "keep", "we", "approach", "simple", "focus", "we", "choose", "explore", "complicate", "fix", "some", "issue", "like", "those", "paper", "mache-ing", "go", "beyond", "hack", "case", "different", "kind", "topology", "change", "different", "behavior", "might", "more", "appropriate", "consider", "behavior", "soap", "film", "when", "two", "soap", "bubble", "collide", "low", "speed", "rather", "than", "annihilate", "each", "other", "two", "collide", "surface", "merge", "single", "interface", "example", "like", "one", "suggest", "multiple", "different", "kind", "topology", "change", "behavior", "necessary", "satisfy", "user", "expectation", "closed", "cylinder", "plunge", "downward", "through", "single", "giant", "triangle", "-lrb-", "left", "-rrb-", "because", "parity", "sample", "triangle", "itself", "we", "algorithm", "do", "properly", "delete", "hole", "cause", "cylinder", "instead", "cause", "non-manifold", "junction", "between", "both", "model", "-lrb-", "right", "-rrb-", "we", "method", "do", "require", "input", "mesh", "represent", "solid", "object", "so", "more", "widely", "applicable", "than", "most", "exist", "algorithm", "further", "improve", "method?s", "reliability", "we", "provide", "novel", "error", "correction", "mechanism", "both", "handle", "poor-quality", "mesh", "tolerate", "inaccuracy", "collision", "detection", "computation", "because", "we", "method", "error-tolerant", "applicable", "wide", "range", "potential", "input", "we", "believe", "can", "integrate", "nicely", "geometric", "modeling", "application", "future", "algorithm?s", "efficiency", "simplicity", "allow", "topology", "change", "happen", "naturally", "any", "deformation", "tool", "instead", "need", "explicitly", "effect", "through", "special", "tool", "consequence", "ease", "integration", "we", "believe", "we", "method", "have", "potential", "significantly", "improve", "standard", "work", "flow", "geometric", "modeler", "once", "user", "understand", "general", "idea", "behavior", "like", "topology", "change", "how", "different", "tool", "can", "use", "deform", "surface", "can", "discover", "new", "strategy", "through", "exploration", "continue", "use", "tool", "less", "likely", "lead", "user", "discover", "serendipitous", "use", "combination", "we", "see", "we", "method", "way", "easily", "incorporate", "topology", "change", "3d", "modeler", "similar", "way", "Harmon", "et", "al.", "-lsb-", "2011", "-rsb-", "incorporate", "collision", "detection", "response", "we", "suspect", "line", "thinking", "may", "lead", "further", "innovation", "3d", "modeling", "tool", "how", "can", "we", "incorporate", "more", "behavior", "-lrb-", "e.g.", "topology", "change", "collision", "response", "-rrb-", "natural", "otherwise", "compound", "effect", "we", "tool", "how", "few", "tool", "behavior", "can", "we", "use", "build", "parsimonious", "compelling", "flexible", "modeling", "system", "most", "all", "we", "would", "like", "thank", "Zoran", "Popovic", "he", "help", "guidance", "earlier", "iteration", "research", "thank", "you", "researcher", "involve", "compile", "maintain", "both", "Brown", "Mesh", "set", "Princeton", "shape", "Benchmark", "thank", "you", "also", "Siddhartha", "Chaudhuri", "provide", "cow", "model", "we", "use", "research", "support", "via", "NSF", "grfp", "dge-0718124", "active", "technique", "ACM", "Press/Addison-Wesley", "Publishing", "Co.", "New", "York", "NY", "USA", "SIGGRAPH", "99", "409", "416", "T.", "2009", "fix", "geometric", "error", "polygonal", "model", "survey", "J.", "Comput", "24", "-lrb-", "Jan.", "-rrb-", "19", "29", "uire", "M.", "2004", "observation", "silhouette", "size", "journal", "graphic", "gpu", "game", "tool", "12", "ojang", "2013", "Minecraft", "ixologic", "2013", "Sculptris", "ixologic", "2013", "equicha", "a.", "A.", "G.", "1977", "mathematical", "model", "rigid", "solid", "object", "Rep.", "TM-28", "Production", "Automation", "Project", "University", "Rochester", "Rochester", "New", "York", "14627", "November", "chmidt", "R.", "INGH", "K.", "2010", "meshmixer", "interface", "rapid", "mesh", "composition", "ACM", "SIGGRAPH", "2010", "talk", "ACM", "New", "York", "NY", "USA", "SIGGRAPH", "10", "6:1", "6:1", "eidel", "R.", "1994", "nature", "meaning", "perturbation", "geometric", "computing", "stac", "94", "Proceedings", "11th", "springer-verlag", "London", "UK", "17", "hewchuk", "J.", "R.", "1996", "triangle", "Engineering", "2d", "quality", "mesh", "generator", "delaunay", "triangulator", "selected", "papers", "from", "metric", "Engineering", "Springer-Verlag", "London", "UK", "UK", "FCRC", "96/wacg", "96", "203", "222", "hewchuk", "J.", "R.", "1997", "adaptive", "precision", "Floating-Point", "Arithmetic", "fast", "robust", "geometric", "predicate", "Discrete", "Computational", "Geometry", "18", "-lrb-", "Oct.", "-rrb-", "305", "363", "anculescu", "L.", "HAINE", "R.", "anus", "m.-p", "2011", "Smi", "2011", "full", "paper", "Freestyle", "sculpt", "mesh", "self-adaptive", "topology", "35", "-lrb-", "June", "-rrb-", "614", "622", "eschner", "M.", "EIDELBERGER", "B.", "ANOCHA", "D.", "OVIN", "DARAJU", "N.", "ACHMANN", "G.", "IMMERLE", "S.", "ezger", "J.", "uhrmann", "a.", "2005", "Collision", "handle", "dynamic", "simulation", "environment", "eurographic", "2005", "Tutorial", "Notes", "ALD", "I.", "2007", "fast", "construction", "sah-based", "bound", "volume", "hierarchy", "Proceedings", "2007", "IEEE", "Symposium", "Interactive", "Ray", "Tracing", "IEEE", "Computer", "Society", "Washington", "DC", "USA", "rt", "07", "33", "40", "OJTAN", "C.", "urey", "N.", "ROSS", "M.", "urk", "G.", "2009", "deform", "mesh", "split", "merge", "SIGGRAPH", "09", "ACM", "SIGGRAPH", "2009", "papers", "ACM", "New", "York", "NY", "USA", "10", "OJTAN", "C.", "urey", "N.", "ROSS", "M.", "urk", "G.", "2010", "physics-inspired", "topology", "change", "thin", "fluid", "feature", "SIGGRAPH", "10", "ACM", "SIGGRAPH", "2010", "papers", "ACM", "New", "York", "NY", "USA", "aharescu", "a.", "oyer", "E.", "oraud", "R.", "2011", "topologyadaptive", "mesh", "deformation", "surface", "evolution", "morph", "multiview", "reconstruction", "IEEE", "transaction", "Pattern", "Analysis", "Machine", "Intelligence", "33", "823", "837", "give", "point", "triangle", "-lrb-", "-rrb-", "motion", "from", "from", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "point", "collide", "triangle?s", "plane", "whenever", "triple", "product", "vanish", "produce", "cubic", "equation", "whose", "root", "find", "via", "interval", "search", "candidate", "intersection", "point", "test", "containment", "triangle", "time", "interval", "-lrb-", "-rrb-", "Standard", "floating-point", "arithmetic", "use", "exact", "method", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "could", "use", "instead", "avoid", "inaccuracy", "due", "floatingpoint", "unnecessary", "due", "error", "correction", "quadratic", "energy", "use", "during", "error", "correction", "minimize", "solve", "linear", "equation", "ax", "use", "sparse", "cholesky", "solver", "system", "can", "set", "up", "use", "follow", "formula", "-lrb-", "-rrb-", "cut", "ij", "ij", "otherwise", "ii", "ij", "ij", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "cut", "we", "begin", "define", "and/or", "recall", "few", "concept", "relate", "point", "polygon", "test", "after", "we", "present", "lemma", "corollary", "recall", "every", "solid", "surface", "-lrb-", "closed", "non-self-intersecting", "-rrb-", "have", "canonical", "normal", "field", "normal", "point", "outward", "-lrb-", "2.1", "-rrb-", "follow", "we", "assume", "all", "solid", "surface", "equip", "canonical", "normal", "field", "furthermore", "we", "assume", "every", "surface", "begin", "end", "its", "motion", "general", "position", "we", "make", "assumption", "here", "simplify", "analysis", "we", "code", "we", "use", "perturbation", "exact", "geometric", "predicate", "treat", "general", "positionrelated", "issues?we", "do", "ignore", "they", "give", "closed", "surface", "equip", "normal", "field", "we", "define", "containment", "number", "-lrb-", "-rrb-", "point", "surface", "follow", "Select", "any", "continuous", "path", "start", "diverge", "towards", "infinity", "path", "never", "cross", "surface", "-lrb-", "-rrb-", "otherwise", "we", "may", "compute", "-lrb-", "-rrb-", "follow", "procedure", "-lrb-", "-rrb-", "trace", "along", "path", "beginning", "p.", "every", "time", "path", "cross", "surface", "increment", "containment", "number", "we", "cross", "surface", "same", "direction", "surface", "normal", "decrement", "containment", "number", "we", "cross", "opposite", "direction", "closed", "surface", "quantity", "compute", "procedure", "invariant", "choice", "path", "surface", "move", "containment", "number", "preserve", "so", "long", "surface", "do", "pass", "over", "p.", "so", "surface", "move", "adjust", "containment", "number", "only", "pass", "over", "rule", "update", "derive", "from", "above", "definition", "surface", "pass", "over", "travel", "direction", "its", "surface", "normal", "containment", "number", "increment", "otherwise", "decrement", "2d", "containment", "number", "equivalent", "wind", "number", "curve", "containment", "number", "can", "use", "classify", "space", "around", "surface", "space", "contain", "inside", "surface", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "space", "outside", "surface", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "binary", "interpretation", "containment", "number", "suffice", "solid", "surface", "we", "consider", "two", "possible", "extension", "self-intersecting", "close", "surface", "sign", "interpretation", "say", "point", "inside", "-lrb-", "-rrb-", "outside", "-lrb-", "-rrb-", "modulo", "interpretation", "say", "point", "inside", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "inside", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "two", "interpretation", "sign", "interpretation", "probably", "more", "natural", "however", "without", "argue", "relative", "merit", "we", "can", "observe", "so", "long", "-lrb-", "-rrb-", "-lcb-", "-rcb-", "both", "interpretation", "agree", "-lrb-", "i.e.", "so", "long", "containment", "number", "deviate", "most", "one", "from", "expect", "value", "-rrb-", "Proof", "sketch", "consider", "point", "surface", "undergo", "deformation", "point", "displaced", "infinitesimally", "away", "from", "normal", "direction", "point", "displaced", "infinitesimally", "far", "away", "from", "opposite", "direction", "before", "surface", "begin", "move", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "during", "movement", "collide", "other", "piece", "surface", "even", "odd", "number", "time", "collide", "even", "number", "time", "containment", "number", "must", "both", "change", "same", "amount", "some", "multiple", "say", "2k", "so", "either", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "under", "modulo", "interpretation", "containment", "number", "mean", "either", "outside", "while", "inside", "vice-versa", "so", "under", "modulo", "interpretation", "we", "would", "choose", "delete", "point", "surface", "which", "collide", "even", "number", "time", "collide", "odd", "number", "time", "containment", "number", "must", "both", "change", "same", "amount", "2k", "so", "either", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "while", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "under", "modulo", "interpretation", "containment", "number", "mean", "either", "both", "inside", "both", "outside", "either", "case", "we", "would", "choose", "delete", "since", "do", "serve", "separate", "inside", "from", "outside", "first", "theorem", "-lrb-", "5.1", "-rrb-", "follow", "directly", "from", "lemma", "since", "we", "just", "demonstrate", "parity", "base", "topology", "change", "can", "interpret", "provide", "inside/outside", "classification", "closed", "surface", "corollary", "8.2", "-lrb-", "Theorem", "5.2", "-rrb-", "consider", "two", "solid", "mesh", "undergo", "independent", "rigid", "motion", "when", "do", "move", "every", "point", "space", "either", "outside", "both", "mesh", "inside", "one", "mesh", "inside", "both", "thus", "-lrb-", "-rrb-", "-lcb-", "-rcb-", "under", "modulo", "interpretation", "containment", "number", "we", "interpret", "value", "outside", "both", "inside", "leverage", "lemma", "8.1", "we", "know", "compute", "parity-based", "topology", "change", "yield", "solid", "mesh", "under", "modulo", "interpretation", "therefore", "result", "mesh", "represent", "boolean", "union", "two", "solid", "mesh", "question", "finally", "extent", "we", "willing", "accept", "informal", "proposition", "-lrb-", "i.e.", "observation", "-rrb-", "-lrb-", "-rrb-", "often", "confine", "set", "value", "-lcb-", "-rcb-", "we", "observe", "compute", "paritybased", "topology", "change", "initially", "solid", "surface", "often", "yield", "same", "result", "under", "sign", "interpretation", "containment", "number" ],
  "content" : "We prove that this new method for topology change produces the expected conventional results when applied to solid (closed, manifold, non-self-intersecting) surfaces?that is, we prove a backwardscompatibility property relative to prior work. Finally, we demonstrate how topology change applied to non-solid objects enables wholly new and useful behaviors. Contributions We provide the first method for topology change applicable to arbitrary non-solid, non-manifold, non-closed, selfintersecting surfaces. We prove that this new method produces expected, conventional results when applied to solid (closed, manifold, non-self-intersecting) surfaces?that is, we prove a backwards-compatibility property relative to prior work. Beyond solid surfaces, we present empirical evidence that our method remains tolerant to a variety of surface aberrations through the incorporation of a novel error correction scheme. Finally, we demonstrate how topology change applied to non-solid objects enables wholly new and useful behaviors. An edge of the mesh is manifold if it has We prefer to use solid, since the definition of watertight is inconsistent and imprecise across the literature. Outside the class of solid meshes, we say that a mesh is unoriented if any pair of triangles sharing a manifold edge are oriented facing opposite directions. There are some meshes which are inherently non-orientable, the most famous example being a M?bius band. 2.2 Why Aren?t All Meshes Solid? To demonstrate this fact, we ran statistics on the Brown mesh set [McGuire 2004]: less than 25% (263/1136) of the meshes were closed manifolds, and over 40% (472/1136) were neither manifold, nor closed; over 90% (1046/1136) were self-intersecting. This can be accomplished through converting the surface into an implicit function representation [Wojtan et al. 2009; Wojtan et al. 2010], into a BSP-based volume representation [Campen and Kobbelt 2010] or by marching around the outside of the mesh, using normals [Zaharescu et al. 2011]. All of these techniques are used to infer a volumetric interpretation (inside vs. outside) of the mesh and discard those parts of the surface which are not necessary to enclose the inferred volume. Brochu & Bridson use a combination of collision detection, local remeshing, and time-step control to get the surfaces of the mesh close but not touching, allowing for a tunnel to be stitched. Similarly, St anculescu et al. tightly control the size of both mesh elements and time-steps in order to create safe conditions for tunnel stitching. However, nei- ther of these constraints are necessarily true in a modeling system, as evidenced by our ?grab? brush(?4). In contrast to prior work, we make no special assumptions about what kinds of meshes our algorithm is presented with. Our approach to topology change relies on existing, well understood computations as components: collision detection, static intersection identification, and triangulation. We string these components together in order to compute a parity field over the mesh, recording the parity of the number of times that point collided with the surface during the given motion. Throughout this process we store an approximation to this (conceptually) continuous field by sampling its value at mesh vertices. As input for our algorithm, we require a triangle mesh at the initial time/frame and a linear displacement of vertices transporting the mesh to its position at the final time/frame. If we only worked with solid surfaces, this raw field would suffice, but because we expect our mesh to exhibit aberrations or other shortcomings we treat the raw parity field as if it has some (relatively) small number of corrupted entries. This results in our final output mesh with suitably altered topology. Our method for topology change relies on knowing the parity of the number of collisions each vertex makes with the rest of the surface. For every vertex of the mesh and every triangle not containing that vertex, we compute the roots of the usual cubic equation (Appendix A) and the associated barycentric coordinates, and we use them to determine whether any collisions occurred. We arrive at the desired collision parity value by accumulating the results of this computation for each vertex across all potentially intersecting triangles. We build this AABVH over the line segments traced out by the moving vertices. At each node, a dimension (x, y, or z) is selected and the geometry is rearranged via a quick select search for the median. The build then recurses on the two halves. The resulting build algorithm takes time comparable to a quick sort of the geometry and consumes a small fraction (10%) of the total time spent performing collision detection. Since no heuristics are used to ensure a quality acceleration structure, and since we don?t make use of narrow-phase collision culling techniques, we expect that the overall cost of collision detection could be significantly improved by just applying existing methods [Teschner et al. 2005]. Nonetheless, this simple strategy suffices to demonstrate our prototype. When used in applications like cloth simulation, accurate collision detection becomes critical to keep surfaces from snagging on themselves. Here we only need an approximation to the parity field that we compute from collision detection. Unless we are presented  with a highly degenerate motion (e.g. the collision of two perfectly aligned grids) these numeric errors are rare. To help ensure that they remain rare, we apply a slight perturbation (similar to perturbations for the intersection computation in the following section). Once the mesh has reached its final position at the end of a frame of movement, we determine the region where the final mesh statically intersects itself. We find these static intersection curves for two reasons: First, this information is used to guide the error correction procedure. Secondly, the intersection curves are used to cleanly segment the mesh into preserved and deleted portions. We find the intersection curves in three steps. First, we identify all edge-triangle intersection points present. Second, we infer the set of all intersection edges from these points. To efficiently find edge-triangle intersections, we use a second AABVH, like the one computed for collision detection, this time built over the edges of the mesh. Triangles are streamed over this structure and tested for intersection with the edges they encounter. For each intersecting edge-triangle pair (e, t), we collect the set of triangles t i with e as an edge. Then, emanating from the point where e and t intersect, there must be exactly one intersection edge on t for each triangle t i , which is uniquely identified by the pair {t, t i }. We accumulate all such pairs identified via this combinatorial generation procedure and eliminate duplicates to form a set of triangle-triangle intersection edges. Triangle-triangle-triangle intersection candidates are rare, so this step takes a negligible amount of time. Geometric robustness Unfortunately, unlike collisions, we rely on robustly computed intersections. If these curves reveal any inconsistencies, then the subdivision algorithm could segmentation fault or produce non-sensical output. To ensure consistent results from our intersection computation at a reasonable overhead, we use a variety of techniques from robust geometric computation. First, we use floating point filters [Shewchuk 1997] to efficiently decide the results of most intersection predicates. When these filters fail, we fallback to exact big number arithmetic, ensuring that all predicates are correctly computed. On our test cases with highly degenerate geometry, this strategy sufficed to eliminate degeneracies after a single perturbation. One strategy is suppressing outliers in the parity field through majority voting. We split them surface into connected components using the static intersection curves (computed at the mesh?s final position) and vote within each component independently. Concretely, we take the vertex-edge graph given by the triangle mesh and remove all edges which are cut by some intersection curve. Within each component, a vertex gets one vote with weight proportional to the area of the surface that it represents. Majority voting works well when the intersection curves neatly partition the surface into primarily odd or even components. However, when the user manipulates an open surface near its boundary (Figure 7), the resulting intersections rarely partition the surface nicely. Graph partitioning algorithms label the vertices of a graph with one of two possible labels, splitting the graph. In image segmentation, labels such as foreground/background are used; here we compute even/odd parity labels. The desired labeling is found by solving an optimization problem with both a binary ?smoothness? term (minimizing the size of the cut between the two regions) and a unary ?accuracy? term. (deviation from the raw parity field) Vision researchers have ex plored a range of different formulations and algorithms for graph partitioning [Boykov et al. 2001; Grady and Schwartz 2006]. Following previous examples, we can formulate our graph partitioning problem as follows: (Here and for the remainder of this section, we let r i denote the value of the raw parity field at vertex i, and x i denote the continuous error corrected value which we solve for. E o denotes only those edges of the triangle mesh which are not already cut by an intersection edge. Edge and vertex weights (w ij , w i ) are explained at the end of this section.) The energy in equation 3.1 can be optimized by solving a linear system and rounding all x i > 0 to 1; x i < 0 to ?1. Alternatively, the energy can be optimized using a min-cut algorithm [Boykov et al. 2001]. We tried both approaches. On the one hand, we want to ensure that the solution boundary between the even and odd portions of the surface is smooth (low ?). However, when ? is set too low, accuracy will be ignored. Every setting would break some test case. Further complications arose when we tried to apply the min-cut algorithm. Although we were able to get reasonable results on most test cases, ignoring edges cut by intersections led to failed cases. In the following, we will see how both prying apart values near the intersections (eq. 3.2) and penalizing unused intersections (eq. The resulting field encodes a constrained set of possible cuts in the form of its isocontours. By re-introducing a stronger accuracy term only after we reach this second stage, we ensure a reasonable degree of accuracy while simultaneously guaranteeing smoothness. In stage 1, we minimize the following quadratic energy within each connected-component: (Appendix B explains how this problem is solved in more detail.) Unfortunately, since we make ? small (= 10 ?3 ) the solved values x will be unreliably small. To avoid this problem, we introduce a few extra binary terms. The extra terms pry apart the values of x on opposite sides of the intersection curve, using the observed difference in the raw parity field. Aside from our dependence on Unfortunately, this heuristic term is necessarily asymmetric, allowing it to be compromised when there are a sizable number of raw parity errors near the intersection curves. In stage 2, we sort the vertices by their x values and perform a sweep cut to determine the rounding threshold x 0 . We begin with x 0 below all x i and ?sweep? upwards until x 0 is greater than all x i . We select whichever x 0 minimizes the cut energy: ? i?V w i 1[r i = y i ] 2 (i, j) ? E c and y i = y j or + (i,j)?E w ij 1 (i, j) ? E o and y i = y j (3.3) (where y i is the rounded value of x i and 1[?] is an indicator function.) Note that we penalize both newly introduced boundary (i, j) ? E o , as well as unused intersections (i, j) ? E c . This results in a geometrically nice, scale-free energy. Edge and vertex weights Edge weights w ij and vertex weights w i should be set to suitably encode the geometry of the mesh. To accomplish this, we use the following scheme: Conceptually, we can think of each triangle as being divided into 3 quadrilaterals by edges which connect the midpoint of each edge to the barycenter of the triangle. Once we have successfully computed intersection curves and a corrected parity field, we have all the data necessary to actually change the topology of the surface. We complete this change in four steps: 1. Decide which curves to resolve. When beginning this step, we have all of the intersection curves already detected. First, we group the intersection curves into connected components. Any connected component of intersections which is adjacent to only even or only odd parity regions is removed from consideration (i.e. it will be left un-subdivided). ?Intersection? vertices are inserted midway along each of these edges. Then, we examine all triangles untouched by an intersection curve, but with both even and odd parity vertices. We then introduce a false ?intersection? edge connecting these vertices. (Note that the resulting false intersection curves will terminate just before entering a triangle containing an actual intersection curve. This produces slight gaps in the curve separating even and odd parity. Closing these gaps explicitly involves more complex geometric reasoning. Instead, we will fix up this minor shortcoming with a post-process after subdividing.) 2. Subdivide the mesh. We solve a constrained triangulation problem on a triangle-by-triangle basis. We accumulate all of the points and edges of intersection lying on each triangle and run Shewchuk?s Triangle[1996] to produce a constrained triangulation. Except for the false intersection curves inserted during step 1, intersections necessarily lie on two different parts of the surface. Delete triangles with odd parity. Finally, we are back to a normal mesh without intersection curves. This occurs in two sub-steps. First, observe that no triangle in the subdivision can have both odd and even parity vertices after subdivision. This is because we inserted some kind of intersection vertex into every edge of the original mesh with opposite parity endpoints. Taking advantage of this observation, we decide the parity of the majority of triangles by simply copying values from the vertices. Triangles still undecided at the end of this process are marked with even parity. Finally, the odd parity triangles are deleted. To demonstrate our method of topology change, we constructed a rudimentary surface deformation modeler (See supplementary material). This modeler is equipped with four brushes: Inflate/Deflate paint to cause instantaneous displacement in the direction of the surface normal Smooth paint to cause instantaneous explicit Laplacian smoothing Grab hold onto part of the surface (with a distance-based falloff in influence) and drag it around Move hold onto an entire connected component of the surface rigidly and drag it around Between every pair of frames we run an edge-based (split/collapse) remeshing algorithm to dynamically adapt mesh resolution. For the inflate and smooth brushes, we incorporate topology change in the obvious manner. Between every pair of frames (before remeshing) we run our algorithm. Doing so produces instantaneous topology change. For the grab and move brushes, user interaction often involves the exploration of different options by dragging through them. While the mouse is depressed, we run collision detection each frame, accumulating new collisions into the running tally kept by the raw parity field. Only when the mouse is released do we execute the full topology change algorithm (using the accumulated raw parity) and commit the result. In this sense, we can think of parity as being backwards-compatible?semantically?with prior work. In order to allow for a more formal exploration of this claim, we restrict our attention to the case of solid surfaces, where all methods? behaviors are well defined. Given this restricted setting, we can make the following claims. Proposition 5.3 (informal). In Appendix C, we formalize the final proposition in to a more precise claim, from which the first two claims follow as corollaries. In total, this argument serves to establish a notion of soundness for our method: solid surfaces are handled as expected. In addition to formal arguments, we also measured the time and space usage of our prototype system. The code for this system is being made available under the LGPL. We are able to operate on meshes of up to ? 10, 000 triangles at interactive rates using less than 120MB RAM. The majority of time is spent computing intersections and collision detection, so we expect that the method can be scaled to larger meshes through the use of more aggressive acceleration structures. As a point of comparison, the grid-based method used by Wojtan et al. [2009] can be used for interactive sculpting of solid surfaces with up to ? 40, 000 triangles. Mr. potato head modeling ? part assembly ( Figure 9 ) Very easy to use modelers can be built around the idea of assembling a model from existing parts [Chaudhuri et al. 2011; Schmidt and Singh 2010; Hecker et al. 2008]. Such modelers depend on some algorithm to allow users to join various parts together. Methods like the one used in Mesh Mixer [Schmidt and Singh 2010] require that the target surface patch be manifold and disk-like (i.e. simply connected), and that the part/surface being attached has a single loop boundary which can be stitched into this disk. By contrast the method presented here enables the attachment of parts as a side effect when used with our move tool. Unlike the more specialized algorithms, ours is universally applicable, allowing any two surfaces to become attached wherever the user desires. Pinch closing ( Figure 10 ) Many brushes in mesh sculpting programs may cause the surface to become pinched. For instance, painting a crease in the surface with a displacement along normal (?inflate?) brush often causes the surface to pinch. When topology change is added to the system, these pinches are correctly deleted as they close up. This ensures that the surface remains well behaved as successive operations are applied near the crease. Paper mache ( Figure 11 ) While not designed for this purpose, topology change can be used to join two surfaces by slotting one into the other. In conjunction with a Laplacian smoothing brush, surfaces can be joined and smoothed together as if one were paper mache-ing an object. More complex example ( Figure 12 ) This example exhibits models of a cow and two wings consisting of about 25,000 triangles in total. This cow model was purchased by a colleague as part of a mesh set. As provided, the cow model is composed of hundreds of disconnected mesh components, many of which intersect each other. Needless to say, this presents a challenging case for topology change, representative of the issues which arise in practice. Nevertheless, our method is able to successfully join the wing to the cow body. Formal properties of our method are proven for the continuous setting. However, the discretization of the parity field which we use (sampling only at mesh vertices) can miss important collisions. For instance, when a cylinder is plunged into a single large triangle ( Figure 13 ), no parity samples lie on the triangle, within the cylinder. The result is incorrect topology change. This shortcoming can be eliminated by adaptively refining the mesh in response to collisions. In the particular scenario we give, adding a single vertex to the large triangle (placed inside the cylinder) would result in correct topology change. In order to keep our prototype implementation simpler, we chose not to address this issue. We have shown some examples of our method dealing with multiple disconnected mesh components (Figures 8 and 12). Our method is able to successfully handle some of these cases, but arbitrary triangle soups may still pose a problem because the error correction algorithm in Section 3.4 assumes a connected graph. Our method is designed for general purpose use, not tailored to specific applications. Unfortunately, this choice also leads to unexpected behavior in some more specific contexts. For instance, when assembling models from existing parts, some of those parts will have open boundaries on the side where they are attached. To take another example, when mimicking a paper mache process, bringing two sheets together will often create tunnels/holes in the process of connecting the two surfaces. Another issue arrises when self-intersecting geometry begins to move. Currently, we do not resolve self-intersections so long as they remain static. However, once the intersecting portion of the surface begins moving, the resulting raw parity field may overwhelm the suppressing effect of error correction and cause holes to open in the mesh as a result. When discussing this system with others, we repeatedly received opinions that our system (or variants of it) produce ?intuitive? or ?unintuitive? behavior. Frequently, we would receive both opinions about the same example. When we restrict ourselves to the case of solid objects, these disagreements disappear, but in non-solid cases disagreement is common. Some of these shortcomings could probably be addressed (at least in particular cases) with specialized hacks. However, from our experience experimenting with error correction schemes, we observed that fixing one problem generates a host of others. In the interest of keeping our approach simple and focused, we chose not to explore complicating fixes. Some of these issues, like those with paper mache-ing, go beyond hacks. In that case, a different kind of topology change with a different behavior might be more appropriate. Consider the behavior of a soap film when two soap bubbles collide at low speed. Rather than annihilate each other, the two colliding surfaces merge into a single interface. Examples like this one suggest that multiple different kinds of topology change behavior are necessary to satisfy users? expectations. A closed cylinder plunges downward through a single giant triangle (left). Because there are no parity samples on the triangle itself, our algorithm does not properly delete the hole caused by the cylinder. Instead, it causes a non-manifold junction between both models (right). Our method does not require the input meshes to represent solid objects, so it is more widely applicable than most existing algorithms. To further improve the method?s reliability, we provide a novel error correction mechanism that both handles poor-quality meshes and tolerates inaccuracies in collision detection computations. Because our method is error-tolerant and applicable to such a wide range of potential inputs, we believe that it can integrate nicely into geometric modeling applications of the future. The algorithm?s efficiency and simplicity allow topology change to happen naturally with any deformation tool, instead of needing to be explicitly effected through a special tool. As a consequence of this ease of integration, we believe our method has the potential to significantly improve the standard work flow of a geometric modeler. Once a user understands the general idea of a behavior like topology change and how their different tools can be used to deform a surface, they can discover new strategies through exploration and continued use. These tools are less likely to lead the user to discover serendipitous uses or combinations. We see our method as a way to easily incorporate topology change into a 3d modeler, similar to the way Harmon et al. [2011] incorporate collision detection and response. We suspect that this line of thinking may lead to further innovations in 3d modeling tools. How can we incorporate more behaviors, (e.g. topology change, collision response) natural or otherwise, with compounding effects into our tools? How few tools and behaviors can we use to build a parsimonious, compelling and flexible modeling system? Most of all we would like to thank Zoran Popovic for his help and guidance with earlier iterations of this research. Thank you to the researchers involved in compiling and maintaining both the Brown Mesh Set and Princeton Shape Benchmark. Thank you also to Siddhartha Chaudhuri for providing the cow model we used. This research was supported via the NSF GRFP DGE-0718124. active techniques, ACM Press/Addison-Wesley Publishing Co., New York, NY, USA, SIGGRAPH ?99, 409?416. J U , T. 2009. Fixing geometric errors on polygonal models: a survey. J. Comput. 24, 1 (Jan.), 19?29. M C G UIRE , M. 2004. Observations on silhouette sizes. journal of graphics, gpu, and game tools 9, 1, 1?12. M OJANG , 2013. Minecraft. P IXOLOGIC , 2013. Sculptris. P IXOLOGIC , 2013. R EQUICHA , A. A. G. 1977. Mathematical models of rigid solid objects. Rep. TM-28, Production Automation Project, University of Rochester, Rochester, New York 14627, November. S CHMIDT , R., AND S INGH , K. 2010. meshmixer: an interface for rapid mesh composition. In ACM SIGGRAPH 2010 Talks, ACM, New York, NY, USA, SIGGRAPH ?10, 6:1?6:1. S EIDEL , R. 1994. The nature and meaning of perturbations in geometric computing. In STACS ?94: Proceedings of the 11th Springer-Verlag, London, UK, 3?17. S HEWCHUK , J. R. 1996. Triangle: Engineering a 2d quality mesh generator and delaunay triangulator. In Selected papers from the metric Engineering, Springer-Verlag, London, UK, UK, FCRC ?96/WACG ?96, 203?222. S HEWCHUK , J. R. 1997. Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates. Discrete & Computational Geometry 18, 3 (Oct.), 305?363. S T ANCULESCU  ? , L., C HAINE , R., AND C ANI , M.-P. 2011. Smi 2011: Full paper: Freestyle: Sculpting meshes with self-adaptive topology. 35, 3 (June), 614?622. T ESCHNER , M., H EIDELBERGER , B., M ANOCHA , D., G OVIN DARAJU , N., Z ACHMANN , G., K IMMERLE , S., M EZGER , J., AND F UHRMANN , A. 2005. Collision handling in dynamic simulation environments. In Eurographics 2005: Tutorial Notes. W ALD , I. 2007. On fast construction of sah-based bounding volume hierarchies. In Proceedings of the 2007 IEEE Symposium on Interactive Ray Tracing, IEEE Computer Society, Washington, DC, USA, RT ?07, 33?40. W OJTAN , C., T H UREY  ? , N., G ROSS , M., AND T URK , G. 2009. Deforming meshes that split and merge. In SIGGRAPH ?09: ACM SIGGRAPH 2009 papers, ACM, New York, NY, USA, 1? 10. W OJTAN , C., T H UREY  ? , N., G ROSS , M., AND T URK , G. 2010. Physics-inspired topology changes for thin fluid features. In SIGGRAPH ?10: ACM SIGGRAPH 2010 papers, ACM, New York, NY, USA, 1?8. Z AHARESCU , A., B OYER , E., AND H ORAUD , R. 2011. Topologyadaptive mesh deformation for surface evolution, morphing, and multiview reconstruction. IEEE Transactions on Pattern Analysis and Machine Intelligence 33, 823?837. Given a point p and triangle (a, b, c) in motion from p 0 to p 1 and from (a 0 , b 0 , c 0 ) to (a 1 , b 1 , c 1 ), the point collides with the triangle?s plane whenever the triple product  vanishes. This produces a cubic equation in t whose roots are found via interval search. Candidate intersection points are then tested for containment in the triangle and in the time interval (0, 1). Standard floating-point arithmetic is used. Exact methods [Brochu et al. 2012] could be used instead to avoid inaccuracies due to floatingpoint, but are unnecessary due to error correction. The quadratic energy used during error correction is minimized by solving a linear equation Ax = b using a sparse Cholesky solver. This system can be set up using the following formulas. 0, (i, j) is cut with r i = r j A ij = ?w ij , otherwise A ii = ? A ij + ? j=i b i = ?r i + w ij (r i ? r j ) where (i, j)is cut and r i = r j j We begin by defining and/or recalling a few concepts related to point in polygon tests. After that, we present a lemma and corollaries. Recall that every solid surface (closed and non-self-intersecting) has a canonical normal field with normals pointing outward(?2.1). In the following, we assume that all solid surfaces are equipped with this canonical normal field. Furthermore, we assume that every surface begins and ends its motion in general position. We make this  assumption here to simplify the analysis. In our code, we use perturbation and exact geometric predicates to treat general positionrelated issues?we do not ignore them. Given a closed surface equipped with a normal field, we define the containment number ?(p) of a point p not on the surface as follows: Select any continuous path starting at p and diverging towards infinity. If this path never crosses the surface, then ?(p) = 0. Otherwise, we may compute ?(p) by the following procedure. Start with ?(p) = 0. Then, trace along the path beginning at p. Every time the path crosses the surface, increment the containment number if we cross the surface in the same direction as the surface normal, and decrement the containment number if we cross in the opposite direction. For closed surfaces the quantity computed by this procedure is invariant to the choice of path. As the surface moves, the containment number at p is preserved so long as the surface does not pass over p. So, as the surface moves, it will adjust the containment number at p only as it passes over p. The rules for this update derive from the above definition. If the surface passes over p traveling in the direction of its surface normal, then the containment number at p is incremented; otherwise it is decremented. In 2d, this containment number is equivalent to the winding number of a curve. Containment numbers can be used to classify the space around a surface into space contained inside the surface (?(p) = 0) and space outside the surface (?(p) = 1). This binary interpretation of containment numbers suffices for solid surfaces; we consider two possible extensions to self-intersecting but closed surfaces: ? The sign interpretation says that a point p is inside if ?(p) > 0 and outside if ?(p) ? 0. ? The modulo interpretation says that a point p is inside if ?(p) ? 1 or 2(mod 4) and inside if ?(p) ? 0 or ?1(mod 4) Of these two interpretations the sign interpretation is probably more natural. However, without arguing their relative merits, we can observe that so long as ?(p) ? {?1, 0, 1, 2}, both interpretations agree. (i.e. so long as the containment number deviates by at most one from the expected values 0 and 1) Proof sketch. Consider a point p of the surface undergoing deformation, a point p + displaced infinitesimally away from p in the normal direction and a point p ? displaced infinitesimally far away from p in the opposite direction. Before the surface begins to move ?(p + ) = 0 and ?(p ? ) = 1. During movement p collides with other pieces of the surface an even or odd number of times. If p collides an even number of times, then the containment numbers of p + and p ? must both change by the same amount: some multiple of 2, say 2k. So either ?(p + ) ? 0(mod 4) while ?(p ? ) ? 1(mod 4), or ?(p + ) ? 2(mod 4) while ?(p ? ) ? ?1(mod 4). Under the modulo interpretation of containment number, this means that either p + is outside while p ? is inside, or vice-versa. So, under the modulo interpretation we would choose to not delete points p on the surface which collide an even number of times. If p collides an odd number of times, then the containment numbers of p + and p ? must both change by the same amount: 2k + 1. So either ?(p + ) ? 1(mod 4) while ?(p ? ) ? 2(mod 4), or ?(p + ) ? ?1(mod 4) while ?(p ? ) ? 0(mod 4). Under the modulo interpretation of containment number, this means that either p + and p ? are both inside, or they are both outside. In either case, we\n        would choose to delete p since it does not serve to separate inside from outside. The first theorem(?5.1) follows directly from this lemma, since we just demonstrated that parity based topology change can be interpreted as providing an inside/outside classification for closed surfaces. Corollary 8.2 (Theorem 5.2). Consider two solid meshes undergoing independent rigid motion. When they are done moving every point p of space is either outside of both meshes, inside one of the meshes or inside both. Thus ?(p) ? {0, 1, 2}. Under the modulo interpretation of containment number, we interpret the value 0 as outside and both 1 and 2 as inside. Leveraging lemma 8.1, we know that computing parity-based topology change will yield a solid mesh under the modulo interpretation. Therefore this resulting mesh will represent the Boolean union of the two solid meshes in question. Finally, to the extent that we are willing to accept the informal proposition (i.e. observation) that ?(p) is often confined to the set of values {?1, 0, 1, 2}, then we observe that computing paritybased topology change for initially solid surfaces often yields the same result as under a sign interpretation of containment numbers.",
  "resources" : [ ]
}