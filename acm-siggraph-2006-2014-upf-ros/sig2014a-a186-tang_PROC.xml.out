{
  "uri" : "sig2014a-a186-tang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2014a/a186-tang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Fast and Exact Continuous Collision Detection with Bernstein Sign Classification",
    "published" : "2014",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Dinesh-Manocha",
      "name" : "Dinesh",
      "surname" : "Manocha"
    } ]
  },
  "bagOfWords" : [ "benefit", "reliable", "CCD", "Queries", "we", "highlight", "benefit", "we", "exact", "CCD", "algorithm", "cloth", "simulation", "we", "algorithm", "can", "use", "generate", "plausible", "simulation", "-lrb-", "-rrb-", "elementary", "test", "typically", "implement", "use", "finiteprecision", "floating-point", "arithmetic", "use", "error", "tolerance", "two", "type", "problem", "false", "negative", "when", "CCD", "algorithm", "may", "miss", "collision", "false", "positive", "when", "CCD", "algorithm", "act", "conservatively", "flag", "non-colliding", "configuration", "collision", "Main", "result", "we", "present", "fast", "accurate", "algorithm", "perform", "reliable", "CCD", "query", "we", "approach", "base", "use", "coplanarity", "inside", "test", "reduce", "computation", "find", "root", "algebraic", "equation", "inequality", "-lrb-", "i.e.", "semi-algebraic", "set", "-rrb-", "overall", "collision", "query", "reduce", "perform", "series", "sign", "evaluation", "algebraic", "expression", "involve", "simple", "arithmetic", "operation", "we", "also", "present", "conservative", "elementary", "culling", "algorithm", "improve", "algorithm?s", "performance", "we", "use", "extended", "precision", "arithmetic", "operation", "accelerate", "performance", "use", "floating-point", "filter", "we", "have", "evaluate", "its", "performance", "cpus", "gpus", "observe", "considerable", "speedup", "over", "prior", "floating-point", "CCD", "algorithm", "furthermore", "we", "observe", "significant", "improvement", "accuracy", "i.e.", "significant", "reduction", "number", "false", "positive", "false", "negative", "use", "we", "algorithm", "overall", "algorithm", "simple", "implement", "use", "only", "addition", "subtraction", "multiplication", "operation", "lowest", "level", "algorithm", "perform", "elementary", "test", "between", "triangle", "pair", "elementary", "test", "typically", "perform", "compute", "root", "cubic", "polynomial", "therefore", "can", "result", "false", "negative", "false", "positive", "tight", "error", "bound", "-lsb-", "Wang", "2014", "-rsb-", "can", "use", "derive", "tighter", "error", "bound", "bsc-float", "simplest", "culling", "algorithm", "use", "bvh", "-lrb-", "bound", "volume", "hierarchy", "-rrb-", "base", "k-dop", "aabb", "many", "algorithm", "implement", "use", "floating-point", "arithmetic", "operation", "prone", "numerical", "error", "we", "assume", "vertex", "mesh", "move", "constant", "velocity", "during", "time", "interval", "CCD", "query", "reduce", "perform", "two", "type", "Boolean", "query", "elementary", "test", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "Brochu", "et", "al.", "2012", "-rsb-", "include", "VF", "query", "which", "check", "whether", "move", "vertex", "intersect", "move", "triangle", "ee", "query", "which", "check", "whether", "move", "edge", "intersect", "another", "move", "edge", "all", "query", "assume", "time", "interval", "-lsb-", "-rsb-", "initial", "configuration", "intersection-free", "many", "application", "only", "parity", "number", "collision", "need", "robust", "simulation", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "exact", "root", "first", "time", "contact", "can", "compute", "use", "root", "isolation", "interval", "arithmetic", "technique", "we", "first", "introduce", "notation", "use", "rest", "paper", "next", "we", "present", "some", "property", "Bernstein", "basis", "function", "b?zier", "curve", "use", "we", "CCD", "algorithm", "we", "use", "follow", "notation", "rest", "paper", "Lower", "case", "letter", "normal", "font", "-lrb-", "e.g.", "-rrb-", "represent", "scalar", "variable", "Upper", "case", "letter", "-lrb-", "e.g.", "-lrb-", "-rrb-", "-rrb-", "-rrb-", "represent", "scalar", "function", "lower", "case", "letter", "bold", "face", "font", "-lrb-", "e.g.", "-rrb-", "represent", "vector", "quantity", "Upper", "case", "letter", "bold", "face", "font", "-lrb-", "e.g.", "-lrb-", "-rrb-", "-rrb-", "represent", "vector-valued", "function", "operator", "???", "???", "???", "denote", "usual", "scalar", "multiplication", "dot", "product", "cross", "product", "respectively", "operator", "sign", "-lrb-", "-rrb-", "return", "sign", "scalar", "variable", "we", "use", "symbol", "-lrb-", "-rrb-", "represent", "th", "basis", "function", "Bernstein", "polynomial", "degree", "i.e.", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "n?i", "where", "-lsb-", "-rsb-", "Bernstein", "polynomial", "basis", "widely", "use", "geometric", "modeling", "curve", "surface", "representation", "well", "numerical", "analysis", "computer", "algebra", "root", "computation", "-lsb-", "Mourrain", "et", "al.", "2005", "-rsb-", "result", "we", "represent", "semi-algebraic", "set", "use", "CCD", "query", "Bernstein", "basis", "give", "cubic", "polynomial", "-lrb-", "-rrb-", "can", "express", "use", "Bernstein", "basis", "i.e.", "correspond", "cubic", "b?zier", "curve", "-lrb-", "-rrb-", "plane", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "1/3", "-lrb-", "-rrb-", "b?zier", "classification", "we", "classify", "cubic", "b?zier", "curve", "three", "category", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "depend", "whether", "have", "inflection", "point", "extreme", "point", "bend", "direction", "extreme", "point", "correspond", "local", "minimum", "maximum", "every", "cubic", "b?zier", "curve", "can", "classify", "three", "category", "-lrb-", "show", "fig.", "-rrb-", "depend", "whether", "have", "any", "inflection", "point", "extreme", "point", "over", "its", "domain", "-lrb-", "-lsb-", "-rsb-", "-rrb-", "-lsb-", "Farin", "2002", "-rsb-", "case", "-lrb-", "-rrb-", "curve", "have", "inflection", "point", "case", "-lrb-", "-rrb-", "curve", "have", "inflection", "point", "extreme", "point", "cubic", "Bernstein", "polynomial", "can", "decompose", "lowerdegree", "polynomial", "base", "follow", "theorem", "Polynomial", "Decomposition", "Theorem", "let", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "cubic", "polynomial", "quadratic", "polynomial", "respectively", "CCD", "test", "between", "triangle", "pair", "reduce", "perform", "VF", "query", "ee", "query", "each", "query", "can", "further", "decompose", "two", "part", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "-rsb-", "coplanarity", "test", "VF", "EE", "query", "involve", "use", "four", "deform", "vertex", "order", "collision", "occur", "necessary", "those", "four", "vertex", "coplanar", "coplanarity", "test", "VF", "pair", "can", "express", "where", "correspond", "move", "vertex", "vertex", "deform", "triangle", "normal", "vector", "triangle", "-lrb-", "i.e.", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "order", "perform", "inside", "test", "VF", "pair", "we", "need", "perform", "three", "one-sided", "test", "i.e.", "need", "inside", "triangle", "can", "express", "base", "follow", "inequality", "VF", "query", "reduce", "check", "whether", "semi-algebraic", "set", "have", "real", "solution", "-lsb-", "-rsb-", "distance", "become", "zero", "any", "time", "interval", "four", "vertex", "classify", "coplanar", "base", "follow", "theorem", "coplanarity", "test", "Theorem", "VF", "Pair", "deform", "triangle", "whose", "initial", "final", "position", "give", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "vertex", "initial", "final", "position", "coplanarity", "test", "can", "formulate", "term", "following", "equation", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lsb-", "-rsb-", "scalar", "can", "calculate", "from", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "coplanarity", "test", "reduce", "check", "whether", "2d", "cubic", "b?zier", "curve", "-lrb-", "-rrb-", "-lrb-", "equation", "-lrb-", "-rrb-", "-rrb-", "define", "-lrb-", "-rrb-", "plane", "intersect", "x-axis", "we", "can", "also", "formulate", "inside", "test", "use", "Bernstein", "polynomial", "where", "-lsb-", "...", "-rsb-", "-lsb-", "...", "-rsb-", "show", "supplementary", "material", "-rsb-", "-lsb-", "...", "-rsb-", "scalar", "define", "above", "-lsb-", "...", "-rsb-", "-lsb-", "...", "-rsb-", "coefficient", "correspond", "other", "inside", "test", "section", "we", "use", "formulation", "CCD", "computation", "term", "Bernstein", "polynomial", "present", "accurate", "algorithm", "perform", "CCD", "query", "we", "formulation", "consist", "two", "stage", "geometric", "coplanarity", "test", "deduce", "sign", "polynomial", "its", "extreme", "point", "compare", "sign", "its", "end", "point", "interval", "-lsb-", "-rsb-", "we", "can", "check", "existence", "root", "coplanarity", "equation", "geometric", "inside", "test", "during", "stage", "we", "evaluate", "sign", "inequality", "root", "have", "pass", "coplanarity", "test", "check", "whether", "root", "also", "satisfy", "inside", "test", "we", "use", "characterization", "B?zier", "curve", "three", "different", "case", "present", "section", "3.2", "case", "-lrb-", "-rrb-", "section", "3.2", "we", "subdivide", "curve", "its", "inflection", "point", "i.e.", "use", "de", "Casteljau?s", "+3", "algorithm", "two", "subdivide", "curve", "either", "correspond", "case", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "section", "3.2", "we", "discuss", "both", "case", "case", "-lrb-", "-rrb-", "have", "different", "sign", "only", "one", "root", "domain", "otherwise", "we", "use", "follow", "RootFinding", "Lemma", "determine", "whether", "zero", "root", "two", "root", "domain", "case", "-lrb-", "-rrb-", "have", "same", "sign", "root", "otherwise", "one", "root", "its", "domain", "Computing", "Number", "root", "-lrb-", "-rrb-", "we", "can", "compute", "they", "base", "sign", "evaluation", "evaluate", "sign", "-lrb-", "-rrb-", "base", "Sign", "Determination", "Theorem", "Sign", "Determination", "Theorem", "II", "we", "can", "evaluate", "sign", "-lrb-", "-rrb-", "we", "decompose", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "two", "linear", "polynomial", "can", "calculate", "Polynomial", "Decomposition", "Theorem", "Section", "3.2", "we", "use", "classification", "Fig.", "compute", "number", "root", "-lrb-", "-rrb-", "base", "formulation", "we", "can", "compute", "number", "root", "case", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "consequently", "case", "-lrb-", "-rrb-", "order", "perform", "specific", "inside", "test", "along", "coplanarity", "test", "we", "need", "test", "follow", "system", "we", "compute", "similar", "system", "other", "two", "inside", "test", "base", "Polynomial", "Decomposition", "Theorem", "Section", "3.2", "we", "can", "express", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "linear", "polynomial", "let", "root", "-lrb-", "-rrb-", "domain", "-lsb-", "-rsb-", "i.e.", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "from", "equation", "-lrb-", "15", "-rrb-", "we", "obtain", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "use", "follow", "theorem", "compute", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "rule", "evaluate", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "use", "rule", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "Sign", "Determination", "Theorem", "Sign", "Determination", "Theorem", "II", "respectively", "sign", "Determination", "Theorem", "let", "-lrb-", "-rrb-", "linear", "polynomial", "-lrb-", "-rrb-", "cubic", "polynomial", "which", "correspond", "B?zier", "curve", "case", "-lrb-", "-rrb-", "domain", "-lsb-", "-rsb-", "-lrb-", "fig.", "-lrb-", "-rrb-", "-rrb-", "let", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "we", "can", "use", "rule", "Fig.", "-lrb-", "-rrb-", "evaluate", "sign", "-lrb-", "-rrb-", "-rrb-", "sign", "Determination", "Theorem", "II", "let", "-lrb-", "-rrb-", "linear", "polynomial", "-lrb-", "-rrb-", "cubic", "polynomial", "correspond", "B?zier", "curve", "case", "-lrb-", "-rrb-", "domain", "-lsb-", "-rsb-", "-lrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "-rrb-", "let", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "1st", "order", "derivative", "-lrb-", "-rrb-", "we", "can", "use", "rule", "Fig.", "-lrb-", "-rrb-", "determine", "sign", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "base", "Sign", "Determination", "Theorem", "Sign", "Determination", "Theorem", "II", "we", "can", "determine", "sign", "-lrb-", "-rrb-", "base", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "can", "compute", "sign", "-lrb-", "-rrb-", "consequently", "check", "whether", "equality", "inequality", "equation", "-lrb-", "14", "-rrb-", "satisfied", "repeat", "other", "two", "inequality", "well", "all", "they", "satisfied", "answer", "CCD", "query", "positive", "many", "time", "collision", "we", "use", "simple", "culling", "scheme", "accelerate", "algorithm", "similar", "use", "non-penetration", "filter", "-lsb-", "Tang", "et", "al.", "2010b", "-rsb-", "plane-culling", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "one", "sufficient", "condition", "when", "all", "coefficient", "-lsb-", "...", "-rsb-", "either", "greater", "than", "zero", "less", "than", "zero", "instead", "compute", "-lsb-", "...", "-rsb-", "exactly", "we", "use", "floating-point", "filter", "-lsb-", "Burnikel", "et", "al.", "2001", "-rsb-", "perform", "conservative", "culling", "other", "word", "we", "compute", "-lsb-", "...", "-rsb-", "use", "floatingpoint", "arithmetic", "instead", "compare", "they", "zero", "we", "check", "whether", "all", "greater", "than", "all", "less", "than", "where", "conservative", "error", "bind", "detailed", "method", "computing", "supplementary", "material", "algorithm", "vf-test", "CCD", "test", "VF", "pair", "input", "position", "deform", "triangle", "-lrb-", "-rrb-", "move", "vertex", "-lrb-", "-rrb-", "output", "true", "false", "have", "collision", "collision", "-lsb-", "-rsb-", "getcoefficient", "-lrb-", "-rrb-", "get", "coefficient", "-lrb-", "-rrb-", "-rrb-", "Perform", "conservative", "culling", "test", "ConservativeFilter", "-lrb-", "-rrb-", "return", "false", "end", "ctype", "beziertype", "-lrb-", "-rrb-", "get", "type", "B?zier", "curve", "case", "-lrb-", "-rrb-", "subdivide", "check", "interval", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "here", "correspond", "inflection", "point", "ctype", "case", "10", "subdivide", "two", "interval", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "11", "return", "vf-test", "-lrb-", "-lsb-", "-rsb-", "-rrb-", "vf-test", "-lrb-", "-lsb-", "-rsb-", "-rrb-", "12", "end", "13", "case", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "continue", "check", "14", "perform", "coplanarity", "test", "-lrb-", "section", "4.1", "-rrb-", "coplanaritytest", "-lrb-", "-rrb-", "16", "return", "false", "17", "end", "18", "perform", "inside", "test", "-lrb-", "section", "4.2", "-rrb-", "InsideTest", "-lrb-", "-rrb-", "20", "return", "false", "21", "end", "22", "return", "true", "4.4", "overall", "VF", "Query", "Algorithm", "we", "overall", "algorithm", "VF", "query", "describe", "algorithm", "we", "first", "compute", "coefficient", "-lrb-", "-rrb-", "i.e.", "-lsb-", "...", "-rsb-", "-lrb-", "line", "-rrb-", "perform", "conservative", "culling", "test", "-lrb-", "line", "-rrb-", "cull", "test", "fail", "we", "classify", "type", "B?zier", "curve", "-lrb-", "line", "-rrb-", "case", "-lrb-", "-rrb-", "we", "subdivide", "interval", "-lsb-", "-rsb-", "two", "sub-interval", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "recursively", "perform", "CCD", "test", "sub-interval", "-lrb-", "line", "12", "-rrb-", "case", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "perform", "coplanarity", "test", "-lrb-", "line", "15", "17", "-rrb-", "inside", "test", "-lrb-", "line", "19", "21", "-rrb-", "we", "use", "similar", "algorithm", "ee", "test", "detail", "its", "derivation", "give", "supplementary", "material", "main", "difference", "respect", "VF", "test", "term", "inequality", "use", "inside", "test", "BSC-exact", "exact", "VF", "Computation", "order", "perform", "reliable", "collision", "query", "we", "use", "well-known", "paradigm", "exact", "geometric", "computation", "-lsb-", "yap", "2004", "-rsb-", "which", "widely", "use", "geometric", "computation", "have", "also", "be", "use", "perform", "exact", "boolean", "answer", "CCD", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "underlie", "philosophy", "we", "compute", "correct", "answer", "boolean", "query", "assume", "we", "use", "exact", "arithmetic", "error", "due", "use", "fix", "precision", "floating-point", "arithmetic", "user", "specify", "tolerance", "we", "exact", "algorithm", "bsc-exact", "use", "combination", "extended", "precision", "arithmetic", "operation", "float", "point", "filter", "we", "conservative-culling", "test", "only", "use", "floating", "point", "filter", "do", "perform", "exact", "arithmetic", "operation", "rest", "computation", "include", "many", "expression", "evaluate", "sign", "polynomial", "all", "computation", "can", "accelerate", "use", "float", "point", "filter", "case", "all", "step", "algorithm", "implement", "use", "floating-point", "arithmetic", "prone", "numerical", "error", "we", "result", "algorithm", "bsc-float", "base", "IEEE", "floating-point", "standard", "section", "we", "describe", "we", "implementation", "highlight", "performance", "we", "algorithm", "several", "benchmark", "we", "have", "implement", "we", "algorithm", "standard", "pc", "-lrb-", "Intel", "i73770K", "CPU", "3.5", "GHz", "4GB", "RAM", "64-bits", "window", "os", "NVIDIA", "Tesla", "K40c", "GPU", "-rrb-", "include", "cpu-based", "C++", "implementation", "bsc-exact", "use", "single", "core", "use", "exact", "computation", "library", "base", "interval", "arithmetic", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "we", "have", "also", "implement", "bsc-float", "CPU", "-lrb-", "C++", "-rrb-", "GPU", "-lrb-", "use", "CUDA", "5.5", "-rrb-", "use", "hardware-supported", "floating-point", "operation", "we", "compare", "performance", "we", "algorithm", "follow", "algorithm", "El-Topo-exact", "implementation", "exact", "algorithm", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "make", "available", "author", "also", "use", "plane-based", "culling", "accelerate", "computation", "along", "interval", "arithmetic-based", "filter", "exact", "expansion", "exact", "arithmetic", "operation", "order", "compare", "performance", "bsc-exact", "we", "use", "same", "implementation", "exact", "arithmetic", "operation", "El-Topo-float", "floating-point-based", "cubic", "root", "solver", "CCD", "implementation", "available", "part", "El-Topo", "surfacetrack", "library", "-lsb-", "Brochu", "Bridson", "2009", "-rsb-", "we", "measure", "its", "performance", "use", "single", "thread", "CPU", "bsc-float-gpu", "el-topo-float-gpu", "we", "also", "port", "bsc-float", "el-topo-float", "algorithm", "gpus", "test", "performance", "multiple", "thread", "refer", "bscfloat-gpu", "el-topo-float-gpu", "respectively", "order", "test", "performance", "we", "algorithm", "we", "use", "five", "different", "benchmark", "arise", "from", "different", "simulation", "scenario", "use", "CCD", "query", "dancer", "dancer", "wear", "simple", "skirt", "5k", "10k", "triangle", "number", "triangle", "change", "during", "simulation", "due", "adaptive", "computation", "benchmark", "have", "high", "number", "self-collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "twist", "cloth", "2k", "50k", "triangle", "twist", "severely", "underlie", "ball", "rotate", "benchmark", "have", "high", "number", "self-collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "Flamenco", "fiery", "Flamenco", "dancer", "wear", "colorful", "skirt", "ruffle", "benchmark", "-lrb-", "49k", "triangle", "-rrb-", "have", "many", "interand", "intra-object", "collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "funnel", "cloth", "2k", "42k", "triangle", "fall", "funnel", "fold", "fit", "funnel", "many", "self-collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "crash", "Ford", "Explorer", "1.1", "triangle", "crash", "against", "rigid", "wall", "deformation", "simulated", "use", "finite-element", "meshing", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "first", "three", "benchmark", "-lrb-", "dancer", "twist", "funnel", "-rrb-", "generate", "integrate", "we", "CCD", "algorithm", "cloth", "simulation", "system", "ArcSim", "-lsb-", "Narain", "et", "al.", "2012", "-rsb-", "input", "Flamenco", "crash", "benchmark", "give", "discrete", "keyframe", "we", "use", "linear", "interpolation", "between", "key-frame", "check", "interobject", "self-collision", "we", "also", "use", "bvh-based", "hierarchical", "culling", "-lrb-", "use", "aabb", "-rrb-", "reduce", "number", "elementary", "test", "worst-case", "Query", "Performance", "collision", "we", "culling", "algorithm", "able", "discard", "many", "those", "instance", "query", "time", "higher", "when", "actual", "contact", "worstcase", "query", "time", "we", "algorithm", "vs.", "prior", "algorithm", "BSC-exact", "worst-case", "time", "ee", "VF", "query", "about", "876", "n", "contrast", "worst-case", "query", "time", "ElTopo-exact", "15", "m", "11", "ee", "ve", "query", "respectively", "BSC-float", "worst-case", "time", "ee", "VF", "query", "about", "105", "n", "contrast", "worst-case", "query", "time", "El-Topo-float", "about", "953", "n", "both", "query", "CPU", "core", "moreover", "we", "observe", "fewer", "incorrect", "query", "result", "use", "bsc-float", "Figure", "highlight", "performance", "we", "algorithm", "bsc-exact", "bsc-float", "compare", "they", "two", "prior", "CCD", "algorithm", "el-topo-exact", "el-topo-float", "single", "CPU", "core", "all", "benchmark", "performance", "bsc-exact", "about", "10", "25x", "faster", "than", "El-Topo-exact", "offer", "similar", "reliability", "furthermore", "we", "observe", "up", "order", "magnitude", "speedup", "float", "point", "implementation", "we", "approach", "bsc-float", "involve", "fewer", "arithmetic", "operation", "compare", "El-Topo-float", "combination", "fewer", "operation", "improve", "numerical", "stability", "property", "Bernstein", "polynomial", "also", "improve", "accuracy", "bscfloat", "i.e.", "fewer", "incorrect", "result", "collision", "query", "term", "false-negative", "false-positive", "we", "have", "also", "evaluate", "performance", "NVIDIA", "Tesla", "K40c", "GPU", "we", "aware", "any", "widely", "optimize", "extended", "precision", "library", "gpus", "so", "we", "only", "evaluate", "relative", "performance", "bsc-float-gpu", "el-topo-float-gpu", "various", "benchmark", "we", "compare", "accuracy", "query", "result", "those", "compute", "exact", "cpu-based", "implementation", "case", "bsc-float-gpu", "result", "much", "fewer", "inaccurate", "collision", "query", "compare", "ElTopo-float-GPU", "internal", "register", "use", "gpus", "may", "have", "different", "precision", "from", "cpus", "so", "we", "may", "observe", "considerable", "difference", "accuracy", "result", "bsc-float-gpu", "el-topo-floatgpu", "compare", "CPU", "counterpart", "example", "many", "Intel", "processor", "use", "80-bit", "internal", "register", "floating-point", "operation", "may", "result", "higher", "accuracy", "cpu-based", "implementation", "we", "have", "also", "integrate", "bsc-float", "el-topo-float", "gpu-based", "cloth", "simulation", "system", "-lsb-", "Tang", "et", "al.", "2013", "-rsb-", "compare", "runtime", "query", "performance", "both", "CCD", "algorithm", "within", "system", "Figure", "highlight", "performance", "bscfloat-gpu", "el-topo-float-gpu", "due", "parallelism", "relative", "performance", "improvement", "bsc-float-gpu", "over", "El-Topo-floatGPU", "less", "than", "those", "cpus", "computational", "cost", "we", "exact", "CCD", "algorithm", "-lrb-", "bsc-exact", "-rrb-", "vary", "respect", "different", "case", "describe", "section", "3.2", "case", "-lrb-", "-rrb-", "operation", "cost", "coplanarity", "test", "involve", "polynomial", "decomposition", "polynomial", "evaluation", "-lrb-", "degree", "-rrb-", "inside", "test", "case", "-lrb-", "-rrb-", "its", "operation", "cost", "include", "polynomial", "decomposition", "polynomial", "evaluation", "-lrb-", "degree", "-rrb-", "coplanarity", "test", "polynomial", "decomposition", "polynomial", "evaluation", "-lrb-", "three", "degree", "three", "degree", "-rrb-", "inside", "test", "case", "-lrb-", "-rrb-", "its", "total", "operation", "cost", "sum", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "overall", "operation", "count", "we", "algorithm", "much", "lower", "than", "eltopo-exact", "result", "considerable", "speedup", "show", "fig.", "furthermore", "we", "only", "perform", "simple", "arithmetic", "operation", "addition", "subtraction", "multiplication", "-lrb-", "see", "detail", "appendix", "-rrb-", "term", "extended", "precision", "computation", "division", "operation", "more", "expensive", "than", "three", "operation", "we", "avoid", "those", "expensive", "operation", "we", "algorithm", "first", "time", "contact", "can", "easily", "compute", "use", "root", "isolation", "we", "perform", "mid-point", "subdivision", "-lrb-", "use", "Bernstein", "formulation", "-rrb-", "recursively", "after", "Algorithm", "return", "true", "subdivision", "terminate", "when", "size", "interval", "contain", "root", "less", "than", "user-threshold", "mid-point", "interval", "use", "compute", "intersection", "point", "take", "about", "30", "40", "ns/query", "we", "also", "compare", "performance", "we", "solver", "JenkinsTraub", "solver", "more", "accurate", "than", "newton-interval", "solver", "-lrb-", "e.g.", "use", "El", "Topo-float", "-rrb-", "about", "3x", "slower", "all", "numeric", "solver", "prone", "floating-point", "error", "can", "result", "falsepositive", "false-negative", "contrast", "we", "bsc-exact", "algorithm", "reliable", "faster", "than", "most", "numeric", "solver", "we", "have", "present", "novel", "algorithm", "perform", "accurate", "CCD", "query", "between", "triangular", "mesh", "we", "exploit", "property", "Bern", "stein", "function", "b?zier", "curve", "reduce", "CCD", "query", "evaluate", "sign", "Bernstein", "polynomial", "algebraic", "expression", "we", "present", "two", "version", "algorithm", "base", "exact", "geometric", "computation", "ieee", "floating-point", "implementation", "we", "have", "implement", "algorithm", "cpus", "gpus", "we", "exact", "algorithm", "more", "than", "order", "magnitude", "faster", "than", "prior", "exact", "algorithm", "furthermore", "we", "floating-point", "variant", "faster", "more", "accurate", "than", "prior", "solver", "elementary", "test", "we", "approach", "have", "some", "limitation", "we", "current", "formulation", "assume", "vertex", "move", "constant", "velocity", "we", "reliable", "algorithm", "assume", "exact", "representation", "vertex", "edge", "face", "do", "take", "account", "any", "error", "input", "we", "floating-point", "variant", "-lrb-", "bsc-float", "-rrb-", "faster", "more", "accurate", "than", "prior", "method", "do", "guarantee", "safe", "reliable", "solution", "we", "perform", "only", "boolean", "collision", "query", "additional", "computation", "base", "root", "isolation", "would", "need", "compute", "first-time-of-contact", "besides", "overcome", "limitation", "may", "useful", "derive", "tight", "error", "bind", "we", "floating-point", "variant", "exact", "number", "bit", "need", "extended", "precision", "would", "help", "explain", "its", "high", "accuracy", "we", "benchmark", "would", "useful", "use", "we", "reliable", "CCD", "algorithm", "other", "application", "include", "hair", "simulation", "dynamic", "solver", "-lsb-", "Zhao", "et", "al.", "2012", "-rsb-", "research", "support", "part", "nsfc", "-lrb-", "61170140", "-rrb-", "National", "Basic", "Research", "Program", "China", "-lrb-", "2011CB302205", "-rrb-", "National", "Key", "Technology", "R&D", "Program", "China", "-lrb-", "2012bad35b01", "-rrb-", "Doctoral", "Fund", "Ministry", "Education", "China", "-lrb-", "20130101110133", "-rrb-", "Dinesh", "Manocha", "support", "part", "ARO", "Contract", "W911NF-10-1-0506", "Intel", "Office", "director", "National", "Institutes", "Health", "under", "award", "number", "r44od018334", "National", "Thousand", "Talents", "Program", "China", "content", "solely", "responsibility", "author", "do", "necessarily", "represent", "official", "view", "National", "Institutes", "Health", "Ruofeng", "Tong", "partly", "support", "nsfc", "-lrb-", "61170141", "-rrb-", "National", "High-Tech", "Research", "Development", "Program", "-lrb-", "No.", "2013AA013903", "-rrb-", "China", "we", "gratefully", "acknowledge", "support", "NVIDIA", "Corporation", "donation", "Tesla", "k40c", "GPU", "use", "research" ],
  "content" : "Benefits of Reliable CCD Queries: We highlight the benefits of our exact CCD algorithm on cloth simulation. Our algorithm can be used to generate a plausible simulation (a). The elementary tests are typically implemented using finiteprecision or floating-point arithmetic and use error tolerances. There are two types of problems: false negatives, when the CCD algorithm may miss a collision; and false positives, when the CCD algorithm, acting conservatively, flags a non-colliding configuration as a collision. Main Results: We present fast and accurate algorithms to perform reliable CCD queries. Our approach is based on using coplanarity and inside tests and reduces the computation to finding roots of algebraic equations and inequalities (i.e. a semi-algebraic set). The overall collision query is reduced to performing a series of sign evaluations of algebraic expressions and involves simple arithmetic operations. We also present a conservative elementary culling algorithm to improve the algorithm?s performance. We use extended precision arithmetic operations and accelerate the performance using floating-point filters. We have evaluated its performance on CPUs and GPUs and observe considerable speedups over prior floating-point CCD algorithms. Furthermore, we observe significant improvement in accuracy, i.e. significant reduction in the number of false positives and false negatives using our algorithm. The overall algorithms are simple to implement, using only addition, subtraction, and multiplication operations. At the lowest level, these algorithms perform elementary tests between triangle pairs. The elementary tests are typically performed by computing roots of cubic polynomials. Therefore, they can result in false negatives and false positives. The tight error bounds in [Wang 2014] can be used to derive tighter error bounds for BSC-float. The simplest culling algorithms use BVHs (bounding volume hierarchies) based on k-DOPs or AABBs. Many of these algorithms are implemented using floating-point arithmetic operations and are prone to numerical errors. We assume that the vertices of the mesh move with a constant velocity during the time interval and that the CCD query reduces to performing two types of Boolean queries or elementary tests [Provot 1997; Bridson et al. 2002; Brochu et al. 2012]. These include the VF query, which checks whether a moving vertex intersects with a moving triangle, and the EE query, which checks whether a moving edge intersects with another moving edge. All these queries assume that the time interval is t ? [0, 1] and that the initial configuration at t = 0 is intersection-free. In many applications, only the parity of the number of collisions is needed for robust simulation [Brochu et al. 2012]. The exact root and the first time of contact can be computed using root isolation and interval arithmetic techniques. We first introduce the notations used in the rest of the paper. Next, we present some properties of Bernstein basis functions and B?zier curves that are used by our CCD algorithm. We use following notations in the rest of the paper: Lower case letters in normal fonts (e.g. a, b, a i ,) represent scalar variables. Upper case letters (e.g., L, J(t))) represent scalar functions. Lower case letters in bold face fonts (e.g. a, b t ) represent vector quantities. Upper case letters in bold face fonts (e.g., L, J(t)) represent vector-valued functions. The operators ???, ???, and ??? denote the usual scalar multiplication, dot product, and cross product, respectively. Operator Sign() returns the sign of a scalar variable. We use the symbol B i n (t) to represent the i th basis function of the Bernstein polynomials of degree n, i.e. B i n (t) = i! (1 ? t) n?i t i , where t ? [0, 1] and 0 ? i ? n. The Bernstein polynomial basis is widely used in geometric modeling for curve and surface representation as well as in numerical analysis and computer algebra for root computations [Mourrain et al. 2005]. As a result, we represent the semi-algebraic set used for CCD queries in Bernstein basis. Given a cubic polynomial Y (t), it can be expressed using the Bernstein basis, i.e. It corresponds to a cubic B?zier curve F(t) in a plane, where: F(t) = Y t (t) = k 0 0 ? B 0 3 (t) + 1/3 k 1 ? B 1 3 (t) B?zier Classifications: We classify the cubic B?zier curve into three categories (a)-(c), depending on whether it has an inflection point or an extreme point. bending direction. The extreme points correspond to local minima or maxima. Every cubic B?zier curve can be classified into three categories (as shown in Fig. 2 ), depending on whether it has any inflection point or extreme point over its domain (t ? [0, 1]) [Farin 2002]: ? Case (a): The curve has an inflection point. ? Case (b): The curve has no inflection point, but an extreme point. A cubic Bernstein polynomial can be decomposed into lowerdegree polynomials based on the following theorem: Polynomial Decomposition Theorem: Let G(t) and H(t) be a cubic polynomial and a quadratic polynomial, respectively: The CCD test between a triangle pair reduces to performing 6 VF queries and 9 EE queries. Each of these queries can be further decomposed into two parts [Provot 1997; Bridson et al. 2002]: ? Coplanarity test: The VF and EE queries involve the use of four deforming vertices. In order for a collision to occur, it is necessary that those four vertices be coplanar. The coplanarity test for a VF pair can be expressed as: where p t corresponds to the moving vertex, a t , b t , c t are the vertices of the deforming triangle, and n t is the normal vector of the triangle (i.e. n t = (b t ? a t ) ? (c t ? a t )). In order to perform an inside test for a VF pair, we need to perform three one-sided tests, i.e. p t needs to be inside the triangle. This can be expressed based on the following inequalities: The VF query reduces to checking whether this semi-algebraic set has a real solution for t ? [0, 1]. If this distance becomes zero at any time in the interval, the four vertices are classified as coplanar based on following theorem. Coplanarity Test Theorem for a VF Pair: For a deforming triangle, whose initial and final positions are given as (a 0 , b 0 , c 0 ) and (a 1 , b 1 , c 1 ) and a vertex with initial and final positions as p 0 and p 1 , the coplanarity test can be formulated in terms of the following equation: Y (t) = (p t ? a t ) ? n t = 0 where k [0.. 3] are scalars can be calculated from (a 0 ,b 0 , c 0 , p 0 ) and (a 1 , b 1 , c 1 , p 1 ). The coplanarity test reduces to checking whether the 2D cubic B?zier curve F(t) (Equation (2)) defined in the (X, Y ) plane intersects with the X-axis. We can also formulate the inside tests using Bernstein polynomials. where p [0... 3] and l [0... 4] , as shown in the supplementary material. 3] and p [0... 2] are scalars defined above, q [0... 2] and r [0... 2] are the coefficients corresponding to 2 other inside tests. In this section, we use the formulation of CCD computation in terms of Bernstein polynomials and present accurate algorithms to perform CCD queries. Our formulation consists of two stages: ? Geometric Coplanarity Test: By deducing the signs of the polynomials at its extreme points and comparing with the signs of its end points in the interval [0, 1], we can check for the existence of roots for coplanarity equations. ? Geometric Inside Tests: During this stage, we evaluate the signs of the inequalities at the roots that have passed coplanarity tests to check whether these roots also satisfy the inside tests. We use the characterization of B?zier curves into three different cases presented in Section 3.2. For the Case (a) in Section 3.2, we subdivide the curve at its inflection point, i.e. t = k 2 ?2?k 1 +k 0 , using de Casteljau?s k 0 ?3?k 1 +3?k 2 ?k 3 algorithm. The two subdivided curves either correspond to Case (b) or Case (c) in Section 3.2. We discuss both these cases: ? Case (b): If k 0 and k 3 have different signs, there is only one root in the domain. Otherwise, we use the following RootFinding Lemma to determine whether there are zero roots or two roots in the domain. ? Case (c): If k 0 and k 3 have the same sign, there is no root; otherwise there is one root in its domain. Computing the Number of Roots of Y (t): We can compute them based on sign evaluations. Evaluate the Sign of L( t): Based on Sign Determination Theorem I and Sign Determination Theorem II, we can evaluate the sign of L( t). We decompose Y (t) = Y (t) ? S(t) + T (t), where S(t) and T (t) are two linear polynomials and can be calculated with the Polynomial Decomposition Theorem in Section 3.2. We use the classification in Fig. 3 to compute the number of roots of Y (t). Based on this formulation, we can compute the number of roots for Case (b) and Case (c), and consequently for Case (a). In order to perform a specific inside test, along with the coplanarity test, we need to test the following system: We compute a similar system for the other two inside tests. Based on the Polynomial Decomposition Theorem in Section 3.2, we can express: where L(t) and K(t) are linear polynomials. Let t be a root of Y (t) in the domain [0, 1], i.e. Y ( t) = 0, t ? [0, 1]. From Equation (15), we obtain P ( t) = ?K( t)/L( t). We use following theorems to compute the signs of K( t) and L( t): Rules for Evaluating the Sign of L( t), L( t 0 ), and L( t 1 ): We use the rules in (a) and (b) for Sign Determination Theorem I and Sign Determination Theorem II, respectively. Sign Determination Theorem I: Let L(t) be a linear polynomial and Y (t) be a cubic polynomial which corresponds to the B?zier curve of Case (b) in the domain [0, 1] ( Fig. 4(a) ). Let: ? L(t ) = 0, and t ? [0, 1], ? Y ( t) = 0, and t ? [0, 1]. We can use the rules in Fig. 5(a) to evaluate the sign of L( t)). Sign Determination Theorem II: Let L(t) be a linear polynomial and Y (t) be a cubic polynomial that corresponds to the B?zier curve of Case (c) in the domain [0, 1] ( Fig. 4(b) and Fig. 4(c) ). Let: ? L(t ) = 0, and t ? [0, 1], ? Y ( t 0 ) = 0 and Y ( t 1 ) = 0, and t 0 ? [0, 1], t 1 ? [0, 1], t 0 < t 1 , ? Y (t ) = 0, and t ? [0, 1]. Y (t) is the 1st order of derivative of Y (t). We can use the rules in Fig. 5(b) to determine the sign of L( t 0 )) and L( t 1 )). Based on Sign Determination Theorem I and Sign Determination Theorem II, we can determine the sign of L( t). Based on the signs of L( t) and K( t), we can compute the sign of P ( t) and consequently check whether the equality and inequality in Equation (14) are satisfied or not. This is repeated for the other two inequalities as well. If all of them are satisfied, then the answer to the CCD query is positive. Many times there is no collision, and we use a simple culling scheme to accelerate the algorithm. This is similar to using the non-penetration filter [Tang et al. 2010b] or plane-culling [Brochu et al. 2012]. One sufficient condition is when all the coefficients k [0... 3] are either greater than zero or less than zero. Instead of computing k [0... 3] exactly, we use floating-point filters [Burnikel et al. 2001] to perform conservative culling. In other words, we compute k [0... 3] using floatingpoint arithmetic. Instead of comparing them with zeros, we check whether they are all greater than , or all less than ? , where is a conservative error bound. The detailed method for computing is in the supplementary material. Algorithm 1 VF-Test: CCD test for a VF pair. Input: Positions at t = 0 and t = 1 for a deforming triangle (a 0 , a 1 , b 0 , b 1 , c 0 , c 1 ) and a moving vertex (p 0 , p 1 ). Output: True or False for has a collision or no collision in [0, 1]. 1: GetCoefficients() // Get coefficients of Y (t)). 2: // Perform conservative culling test. 3: if ConservativeFilter() then 4: Return False. 5: end if 6: ctype ? BezierType() // Get type of the B?zier curve. 7: // For case (a), subdivide and check on interval [0, t ] and [t , 1]. 8: // Here t is corresponding to the inflection point. 9: if ctype = Case A then 10: Subdivide into two intervals [0, t ] and [t , 1]. 11: Return VF-Test([0, t ]) OR VF-Test([t , 1]). 12: end if 13: // For case (b) and case (c), continue checking. 14: // Perform Coplanarity Test (Section 4.1). CoplanarityTest() then 16: Return False. 17: end if 18: // Perform Inside Test (Section 4.2). InsideTest() then 20: Return False. 21: end if 22: Return True. 4.4 Overall VF Query Algorithm\n          Our overall algorithm for VF query is described in Algorithm 1. We first compute the coefficients of Y (t), i.e. k [0... 3] (Line 1), and perform the conservative culling test (Line 3?5). If the culling test fails, we classify the type of B?zier curves (Line 6). For case (a), we subdivide the interval [0, 1] into two sub-intervals [0, t ] and [t , 1], and recursively perform CCD tests on these sub-intervals (Line 9? 12). For case (b) and (c), we perform the coplanarity test (Line 15?17) and inside tests (Line 19?21). We use a similar algorithm for EE tests. The details of its derivation are given in the supplementary material. The main difference with respect to the VF test is in terms of the inequalities used for the inside tests. BSC-exact: Exact VF Computation: In order to perform reliable collision queries, we use the well-known paradigm of Exact Geometric Computation [Yap 2004], which is widely used for geometric computations and has also been used to perform exact Boolean answers for CCD [Brochu et al. 2012]. The underlying philosophy is that we compute the correct answer to these Boolean queries assuming that we use exact arithmetic and there are no errors due to use of fixed precision or floating-point arithmetic or user specified tolerances. Our exact algorithm, BSC-exact, uses a combination of extended precision arithmetic operations and floating point filters. Our conservative-culling test only uses floating point filters and does not perform exact arithmetic operations. The rest of the computations include many expressions and evaluating signs of polynomials. All these computations can be accelerated using floating point filters. In this case, all the steps of Algorithm 1 are implemented using floating-point arithmetic and are prone to numerical errors. Our resulting algorithm, BSC-float, is based on the IEEE floating-point standard. In this section, we describe our implementation and highlight the performance of our algorithm on several benchmarks. We have implemented our algorithms on a standard PC (Intel i73770K CPU @3.5GHz, 4GB RAM, 64-bits Window 7 OS, NVIDIA Tesla K40c GPU). This includes a CPU-based C++ implementation of BSC-exact that uses a single core and uses an exact computation library based on interval arithmetic [Brochu et al. 2012]. We have also implemented BSC-float on a CPU (with C++) and a GPU (using CUDA 5.5) using hardware-supported floating-point operations. We compare the performance of our algorithms with the following algorithms:\n          1. El-Topo-exact: This is the implementation of the exact algorithm of [Brochu et al. 2012], made available by the authors. It also uses plane-based culling to accelerate the computation, along with interval arithmetic-based filters and exact expansions for exact arithmetic operations. In order to compare the performance with BSC-exact, we use the same implementation of exact arithmetic operations. El-Topo-float: This is a floating-point-based cubic root solver CCD implementation, available as part of El-Topo surfacetracking library [Brochu and Bridson 2009]. We measured its performance using a single thread on the CPU. BSC-float-GPU and El-Topo-float-GPU: We also ported BSC-float and El-Topo-float algorithms to GPUs and tested their performance with multiple threads, referred to as BSCfloat-GPU and El-Topo-float-GPU, respectively. In order to test the performance of our algorithms, we used five different benchmarks arising from different simulation scenarios that use CCD queries. ? Dancer: A dancer wearing a simple skirt with 5K ? 10K triangles, the number of triangles change during the simulation due to adaptive computations. This benchmark has a high number of self-collisions ( Figure 6(d) ). ? Twisting: A cloth with 2K ? 50K triangles twists severely as the underlying ball is rotating. This benchmark has a high number of self-collisions ( Figure 6(a) ). ? Flamenco: A fiery Flamenco dancer wearing a colorful skirt with ruffles. This benchmark (49K triangles) has many interand intra-object collisions ( Figure 6(c) ). ? Funnel: A cloth with 2K ? 42K triangles falls into a funnel and folds to fit into the funnel with many self-collisions ( Figure 6(b) ). ? Crashing: A Ford Explorer with 1.1M triangles crashes against a rigid wall and the deformation is simulated using finite-element meshing ( Figure 6(e) ). The first three benchmarks (Dancer, Twisting, and Funnel) are generated by integrating our CCD algorithm into a cloth simulation system, ArcSim [Narain et al. 2012]. The input for the Flamenco and the Crashing benchmarks is given as discrete keyframes. We use linear interpolation between key-frames and check for interobject and self-collisions. We also use BVH-based hierarchical culling (using AABBs) to reduce the number of elementary tests. Worst-Case Query Performance: If there is no collision, our culling algorithm is able to discard many of those instances. The query time is higher when there is an actual contact. The worstcase query times for our algorithm vs. prior algorithms are: ? BSC-exact: The worst-case time for EE and VF queries are about 876 ns. In contrast, the worst-case query times for ElTopo-exact are 15 ms and 11?s for EE and VE queries, respectively. ? BSC-float: The worst-case time for EE and VF queries are about 105 ns. In contrast, the worst-case query times for El-Topo-float are about 953 ns for both queries on a CPU core. Moreover, we observe fewer incorrect query results using BSC-float. Figure 7 highlights the performance of our algorithms, BSC-exact and BSC-float, and compares them with two prior CCD algorithms, El-Topo-exact and El-Topo-float, on a single CPU core. For all these benchmarks, the performance of BSC-exact is about 10?25X faster than El-Topo-exact, and offers similar reliability. Furthermore, we observe up to an order of magnitude speedup in the floating point implementations. Our approach, BSC-float, involves fewer arithmetic operations, as compared to El-Topo-float. The combination of fewer operations and improved numerical stability properties of Bernstein polynomials also improves the accuracy of BSCfloat, i.e. fewer incorrect results to the collision queries in terms of false-negatives or false-positives. We have also evaluated the performance on the NVIDIA Tesla K40c GPU. We are not aware of any widely optimized extended precision libraries on GPUs, so we only evaluated the relative performance of BSC-float-GPU and El-Topo-float-GPU on various benchmarks. We compared the accuracy of query results with those computed by exact CPU-based implementations. In this case, BSC-float-GPU results in much fewer inaccurate collision queries as compared to ElTopo-float-GPU. The internal registers used in GPUs may have different precision from CPUs, so we may observe considerable differences in the accuracy results of BSC-float-GPU and El-Topo-floatGPU, as compared to their CPU counterparts. For example, many Intel processors use 80-bit internal registers for floating-point operations, and this may result in higher accuracy for CPU-based implementations. We have also integrated BSC-float and El-Topo-float into a GPU-based cloth simulation system [Tang et al. 2013] and compared the runtime query performance of both CCD algorithms within that system. Figure 7 highlights the performance of BSCfloat-GPU and El-Topo-float-GPU. Due to parallelism, the relative performance improvement of BSC-float-GPU over El-Topo-floatGPU is less than those on the CPUs. The computational costs of our exact CCD algorithm (BSC-exact) varies with respect to different cases described in Section 3.2: ? Case (c): No operation cost for the coplanarity test; involves 3 polynomial decompositions and 3 polynomial evaluations (of degree 3) for inside tests. ? Case (b): Its operation cost includes 1 polynomial decomposition and 1 polynomial evaluation (of degree 2) for the coplanarity test; 3 polynomial decompositions and 6 polynomial evaluations (three of degree 2 and three of degree 3) for the inside test. ? Case (a): Its total operation cost is the sum of (c) and (b). The overall operation count of our algorithm is much lower than Eltopo-exact and this results in considerable speedups, as shown in Fig. 7 . Furthermore, we only perform simple arithmetic operations such as additions, subtractions, and multiplications (see details in the appendix). In terms of extended precision computations, the division operations are more expensive than these three operations and we avoid those expensive operations in our algorithm. The first time of contact can be easily computed using root isolation We perform mid-point subdivision (using Bernstein formulation) recursively, after Algorithm 1 returns true. The subdivision terminates when the size of the interval containing the root is less than a user-threshold. The mid-point of the interval is used to compute the intersection points. This takes about 30 ? 40 ns/query. We also compared the performance of our solver with the JenkinsTraub solver 1 . It is more accurate than Newton-interval solver (e.g. used in El Topo-float), but about 3X slower. All such numeric solvers are prone to floating-point errors and can result in falsepositives and false-negatives. In contrast, our BSC-exact algorithm is reliable and faster than most of these numeric solvers. We have presented novel algorithms to perform accurate CCD queries between triangular meshes. We exploit properties of Bern stein functions and B?zier curves, reducing the CCD queries to evaluating signs of Bernstein polynomials and algebraic expressions. We present two versions of the algorithm based on exact geometric computation and IEEE floating-point implementations. We have implemented these algorithms on CPUs and GPUs. Our exact algorithm is more than an order of magnitude faster than prior exact algorithms. Furthermore, our floating-point variant is faster and more accurate than prior solvers for elementary tests. Our approach has some limitations. Our current formulation assumes that the vertices move with a constant velocity. Our reliable algorithm assumes exact representation of vertices, edges, and faces and does not take into account any errors in the input. Our floating-point variant (BSC-float) is faster and more accurate than prior methods, but it does not guarantee a safe and reliable solution. We perform only Boolean collision queries; and additional computations based on root isolation would be needed to compute the first-time-of-contact. Besides overcoming these limitations, it may be useful to derive a tight error bound on our floating-point variant and the exact number of bits needed for extended precision. This would help explain its high accuracy in our benchmarks. It would be useful to use our reliable CCD algorithm for other applications including hair simulation and dynamic solvers [Zhao et al. 2012]. This research is supported in part by NSFC (61170140), the National Basic Research Program of China (2011CB302205), the National Key Technology R&D Program of China (2012BAD35B01), the Doctoral Fund of Ministry of Education of China (20130101110133). Dinesh Manocha is supported in part by ARO Contract W911NF-10-1-0506, Intel and the Office Of The Director, National Institutes Of Health under Award Number R44OD018334, and the National Thousand Talents Program of China. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health. Ruofeng Tong is partly supported by NSFC (61170141), the National High-Tech Research and Development Program (No.2013AA013903) of China. We gratefully acknowledge the support of NVIDIA Corporation with the donation of the Tesla K40c GPU used for this research.",
  "resources" : [ ]
}