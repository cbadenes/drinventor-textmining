{
  "uri" : "sig2008a-a144-sander_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a144-sander_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Efficient Traversal of Mesh Edges using Adjacency Primitives",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Eden-Chlamtac",
      "name" : "Eden",
      "surname" : "Chlamtac"
    }, {
      "uri" : "http://drinventor/Hugues-Hoppe",
      "name" : "Hugues",
      "surname" : "Hoppe"
    } ]
  },
  "bagOfWords" : [ "ff107008c947e0369be94365cdc034a17eda408e60bc71598c16a5c54d578249", "ou4", "10.1145", "1409060.1409097", "name", "identification", "possible", "efficient", "traversal", "Mesh", "Edges", "use", "Adjacency", "Primitives", "Pedro", "V.", "Sander", "Diego", "Nehab", "Hong", "Kong", "UST", "Microsoft", "Research", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "-lrb-", "-rrb-", "we", "goal", "enable", "efficient", "processing", "edge", "triangle", "mesh", "use", "adjacency", "primitive", "-lrb-", "-rrb-", "we", "select", "minimal", "subset", "triangle", "-lrb-", "blue", "-rrb-", "cover", "all", "mesh", "edge", "-lrb-", "-rrb-", "each", "remain", "triangle", "-lrb-", "white", "-rrb-", "assign", "cover", "triangle", "-lrb-", "indicate", "red", "segment", "-rrb-", "-lrb-", "-rrb-", "we", "encode", "each", "triangle", "pair", "triangle-with-adjacency", "primitive", "order", "primitive", "vertex", "cache", "locality", "-lrb-", "cache", "hit", "green", "miss", "red", "-rrb-", "new", "representation", "reduce", "storage", "bandwidth", "GPU", "computation", "result", "substantial", "gain", "variety", "edge-processing", "technique", "processing", "mesh", "edge", "lie", "core", "many", "advanced", "realtime", "render", "technique", "range", "from", "shadow", "silhouette", "computation", "motion", "blur", "fur", "rendering", "we", "present", "scheme", "efficient", "traversal", "mesh", "edge", "build", "adjacency", "primitive", "programmable", "geometry", "shader", "introduce", "recent", "graphic", "hardware", "we", "scheme", "aim", "minimize", "number", "primitive", "while", "maximize", "simd", "parallelism", "objective", "reduce", "set", "discrete", "optimization", "problem", "dual", "graph", "mesh", "we", "develop", "practical", "solution", "graph", "problem", "addition", "we", "extend", "two", "exist", "vertex", "cache", "optimization", "algorithm", "produce", "cache-efficient", "traversal", "ordering", "adjacency", "primitive", "we", "demonstrate", "significant", "runtime", "speedup", "several", "practical", "real-time", "rendering", "algorithm", "keyword", "real-time", "rendering", "silhouette", "shadow", "volume", "vertex", "locality", "programmable", "geometry", "shader", "introduction", "triangle", "widespread", "rasterization", "primitive", "so", "large", "body", "work", "optimize", "traversal", "triangle", "mesh", "efficient", "render", "e.g.", "use", "triangle", "strip", "-lsb-", "Evans", "et", "al.", "1996", "Xiang", "et", "al.", "1999", "Estkowski", "et", "al.", "2002", "-rsb-", "manage", "vertex", "buffer", "-lsb-", "deer", "1995", "Chow", "1997", "-rsb-", "index", "strip", "vertex", "caching", "-lsb-", "hoppe", "1999", "Lin", "Yu", "2006", "Sander", "et", "al.", "2007", "Chhugani", "Kumar", "2007", "-rsb-", "particular", "current", "gpus", "include", "vertex", "cache", "al", "low", "reuse", "post-shaded", "vertex", "among", "several", "adjacent", "triangle", "thereby", "achieve", "significant", "reduction", "both", "memory", "bandwidth", "vertex", "shader", "computation", "many", "advanced", "rendering", "technique", "process", "only", "mesh", "face", "also", "mesh", "edge", "application", "include", "shadow", "volume", "-lsb-", "Crow", "1977", "-rsb-", "silhouette", "render", "-lsb-", "Hertzmann", "1999", "Gooch", "Gooch", "2001", "-rsb-", "motion", "blur", "-lsb-", "wloka", "Zeleznik", "1996", "-rsb-", "fur", "rendering", "-lsb-", "Lengyel", "et", "al.", "2001", "-rsb-", "wireframe", "rendering", "most", "technique", "process", "edge", "require", "access", "its", "two", "adjacent", "face", "have", "motivate", "introduction", "adjacency", "primitive", "latest", "graphic", "system", "-lsb-", "Blythe", "2006", "-rsb-", "primitive", "process", "new", "programmable", "unit", "graphic", "pipeline", "geometry", "shader", "which", "read", "primitive", "perform", "computation", "emit", "variable", "number", "new", "primitive", "paper", "we", "present", "general", "scheme", "optimize", "traversal", "mesh", "efficient", "GPU", "processing", "its", "edge", "we", "knowledge", "first", "attempt", "optimization", "some", "graphic", "application", "require", "traversal", "triangle", "addition", "edge", "we", "explore", "how", "can", "achieve", "efficiently", "same", "traversal", "pass", "separate", "pass", "use", "same", "vertex", "index", "buffer", "approach", "we", "basic", "strategy", "traverse", "mesh", "use", "list", "triangle-with-adjacency", "primitive", "show", "Figure", "2a", "each", "primitive", "use", "index", "encode", "central", "cover", "face", "well", "its", "adjacent", "face", "principle", "primitive", "permit", "processing", "cover", "face", "itself", "all", "its", "edge", "all", "its", "adjacent", "face", "we", "goal", "process", "all", "mesh", "edge", "triangle", "exactly", "once", "use", "same", "list", "primitive", "while", "keep", "overall", "number", "primitive", "minimum", "because", "geometry", "shader", "consider", "many", "primitive", "simultaneously", "simd", "parallelism", "GPU", "crucial", "computational", "efficiency", "processing", "each", "primitive", "require", "same", "sequence", "step", "maximize", "simd", "efficiency", "we", "allow", "each", "adjacency", "primitive", "process", "face", "time", "-lrb-", "figure", "2a", "-rrb-", "central", "cover", "face", "optional", "adjacent", "face", "we", "refer", "assign", "face", "further", "improve", "simd", "parallelism", "we", "place", "some", "restriction", "selection", "assign", "face", "discuss", "section", "note", "regular", "mesh", "region", "all", "edge", "face", "can", "cover", "introduce", "primitive", "only", "half", "triangle", "i.e.", "all", "face", "point", "same", "direction", "-lrb-", "figure", "2b", "-rrb-", "each", "one", "assign", "face", "point", "opposite", "direction", "other", "hand", "around", "any", "irregular", "vertex", "odd", "degree", "least", "one", "edge", "must", "cover", "twice", "therefore", "some", "redundancy", "inevitable", "-lrb-", "figure", "2c", "-rrb-", "nevertheless", "because", "most", "triangles-with-adjacency", "primitive", "encode", "two", "face", "index", "buffer", "contain", "only", "about", "index", "per", "mesh", "triangle", "-lrb-", "one", "primitive", "every", "mesh", "triangle", "index", "per", "primitive", "-rrb-", "therefore", "have", "approximately", "same", "memory", "cost", "widely", "use", "index", "triangle", "list", "representation", "algorithm", "overview", "problem", "we", "face", "can", "formulate", "graph", "theoretical", "problem", "dual", "graph", "induce", "triangle", "mesh", "particular", "we", "show", "select", "minimum", "number", "primitive", "cover", "all", "edge", "reduce", "minimum", "vertex", "cover", "problem", "assign", "remain", "face", "primitive", "reduce", "two", "bipartite", "matching", "problem", "we", "algorithm", "have", "three", "major", "step", "show", "Figure", "vertex", "cover", "problem", "np-complete", "fortunately", "we", "particular", "setting", "we", "can", "rely", "fast", "approximation", "use", "stochastic", "algorithm", "moreover", "derive", "good", "lower", "bind", "number", "cover", "face", "we", "able", "show", "practical", "triangle", "mesh", "approximate", "solution", "within", "few", "percent", "optimal", "face", "assignment", "problem", "reduce", "two", "bipartite", "matching", "problem", "can", "therefore", "solve", "quickly", "-lrb-", "1.5", "-rrb-", "time", "e.g.", "only", "sec", "mesh", "75,000", "vertex", "particular", "we", "prove", "surprising", "result", "perfect", "matching", "guarantee", "exist", "even", "add", "restriction", "introduce", "simd", "efficiency", "have", "determine", "set", "triangles-with-adjacency", "we", "optimize", "order", "maximize", "vertex", "cache", "reuse", "cover", "assignment", "problem", "always", "solve", "offline", "preprocess", "because", "order", "efficiency", "depend", "cache", "size", "we", "provide", "two", "order", "algorithm", "slower", "careful", "scheme", "assume", "prior", "knowledge", "cache", "size", "faster", "scheme", "can", "run", "load", "time", "base", "specific", "hardware", "ACM", "Reference", "Format", "Sander", "P.", "Nehab", "D.", "Chlamtac", "E.", "Hoppe", "H.", "2008", "efficient", "traversal", "Mesh", "Edges", "use", "Adjacency", "Primitives", "ACM", "Trans", "graph", "27", "Article", "144", "-lrb-", "December", "2008", "-rrb-", "page", "dous", "10.1145", "1409060.1409097", "http://doi.acm.org/10.1145/1409060.1409097", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "fus", "rst", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb- 869-0481", "permissions@acm.org", "2008", "ACM", "0730-0301/2008", "05-art144", "5.00", "DOI", "10.1145", "1409060.1409097", "http://doi.acm.org/10.1145/1409060.1409097", "Eden", "Chlamtac", "Hugues", "Hoppe", "Princeton", "University", "Microsoft", "Research", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "-lrb-", "-rrb-", "we", "mesh", "traversal", "primitive", "triangle-withadjacency", "which", "we", "use", "process", "up", "edge", "face", "-lrb-", "-rrb-", "provide", "optimal", "cover", "regular", "mesh", "region", "-lrb-", "-rrb-", "other", "hand", "around", "any", "odd-degree", "vertex", "least", "one", "adjacent", "edge", "must", "cover", "twice", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "144:2", "P.", "Sander", "et", "al.", "edge", "face", "contribution", "construction", "minimize", "number", "adjacency", "primitive", "need", "processing", "mesh", "-lrb-", "section", "-rrb-", "accurate", "lower", "bind", "algorithm", "confirm", "quality", "minimization", "-lrb-", "appendix", "-rrb-", "construction", "allow", "reduce", "set", "primitive", "process", "all", "mesh", "retain", "simd", "efficiency", "-lrb-", "section", "-rrb-", "first", "modify", "algorithm", "perform", "vertex", "cache", "optimization", "list", "triangles-with-adjacency", "-lrb-", "section", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "-lrb-", "-rrb-", "primal", "graph", "associate", "mesh", "-lrb-", "black", "-rrb-", "its", "dual", "-lrb-", "red", "-rrb-", "-lrb-", "-rrb-", "Automatic", "inclusion", "boundary", "face", "cover", "previous", "work", "optimize", "traversal", "mesh", "edge", "GPU", "relatively", "unexplored", "area", "one", "prior", "technique", "compute", "shadow", "volume", "entirely", "GPU", "introduce", "degenerate", "quadrilateral", "each", "edge", "input", "mesh", "selectively", "translate", "vertex", "expand", "fraction", "degenerate", "face", "form", "side", "shadow", "volume", "-lsb-", "Brennan", "2002", "-rsb-", "however", "technique", "require", "splitting", "mesh", "vertex", "preprocess", "result", "mesh", "time", "large", "original", "some", "related", "technique", "GPU", "rendering", "silhouette", "fin", "also", "introduce", "degenerate", "quadrilateral", "edge", "-lsb-", "card", "Mitchell", "2002", "McGuire", "Hughes", "2004", "-rsb-", "therefore", "also", "require", "memory", "buffer", "many", "additional", "vertex", "face", "several", "sample", "program", "demonstrate", "application", "new", "triangle-with-adjacency", "primitive", "-lsb-", "Microsoft", "Corp", "2007", "Tariq", "2007", "-rsb-", "basic", "approach", "all", "program", "instantiate", "primitive", "each", "input", "triangle", "avoid", "processing", "interior", "edge", "twice", "test", "perform", "geometry", "shader", "appropriately", "skip", "half", "edge", "test", "base", "either", "triangle", "orientation", "silhouette", "per-edge", "order", "vertex", "index", "note", "local", "branch", "lead", "inefficient", "simd", "processing", "contrast", "we", "scheme", "generate", "roughly", "half", "many", "primitive", "moreover", "most", "primitive", "process", "all", "adjacent", "edge", "result", "excellent", "simd", "utilization", "notation", "we", "describe", "we", "processing", "pipeline", "next", "three", "section", "use", "follow", "notation", "triangle", "mesh", "-lrb-", "-rrb-", "define", "set", "vertex", "edge", "triangle", "each", "triangle", "form", "three", "vertex", "-lcb-", "-rcb-", "define", "three", "edge", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "-lcb-", "-rcb-", "set", "contain", "all", "edge", "define", "triangle", "show", "Figure", "3a", "two", "undirected", "graph", "can", "associate", "mesh", "primal", "graph", "-lrb-", "-rrb-", "have", "same", "vertex", "edge", "dual", "graph", "-lrb-", "-rrb-", "other", "hand", "have", "one", "vertex", "each", "triangle", "edge", "connect", "two", "vertex", "only", "associate", "triangle", "share", "edge", "E.", "Covering", "all", "edge", "recall", "we", "goal", "create", "minimum", "set", "triangle-withadjacency", "primitive", "allow", "processing", "all", "edge", "mesh", "-lrb-", "-rrb-", "equivalent", "find", "minimum", "vertex", "cover", "dual", "graph", "-lrb-", "-rrb-", "general", "set", "vertex", "may", "adjacent", "mesh", "boundary", "must", "therefore", "part", "cover", "mesh", "boundary", "we", "find", "minimal", "vertex", "cover", "reduce", "graph", "-lrb-", "-rrb-", "-lrb-", "i.e.", "all", "boundary", "vertex", "remove", "show", "Figure", "3b", "-rrb-", "return", "ideally", "we", "would", "like", "find", "minimum", "vertex", "cover", "however", "problem", "np-complete", "-lsb-", "Garey", "Johnson", "1977", "-rsb-", "even", "graph", "maximum", "degree", "arise", "from", "manifold", "triangle", "mesh", "therefore", "we", "look", "heuristic", "produce", "good", "minimal", "cover", "which", "vertex", "can", "trivially", "remove", "without", "leave", "uncovered", "edge", "note", "cover", "also", "minimal", "since", "every", "need", "cover", "corresponding", "boundary", "edge", "minimality", "can", "remove", "without", "expose", "internal", "edge", "several", "recent", "stochastic", "algorithm", "address", "related", "problem", "compute", "approximation", "minimal", "vertex", "cover", "maximum", "clique", "maximum", "independent", "set", "large", "graph", "-lsb-", "Grosso", "et", "al.", "2007", "Andrade", "et", "al.", "2008", "-rsb-", "although", "we", "could", "use", "any", "they", "we", "purpose", "we", "implementation", "base", "method", "Grosso", "et", "al.", "-lsb-", "2007", "-rsb-", "excellent", "maximum", "clique", "approximation", "heuristic", "which", "related", "minimum", "vertex", "cover", "follow", "minimum", "vertex", "cover", "graph", "-lrb-", "-rrb-", "only", "maximum", "clique", "complement", "graph", "-lrb-", "-rrb-", "where", "set", "all", "edge", "algorithm", "Grosso", "et", "al.", "iterate", "between", "two", "step", "perturbation", "tabu", "search", "each", "iteration", "maximal", "clique", "end", "new", "maximal", "clique", "first", "perturbation", "set", "add", "random", "vertex", "correct", "remove", "from", "all", "vertex", "adjacent", "v.", "next", "tabu", "search", "successively", "grow", "until", "maximal", "again", "while", "also", "attempt", "translate", "away", "from", "long", "share", "least", "one", "vertex", "end", "iteration", "replace", "cardinality", "larger", "fortunately", "possible", "apply", "stochastic", "algorithm", "we", "vertex", "cover", "problem", "without", "have", "explicitly", "construct", "complement", "set", "which", "would", "have", "quadratic", "complexity", "we", "first", "modify", "algorithm", "Grosso", "et", "al.", "negate", "all", "edge", "test", "construct", "maximal", "independent", "set", "we", "minimal", "vertex", "cover", "simply", "complement", "intermediate", "result", "we", "find", "stochastic", "algorithm", "produce", "excellent", "minimal", "cover", "wide", "variety", "input", "graph", "produce", "from", "triangle", "mesh", "quantify", "quality", "result", "we", "develop", "efficient", "algorithm", "provide", "good", "lower", "bind", "emphasize", "bind", "only", "use", "evaluation", "purpose", "necessary", "part", "we", "processing", "pipeline", "we", "describe", "appendix", "use", "lower", "bind", "we", "determine", "cover", "typically", "within", "2-3", "optimal", "-lrb-", "see", "Table", "-rrb-", "fact", "since", "lower", "bind", "tight", "cover", "may", "closer", "optimal", "than", "suggest", "number", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "efficient", "traversal", "Mesh", "Edges", "use", "Adjacency", "Primitives", "144:3", "Figure", "fast", "geometry", "shader", "evaluation", "we", "allow", "only", "configuration", "triangle-with-adjacency", "primitive", "each", "primitive", "process", "central", "triangle", "-lrb-", "blue", "-rrb-", "subset", "its", "edge", "-lrb-", "solid", "line", "-rrb-", "optional", "match", "triangle", "-lrb-", "white", "-rrb-", "repeated", "vertex", "index", "identify", "edge", "should", "process", "miss", "adjacent", "face", "both", "assign", "remain", "triangle", "have", "create", "triangle-with-adjacency", "primitive", "centered", "each", "cover", "face", "we", "assign", "uncovered", "face", "adjacent", "face", "within", "primitive", "efficient", "simd", "load-balancing", "we", "assign", "most", "one", "uncovered", "face", "each", "primitive", "simplify", "runtime", "traversal", "we", "assume", "assign", "face", "first", "adjacent", "face", "-lcb-", "-rcb-", "within", "primitive", "-lrb-", "see", "Figure", "-rrb-", "primitive", "lack", "assign", "face", "boundary", "one", "its", "edge", "have", "already", "be", "cover", "neighbor", "primitive", "we", "encode", "degenerate", "face", "duplicate", "some", "vertex", "index", "-lrb-", "also", "show", "Figure", "-rrb-", "two", "way", "duplicate", "index", "we", "can", "use", "they", "distinguish", "between", "boundary", "edge", "edge", "have", "already", "be", "cover", "note", "however", "whenever", "-lcb-", "-rcb-", "boundary", "edge", "face", "-lcb-", "-rcb-", "make", "degenerate", "edge", "-lcb-", "-rcb-", "also", "become", "degenerate", "can", "process", "current", "primitive", "recall", "processing", "edge", "require", "access", "both", "its", "adjacent", "triangle", "primitive", "one", "they", "degenerate", "therefore", "edge", "must", "process", "another", "primitive", "primitive", "center", "face", "-lcb-", "-rcb-", "which", "must", "cover", "face", "too", "thus", "non-boundary", "cover", "face", "lack", "assign", "face", "must", "adjacent", "another", "cover", "face", "which", "also", "lack", "assign", "face", "boundary", "must", "adjacent", "third", "cover", "face", "etc.", "chain", "restriction", "satisfy", "every", "connected", "component", "cover", "face", "have", "least", "one", "face", "either", "adjacent", "mesh", "boundary", "match", "uncovered", "face", "constrain", "acceptable", "matching", "we", "prove", "nonetheless", "always", "possible", "find", "perfect", "restricted", "matching", "formally", "give", "minimal", "cover", "dual", "graph", "-lrb-", "include", "all", "dual", "vertex", "correspond", "boundary", "face", "-rrb-", "we", "must", "match", "each", "remain", "vertex", "vertex", "C.", "Finding", "unrestricted", "matching", "from", "easy", "let", "-lrb-", "-rrb-", "denote", "degree", "vertex", "we", "consider", "bipartite", "graph", "-lrb-", "-lcb-", "-rcb-", "-lrb-", "-rrb-", "-rrb-", "where", "-lrb-", "-rrb-", "subset", "edge", "between", "we", "see", "-lrb-", "-rrb-", "all", "-lrb-", "since", "cover", "all", "its", "three", "neighbor", "must", "-rrb-", "-lrb-", "-rrb-", "all", "-lrb-", "triangle", "have", "most", "three", "neighbor", "-rrb-", "follow", "satisfy", "marriage", "condition", "which", "any", "subset", "its", "neighbor", "-lrb-", "-rrb-", "we", "have", "-lrb-", "-rrb-", "thus", "hall?s", "theorem", "-lsb-", "hall", "1935", "-rsb-", "guarantee", "existence", "matching", "from", "C.", "express", "condition", "restricted", "matching", "denote", "-lcb-", "-rcb-", "partition", "connected", "component", "subgraph", "induce", "c.", "each", "we", "must", "ensure", "least", "one", "follow", "two", "condition", "hold", "some", "correspond", "mesh", "boundary", "triangle", "some", "match", "i.e.", "have", "assign", "face", "proof", "follow", "lemma", "-lrb-", "illustrate", "Figure", "-rrb-", "describe", "construction", "algorithm", "restricted", "matching", "Lemma", "any", "bipartite", "graph", "above", "always", "exist", "perfect", "restricted", "matching", "from", "satisfy", "above", "requirement", "proof", "we", "have", "see", "always", "exist", "some", "unrestricted", "perfect", "matching", "from", "-lrb-", "figure", "5a", "-rrb-", "we", "must", "find", "matching", "also", "cover", "least", "one", "face", "each", "component", "do", "contain", "boundary", "face", "let", "-lcb-", "-rcb-", "denote", "set", "component", "let", "we", "collapse", "moment", "each", "single", "vertex", "merge", "repeat", "edge", "we", "problem", "find", "perfect", "matching", "graph", "from", "we", "again", "use", "hall?s", "theorem", "which", "we", "can", "apply", "marriage", "condition", "satisfied", "any", "subset", "non-boundary", "component", "its", "neighbor", "-lrb-", "-rrb-", "we", "must", "show", "-lrb-", "-rrb-", "indeed", "let", "-lrb-", "-rrb-", "set", "dual", "edge", "from", "-lrb-", "-rrb-", "before", "merge", "note", "each", "must", "have", "least", "three", "edge", "go", "-lrb-", "since", "minimality", "cover", "corresponding", "bound", "region", "primal", "surround", "face", "-rrb-", "moreover", "every", "have", "degree", "-lrb-", "originally", "every", "have", "degree", "though", "some", "its", "edge", "might", "participate", "-lrb-", "-rrb-", "-rrb-", "therefore", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "thus", "hall?s", "theorem", "exist", "matching", "from", "-lrb-", "figure", "5b", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "144:4", "P.", "Sander", "et", "al.", "-lrb-", "-rrb-", "match", "-lrb-", "-rrb-", "match", "figure", "face", "assignment", "correspond", "restricted", "matching", "problem", "bipartite", "graph", "-lrb-", "where", "gray", "shaded", "region", "denote", "connected", "component", "-rrb-", "-lrb-", "-rrb-", "initial", "unrestricted", "perfect", "matching", "leave", "isolate", "covered", "face", "-lrb-", "star", "-rrb-", "unmatched", "-lrb-", "-rrb-", "after", "several", "step", "we", "construction", "guarantee", "find", "final", "perfect", "match", "all", "connected", "covered", "face", "have", "least", "one", "matching", "now", "consider", "union", "two", "matching", "-lrb-", "figure", "5c", "-rrb-", "form", "disjoint", "collection", "cycle", "path", "-lrb-", "because", "every", "vertex", "graph", "have", "degree", "-rrb-", "let", "vertex", "participate", "match", "-lrb-", "star", "Figure", "-rrb-", "path", "alternate", "between", "which", "end", "vertex", "which", "participate", "-lrb-", "figure", "5d", "-rrb-", "let", "set", "edge", "all", "alternate", "path", "-lrb-", "note", "disjoint", "-rrb-", "now", "take", "flip", "membership", "all", "edge", "alternate", "path", "produce", "new", "perfect", "matching", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "Figure", "5e", "-rrb-", "clearly", "match", "also", "cover", "all", "C.", "let", "we", "verify", "every", "participate", "matching", "since", "completely", "match", "every", "must", "contain", "some", "vertex", "match", "also", "match", "participate", "regardless", "whether", "alternate", "path", "go", "through", "flip", "otherwise", "initial", "vertex", "alternate", "path", "thus", "participate", "once", "path", "flip", "find", "bipartite", "matching", "we", "use", "algorithm", "Hopcroft", "Karp", "-lsb-", "1973", "-rsb-", "implement", "Rothberg", "-lsb-", "1985", "-rsb-", "time", "complexity", "algorithm", "-lrb-", "-rrb-", "which", "simply", "-lrb-", "1.5", "-rrb-", "size", "input", "mesh", "order", "primitive", "vertex", "locality", "idea", "reordering", "primitive", "efficient", "GPU", "traversal", "new", "have", "previously", "be", "limit", "triangle", "primitive", "several", "method", "optimize", "traversal", "index", "triangle", "mesh", "maximize", "runtime", "efficiency", "GPU", "vertex", "cache", "we", "focus", "here", "method", "most", "related", "we", "approach", "refer", "reader", "Chhugani", "Kumar", "-lsb-", "2007", "-rsb-", "more", "complete", "survey", "hoppe", "-lsb-", "1999", "-rsb-", "show", "efficacy", "FIFO", "cache", "build", "successive", "triangle", "strip", "greedily", "optimize", "length", "Lin", "Yu", "-lsb-", "2006", "-rsb-", "improve", "cache", "efficiency", "use", "triangle", "fan", "optimize", "selection", "base", "age", "vertex", "cache", "number", "cache", "miss", "would", "result", "Chhugani", "Kumar", "-lsb-", "2007", "-rsb-", "further", "improve", "cache", "efficiency", "approach", "partition", "mesh", "triangle", "adjacent", "chain", "split", "chain", "strip", "use", "dynamic", "programming", "Sander", "et", "al.", "-lsb-", "2007", "-rsb-", "develop", "fast", "algorithm", "do", "require", "mesh", "adjacency", "have", "linear", "complexity", "independent", "cache", "size", "therefore", "suitable", "load-time", "optimization", "triangle", "buffer", "we", "contribution", "optimize", "traversal", "triangle", "primitive", "adjacency", "create", "describe", "previous", "two", "section", "because", "each", "adjacency", "primitive", "involve", "larger", "stencil", "up", "vertex", "naive", "application", "previous", "reordering", "method", "give", "poor", "result", "-lrb-", "we", "arbitrarily", "select", "-lsb-", "Lin", "Yu", "2006", "-rsb-", "representative", "off-the-shelf", "method", "-rrb-", "-lrb-", "-rrb-", "alternate", "path", "-lrb-", "-rrb-", "final", "match", "-lrb-", "-rrb-", "careful", "scheme", "primitive", "-lrb-", "-rrb-", "fast", "scheme", "primitive", "Figure", "each", "we", "reordering", "algorithm", "consider", "different", "set", "primitive", "around", "central", "vertex", "we", "choose", "extend", "two", "prior", "method", "namely", "-lsb-", "Lin", "Yu", "2006", "-rsb-", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "because", "strategy", "emit", "all", "unvisited", "primitive", "adjacent", "central", "vertex", "can", "generalize", "other", "primitive", "type", "result", "we", "denote", "we", "extension", "two", "method", "careful", "fast", "scheme", "respectively", "careful", "scheme", "base", "extend", "-lsb-", "Lin", "Yu", "2006", "-rsb-", "algorithm", "Lin", "Yu", "proceeds", "iteratively", "select", "central", "vertex", "emit", "all", "its", "adjacent", "unvisited", "face", "vertex", "selection", "algorithm", "consider", "position", "vertex", "cache", "number", "unvisited", "face", "number", "cache", "miss", "would", "result", "we", "modify", "cost", "analysis", "consider", "ring", "adjacency", "primitive", "reference", "candidate", "central", "vertex", "regular", "mesh", "region", "primitive", "show", "Figure", "6a", "we", "also", "modify", "algorithm", "emit", "adjacent", "primitive", "order", "minimize", "result", "number", "cache", "miss", "fast", "scheme", "base", "extend", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "algorithm", "Sander", "et", "al.", "consider", "fewer", "candidate", "next", "central", "vertex", "process", "make", "conservative", "assumption", "unvisited", "adjacent", "face", "may", "cause", "two", "additional", "cache", "miss", "adjacency", "primitive", "conservative", "bind", "must", "raise", "five", "cache", "miss", "per", "primitive", "therefore", "obtain", "good", "result", "we", "find", "necessary", "emit", "only", "primitive", "whose", "cover", "face", "immediately", "adjacent", "central", "vertex", "i.e.", "only", "up", "adjacency", "primitive", "regular", "mesh", "region", "show", "Figure", "6b", "scheme", "take", "only", "fraction", "second", "run", "even", "large", "mesh", "-lrb-", "Table", "-rrb-", "can", "use", "quickly", "specialize", "primitive", "order", "cache", "size", "give", "graphic", "system", "note", "cover", "assignment", "can", "still", "obtain", "preprocessing", "stage", "since", "unaffected", "cache", "size", "future", "work", "would", "also", "interesting", "explore", "extension", "-lsb-", "Hoppe", "1999", "-rsb-", "-lsb-", "Chhugani", "Kumar", "2007", "-rsb-", "which", "base", "strip", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "efficient", "traversal", "Mesh", "Edges", "use", "Adjacency", "Primitives", "144:5", "Table", "result", "we", "traversal", "optimization", "several", "mesh", "order", "input", "mesh", "Cover", "Assignment", "Careful", "fast", "name", "face", "lower", "bind", "-lrb-", "-rrb-", "Cover", "-lrb-", "-rrb-", "C/B", "Time", "-lrb-", "-rrb-", "Time", "-lrb-", "-rrb-", "cm/v", "gain", "Time", "-lrb-", "-rrb-", "cm/v", "gain", "Time", "-lrb-", "-rrb-", "fandisk", "9,926", "5,199", "-lrb-", "52.3", "-rrb-", "5,335", "-lrb-", "53.7", "-rrb-", "1.026", "0.62", "0.07", "1.496", "1.955", "1.23", "1.755", "1.666", "0.002", "gargoyle", "20,000", "10,880", "-lrb-", "54.4", "-rrb-", "11,225", "-lrb-", "56.1", "-rrb-", "1.032", "1.42", "0.22", "1.517", "1.794", "3.12", "1.805", "1.508", "0.006", "feline", "41,262", "21,937", "-lrb-", "53.2", "-rrb-", "22,570", "-lrb-", "54.7", "-rrb-", "1.029", "3.50", "0.70", "1.529", "1.903", "6.17", "1.816", "1.602", "0.014", "bunny", "69,473", "36,382", "-lrb-", "52.4", "-rrb-", "37,168", "-lrb-", "53.5", "-rrb-", "1.022", "8.47", "0.92", "1.535", "1.938", "9.33", "1.780", "1.672", "0.023", "dragon", "150,000", "81,520", "-lrb-", "54.3", "-rrb-", "84,034", "-lrb-", "56.0", "-rrb-", "1.031", "50.32", "4.02", "1.505", "1.671", "21.73", "1.807", "1.417", "0.053", "turtle", "267,931", "142,390", "-lrb-", "53.1", "-rrb-", "146,158", "-lrb-", "54.6", "-rrb-", "1.026", "55.08", "5.95", "1.533", "1.885", "36.38", "1.792", "1.608", "0.099", "buddha", "1,087,716", "591,909", "-lrb-", "54.4", "-rrb-", "610,526", "-lrb-", "56.1", "-rrb-", "1.031", "315.38", "341.00", "1.501", "1.677", "212.58", "1.798", "1.400", "1.256", "measurement", "measurement", "base", "cache", "24", "entry", "cm/v", "indicate", "cache", "miss", "per", "mesh", "vertex", "have", "lower", "bind", "gain", "factor", "reduction", "cache", "miss", "compare", "off-the-shelf", "method", "order", "input", "mesh", "Cover", "Assignment", "Careful", "fast", "name", "face", "lower", "bind", "-lrb-", "-rrb-", "Cover", "-lrb-", "-rrb-", "C/B", "Time", "-lrb-", "-rrb-", "Time", "-lrb-", "-rrb-", "cm/v", "gain", "Time", "-lrb-", "-rrb-", "cm/v", "gain", "Time", "-lrb-", "-rrb-", "fandisk", "9,926", "5,199", "-lrb-", "52.3", "-rrb-", "5,335", "-lrb-", "53.7", "-rrb-", "1.026", "0.62", "0.07", "1.496", "1.955", "1.23", "1.755", "1.666", "0.002", "gargoyle", "20,000", "10,880", "-lrb-", "54.4", "-rrb-", "11,225", "-lrb-", "56.1", "-rrb-", "1.032", "1.42", "0.22", "1.517", "1.794", "3.12", "1.805", "1.508", "0.006", "feline", "41,262", "21,937", "-lrb-", "53.2", "-rrb-", "22,570", "-lrb-", "54.7", "-rrb-", "1.029", "3.50", "0.70", "1.529", "1.903", "6.17", "1.816", "1.602", "0.014", "bunny", "69,473", "36,382", "-lrb-", "52.4", "-rrb-", "37,168", "-lrb-", "53.5", "-rrb-", "1.022", "8.47", "0.92", "1.535", "1.938", "9.33", "1.780", "1.672", "0.023", "dragon", "150,000", "81,520", "-lrb-", "54.3", "-rrb-", "84,034", "-lrb-", "56.0", "-rrb-", "1.031", "50.32", "4.02", "1.505", "1.671", "21.73", "1.807", "1.417", "0.053", "turtle", "267,931", "142,390", "-lrb-", "53.1", "-rrb-", "146,158", "-lrb-", "54.6", "-rrb-", "1.026", "55.08", "5.95", "1.533", "1.885", "36.38", "1.792", "1.608", "0.099", "buddha", "1,087,716", "591,909", "-lrb-", "54.4", "-rrb-", "610,526", "-lrb-", "56.1", "-rrb-", "1.031", "315.38", "341.00", "1.501", "1.677", "212.58", "1.798", "1.400", "1.256", "measurement", "base", "cache", "24", "entry", "cm/v", "indicate", "cache", "miss", "per", "mesh", "vertex", "have", "lower", "bind", "gain", "factor", "indicate", "reduction", "cache", "miss", "compare", "off-the-shelf", "method", "-lrb-", "-rrb-", "input", "mesh", "-lrb-", "-rrb-", "Cover", "face", "-lrb-", "-rrb-", "careful", "assignment", "vertex", "cache", "order", "figure", "result", "we", "mesh", "traversal", "construction", "representative", "mesh", "from", "Table", "-lrb-", "-rrb-", "fast", "-lrb-", "-rrb-", "off-the-shelf", "vertex", "cache", "order", "vertex", "cache", "order", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "144:6", "P.", "Sander", "et", "al.", "result", "application", "Table", "show", "result", "we", "traversal", "construction", "assortment", "practical", "mesh", "c/b", "column", "represent", "ratio", "between", "cover", "result", "-lrb-", "-rrb-", "we", "compute", "lower", "bind", "result", "-lrb-", "-rrb-", "remarkably", "c/b", "indicate", "Grosso", "et", "al.", "-lsb-", "2007", "-rsb-", "can", "find", "cover", "solution", "only", "worse", "than", "lower", "bind", "therefore", "most", "worse", "than", "optimal", "practice", "both", "cover", "assignment", "step", "can", "perform", "efficiently", "-lrb-", "seconds", "small", "model", "minute", "large", "model", "-rrb-", "note", "pre-processing", "algorithm", "therefore", "time-critical", "show", "later", "application", "excellent", "cover", "assignment", "result", "translate", "significant", "speedup", "practical", "render", "scenario", "Figure", "plot", "cache", "efficiency", "function", "cache", "size", "efficiency", "denote", "cm/v", "give", "number", "cache", "miss", "divide", "number", "vertex", "lower", "value", "better", "optimal", "minimum", "value", "give", "each", "vertex", "must", "process", "least", "once", "note", "substantial", "reduction", "number", "cache", "miss", "per", "vertex", "both", "we", "careful", "fast", "scheme", "compare", "order", "produce", "representative", "prior", "algorithm", "design", "triangle", "primitive", "without", "adjacency", "show", "Table", "fast", "scheme", "order", "magnitude", "faster", "than", "careful", "scheme", "like", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "its", "processing", "time", "independent", "cache", "size", "figure", "show", "visualization", "result", "mesh", "from", "Table", "spatial", "distribution", "cache", "efficiency", "convey", "color", "each", "mesh", "vertex", "accord", "its", "total", "number", "cache", "miss", "color", "white", "correspond", "optimal", "single", "cache", "miss", "per", "vertex", "darker", "shades", "gray", "indicate", "progressively", "more", "cache", "miss", "per", "vertex", "we", "demonstrate", "practical", "advantage", "we", "efficient", "edgeprocess", "traversal", "three", "application", "-lrb-", "see", "Figure", "-rrb-", "Shadow", "volume", "mesh", "render", "shadow", "volume", "screen-space", "stencil", "buffer", "-lsb-", "Heidmann", "1991", "-rsb-", "shadow", "volume", "form", "within", "geometry", "shader", "displace", "triangle", "form", "front", "cap", "rear", "cap", "-lrb-", "depend", "whether", "face", "light", "-rrb-", "extrude", "silhouette", "edge", "-lrb-", "respect", "light", "-rrb-", "form", "quadrilateral", "span", "cap", "baseline", "we", "use", "sample", "program", "shadowvolume10", "DirectX", "10", "SDK", "modify", "use", "we", "optimize", "set", "cover", "primitive", "-lrb-", "figure", "8a", "-rrb-", "note", "we", "geometry", "shader", "output", "triangle", "strip", "rather", "than", "independent", "triangle", "-lrb-", "figure", "10", "-rrb-", "result", "small", "speed", "improvement", "10", "20", "apply", "all", "measurement", "Line", "illustration", "many", "render", "technique", "enhance", "object", "appearance", "emphasize", "silhouette", "other", "important", "contour", "e.g.", "-lsb-", "Gooch", "Gooch", "2001", "DeCarlo", "et", "al.", "2003", "-rsb-", "geometry", "shader", "silhouette", "rendering", "some", "sense", "ideal", "scenario", "highlight", "efficiency", "GPU", "edge-processing", "because", "output", "silhouette", "often", "have", "sub-linear", "complexity", "we", "develop", "simple", "prototype", "render", "both", "silhouette", "sharp", "feature", "-lrb-", "figure", "8b", "-rrb-", "again", "we", "use", "baseline", "basic", "approach", "process", "all", "face", "triangle", "adjacency", "follow", "framework", "from", "dx10", "shadow", "volume", "sample", "since", "we", "use", "small", "quadrilateral", "render", "primitive", "we", "can", "control", "thickness", "line", "well", "render", "mesh", "triangle", "white", "hidden", "line", "removal", "all", "single", "render", "pass", "Motion", "blur", "Wloka", "Zeleznik", "-lsb-", "1996", "-rsb-", "describe", "real-time", "technique", "approximate", "blur", "cause", "motion", "object", "relative", "viewer", "approach", "have", "similarity", "shadow", "volume", "mesh", "also", "split", "front", "part", "rear", "part", "silhouette", "edge", "-lrb-", "respect", "motion", "-rrb-", "extrude", "form", "quadrilateral", "previous", "application", "we", "compare", "against", "traditional", "approach", "process", "all", "triangle", "adjacency", "result", "motion", "volume", "render", "par", "tial", "transparency", "use", "geometry", "shader", "program", "can", "all", "do", "single", "render", "pass", "-lrb-", "figure", "8c", "-rrb-", "shadow", "volume", "application", "we", "output", "triangle", "strip", "since", "extruded", "quadrilateral", "share", "vertex", "emit", "triangle", "face", "-lrb-", "figure", "10", "-rrb-", "quantitative", "speedup", "we", "measure", "performance", "speedup", "factor", "use", "we", "approach", "against", "baseline", "method", "outline", "above", "each", "application", "measurement", "be", "perform", "both", "NVIDIA", "GeForce", "8800GTX", "AMD", "ATI", "Radeon", "hd2900", "simulate", "more", "realistic", "graphic", "scene", "measurement", "use", "multiple", "instance", "model", "factor", "out", "overhead", "due", "frame", "setup", "other", "element", "scene", "through", "experimentation", "we", "observe", "best", "result", "we", "application", "AMD", "NVIDIA", "card", "when", "set", "vertex", "cache", "parameter", "12", "24", "vertex", "respectively", "any", "rate", "result", "we", "report", "be", "significantly", "affect", "cache", "size", "parameter", "we", "geometry-shader-bound", "prototype", "application", "which", "just", "use", "Gouraud", "shade", "vertex", "program", "may", "overly", "simple", "we", "have", "verify", "more", "expensive", "vertex", "program", "do", "give", "rise", "greater", "speedup", "likely", "geometry", "shader", "implementation", "may", "become", "more", "efficient", "future", "thus", "further", "increase", "importance", "careful", "primitive", "order", "speedup", "produce", "use", "we", "approach", "report", "Table", "since", "we", "process", "just", "over", "half", "number", "primitive", "speedup", "cover", "computation", "could", "reach", "close", "however", "practice", "do", "occur", "because", "each", "we", "geometry", "shader", "instance", "emit", "more", "datum", "general", "application", "result", "speedup", "between", "1.5", "2.0", "most", "input", "mesh", "other", "application", "many", "other", "application", "would", "also", "benefit", "from", "efficient", "edge", "traversal", "some", "notable", "example", "include", "fur", "rendering", "selective", "extrusion", "fin", "from", "edge", "near", "silhouette", "-lsb-", "Lengyel", "et", "al.", "2001", "-rsb-", "soft-shadow", "use", "penumbra", "wedge", "-lsb-", "assarsson", "akenine-m", "ller", "2003", "-rsb-", "beveled", "edge", "-lsb-", "bahnassus", "bahnassi", "2007", "-rsb-", "one", "final", "note", "set", "cover", "face", "can", "also", "use", "render", "wireframe", "model", "-lrb-", "without", "geometry", "shader", "i.e.", "mode", "d3d10", "fill", "wireframe", "-rrb-", "we", "notice", "speedup", "roughly", "70", "when", "use", "cover", "face", "rather", "than", "all", "face", "model", "naturally", "efficient", "100", "improvement", "can", "obtain", "create", "buffer", "line", "contain", "edge", "model", "however", "may", "practical", "value", "list", "cover", "face", "already", "available", "-lrb-", "e.g.", "one", "above", "application", "-rrb-", "since", "would", "consume", "any", "additional", "video", "memory", "off-the-shelf", "fast", "3.5", "careful", "cm/v", "2.5", "1.5", "12", "16", "20", "24", "28", "32", "36", "40", "44", "48", "52", "56", "60", "64", "Cache", "size", "figure", "number", "cache", "miss", "per", "vertex", "compare", "we", "order", "algorithm", "against", "off-the-shelf", "technique", "when", "run", "bunny", "mesh", "Figure", "10", "grouping", "geometry", "shader", "output", "form", "triangle", "strip", "application", "shadow", "volume", "motion", "blur", "just", "two", "strip", "sufficient", "all", "case", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "efficient", "traversal", "Mesh", "Edges", "use", "Adjacency", "Primitives", "144:7", "-lrb-", "-rrb-", "Shadow", "volume", "-lrb-", "-rrb-", "line", "illustration", "figure", "screenshot", "we", "prototype", "application", "Table", "render", "speedup", "we", "prototype", "application", "compare", "common", "approach", "process", "one", "adjacency", "primitive", "per", "mesh", "face", "timing", "we", "approach", "-lrb-", "millisecond", "-rrb-", "show", "parenthesis", "input", "mesh", "Shadow", "volume", "line", "illustration", "Motion", "blur", "name", "AMD", "NVIDIA", "AMD", "NVIDIA", "AMD", "NVIDIA", "fandisk", "1.65", "1.76", "-lrb-", "0.6", "-rrb-", "1.70", "1.82", "-lrb-", "0.6", "-rrb-", "1.54", "1.52", "-lrb-", "0.6", "-rrb-", "gargoyle", "1.58", "1.76", "-lrb-", "1.2", "-rrb-", "1.70", "1.83", "-lrb-", "1.2", "-rrb-", "1.54", "1.51", "-lrb-", "1.1", "-rrb-", "feline", "1.60", "1.77", "-lrb-", "2.3", "-rrb-", "1.72", "1.87", "-lrb-", "2.4", "-rrb-", "1.59", "1.52", "-lrb-", "2.2", "-rrb-", "bunny", "1.73", "1.76", "-lrb-", "3.2", "-rrb-", "1.81", "1.92", "-lrb-", "3.7", "-rrb-", "1.60", "1.48", "-lrb-", "3.4", "-rrb-", "dragon", "1.74", "1.82", "-lrb-", "7.7", "-rrb-", "1.84", "1.89", "-lrb-", "7.9", "-rrb-", "1.62", "1.52", "-lrb-", "8.5", "-rrb-", "turtle", "1.70", "1.75", "-lrb-", "13.7", "-rrb-", "1.80", "1.96", "-lrb-", "14.0", "-rrb-", "1.60", "1.48", "-lrb-", "14.9", "-rrb-", "buddha", "1.70", "1.73", "-lrb-", "55.5", "-rrb-", "1.80", "1.95", "-lrb-", "57.0", "-rrb-", "1.61", "1.50", "-lrb-", "60.8", "-rrb-", "Input", "mesh", "Shadow", "volume", "line", "illustration", "Motion", "blur", "name", "AMD", "NVIDIA", "AMD", "NVIDIA", "AMD", "NVIDIA", "fandisk", "1.65", "1.76", "-lrb-", "0.6", "-rrb-", "1.70", "1.82", "-lrb-", "0.6", "-rrb-", "1.54", "1.52", "-lrb-", "0.6", "-rrb-", "gargoyle", "1.58", "1.76", "-lrb-", "1.2", "-rrb-", "1.70", "1.83", "-lrb-", "1.2", "-rrb-", "1.54", "1.51", "-lrb-", "1.1", "-rrb-", "feline", "1.60", "1.77", "-lrb-", "2.3", "-rrb-", "1.72", "1.87", "-lrb-", "2.4", "-rrb-", "1.59", "1.52", "-lrb-", "2.2", "-rrb-", "bunny", "1.73", "1.76", "-lrb-", "3.2", "-rrb-", "1.81", "1.92", "-lrb-", "3.7", "-rrb-", "1.60", "1.48", "-lrb-", "3.4", "-rrb-", "dragon", "1.74", "1.82", "-lrb-", "7.7", "-rrb-", "1.84", "1.89", "-lrb-", "7.9", "-rrb-", "1.62", "1.52", "-lrb-", "8.5", "-rrb-", "turtle", "1.70", "1.75", "-lrb-", "13.7", "-rrb-", "1.80", "1.96", "-lrb-", "14.0", "-rrb-", "1.60", "1.48", "-lrb-", "14.9", "-rrb-", "buddha", "1.70", "1.73", "-lrb-", "55.5", "-rrb-", "1.80", "1.95", "-lrb-", "57.0", "-rrb-", "1.61", "1.50", "-lrb-", "60.8", "-rrb-", "discussion", "dismiss", "alternative", "scheme", "we", "briefly", "summarize", "some", "other", "scheme", "we", "consider", "associate", "drawback", "each", "edge", "could", "process", "individually", "consider", "its", "pair", "adjacent", "face", "encode", "vertex", "e.g.", "index", "line-with-adjacency", "primitive", "however", "would", "result", "index", "buffer", "4e", "index", "edge", "about", "twice", "many", "we", "scheme", "also", "face", "processing", "could", "well", "load-balanced", "among", "primitive", "triangle-strip-with-adjacency", "primitive", "would", "appear", "promising", "way", "string", "together", "several", "triangle-with-adjacency", "primitive", "however", "even", "regular", "mesh", "region", "one", "can", "obtain", "regular", "covering", "mesh", "edge", "therefore", "branch", "would", "necessary", "geometry", "shader", "again", "degrading", "simd", "parallelism", "efficiency", "Limitations", "current", "gpus", "introduction", "any", "geometry", "shader", "slow", "down", "render", "pipeline", "therefore", "use", "we", "representation", "render", "just", "mesh", "face", "incur", "additional", "cost", "however", "most", "application", "perform", "edge", "processing", "bottleneck", "edge", "processing", "itself", "therefore", "mesh", "render", "time", "do", "significantly", "impact", "result", "timing", "number", "previous", "section", "take", "account", "since", "geometry", "shader", "novel", "architectural", "feature", "may", "better", "optimize", "future", "hardware", "generation", "-lrb-", "-rrb-", "Motion", "blur", "Summary", "future", "work", "we", "have", "design", "efficient", "representation", "process", "both", "edge", "face", "mesh", "GPU", "we", "optimize", "traversal", "representation", "provide", "two", "separate", "improvement", "over", "prior", "approach", "-lrb-", "-rrb-", "nearly", "two-fold", "reduction", "number", "adjacency", "primitive", "-lrb-", "-rrb-", "additional", "reduction", "vertex", "processing", "memory", "bandwidth", "due", "improve", "vertex", "caching", "optimization", "result", "substantial", "gain", "several", "real-time", "rendering", "method", "future", "hardware", "likely", "include", "larger", "primitive", "form", "surface", "patch", "define", "efficient", "traversal", "patch", "interesting", "area", "continue", "research", "Acknowledgments", "Pedro", "Sander", "partly", "support", "Hong", "Kong", "RGC", "CERG", "grant", "619008", "reference", "ndrade", "D.", "ESENDE", "M.", "G.", "C.", "ERNECK", "R.", "2008", "fast", "local", "search", "maximum", "independent", "set", "problem", "Proceedings", "Workshop", "experimental", "algorithm", "lnc", "5038", "page", "220", "234", "SSARSSON", "U.", "kenine", "OLLER", "t.", "2003", "geometrybased", "soft", "shadow", "volume", "algorithm", "use", "graphic", "hardware", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "2003", "-rrb-", "22", "-lrb-", "-rrb-", ":511", "520", "ShaderX5", "Advanced", "Rendering", "Techniques", "W.", "2007", "micro-beveled", "edge", "Charles", "River", "AHNASSI", "H.", "AHNASSI", "Media", "lythe", "D.", "2006", "direct3d", "10", "system", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "2003", "-rrb-", "25", "-lrb-", "-rrb-", ":724", "734", "ShaderX", "Vertex", "Pixel", "Shader", "Tips", "Tricks", "rennan", "C.", "2002", "Shadow", "volume", "extrusion", "use", "vertex", "shader", "wordware", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "144:8", "P.", "Sander", "et", "al.", "ard", "D.", "ITCHELL", "J.", "2002", "non-photorealistic", "render", "pixel", "vertex", "shader", "ShaderX", "Vertex", "Pixel", "Shader", "Tips", "Tricks", "Wordware", "hhuganus", "J.", "UMAR", "S.", "2007", "geometry", "engine", "optimization", "cache", "friendly", "compress", "representation", "geometry", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "page", "16", "how", "M.", "M.", "1997", "optimize", "geometry", "compression", "realtime", "rendering", "IEEE", "visualization", "page", "347", "354", "row", "F.", "C.", "1977", "Shadow", "algorithm", "computer", "graphic", "page", "242", "248", "Proceedings", "ACM", "SIGGRAPH", "77", "arlo", "D.", "inkelstein", "a.", "usinkiewicz", "S.", "TELLA", "A.", "2003", "suggestive", "contour", "convey", "shape", "22", "-lrb-", "-rrb-", ":848", "855", "eering", "M.", "1995", "geometry", "compression", "page", "13", "20", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "2003", "-rrb-", "Proceedings", "ACM", "SIGGRAPH", "95", "dmond", "J.", "OHNSON", "E.", "L.", "1973", "match", "Euler", "tour", "chinese", "postman", "mathematical", "programming", "5:88", "129", "stkowskus", "R.", "ITCHELL", "J.", "S.", "B.", "iang", "X.", "2002", "optimal", "decomposition", "polygonal", "model", "triangle", "strip", "Proceedings", "Symposium", "Computational", "Geometry", "page", "254", "263", "ARSHNEY", "IEEE", "visualization", "implementation", "algorithm", "Maximum", "match", "Nonbipartite", "Graphs", "van", "F.", "kiena", "S.", "a.", "1996", "optimize", "triangle", "strip", "fast", "rendering", "page", "319", "326", "abow", "H.", "N.", "1974", "phd", "thesis", "Stanford", "University", "D.", "S.", "1977", "rectilinear", "Steiner", "AREY", "M.", "R.", "OHNSON", "tree", "problem", "32", "-lrb-", "-rrb-", ":826", "834", "np-complete", "SIAM", "Journal", "Applied", "Mathematics", "non-photorealistic", "rendering", "ooch", "ooch", "B.", "A.", "2001", "a.", "K.", "Peters", "Ltd.", "rosso", "a.", "ocatellus", "M.", "ullan", "W.", "2007", "simple", "ingredient", "lead", "very", "efficient", "heuristic", "maximum", "clique", "problem", "Journal", "Heuristics", "on-line", "all", "P.", "1935", "representative", "subset", "10:26", "30", "EIDMANN", "Journal", "London", "Mathematical", "Society", "Iris", "Universe", "18", "t.", "1991", "real", "shadow", "real", "time", "28", "31", "ertzmann", "a.", "1999", "silhouette", "outline", "introduction", "3d", "Non-Photorealistic", "Rendering", "chapter", "ACM", "SIGGRAPH", "Course", "Notes", "algorithm", "SIAM", "Journal", "OPCROFT", "J.", "E.", "ARP", "R.", "M.", "1973", "5/2", "maximum", "matching", "bipartite", "graph", "-lrb-", "-rrb-", ":225", "231", "Computing", "OPPE", "H.", "1999", "optimization", "mesh", "locality", "transparent", "vertex", "caching", "Proceedings", "ACM", "SIGGRAPH", "99", "page", "269", "276", "ARYPIS", "G.", "UMAR", "V.", "1995", "METIS", "Unstructured", "Graph", "partitioning", "sparse", "Matrix", "Ordering", "System", "Version", "2.0", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "engyel", "J.", "raun", "E.", "inkelstein", "a.", "oppe", "H.", "2001", "real-time", "fur", "over", "arbitrary", "surface", "page", "227", "232", "G.", "T.", "P.-Y", "2006", "improve", "vertex", "caching", "scheme", "3d", "mesh", "rendering", "IEEE", "transaction", "visualization", "computer", "graphic", "12", "-lrb-", "-rrb-", ":640", "648", "uire", "M.", "UGHES", "J.", "2004", "hardware-determined", "feature", "edge", "page", "35", "47", "ICROSOFT", "ORP", "Proceedings", "Symposium", "Non-Photorealistic", "Animation", "Rendering", "-lrb-", "npar", "-rrb-", "DirectX", "10", "SDK", "2007", "othberg", "E.", "1985", "MATHPROG", "http://elib.zib.de/", "pub/packages/mathprog", "matching/weighted", "ander", "P.", "V.", "EHAB", "D.", "arczak", "J.", "2007", "fast", "triangle", "reordering", "vertex", "locality", "reduce", "overdraw", "ACM", "Trans", "action", "graphic", "-lrb-", "Proceedings", "ACM", "SIGGRAPH", "2007", "-rrb-", "26", "-lrb-", "-rrb-", ":89", "ARIQ", "S.", "2007", "Fur", "-lrb-", "use", "shell", "fin", "-rrb-", "Technical", "Report", "WP-03021-001-v01", "NVIDIA", "Corp.", "LOKA", "M.", "M.", "ELEZNIK", "motion", "blur", "Visual", "Computer", "R.", "C.", "1996", "interactive", "real-time", "12", "-lrb-", "-rrb-", ":283", "295", "iang", "X.", "ELD", "M.", "itchell", "J.", "S.", "B.", "1999", "fast", "effective", "stripification", "polygonal", "surface", "model", "pro-", "ceeding", "Symposium", "interactive", "3d", "graphic", "Games", "-lrb-", "i3d", "-rrb-", "page", "71", "78", "appendix", "find", "lower", "bind", "simple", "lower", "bind", "size", "we", "vertex", "cover", "obtain", "follow", "let", "-lrb-", "-rrb-", "denote", "degree", "vertex", "-lrb-", "either", "primal", "dual", "graph", "-rrb-", "-lrb-", "-rrb-", "every", "dual", "vertex", "since", "each", "triangle", "have", "most", "neighbor", "thus", "every", "vertex", "cover", "most", "three", "edge", "so", "can", "tighten", "obtain", "lower", "bind", "number", "edge", "must", "cover", "twice", "intuition", "all", "odddegree", "vertex", "mesh", "must", "have", "least", "one", "adjacent", "edge", "cover", "twice", "moreover", "doubly", "cover", "edge", "must", "form", "path", "terminate", "only", "other", "odd-degree", "vertex", "formally", "consider", "vertex", "primal", "graph", "ring", "-lrb-", "-rrb-", "dual", "vertex", "surround", "-lrb-", "i.e.", "red", "cycle", "Figure", "3a", "-rrb-", "let", "-lrb-", "-rrb-", "denote", "number", "edge", "-lrb-", "-rrb-", "cover", "twice", "since", "cover", "one", "can", "show", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "let", "-lrb-", "-rrb-", "minimum", "subgraph", "-lrb-", "minimize", "-rrb-", "all", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "mod", "-rrb-", "number", "edge", "cover", "twice", "must", "least", "argue", "before", "we", "obtain", "-lrb-", "-rrb-", "set", "edge", "which", "odd-degree", "vertex", "coincide", "set", "call", "join", "thus", "set", "minimum", "odd", "join", "where", "odd", "set", "odd-degree", "vertex", "have", "be", "show", "find", "minimum", "join", "can", "reduce", "minimum-weight", "perfect", "matching", "problem", "particular", "Edmonds", "Johnson", "-lsb-", "1973", "-rsb-", "have", "show", "minimum", "odd", "join", "equivalent", "minimum", "weight", "matching", "between", "odddegree", "vertex", "where", "weight", "attach", "any", "pair", "vertex", "odd", "exactly", "shortest-path", "distance", "dist", "-lrb-", "-rrb-", "thus", "compute", "we", "find", "minimum-weight", "perfect", "matching", "use", "-lrb-", "odd", "-rrb-", "algorithm", "Gabow", "-lsb-", "1974", "-rsb-", "implement", "METIS", "library", "-lsb-", "Karypis", "Kumar", "1995", "-rsb-", "we", "able", "greatly", "speed", "up", "computation", "note", "shortest", "path", "between", "two", "vertex", "odd", "cross", "two", "other", "vertex", "odd", "can", "contribute", "minimum-weight", "perfect", "matching", "we", "call", "path", "illegal", "often", "prune", "99", "search", "space", "verify", "validity", "optimization", "we", "prove", "follow", "lemma", "-lrb-", "actual", "proof", "necessary", "implementation", "either", "we", "algorithm", "lower", "bind", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008", "efficient", "traversal", "Mesh", "Edges", "use", "Adjacency", "Primitives", "144:9", "lemma", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "odd", "odd", "prune", "-lrb-", "odd", "prune", "-rrb-", "odd", "dist", "-lrb-", "-rrb-", "prune", "let", "where", "minimum", "join", "disjoint", "union", "legal", "path", "between", "vertex", "let", "weighted", "graph", "where", "we", "connect", "edge", "weight", "only", "shortest", "path", "between", "illegal", "any", "have", "perfect", "matching", "any", "minimum-weight", "perfect", "matching", "have", "weight", "Proof", "prove", "-lrb-", "-rrb-", "note", "contain", "cycle", "-lrb-", "removal", "preserve", "odd", "join", "-rrb-", "thus", "forest", "i.e.", "vertex-disjoint", "union", "tree", "each", "tree", "we", "find", "legal", "path", "decomposition", "repeatedly", "perform", "following", "contract", "all", "uninterrupted", "path", "individual", "edge", "choose", "lowest", "leaf", "match", "its", "sibling", "remove", "connect", "path", "prove", "-lrb-", "-rrb-", "note", "any", "matching", "total", "length", "all", "shortest", "path", "minimal", "path", "must", "edge-disjoint", "thus", "union", "all", "path", "indeed", "odd", "join", "we", "must", "show", "some", "minimal", "odd", "join", "odd", "connect", "legal", "path", "also", "connect", "illegal", "shortest", "path", "we", "two", "crucial", "observation", "which", "follow", "from", "minimality", "observation", "G.", "Observation", "E.", "any", "vertex", "same", "tree", "shortest", "tree", "path", "connect", "they", "shortest", "path", "any", "vertex", "above", "tree", "path", "only", "shortest", "path", "intersect", "both", "observation", "follow", "from", "same", "principle", "we", "have", "path", "between", "violate", "either", "observation", "observation", "-lrb-", "shorter", "than", "distinct", "shortest", "path", "intersect", "-rrb-", "we", "could", "construct", "strictly", "smaller", "odd", "join", "remove", "path", "take", "symmetric", "difference", "remain", "edge", "set", "set", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "would", "contradict", "minimality", "-lrb-", "see", "replacement", "Figure", "11", "-rrb-", "we", "may", "assume", "contain", "minimum", "number", "tree", "among", "all", "minimum", "odd", "join", "suppose", "sake", "contradiction", "some", "vertex", "odd", "some", "tree", "connect", "legal", "path", "exist", "illegal", "shortest", "path", "contain", "two", "internal", "vertex", "odd", "we", "consider", "two", "case", "Case", "node", "same", "tree", "-lrb-", "possibly", "-rrb-", "-lrb-", "figure", "11a", "-rrb-", "proof", "let", "sub-path", "from", "let", "shortest", "tree", "path", "from", "y.", "minimality", "observation", "both", "path", "shortest", "path", "from", "y.", "thus", "replace", "we", "get", "shortest", "path", "-lrb-", "figure", "11b", "-rrb-", "path", "illegal", "so", "distinct", "from", "intersect", "which", "observation", "contradict", "minimality", "-lrb-", "figure", "11c", "-rrb-", "case", "tree", "-lrb-", "figure", "11d", "-rrb-", "proof", "observation", "do", "intersect", "E.", "thus", "we", "replace", "new", "odd", "join", "-lrb-", "-rrb-", "-lrb-", "figure", "11e", "-rrb-", "contain", "strictly", "fewer", "tree", "than", "contradict", "we", "assumption", "G.", "Figure", "11", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "collapse", "-lrb-", "-rrb-", "replacement", "yield", "fewer", "edge", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "replacement", "yield", "fewer", "tree", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "144", "publication", "date", "December", "2008" ],
  "content" : "\n  \n    ff107008c947e0369be94365cdc034a17eda408e60bc71598c16a5c54d578249\n    ou4\n    10.1145/1409060.1409097\n    Name identification was not possible. \n  \n  \n    \n      \n        Efficient Traversal of Mesh Edges using Adjacency Primitives\n      \n      Pedro V. Sander Diego Nehab Hong Kong UST Microsoft Research\n      \n        \n        \n      \n      (a) (b)\n      \n        Figure 1: (a) Our goal is to enable efficient processing of edges in a triangle mesh using adjacency primitives. (b) We select a minimal subset of triangles (blue) that covers all mesh edges. (c) Each remaining triangle (white) is assigned to a cover triangle (indicated by red segments). (d) We encode each triangle pair as a triangle-with-adjacency primitive, and order these primitives for vertex cache locality (cache hits in green, misses in red). This new representation reduces storage, bandwidth, and GPU computation, resulting in substantial gains for a variety of edge-processing techniques.\n      \n      Processing of mesh edges lies at the core of many advanced realtime rendering techniques, ranging from shadow and silhouette computations, to motion blur and fur rendering. We present a scheme for efficient traversal of mesh edges that builds on the adjacency primitives and programmable geometry shaders introduced in recent graphics hardware. Our scheme aims to minimize the number of primitives while maximizing SIMD parallelism. These objectives reduce to a set of discrete optimization problems on the dual graph of the mesh, and we develop practical solutions to these graph problems. In addition, we extend two existing vertex cache optimization algorithms to produce cache-efficient traversal orderings for adjacency primitives. We demonstrate significant runtime speedups for several practical real-time rendering algorithms. Keywords: real-time rendering, silhouettes, shadow volumes, vertex locality, programmable geometry shader.\n    \n    \n      \n        1 Introduction\n      \n      Triangles are a widespread rasterization primitive, so there is a large body of work on optimizing the traversal of triangle meshes for efficient rendering, e.g. using triangle strips [Evans et al. 1996; Xiang et al. 1999; Estkowski et al. 2002], managed vertex buffers [Deering 1995; Chow 1997], and indexed strips with vertex caching [Hoppe 1999; Lin and Yu 2006; Sander et al. 2007; Chhugani and Kumar 2007]. In particular, current GPUs include a vertex cache to al low reuse of post-shaded vertices among several adjacent triangles, thereby achieving significant reduction in both memory bandwidth and vertex shader computation. Many advanced rendering techniques process not only mesh faces but also mesh edges. Applications include shadow volumes [Crow 1977], silhouette rendering [Hertzmann 1999; Gooch and Gooch 2001], motion blur [Wloka and Zeleznik 1996], fur rendering [Lengyel et al. 2001], and wireframe rendering. In most techniques, processing an edge requires access to its two adjacent faces. This has motivated the introduction of adjacency primitives in the latest graphics systems [Blythe 2006]. The primitives are processed in a new programmable unit of the graphics pipeline, the geometry shader, which reads a primitive, performs computation, and emits a variable number of new primitives. In this paper, we present a general scheme that optimizes the traversal of a mesh for efficient GPU processing of its edges. To our knowledge, this is the first attempt at such an optimization. Some graphics applications require traversal of triangles in addition to edges, and we explore how this can be achieved efficiently in the same traversal pass, or in separate passes using the same vertex and index buffers. Approach Our basic strategy is to traverse the mesh using a list of triangle-with-adjacency primitives. As shown in Figure 2a , each such primitive uses 6 indices to encode a central cover face as well as its 3 adjacent faces. In principle, the primitive permits the processing of the cover face itself, all its 3 edges, and all its 3 adjacent faces. Our goal is to process all mesh edges and triangles exactly once, using the same list of primitives, while keeping the overall number of primitives to a minimum. Because the geometry shaders consider many primitives simultaneously with SIMD parallelism on the GPU, it is crucial for computational efficiency that processing each primitive requires the same sequence of steps. To maximize this SIMD efficiency, we allow each adjacency primitive to process 1 or 2 faces at a time (Figure 2a): the central cover face, and an optional adjacent face that we refer to as the assigned face. To further improve SIMD parallelism, we place some restrictions on the selection of assigned faces, as discussed in Section 5. Note that, in regular mesh regions, all edges and faces can be covered by introducing primitives for only half of the triangles, i.e. all the faces ?pointing in the same direction? ( Figure 2b ), each one assigned to a face pointing in the opposite direction. On the other hand, around any irregular vertex of odd degree, at least one edge must be covered twice, and therefore some redundancy is inevitable ( Figure 2c ). Nevertheless, because most triangles-with-adjacency primitives encode two faces, the index buffer contains only about 3 indices per mesh triangle (one primitive for every 2 mesh triangles, 6 indices per primitive), and therefore has approximately the same memory cost as the widely used indexed triangle list representation. Algorithm overview The problems we face can be formulated as graph theoretical problems on the dual graph induced by the triangle mesh. In particular, we show that selecting a minimum number of primitives to cover all edges reduces to a minimum vertex cover problem, and that assigning the remaining faces to these primitives reduces to two bipartite matching problems. Our algorithm has three major steps, as shown in Figure 1 : 1. The vertex cover problem is NP-complete, but fortunately in our particular setting we can rely on a fast approximation using a stochastic algorithm. Moreover, by deriving a good lower bound on the number of cover faces, we are able to show that, for practical triangle meshes, the approximate solutions are within a few percent of optimal; 2. The face assignment problem reduces to two bipartite matching problems, and can therefore be solved quickly in O(n 1.5 ) time; e.g. only 4 sec for a mesh with n = 75,000 vertices. In particular, we prove the surprising result that perfect matchings are guaranteed to exist, even with the added restrictions introduced for SIMD efficiency; 3. Having determined a set of triangles-with-adjacency, we optimize their ordering to maximize vertex cache reuse. The cover and assignment problems are always solved in an offline preprocess. Because ordering efficiency depends on cache size, we provide two ordering algorithms: a slower, careful scheme that assumes prior knowledge of the cache size, and a faster scheme that can be run at load time based on the specific hardware.\n      ACM Reference Format Sander, P., Nehab, D., Chlamtac, E., Hoppe, H. 2008. Efficient Traversal of Mesh Edges using Adjacency Primitives. ACM Trans. Graph. 27, 5, Article 144 (December 2008), 9 pages. DOI = 10.1145/1409060.1409097 http://doi.acm.org/10.1145/1409060.1409097. Copyright Notice Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the fi rst page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2008 ACM 0730-0301/2008/05-ART144 $5.00 DOI 10.1145/1409060.1409097 http://doi.acm.org/10.1145/1409060.1409097\n      Eden Chlamtac Hugues Hoppe Princeton University Microsoft Research\n      \n        \n        \n      \n      (c) (d)\n      (a) (b) (c)\n      \n        Figure 2: (a) Our mesh traversal primitive is the triangle-withadjacency, which we use to process up to 3 edges and 2 faces. (b) It provides an optimal cover in regular mesh regions. (c) On the other hand, around any odd-degree vertex, at least one adjacent edge must be covered twice.\n      \n      ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n      144:2 ? P. Sander et al.\n      \n        edges\n      \n      \n        faces,\n        Contributions: ? A construction that minimizes the number of adjacency primitives needed for the processing of mesh (Section 4); ? An accurate lower bound algorithm that confirms the quality of this minimization (Appendix); ? A construction that allows this reduced set of primitives to process all mesh retaining SIMD efficiency (Section 5); ? The first modified algorithms that perform vertex cache optimization on lists of triangles-with-adjacency (Section 6).\n        (a) (b)\n        \n          Figure 3: (a) Primal graph associated to a mesh (black), and its dual (red). (b) Automatic inclusion of boundary faces into cover.\n        \n      \n      \n        2 Previous work\n        Optimizing the traversal of mesh edges on the GPU is a relatively unexplored area. One prior technique for computing shadow volumes entirely on the GPU is to introduce a degenerate quadrilateral on each edge of the input mesh, and to selectively translate vertices to expand a fraction of these degenerate faces to form the sides of the shadow volume [Brennan 2002]. However, the technique requires splitting the mesh vertices in a preprocess, resulting in a mesh that is 6 times as large as the original. Some related techniques for GPU rendering of silhouettes or fins also introduce degenerate quadrilaterals on edges [Card and Mitchell 2002; McGuire and Hughes 2004], and therefore also require memory buffers with many additional vertices and faces. Several sample programs demonstrate applications of the new triangle-with-adjacency primitive [Microsoft Corp 2007; Tariq 2007]. The basic approach in all these programs is to instantiate a primitive for each input triangle. To avoid processing interior edges twice, a test is performed in the geometry shader to appropriately skip half of the edges. This test is based either on the triangle orientation at silhouettes, or on per-edge ordering of vertex indices. Note that such local branching leads to inefficient SIMD processing. In contrast, our scheme generates roughly half as many primitives, and moreover most of these primitives process all 3 of their adjacent edges, resulting in excellent SIMD utilization.\n      \n      \n        3 Notation\n        We describe our processing pipeline in the next three sections using the following notation. A triangle mesh M (V, E, T ) is defined by a set of vertices V , edges E, and triangles T . Each triangle is formed by three vertices {v i , v j , v k } in V , and defines three edges: {v i , v j }, {v j , v k }, and {v k , v i }. The set E contains all edges defined by the triangles in T . As shown in Figure 3a , two undirected graphs can be associated with mesh M . The primal graph G(V, E) has the same vertices V and edges E. The dual graph G (V , E ), on the other hand, has one vertex in V for each triangle in T . The edges in E connect two vertices in V if and only if the associated triangles in T share an edge in E.\n      \n      \n        4 Covering all edges\n        Recall that our goal is to create a minimum set of triangle-withadjacency primitives that allow the processing of all edges in a mesh M (V, E, T ). This is equivalent to finding the minimum vertex cover C ? V in the dual graph G (V , E ). In general, a set of vertices B ? V may be adjacent to the mesh boundary, and must therefore be part of the cover. For meshes with boundaries, we find the minimal vertex cover C ? on the reduced graph G ? (V \\B , E ? ) (i.e., G with all boundary vertices removed, as shown in Figure 3b), and return C = C ? ? B . Ideally, we would like to find the minimum vertex cover in G ? . However, the problem is NP-complete [Garey and Johnson 1977], even for the graphs with maximum degree 3 arising from manifold triangle meshes. Therefore, we look for heuristics that produce  good minimal covers, in which no vertex can be trivially removed without leaving an uncovered edge. Note that the cover C is also minimal, since every v ? B is needed to cover a corresponding boundary edge, and by minimality of C ? , no v ? C ? can be removed without exposing an internal edge in G ? . Several recent stochastic algorithms address the related problems of computing approximations to minimal vertex covers, maximum cliques, or maximum independent sets on large graphs [Grosso et al. 2007; Andrade et al. 2008]. Although we could use any of them for our purposes, our implementation is based on the method of Grosso et al. [2007]. This is an excellent maximum clique approximation heuristic, which is related to the minimum vertex cover as follows: C is a minimum vertex cover for graph G (V , E ) if and only if C = V \\ C is a maximum clique on the complement graph G (V , E ), where E is the set of all edges not in E . The algorithm of Grosso et al. iterates between two steps: a perturbation and a tabu search. Each iteration starts with a maximal clique K, and ends with a new maximal clique K . First, the perturbation sets K =K, adds a random vertex v ? K , and corrects K by removing from it all vertices not adjacent to v. Next, the tabu search successively grows K until it is maximal again, while also attempting to translate it away from K as long as they share at least one vertex. At the end of the iteration, K is replaced by K if the cardinality of K is larger. Fortunately, it is possible to apply the stochastic algorithm to our vertex cover problem without having to explicitly construct the complement set E , which would have quadratic complexity. We first modify the algorithm of Grosso et al. by negating all the edge tests, to construct a maximal independent set I. Our minimal vertex cover C is simply the complement I of this intermediate result. We find that the stochastic algorithm produces excellent minimal covers C on a wide variety of input graphs produced from triangle meshes. To quantify the quality of these results, we develop an efficient algorithm that provides a good lower bound on |C|. To emphasize that this bound is only used for evaluation purposes, and is not a necessary part of our processing pipeline, we describe it in the appendix. Using this lower bound, we determine that the covers C are typically within 2-3% of optimal (see Table 1 ). In fact, since the lower bound is not tight, the covers may be closer to optimal than suggested by these numbers.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        Efficient Traversal of Mesh Edges using Adjacency Primitives ? 144:3\n        \n          Figure 4: For fast geometry shader evaluation, we allow only 6 configurations of the triangle-with-adjacency primitive. Each primitive processes the central triangle (blue), a subset of its edges (solid lines), and an optional matched triangle (white). Repeated vertex indices identify edges that should not be processed, a missing adjacent face, or both.\n        \n      \n      \n        5 Assigning the remaining triangles\n        Having created a triangle-with-adjacency primitive centered at each cover face, we assign the uncovered faces to adjacent faces within these primitives. For efficient SIMD load-balancing, we assign at most one uncovered face to each primitive. And to simplify the runtime traversal, we assume that this assigned face is the first adjacent face {0, 1, 2} within the primitive (see Figure 4 ). If the primitive lacks an assigned face, is at the boundary, or if one of its edges has already been covered by a neighboring primitive, we encode a degenerate face by duplicating some vertex indices (also shown in Figure 4 ). There are two ways to duplicate the index, and we can use them to distinguish between boundary edges and edges that have already been covered. Note, however, that whenever {0, 2} is not a boundary edge and face {0, 1, 2} is made degenerate, edge {0, 2} also becomes degenerate and cannot be processed by the current primitive. Recall that processing of an edge requires access to both its adjacent triangles, but in this primitive one of them is degenerate. Therefore, the edge must be processed by another primitive: the primitive centered on face {0, 1, 2}, which must be a cover face too. Thus, if a non-boundary cover face f 1 lacks an assigned face, it must be adjacent to another cover face f 2 , which if it also lacks an assigned face and is not on the boundary, must be adjacent to a third cover face f 3 , etc. This chain of restrictions is satisfied if every connected component of cover faces has at least one face that is either adjacent to the mesh boundary or is matched to an uncovered face. This constrains the acceptable matchings, but we will prove that nonetheless it is always possible to find such a perfect restricted matching. Formally, given the minimal cover C in the dual graph G (including all dual vertices corresponding to boundary faces), we must match each remaining vertex in C = V \\ C to a vertex in C. Finding an unrestricted matching from C to C is easy. Let d(v) denote the degree of vertex v. If we consider the bipartite graph G = ({C, C}, E (C, C)), where E (C, C) ? E is the subset of edges between C and C, we see that d G (v ) = 3 for all v ? C (since v is not in the cover, all its three neighbors must be), and d G (v ) ? 3 for all v ? C (a triangle has at most three neighbors). It follows that C satisfies the marriage condition, which is that for any subset C ? C and its neighbors ? G (C ) ? C, we have |? G (C )| ? |C |. Thus Hall?s theorem [Hall 1935] guarantees the existence of a matching M from C to C. To express the conditions on the restricted matching, denote by {C i } the partition into connected components of the subgraph of G induced on C. For each C i we must ensure that at least one of the following two conditions holds: 1. Some v ? C i corresponds to a mesh boundary triangle, or 2. Some v ? C i is matched to C, i.e. it has an assigned face. The proof of the following lemma (illustrated in Figure 5 ) describes a construction algorithm for the restricted matching.\n        Lemma 1.\n        G M\n        C C\n      \n      \n        For any bipartite graph as above, there always exists a perfect restricted matching from to satisfying the above requirements.\n        Proof. As we have seen, there always exists some unrestricted perfect matching M from C to C ( Figure 5a ). We must find a matching M that also covers at least one face in each component C i that does not contain a boundary face. Let A ? {C i } denote this set of components. Let us collapse for a moment each C i ? A to a single vertex, and merge repeated edges. Our problem is to find a perfect matching in this graph from A to C. We again use Hall?s theorem, which we can apply if the marriage condition is satisfied. That is, for any subset K ? A of non-boundary components, and its neighbors ?(K) ? C, we must show that |K| ? |?(K)|. Indeed, let E (K) be the set of dual edges from K to ?(K) before merging. Note that each C i ? A must have at least three edges in G going to C (since, by minimality of the cover C, the corresponding bounded region in the primal is surrounded by faces in C). Moreover, every u ? C has degree ? 3 (originally every u ? C had degree 3, though some of its edges might not participate in E (K)). Therefore 3|K| ? |E (K)| ? 3|?(K)|. Thus, by Hall?s theorem, there exists a matching N from A into C ( Figure 5b ).\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        144:4 ? P. Sander et al.\n        \n          c\n          (a) Matching M (b) Matching N M\n        \n        \n          Figure 5: The face assignment corresponds to a restricted matching problem on a bipartite graph (where gray shaded regions denote connected components). (a) The initial unrestricted perfect matching leaves an isolated covered face (star) unmatched. (e) After several steps, our construction is guaranteed to find a final perfect matching such that all connected covered faces have at least one matching.\n        \n        Now consider the union of the two matchings M ?N ( Figure 5c ). These form a disjoint collection of cycles and paths (because every vertex in this graph has degree ? 2). Let v ? C be a vertex participating in matching N but not in M (the star in Figure 5 ). Then there is a path alternating between C and C which starts at v and ends in a vertex u ? C which participates in M but not N (Figure 5d). Let P be the set of edges in all such alternating paths (note that they are disjoint). Now take M and flip the membership of all edges in the alternating paths, producing a new perfect matching M = (M \\ P ) ? (P \\ M ) ( Figure 5e ). Clearly, matching M also covers all of C. Let us verify that every C i ? A participates in this matching. Since A is completely matched by N , every C i must contain some vertex v that is matched by N . If it is also matched by M , then it will participate in M regardless of whether an alternating path going through it is flipped. Otherwise, it is the initial vertex in an alternating path, and thus will participate in M once this path is flipped. To find the bipartite matchings, we use the algorithm by Hopcroft and Karp [1973], as implemented by Rothberg [1985]. The time complexity of this algorithm is O(|E | |V |), which is simply O(n 1.5 ) on the size of the input mesh.\n      \n      \n        6 Ordering primitives for vertex locality\n        The idea of reordering primitives for efficient GPU traversal is not new, but has previously been limited to triangle primitives. Several methods optimize the traversal of indexed triangles in a mesh to maximize the runtime efficiency of a GPU vertex cache. We focus here on the methods that are most related to our approach, and refer the reader to Chhugani and Kumar [2007] for a more complete survey. Hoppe [1999] shows the efficacy of a FIFO cache, and builds successive triangle strips by greedily optimizing their lengths. Lin and Yu [2006] improve caching efficiency by using triangle fans and optimizing their selection based on the age of the vertex in the cache and the number of cache misses that would result. Chhugani and Kumar [2007] further improve the cache efficiency; their approach partitions the mesh triangles into adjacent chains, and then splits the chains into strips using dynamic programming. Sander et al. [2007] develop a fast algorithm that does not require mesh adjacency, has linear complexity independent of cache size, and is therefore suitable for load-time optimization of triangle buffers. Our contribution is to optimize the traversal of triangle primitives with adjacency, created as described in the previous two sections. Because each adjacency primitive involves a larger stencil of up to 6 vertices, naive application of previous reordering methods gives poor results. (We arbitrarily selected [Lin and Yu 2006] as the representative ?off-the-shelf? method.)\n        \n          c\n          ? N\n        \n        (d) Alternating path (e) Final matching M\n        (a) Careful scheme: 6 primitives (b) Fast scheme: 3 primitives\n        \n          Figure 6: Each of our reordering algorithms considers a different set of primitives around a central vertex.\n        \n        We chose to extend two of the prior methods, namely [Lin and Yu 2006] and [Sander et al. 2007], because their strategy of emitting all unvisited primitives adjacent to a central vertex can be generalized to other primitive types. In the results, we denote our extensions of these two methods as the ?careful? and ?fast? schemes, respectively.  Careful scheme based on extending [Lin and Yu 2006] The algorithm of Lin and Yu proceeds by iteratively selecting a central vertex and emitting all its adjacent unvisited faces. The vertex selection algorithm considers the position of the vertex in the cache, the number of unvisited faces, and the number of cache misses that would result. We modify this cost analysis to consider the ring of adjacency primitives that reference the candidate central vertex. In a regular mesh region, there are 6 such primitives, as shown in Figure 6a. We also modify the algorithm to emit the adjacent primitives in the order that minimizes the resulting number of cache misses. Fast scheme based on extending [Sander et al. 2007] The algorithm of Sander et al. considers fewer candidates for the next central vertex to process, and makes the conservative assumption that unvisited adjacent faces may cause two additional cache misses. With adjacency primitives, this conservative bound must be raised to five cache misses per primitive. Therefore, to obtain good results, we found it necessary to emit only the primitives whose cover face is immediately adjacent to the central vertex; i.e. only up to 3 adjacency primitives in a regular mesh region, as shown in Figure 6b . As this scheme takes only a fraction of a second to run even on large meshes ( Table 1 ), it can be used to quickly specialize the primitive ordering to the cache size of a given graphics system. Note that the cover and assignment can still be obtained in a preprocessing stage, since they are unaffected by cache size. As future work, it would also be interesting to explore extensions of [Hoppe 1999] and [Chhugani and Kumar 2007], which are based on strips.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        Efficient Traversal of Mesh Edges using Adjacency Primitives ? 144:5\n        \n          Table 1: Results of our traversal optimization on several meshes.\n          \n             Ordering ? Input mesh Cover Assignment Careful Fast\n            \n              \n                \n                   Name\n                   # Faces\n                   Lower bound (B)\n                   Cover (C)\n                   C/B\n                   Time (s)\n                   Time (s)\n                   CM/V ?\n                   Gain ?\n                   Time (s)\n                   CM/V ?\n                   Gain ?\n                   Time (s)\n                \n              \n              \n                \n                   fandisk\n                   9,926\n                   5,199 (52.3%)\n                   5,335 (53.7%)\n                   1.026\n                   0.62\n                   0.07\n                   1.496\n                   1.955\n                   1.23\n                   1.755\n                   1.666\n                   0.002\n                \n                \n                   gargoyle\n                   20,000\n                   10,880 (54.4%)\n                   11,225 (56.1%)\n                   1.032\n                   1.42\n                   0.22\n                   1.517\n                   1.794\n                   3.12\n                   1.805\n                   1.508\n                   0.006\n                \n                \n                   feline\n                   41,262\n                   21,937 (53.2%)\n                   22,570 (54.7%)\n                   1.029\n                   3.50\n                   0.70\n                   1.529\n                   1.903\n                   6.17\n                   1.816\n                   1.602\n                   0.014\n                \n                \n                   bunny\n                   69,473\n                   36,382 (52.4%)\n                   37,168 (53.5%)\n                   1.022\n                   8.47\n                   0.92\n                   1.535\n                   1.938\n                   9.33\n                   1.780\n                   1.672\n                   0.023\n                \n                \n                   dragon\n                   150,000\n                   81,520 (54.3%)\n                   84,034 (56.0%)\n                   1.031\n                   50.32\n                   4.02\n                   1.505\n                   1.671\n                   21.73\n                   1.807\n                   1.417\n                   0.053\n                \n                \n                   turtle\n                   267,931\n                   142,390 (53.1%)\n                   146,158 (54.6%)\n                   1.026\n                   55.08\n                   5.95\n                   1.533\n                   1.885\n                   36.38\n                   1.792\n                   1.608\n                   0.099\n                \n                \n                   buddha\n                   1,087,716\n                   591,909 (54.4%)\n                   610,526 (56.1%)\n                   1.031\n                   315.38\n                   341.00\n                   1.501\n                   1.677\n                   212.58\n                   1.798\n                   1.400\n                   1.256\n                \n                \n                   Measurements Measurements\n                   are based\n                   on a cache with\n                   24 entries. ? CM/V\n                   indicates\n                   cache misses\n                   per mesh\n                   vertex and\n                   has a\n                   lower bound\n                   of 1. ?\n                   Gain factors\n                  \n                \n                \n                   reduction in\n                   cache misses\n                   compared to an\n                   off-the-shelf method.\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                \n              \n            \n          \n          Ordering ? Input mesh Cover Assignment Careful Fast Name # Faces Lower bound (B) Cover (C) C/B Time (s) Time (s) CM/V ? Gain ? Time (s) CM/V ? Gain ? Time (s) fandisk 9,926 5,199 (52.3%) 5,335 (53.7%) 1.026 0.62 0.07 1.496 1.955 1.23 1.755 1.666 0.002 gargoyle 20,000 10,880 (54.4%) 11,225 (56.1%) 1.032 1.42 0.22 1.517 1.794 3.12 1.805 1.508 0.006 feline 41,262 21,937 (53.2%) 22,570 (54.7%) 1.029 3.50 0.70 1.529 1.903 6.17 1.816 1.602 0.014 bunny 69,473 36,382 (52.4%) 37,168 (53.5%) 1.022 8.47 0.92 1.535 1.938 9.33 1.780 1.672 0.023 dragon 150,000 81,520 (54.3%) 84,034 (56.0%) 1.031 50.32 4.02 1.505 1.671 21.73 1.807 1.417 0.053 turtle 267,931 142,390 (53.1%) 146,158 (54.6%) 1.026 55.08 5.95 1.533 1.885 36.38 1.792 1.608 0.099 buddha 1,087,716 591,909 (54.4%) 610,526 (56.1%) 1.031 315.38 341.00 1.501 1.677 212.58 1.798 1.400 1.256 ? Measurements are based on a cache with 24 entries. ? CM/V indicates cache misses per mesh vertex and has a lower bound of 1. ? Gain factors indicate reduction in cache misses compared to an off-the-shelf method.\n        \n        \n          \n        \n        (a) Input mesh (b) Cover faces and (c) Careful assignment vertex cache ordering\n        \n          Figure 7: Results of our mesh traversal construction on 4 representative meshes from Table 1 .\n        \n        (d) Fast (e) Off-the-shelf vertex cache ordering vertex cache ordering\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        144:6 ? P. Sander et al.\n      \n      \n        7 Results and applications\n         Table 1 shows the results of our traversal construction for an assortment of practical meshes. The C/B column represents the ratio between the cover results (C) and our computed lower bound results (B). Remarkably, C/B indicate that Grosso et al. [2007] can find cover solutions that are only 2?3% worse than the lower bound, and therefore at most 2?3% worse than optimal. In practice, both the cover and the assignment steps can be performed efficiently (in seconds for small models, and minutes for large models). Note that this is a pre-processing algorithm and therefore not time-critical. As shown later in the applications, the excellent cover and assignment results translate into significant speedups in practical rendering scenarios. Figure 9 plots the cache efficiency as a function of cache size. The efficiency, denoted CM/V, is given by the number of cache misses divided by the number of vertices. Lower values are better, and the optimal minimum value is 1, given that each vertex must be processed at least once. Note the substantial reduction in the number of cache misses per vertex for both our careful and fast schemes compared to the ordering produced by a representative prior algorithm designed for triangle primitives without adjacency. As shown in Table 1 , the fast scheme is orders of magnitude faster than the careful scheme, and like [Sander et al. 2007], its processing time is independent of the cache size. Figure 7 shows a visualization of the results on 4 meshes from Table 1 . The spatial distribution of cache efficiency is conveyed by coloring each mesh vertex according to its total number of cache misses. The color white corresponds to the optimal single cache miss per vertex. Darker shades of gray indicate progressively more cache misses per vertex. We demonstrate the practical advantages of our efficient edgeprocessing traversal with three applications (see Figure 8 ). Shadow volumes The mesh is rendered as a shadow volume into a screen-space stencil buffer [Heidmann 1991]. The shadow volume is formed within the geometry shader, by displacing triangles to form a front cap and a rear cap (depending on whether they face the light), and by extruding silhouette edges (with respect to the light) to form quadrilaterals spanning these caps. As a baseline, we used sample program ShadowVolume10 of the DirectX 10 SDK, and modified it to use our optimized set of cover primitives (Figure 8a). Note that our geometry shader outputs triangle strips rather than independent triangles ( Figure 10 ). This results in a small speed improvement of 10?20%, and was applied in all measurements. Line illustration Many rendering techniques enhance object appearance by emphasizing silhouettes or other important contours, e.g. [Gooch and Gooch 2001; DeCarlo et al. 2003]. With geometry shaders, silhouette rendering is in some sense an ideal scenario to highlight the efficiency of GPU edge-processing, because the output silhouette often has sub-linear complexity. We developed a simple prototype that renders both silhouettes and sharp features ( Figure 8b ). Again, we used as a baseline the basic approach of processing all faces as triangles with adjacency following the framework from the DX10 shadow volume sample. Since we use small quadrilaterals as the rendering primitive, we can control the thickness of the lines, as well as render the mesh triangles in white for hidden line removal, all in a single rendering pass. Motion blur Wloka and Zeleznik [1996] describe a real-time technique to approximate the blur caused by the motion of an object relative to the viewer. The approach has similarities to shadow volumes, in that the mesh is also split into a front part and a rear part, and silhouette edges (with respect to the motion) are extruded to form quadrilaterals. As in the previous applications, we compared against the traditional approach of processing all triangles with adjacency. The resulting motion volume is rendered with par- tial transparency. Using a geometry shader program, this can all be done in a single rendering pass ( Figure 8c ). As in the shadow volume application, we output triangle strips since the extruded quadrilaterals share vertices with the emitted triangle faces ( Figure 10 ). Quantitative speedups We measured performance speedup factors of using our approach against the baseline methods outlined above for each application. Measurements were performed on both an NVIDIA GeForce 8800GTX and an AMD ATI Radeon HD2900. To simulate a more realistic graphics scene, the measurements used multiple instances of the models to factor out overhead due to frame setup and other elements in the scene. Through experimentation, we observed best results for our applications on the AMD and NVIDIA cards when setting the vertex cache parameter to 12 and 24 vertices, respectively. At any rate, the results we report were not significantly affected by the cache size parameter. For our geometry-shader-bound prototype applications, which just use Gouraud shading, the vertex programs may be overly simple. We have verified that a more expensive vertex program does give rise to greater speedups. It is likely that geometry shader implementations may become more efficient in the future, thus further increasing the importance of careful primitive ordering. The speedups produced by using our approach are reported in Table 2 . Since we are processing just over half of the number of primitives, the speedup of the cover computation could reach close to 2?. However, in practice this does not occur because each of our geometry shader instances emit more data. In general, these applications results in speedups between 1.5? and 2.0? for most input meshes. Other applications Many other applications would also benefit from efficient edge traversal. Some notable examples include fur rendering by selective extrusion of fins from edges near the silhouette [Lengyel et al. 2001], soft-shadows using penumbra wedges [Assarsson and Akenine-M?ller 2003], and beveled edges [Bahnassi and Bahnassi 2007]. One final note is that the set of cover faces can also be used to render the wireframe of the model (without a geometry shader, i.e. with mode D3D10 FILL WIREFRAME). We noticed a speedup of roughly 70% when using the cover faces rather than all faces of the model. This is naturally not as efficient as the 100% improvement that can be obtained by creating a buffer of lines containing the edges of the model. However, it may be of practical value if the list of cover faces is already available (e.g., for one the above applications), since it would not consume any additional video memory.\n        4 off-the-shelf fast 3.5 careful 3 CM/V 2.5 2 1.5 1 12 16 20 24 28 32 36 40 44 48 52 56 60 64 Cache size\n        \n          Figure 9: Number of cache misses per vertex comparing our ordering algorithms against the off-the-shelf technique, when run on the bunny mesh.\n        \n        \n          Figure 10: Grouping of geometry shader output to form triangle strips, for the applications of shadow volume and motion blur. Just two strips are sufficient in all cases.\n        \n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        Efficient Traversal of Mesh Edges using Adjacency Primitives ? 144:7\n        \n          \n        \n        (a) Shadow volume (b) Line illustration\n        \n          Figure 8: Screenshots of our prototype applications.\n        \n        \n          Table 2: Rendering speedup of our prototype applications compared to the common approach of processing one adjacency primitive per mesh face. Timings of our approach (in milliseconds) are shown in parenthesis.\n          \n             Input mesh Shadow volume Line illustration Motion blur\n            \n              \n                \n                   Name\n                   AMD\n                   NVIDIA\n                   AMD\n                   NVIDIA\n                   AMD\n                   NVIDIA\n                \n              \n              \n                \n                   fandisk\n                   1.65\n                   1.76 (0.6)\n                   1.70\n                   1.82 (0.6)\n                   1.54\n                   1.52 (0.6)\n                \n                \n                   gargoyle\n                   1.58\n                   1.76 (1.2)\n                   1.70\n                   1.83 (1.2)\n                   1.54\n                   1.51 (1.1)\n                \n                \n                   feline\n                   1.60\n                   1.77 (2.3)\n                   1.72\n                   1.87 (2.4)\n                   1.59\n                   1.52 (2.2)\n                \n                \n                   bunny\n                   1.73\n                   1.76 (3.2)\n                   1.81\n                   1.92 (3.7)\n                   1.60\n                   1.48 (3.4)\n                \n                \n                   dragon\n                   1.74\n                   1.82 (7.7)\n                   1.84\n                   1.89 (7.9)\n                   1.62\n                   1.52 (8.5)\n                \n                \n                   turtle\n                   1.70\n                   1.75 (13.7)\n                   1.80\n                   1.96 (14.0)\n                   1.60\n                   1.48 (14.9)\n                \n                \n                   buddha\n                   1.70\n                   1.73 (55.5)\n                   1.80\n                   1.95 (57.0)\n                   1.61\n                   1.50 (60.8)\n                \n              \n            \n          \n          Input mesh Shadow volume Line illustration Motion blur Name AMD NVIDIA AMD NVIDIA AMD NVIDIA fandisk 1.65 1.76 (0.6) 1.70 1.82 (0.6) 1.54 1.52 (0.6) gargoyle 1.58 1.76 (1.2) 1.70 1.83 (1.2) 1.54 1.51 (1.1) feline 1.60 1.77 (2.3) 1.72 1.87 (2.4) 1.59 1.52 (2.2) bunny 1.73 1.76 (3.2) 1.81 1.92 (3.7) 1.60 1.48 (3.4) dragon 1.74 1.82 (7.7) 1.84 1.89 (7.9) 1.62 1.52 (8.5) turtle 1.70 1.75 (13.7) 1.80 1.96 (14.0) 1.60 1.48 (14.9) buddha 1.70 1.73 (55.5) 1.80 1.95 (57.0) 1.61 1.50 (60.8)\n        \n      \n      \n        8 Discussion\n        Dismissed alternative schemes We briefly summarize some other schemes that we considered and their associated drawbacks. Each edge could be processed individually by considering its pair of adjacent faces, encoded by 4 vertices, e.g. in an indexed line-with-adjacency primitive. However, this would result in an index buffer with 4e indices for e edges, about twice as many as in our scheme. Also, face processing could not be well load-balanced among these primitives. The triangle-strip-with-adjacency primitive would appear to be a promising way to string together several triangle-with-adjacency primitives. However, even on a regular mesh region, one cannot obtain a regular covering of the mesh edges. Therefore, branching would be necessary in the geometry shader, again degrading SIMD parallelism efficiency. Limitations In current GPUs, the introduction of any geometry shader slows down the rendering pipeline. Therefore using our representation to render just the mesh faces incurs additional cost.  However, for most applications that perform edge processing, the bottleneck is in the edge processing itself, and therefore the mesh rendering time does not significantly impact the results. The timing numbers in the previous section take that into account. Since geometry shaders are a novel architectural feature, they may be better optimized in future hardware generations.\n        (c) Motion blur\n      \n      \n        9 Summary and future work\n        We have designed an efficient representation for processing both edges and faces of a mesh on a GPU. Our optimized traversal representation provides two separate improvements over prior approaches: (1) a nearly two-fold reduction in the number of adjacency primitives, and (2) additional reduction in vertex processing and memory bandwidth due to improved vertex caching. These optimizations result in substantial gains for several real-time rendering methods. Future hardware is likely to include larger primitives in the form of surface patches. Defining efficient traversals for such patches will be an interesting area of continuing research.\n      \n      \n        Acknowledgments\n        Pedro Sander was partly supported by Hong Kong RGC CERG grant #619008.\n      \n      \n        References\n        \n          A NDRADE , D., R ESENDE , M. G. C., and W ERNECK , R. 2008. Fast local search for the maximum independent set problem. In\n        \n      \n      \n        Proceedings of Workshop on Experimental Algorithms, LNCS 5038,\n        pages 220?234.\n        A SSARSSON , U. and A KENINE -M OLLER  ? , T. 2003. A geometrybased soft shadow volume algorithm using graphics hardware.\n      \n      \n        ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2003),\n        22(3):511?520.\n      \n      \n        ShaderX5: Advanced Rendering Techniques.\n        , W. 2007. Micro-beveled edges. Charles River\n        B AHNASSI , H. and B AHNASSI In Media.\n        B LYTHE , D. 2006. The Direct3D 10 system.\n      \n      \n        ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2003),\n        25(3):724?\n        734.\n      \n      \n        ShaderX: Vertex and Pixel Shader Tips and Tricks.\n        B RENNAN , C. 2002. Shadow volume extrusion using a vertex shader. In Wordware.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        144:8 ? P. Sander et al.\n        C ARD , D. and M ITCHELL , J. 2002. Non-photorealistic rendering with pixel and vertex shaders. In ShaderX: Vertex and Pixel Shader Tips and Tricks. Wordware. C HHUGANI , J. and K UMAR , S. 2007. Geometry engine optimization: cache friendly compressed representation of geometry. In Proceedings of Symposium on Interactive 3D Graphics and Games (I3D), pages 9?16. C HOW , M. M. 1997. Optimized geometry compression for realtime rendering. In IEEE Visualization, pages 347?354.\n        C\n        ROW , F. C. 1977. Shadow algorithms for computer graphics. In pages 242?248.\n      \n      \n        Proceedings of ACM SIGGRAPH 77,\n        D E C ARLO , D., F INKELSTEIN , A., R USINKIEWICZ , S., and S AN TELLA , A. 2003. Suggestive contours for conveying shape.\n        22(3):848?855. D EERING , M. 1995. Geometry compression. In pages 13?20.\n      \n      \n        ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2003), Proceedings of ACM SIGGRAPH 95,\n        E DMONDS , J. and J OHNSON , E. L. 1973. Matching, Euler tours and the Chinese postman. Mathematical Programming, 5:88? 129. E STKOWSKI , R., M ITCHELL , J. S. B., and X IANG , X. 2002. Optimal decomposition of polygonal models into triangle strips. In Proceedings of Symposium on Computational Geometry, pages 254?263.\n        ARSHNEY\n      \n      \n        IEEE Visualization,\n      \n      \n        Implementation of Algorithms for Maximum Matching on Nonbipartite Graphs.\n        E VANS , F., S KIENA , S., and V , A. 1996. Optimizing triangle strips for fast rendering. In pages 319?326. G ABOW , H. N. 1974. PhD thesis, Stanford University. , D. S. 1977. The rectilinear Steiner\n        G AREY , M. R. and J OHNSON tree problem is 32(4):826?834.\n      \n      \n        NP-complete. SIAM Journal on Applied Mathematics, Non-photorealistic rendering.\n        OOCH\n        G OOCH , B. and G , A. 2001. A. K. Peters, Ltd.\n        G ROSSO , A., L OCATELLI , M., and P ULLAN , W. 2007. Simple ingredients leading to very efficient heuristics for the maximum clique problem. Journal of Heuristics, on-line.\n        H\n        ALL , P. 1935. On representatives of subsets. 10:26?30.\n        EIDMANN\n      \n      \n        Journal of the London Mathematical Society, Iris Universe,\n        18:\n        H , T. 1991. Real shadows real time. 28?31.\n        H ERTZMANN , A. 1999. Silhouettes and outlines. In Introduction to 3D Non-Photorealistic Rendering, chapter 7. ACM SIGGRAPH Course Notes.\n        algorithm\n      \n      \n        SIAM Journal on\n        H OPCROFT , J. E. and K ARP , R. M. 1973. An n 5/2 for maximum matchings in bipartite graphs. 2(4):225?231.\n      \n      \n        Computing,\n        H OPPE , H. 1999. Optimization of mesh locality for transparent vertex caching. In Proceedings of ACM SIGGRAPH 99, pages 269?276.\n        K ARYPIS , G. and K UMAR , V. 1995.\n      \n      \n        METIS: Unstructured Graph Partitioning and Sparse Matrix Ordering System, Version 2.0.\n      \n      \n        Proceedings of Symposium on Interactive 3D Graphics and Games (I3D),\n        L ENGYEL , J., P RAUN , E., F INKELSTEIN , A., and H OPPE , H. 2001. Real-time fur over arbitrary surfaces. In pages 227?232.\n        L IN , G. and Y U , T. P.-Y. 2006. An improved vertex caching scheme for 3D mesh rendering. IEEE Transactions on Visualization and Computer Graphics, 12(4):640?648.\n        M C G UIRE , M. and H UGHES , J. 2004. Hardware-determined feature edges. In pages 35?47.\n        ICROSOFT ORP\n      \n      \n        Proceedings of Symposium on Non-Photorealistic Animation and Rendering (NPAR), DirectX 10 SDK.\n        M C . 2007.\n        R OTHBERG , E. 1985. MATHPROG. http://elib.zib.de/ pub/Packages/mathprog/matching/weighted.\n        S ANDER , P. V., N EHAB , D., and B ARCZAK , J. 2007. Fast triangle reordering for vertex locality and reduced overdraw. ACM Trans-\n      \n      \n        actions on Graphics (Proceedings of ACM SIGGRAPH 2007),\n        26(3):89. T ARIQ , S. 2007. Fur (using shells and fins). Technical Report WP-03021-001-v01, NVIDIA Corp.\n        W LOKA , M. M. and Z ELEZNIK motion blur.\n      \n      \n        The Visual Computer,\n        , R. C. 1996. Interactive real-time 12(6):283?295.\n        X IANG , X., H ELD , M., and M ITCHELL , J. S. B. 1999. Fast and effective stripification of polygonal surface models. In Pro-\n      \n      \n        ceedings of Symposium on Interactive 3D Graphics and Games (I3D),\n        pages 71?78.\n      \n      \n        Appendix: Finding a lower bound on\n        |C|\n        A simple lower bound on the size |C| of our vertex cover is obtained as follows. Let d(v) denote the degree of vertex v (in either the primal or the dual graph). Then, d(v ) ? 3 for every dual vertex v ? V since each triangle has at most 3 neighbors. Thus, every vertex in C covers at most three edges, and so |C| ? |E |/3. This can be tightened by obtaining a lower bound on the number of edges that must be covered twice. The intuition is that all odddegree vertices in the mesh must have at least one adjacent edge that is covered twice, and moreover these doubly covered edges must form paths that terminate only at other odd-degree vertices. Formally, consider a vertex v in the primal graph, the ring R(v) of dual vertices surrounding v (i.e. a red cycle in Figure 3a ), and let t(v) denote the number of edges in R(v) that are covered twice. Since C is a cover, one can show that t(v) ? d(v) (mod 2). Let G  ? = (V, E)  ? be a minimum subgraph of G (minimizing | E|)  ? such that for all v ? V , d G  ? (v) ? d G (v) (mod 2). Then the number of edges covered twice by C must be at least | E|.  ? Arguing as before, we obtain |C| ? (|E | + | E|)/3.  ? A set of edges for which the odd-degree vertices coincide with a set T is called a T -join. Thus, the set E  ? is a minimum V odd -join, where V odd is the set of odd-degree vertices in G. It has been shown that finding a minimum T -join can be reduced to a minimum-weight perfect matching problem. In particular, Edmonds and Johnson [1973] have shown that the minimum V odd join is equivalent to a minimum weight matching between odddegree vertices, where the weight attached to any pair of vertices u, v ? V odd is exactly the shortest-path distance in G, dist G (u, v). Thus, to compute | E|,  ? we find this minimum-weight perfect matching using the O(|V odd | 3 ) algorithm by Gabow [1974], as implemented in the METIS library [Karypis and Kumar 1995]. We are able to greatly speed up this computation by noting that a shortest path between two vertices in V odd that crosses two other vertices in V odd cannot contribute to the minimum-weight perfect matching. We call such paths illegal. Often this prunes 99% of the search space. To verify the validity of this optimization, we prove the following lemma (the actual proof is not necessary for the implementation of either our algorithm, or the lower bound).\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n        Efficient Traversal of Mesh Edges using Adjacency Primitives ? 144:9\n        Lemma 2. G = (V, E) G  ? = (V, E)  ? E  ? V odd E  ? V odd G prune = (V odd , E prune ) u, v ? V odd dist G (u, v) u v G prune | E|.  ?\n      \n      \n        Let and where is a minimum -join. Then 1. is a disjoint union of legal paths between vertices in . 2. Let be a weighted graph where we connect by an edge of weight if and only if no shortest path between and is illegal. Then any has a perfect matching and any minimum-weight perfect matching has weight\n        Proof. To prove (1), note that G  ? contains no cycles (their removal preserves a V odd -join). Thus, G  ? is a forest, i.e. a vertex-disjoint union of trees. For each such tree T , we find a legal path decomposition by repeatedly performing the following: Contract all uninterrupted paths in T to individual edges. Choose a lowest leaf and match it to its sibling, removing the connecting path in T . To prove (2), note that for any such matching, if the total length of all shortest paths is minimal, the paths must be edge-disjoint. Thus, the union of all paths is indeed a V odd -join. We must show that for some minimal V odd -join E,  ? no u, v ? V odd connected by a legal path in E  ? are also connected by an illegal shortest path. We start with two crucial observations, which follow from the minimality of E:  ?\n        Observation 1. a, b T G,  ? T a,b G. Observation 2. a, b T a,b E.  ?\n      \n      \n        For any vertices in the same tree in the shortest tree path connecting them is a shortest path in For any vertices as above, the tree path is the only shortest path that intersects\n        Both observations follow from the same principle. If we had a path p ? between a and b that violates either Observation 1 or Observation 2 (that is, p ? is shorter than T a,b or is a distinct shortest path intersecting E),  ? we could construct a strictly smaller V odd -join by removing path T a,b and taking the symmetric difference of the remaining edge set and p ? . That is, the set ( E  ? \\ T a,b ) \\ p ? ? p ? \\ ( E  ? \\ T a,b ) would contradict the minimality of E  ? (see replacements in Figure 11 ). We may assume that G  ? contains the minimum number of trees among all minimum V odd -joins. Suppose for the sake of contradiction that for some vertices u, v ? V odd in some tree T connected by a legal T -path p, there exists an illegal shortest path p containing two internal vertices x, y ? V odd . We consider two cases: Case 1: Nodes x and y are in the same tree T (possibly T = T ) in G  ? ( Figure 11a ). Proof. Let p x,y be the sub-path of p from x to y, and let T x,y be the shortest tree path from x to y. By the minimality of p and Observation 1, both paths are shortest paths from x to y. Thus by replacing p x,y with T x,y , we get a shortest path p = p \\ p x,y ? T x,y ( Figure 11b ). This path is illegal, and so distinct from p, and it intersects E,  ? which by Observation 2 contradicts the minimality of E  ? ( Figure 11c ). Case 2: For trees T = T in G,  ? x ? T and y ? T (Figure 11d). Proof. By Observation 2, p does not intersect E.  ? Thus if we replace p with p , the new V odd -join E  ? = ( E  ? \\ p) ? p ( Figure 11e ) contains strictly fewer trees than E,  ? contradicting our assumption for G.  ?\n        \n          Figure 11: (a) Case 1. (b) Collapse p to T . (c) Replacement yields fewer edges. (d) Case 2. (e) Replacement yields fewer trees.\n        \n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 144, Publication date: December 2008.\n      \n    \n  ",
  "resources" : [ ]
}