{
  "uri" : "sig2008a-a126-zhou_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a126-zhou_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-Time KD-Tree Construction on Graphics Hardware",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Qiming-Hou",
      "name" : "Qiming",
      "surname" : "Hou"
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Baining-Guo",
      "name" : "Baining",
      "surname" : "Guo"
    } ]
  },
  "bagOfWords" : [ "edf5499a3955fc05d4b637f3862dcbdbaeace4f3b69a00795937d36adef7a09a", "mhw", "10.1145", "1409060.1409079", "name", "identification", "possible", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "Kun", "Zhou", "Qiming", "Hou", "Rui", "Wang", "Zhejiang", "University", "Tsinghua", "University", "we", "present", "algorithm", "construct", "kd-tree", "gpus", "algorithm", "achieve", "real-time", "performance", "exploit", "gpu?s", "streaming", "architecture", "all", "stage", "kd-tree", "construction", "unlike", "previous", "parallel", "kd-tree", "algorithm", "we", "method", "build", "tree", "node", "completely", "BFS", "-lrb-", "breadth-first", "search", "-rrb-", "order", "we", "also", "develop", "special", "strategy", "large", "node", "upper", "tree", "level", "so", "further", "exploit", "fine-grained", "parallelism", "gpus", "node", "we", "parallelize", "computation", "over", "all", "geometric", "primitive", "instead", "node", "each", "level", "finally", "order", "maintain", "kd-tree", "quality", "we", "introduce", "novel", "scheme", "fast", "evaluation", "node", "split", "cost", "far", "we", "know", "ours", "first", "real-time", "kd-tree", "algorithm", "GPU", "kd-tree", "build", "we", "algorithm", "comparable", "quality", "those", "construct", "off-line", "CPU", "algorithm", "term", "speed", "we", "algorithm", "significantly", "faster", "than", "well-optimized", "single-core", "CPU", "algorithm", "competitive", "multi-core", "CPU", "algorithm", "we", "algorithm", "provide", "general", "way", "handle", "dynamic", "scene", "GPU", "we", "demonstrate", "potential", "we", "algorithm", "application", "involve", "dynamic", "scene", "include", "GPU", "ray", "trace", "interactive", "photon", "mapping", "point", "cloud", "modeling", "keyword", "kd-tree", "programable", "graphic", "hardware", "ray", "trace", "photon", "mapping", "point", "cloud", "modeling", "introduction", "kd-tree", "well-known", "space-partitioning", "datum", "structure", "organize", "point", "k-dimensional", "space", "acceleration", "structure", "have", "be", "use", "variety", "graphic", "application", "include", "triangle", "culling", "ray-triangle", "intersection", "test", "ray", "trace", "nearest", "photon", "query", "photon", "mapping", "nearest", "neighbor", "search", "point", "cloud", "modeling", "particle-based", "fluid", "simulation", "due", "its", "fundamental", "importance", "graphic", "fast", "kd-tree", "construction", "have", "be", "subject", "much", "interest", "recent", "year", "several", "CPU", "algorithm", "propose", "-lsb-", "Popov", "et", "al.", "2006", "Hunt", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "however", "real-time", "construction", "kd-tree", "GPU", "remain", "unsolved", "problem", "paper", "we", "present", "kd-tree", "construction", "algorithm", "GPU", "achieve", "real-time", "performance", "heavily", "exploit", "hardware", "specifically", "we", "algorithm", "build", "tree", "node", "BFS", "-lrb-", "breadth-first", "search", "-rrb-", "order", "fully", "exploit", "fine-grained", "parallelism", "modern", "gpus", "all", "stage", "kd-tree", "construction", "important", "feature", "distinguish", "we", "work", "from", "previous", "parallel", "kd-tree", "algorithm", "include", "-lsb-", "Popov", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "which", "resort", "df", "-lrb-", "depth-first", "search", "-rrb-", "node", "near", "ACM", "Reference", "Format", "Zhou", "K.", "Hou", "Q.", "Wang", "R.", "Guo", "B.", "2008", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "ACM", "Trans", "graph", "27", "Article", "126", "-lrb-", "December", "2008", "-rrb-", "11", "page", "dous", "10.1145", "1409060.1409079", "http://doi.acm.org/10.1145/1409060.1409079", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "fus", "rst", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "permissions@acm.org", "2008", "ACM", "0730-0301/2008", "05-art126", "5.00", "DOI", "10.1145", "1409060.1409079", "http://doi.acm.org/10.1145/1409060.1409079", "Baining", "Guo", "Microsoft", "Research", "Asia", "Figure", "GPU", "ray", "trace", "photon", "mapping", "dynamic", "scene", "where", "both", "scene", "geometry", "light", "source", "can", "change", "two", "kd-tree", "build", "from", "scratch", "each", "frame", "one", "scene", "geometry", "other", "photon", "shadow", "reflection/refraction", "well", "caustic", "cause", "glass", "champagne", "render", "around", "fp", "800", "600", "image", "bottom", "kd-tree", "we", "algorithm", "build", "kd-tree", "comparable", "quality", "those", "construct", "off-line", "CPU", "algorithm", "term", "speed", "we", "algorithm", "time", "faster", "than", "well-optimized", "single-core", "CPU", "algorithm", "-lsb-", "Hunt", "et", "al.", "2006", "-rsb-", "competitive", "multi-core", "CPU", "algorithm", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "design", "kd-tree", "algorithm", "GPU", "we", "must", "address", "two", "challenging", "issue", "first", "how", "maximally", "exploit", "gpu?s", "streaming", "architecture", "when", "parallelize", "kd-tree", "construction", "modern", "GPU", "massively", "parallel", "require", "10", "10", "thread", "optimal", "performance", "-lsb-", "NVIDIA", "2007", "-rsb-", "follow", "BFS", "order", "we", "well", "poise", "take", "advantage", "architecture", "because", "each", "bf", "step", "every", "node", "same", "tree", "level", "spawn", "new", "thread", "total", "number", "thread", "double", "from", "preceding", "step", "addition", "follow", "BFS", "order", "we", "also", "develop", "special", "strategy", "large", "node", "upper", "tree", "level", "so", "further", "exploit", "large", "scale", "parallelism", "gpus", "node", "we", "parallelize", "computation", "over", "all", "geometric", "primitive", "instead", "node", "each", "level", "strategy", "effective", "because", "only", "relatively", "small", "number", "large", "node", "upper", "level", "especially", "near", "top", "tree", "which", "make", "parallelizing", "over", "node", "inefficient", "leave", "massive", "parallelism", "gpus", "underexploit", "moreover", "workload", "among", "thread", "likely", "unbalanced", "because", "number", "primitive", "may", "vary", "significantly", "from", "node", "node", "another", "issue", "efficient", "calculation", "node", "split", "cost", "surface", "area", "heuristic", "-lrb-", "sah", "-rrb-", "-lsb-", "Goldsmith", "Salmon", "1987", "-rsb-", "voxel", "volume", "heuristic", "-lrb-", "vvh", "-rrb-", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "cost", "critical", "maintain", "kd-tree", "quality", "standard", "practice", "precisely", "evaluate", "cost", "all", "tree", "node", "prohibitively", "expensive", "real-time", "technique", "address", "issue", "we", "derive", "novel", "scheme", "so-called", "large", "small", "node", "node", "deem", "large", "number", "triangle", "node", "greater", "than", "user-specified", "threshold", "otherwise", "small", "-lsb-", "Popov", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "large", "node", "upper", "tree", "level", "we", "use", "two", "simple", "inexpensive", "heuristic", "median", "splitting", "empty", "space", "maximize", "-lsb-", "havran", "2001", "Wald", "Havran", "2006", "-rsb-", "estimate", "cost", "small", "node", "near", "bottom", "tree", "where", "exact", "evaluation", "cost", "necessary", "we", "introduce", "novel", "datum", "structure", "store", "geometry", "primitive", "node", "bit", "mask", "which", "allow", "we", "efficiently", "evaluate", "exact", "cost", "sort", "primitive", "use", "bitwise", "operation", "we", "real-time", "kd-tree", "construction", "provide", "general", "way", "deal", "dynamic", "scene", "GPU", "we", "demonstrate", "potential", "we", "kd-tree", "algorithm", "few", "application", "GPU", "Ray", "Tracing", "we", "implement", "GPU", "ray", "tracer", "arbitrary", "dynamic", "scene", "use", "we", "real-time", "kd-tree", "construction", "-lrb-", "section", "-rrb-", "ray", "tracer", "achieve", "interactive", "rate", "shadow", "multi-bounce", "reflection/refraction", "we", "GPU", "ray", "tracer", "can", "handle", "general", "dynamic", "scene", "outperform", "state-of-the-art", "multicore", "CPU", "ray", "tracer", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "unique", "feature", "we", "ray", "tracer", "can", "efficiently", "handle", "dynamic", "geometry", "directly", "evaluate", "GPU", "subdivision", "surface", "-lsb-", "Shiue", "et", "al.", "2005", "-rsb-", "skin", "mesh", "-lsb-", "Wang", "et", "al.", "2007", "-rsb-", "GPU", "Photon", "mapping", "we", "implement", "GPU", "photon", "mapping", "which", "photon", "trace", "photon", "kd-tree", "construction", "nearest", "photon", "query", "all", "perform", "GPU", "fly", "-lrb-", "section", "-rrb-", "combine", "we", "GPU", "ray", "tracer", "photon", "mapping", "capable", "render", "shadow", "reflection/refraction", "well", "realistic", "caustic", "dynamic", "scene", "lighting", "interactive", "rate", "single", "pc", "performance", "have", "be", "achieve", "previous", "work", "point", "cloud", "model", "we", "real-time", "kd-tree", "construction", "can", "also", "use", "dynamic", "point", "cloud", "accelerate", "nearest", "neighbor", "query", "-lrb-", "appendix", "-rrb-", "query", "neighbor", "use", "estimate", "local", "sampling", "density", "calculate", "normal", "update", "deformation", "strength", "field", "free-form", "deformation", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "126:2", "K.", "Zhou", "et", "al.", "related", "work", "optimize", "kd-tree", "early", "research", "mainly", "focus", "optimize", "kd-tree", "triangle", "culling", "ray-triangle", "intersection", "key", "optimization", "determine", "splitting", "plane", "simple", "often-used", "method", "spatial", "median", "splitting", "which", "plane", "position", "spatial", "median", "longest", "axis", "tree", "node", "volume", "improve", "effectiveness", "researcher", "propose", "SAH", "kd-tree", "-lsb-", "Goldsmith", "Salmon", "1987", "MacDonald", "Booth", "1990", "Havran", "2001", "-rsb-", "fact", "appearance", "kd-tree", "base", "packet", "trace", "-lsb-", "Wald", "et", "al.", "2001", "-rsb-", "frustum", "traversal", "-lsb-", "Reshetov", "et", "al.", "2005", "-rsb-", "SAH", "kd-tree", "have", "become", "best", "know", "acceleration", "structure", "ray", "trace", "static", "scene", "-lsb-", "Stoll", "2005", "-rsb-", "other", "application", "photon", "mapping", "kd-tree", "mainly", "use", "accelerate", "nearest", "neighbor", "query", "which", "different", "heuristic", "employ", "achieve", "better", "efficiency", "example", "vvh", "kd-tree", "can", "better", "accelerate", "photon", "gathering", "process", "than", "left-balanced", "tree", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "fast", "kd-tree", "construction", "construction", "high", "quality", "kd-tree", "expensive", "due", "evaluation", "SAH", "cost", "function", "although", "-lrb-", "log", "-rrb-", "construction", "algorithm", "exist", "-lsb-", "Wald", "Havran", "2006", "-rsb-", "time", "need", "large", "animated", "scene", "still", "too", "high", "allow", "tradeoff", "between", "tree", "quality", "construction", "speed", "fast", "kd-tree", "algorithm", "-lsb-", "Popov", "et", "al.", "2006", "Hunt", "et", "al.", "2006", "-rsb-", "approximate", "SAH", "use", "piecewise", "linear", "-lrb-", "quadric", "-rrb-", "function", "-lsb-", "Popov", "et", "al.", "2006", "-rsb-", "also", "propose", "parallel", "algorithm", "construct", "tree", "BFS", "order", "up", "certain", "tree", "level", "however", "goal", "increase", "coherence", "memory", "access", "during", "tree", "construction", "target", "small", "scale", "parallel", "architecture", "like", "multi-core", "cpus", "node", "near", "bottom", "tree", "df", "order", "use", "which", "difficult", "parallelize", "consume", "90", "construction", "time", "base", "report", "timing", "multi-core", "algorithm", "-lsb-", "Popov", "et", "al.", "2006", "-rsb-", "about", "order", "magnitude", "slower", "than", "we", "kd-tree", "algorithm", "tree", "comparable", "quality", "algorithm", "-lsb-", "Hunt", "et", "al.", "2006", "-rsb-", "about", "time", "slower", "than", "we", "algorithm", "Shevstov", "et", "al.", "-lsb-", "2007", "-rsb-", "propose", "parallel", "kd-tree", "algorithm", "share", "memory", "architecture", "multi-core", "cpus", "algorithm", "first", "partition", "space", "several", "balanced", "sub-region", "build", "sub-tree", "each", "sub-region", "parallel", "df", "order", "algorithm", "can", "map", "well", "GPU", "architecture", "because", "modern", "gpus", "require", "10", "10", "thread", "optimal", "performance", "-lsb-", "NVIDIA", "2007", "-rsb-", "order", "magnitude", "greater", "than", "possible", "thread", "number", "multi-core", "cpus", "-lrb-", "e.g.", "four", "thread", "test", "paper", "-rrb-", "another", "problem", "method", "note", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "kd-tree", "construct", "approximately", "half", "quality", "those", "produce", "off-line", "kd-tree", "builder", "ray-tracing", "identical", "dynamic", "scene", "performance", "lower", "than", "we", "GPU", "ray", "tracer", "Ray", "Tracing", "GPUs", "Ray", "trace", "gpus", "have", "stimulate", "much", "interest", "recently", "-lsb-", "Carr", "et", "al.", "2002", "-rsb-", "implement", "ray-triangle", "intersection", "GPU", "-lsb-", "Purcell", "et", "al.", "2002", "-rsb-", "design", "first", "ray", "tracer", "run", "entirely", "GPU", "employ", "uniform", "grid", "acceleration", "-lsb-", "Foley", "Sugerman", "2005", "-rsb-", "introduce", "two", "stackless", "kd-tree", "traversal", "algorithm", "which", "outperform", "uniform", "grid", "approach", "-lsb-", "Carr", "et", "al.", "2006", "-rsb-", "implement", "limited", "GPU", "ray", "tracer", "dynamic", "geometry", "base", "bounding-volume", "hierarchy", "geometry", "image", "none", "above", "GPU", "ray", "tracer", "outperform", "well-optimized", "CPU", "ray", "tracer", "recently", "two", "technique", "-lsb-", "Horn", "et", "al.", "2007", "Popov", "et", "al.", "2007", "-rsb-", "achieve", "better", "performance", "than", "CPU", "ray", "tracer", "both", "technique", "use", "stackless", "kd-tree", "traversal", "packet", "trace", "unfortunately", "two", "technique", "work", "static", "scene", "only", "dynamic", "scene", "most", "exist", "method", "cpu-based", "-lrb-", "e.g.", "-lsb-", "Wald", "et", "al.", "2006", "Yoon", "et", "al.", "2007", "-rsb-", "-rrb-", "we", "work", "lead", "GPU", "ray", "tracer", "general", "dynamic", "scene", "outperform", "state-of-the-art", "multi-core", "CPU", "ray", "tracer", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "Photon", "mapping", "have", "be", "implement", "gpus", "-lsb-", "Purcell", "et", "al.", "2003", "-rsb-", "uniform", "grid", "instead", "kd-tree", "use", "store", "photon", "greatly", "degrade", "performance", "nearest", "photon", "query", "-lsb-", "g?nther", "et", "al.", "2004", "-rsb-", "present", "framework", "real-time", "distribute", "photon", "mapping", "use", "36", "cpus", "achieve", "frame", "rate", "up", "22", "fp", "image", "resolution", "640", "480", "far", "we", "know", "kd-tree", "base", "photon", "mapping", "algorithm", "have", "be", "implement", "GPU", "GPU", "Kd-Tree", "Construction", "section", "we", "describe", "how", "build", "SAH", "kd-tree", "ray", "trace", "GPU", "we", "focus", "SAH", "kd-tree", "streamline", "discussion", "adaption", "we", "algorithm", "other", "kind", "kd-tree", "straightforward", "explain", "later", "section", "follow", "conventional", "kd-tree", "construction", "algorithm", "-lsb-", "Pharr", "Humpreys", "2004", "-rsb-", "we", "technique", "build", "kd-tree", "greedy", "topdown", "manner", "recursively", "splitting", "current", "node", "two", "subnode", "follow", "evaluate", "SAH", "cost", "all", "splitting", "plane", "candidate", "pick", "optimal", "candidate", "lowest", "cost", "split", "node", "two", "child", "node", "sort", "triangle", "distribute", "they", "two", "child", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "126:3", "algorithm", "Kd-Tree", "Construction", "procedure", "uild", "ree", "-lrb-", "triangle", "list", "-rrb-", "begin", "initialization", "stage", "nodelist", "new", "list", "activelist", "new", "list", "smalllist", "new", "list", "nextlist", "new", "list", "create", "rootnode", "activelist.add", "-lrb-", "rootnode", "-rrb-", "each", "input", "triangle", "parallel", "Compute", "AABB", "triangle", "large", "node", "stage", "while", "activelist.empty", "-lrb-", "-rrb-", "nodelist.append", "-lrb-", "activelist", "-rrb-", "nextlist.clear", "-lrb-", "-rrb-", "rocess", "arge", "ode", "-lrb-", "activelist", "smalllist", "nextlist", "-rrb-", "swap", "nextlist", "activelist", "small", "node", "stage", "reprocess", "mall", "ode", "-lrb-", "smalllist", "-rrb-", "activelist", "smalllist", "while", "activelist.empty", "-lrb-", "-rrb-", "nodelist.append", "-lrb-", "activelist", "-rrb-", "nextlist.clear", "-lrb-", "-rrb-", "rocess", "mall", "ode", "-lrb-", "activelist", "nextlist", "-rrb-", "swap", "nextlist", "activelist", "kd-tree", "output", "stage", "reorder", "raversal", "-lrb-", "nodelist", "-rrb-", "end", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "larger", "Node", "Node", "than", "Cut", "off", "empty", "space", "median", "split", "Triangles", "Triangles", "Figure", "two", "case", "large", "node", "split", "-lrb-", "-rrb-", "cut", "off", "empty", "space", "-lrb-", "-rrb-", "spatial", "median", "split", "SAH", "cost", "function", "define", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "sah", "-lrb-", "-rrb-", "t", "where", "t", "constant", "cost", "traverse", "node", "itself", "-lrb-", "-rrb-", "cost", "left", "child", "give", "split", "position", "-lrb-", "-rrb-", "cost", "right", "child", "give", "same", "split", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "surface", "area", "left", "right", "child", "respectively", "surface", "area", "node", "note", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "can", "only", "evaluate", "after", "entire", "sub-tree", "have", "be", "build", "instead", "seek", "globally", "optimal", "solution", "exist", "algorithm", "use", "locally", "greedy", "approximation", "assume", "child", "leaf", "node", "case", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "equal", "number", "element", "contain", "left", "right", "child", "respectively", "Algorithm", "Overview", "algorithm", "take", "triangle", "soup", "input", "follow", "construction", "pipeline", "show", "algorithm", "after", "initialization", "step", "algorithm", "build", "tree", "BFS", "manner", "both", "large", "node", "small", "node", "finally", "all", "node", "tree", "reorganize", "store", "pipeline", "consist", "set", "stream", "processing", "step", "together", "minimal", "coordination", "work", "streaming", "step", "do", "GPU", "while", "coordination", "work", "do", "CPU", "negligible", "cost", "algorithm", "large", "Node", "Stage", "procedure", "rocess", "arge", "ode", "-lrb-", "activelist", "list", "out", "smalllist", "nextlist", "list", "-rrb-", "begin", "group", "triangle", "chunk", "each", "node", "activelist", "parallel", "group", "all", "triangle", "node", "fix", "size", "chunk", "store", "chunk", "chunklist", "compute", "per-node", "bound", "box", "each", "chunk", "chunklist", "parallel", "compute", "bound", "box", "all", "triangle", "use", "standard", "reduction", "Perform", "segmented", "reduction", "per-chunk", "reduction", "result", "compute", "per-node", "bound", "box", "split", "large", "node", "each", "node", "activelist", "parallel", "each", "side", "node", "contain", "more", "than", "empty", "space", "side", "Cut", "off", "i?s", "empty", "space", "side", "split", "node", "spatial", "median", "longest", "axis", "each", "create", "child", "node", "ch", "nextlist.add", "-lrb-", "ch", "-rrb-", "sort", "clip", "triangle", "child", "node", "each", "chunk", "chunklist", "parallel", "k.node", "-lrb-", "-rrb-", "each", "triangle", "parallel", "contain", "both", "child", "sort", "two", "child", "node", "clip", "respective", "owner", "node", "else", "sort", "child", "node", "contain", "count", "triangle", "number", "child", "node", "each", "chunk", "chunklist", "parallel", "k.node", "-lrb-", "-rrb-", "count", "triangle", "number", "i?s", "child", "use", "reduction", "Perform", "segmented", "reduction", "per-chunk", "result", "compute", "per-child-node", "triangle", "number", "small", "node", "filter", "each", "node", "ch", "nextlist", "parallel", "ch", "small", "node", "smalllist.add", "-lrb-", "ch", "-rrb-", "nextlist.delete", "-lrb-", "ch", "-rrb-", "end", "initialization", "stage", "global", "memory", "allocate", "tree", "construction", "root", "node", "create", "additionally", "streaming", "step", "perform", "compute", "aabb", "-lrb-", "axis", "align", "bound", "box", "-rrb-", "each", "input", "triangle", "we", "current", "implementation", "user-specified", "threshold", "large/small", "node", "set", "64", "3.1", "large", "Node", "Stage", "mention", "SAH", "evaluation", "conventional", "greedy", "optimization", "algorithm", "assume", "current", "split", "produce", "two", "leaf", "node", "large", "node", "assumption", "almost", "always", "untrue", "result", "estimation", "far", "from", "accurate", "we", "splitting", "scheme", "large", "node", "combination", "spatial", "median", "splitting", "empty", "space", "maximize", "which", "highly", "effective", "upper", "level", "tree", "note", "-lsb-", "havran", "2001", "-rsb-", "specifically", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "126:4", "K.", "Zhou", "et", "al.", "algorithm", "GPU", "Segmented", "Reduction", "procedure", "pu", "eg", "educe", "-lrb-", "datum", "owner", "list", "op", "reduction", "operator", "out", "result", "list", "-rrb-", "begin", "result", "new", "list", "fill", "result", "op?s", "identity", "element", "assume", "element", "log", "each", "-lrb-", "-rrb-", "+1", "parallel", "owner", "-lsb-", "+1", "-rsb-", "owner", "-lsb-", "+1", "-rsb-", "result", "-lsb-", "-rsb-", "op", "-lrb-", "result", "-lsb-", "-rsb-", "datum", "-lsb-", "+1", "-rsb-", "-rrb-", "else", "datum", "-lsb-", "+1", "-rsb-", "op", "-lrb-", "datum", "-lsb-", "+1", "-rsb-", "datum", "-lsb-", "+1", "-rsb-", "-rrb-", "end", "operator", "identity", "value", "usage", "min", "compute", "bound", "box", "max", "??", "compute", "bound", "box", "count", "triangle", "number", "Table", "reduction", "operator", "usage", "algorithm", "empty", "space", "contain", "current", "node", "larger", "than", "predefined", "ratio", "along", "one", "axis", "empty", "space", "cut", "off", "next", "split", "otherwise", "split", "plane", "choose", "spatial", "median", "node?s", "longest", "axis", "-lrb-", "see", "fig.", "-rrb-", "currently", "we", "take", "25", "note", "apply", "splitting", "scheme", "tight", "bound", "box", "all", "triangle", "contain", "node", "have", "compute", "large", "node", "processing", "procedure", "rocess", "arge", "ode", "elaborate", "algorithm", "procedure", "take", "activelist", "input", "update", "smalllist", "nextlist", "output", "note", "we", "also", "maintain", "triangle-node", "association", "list", "each", "node", "list", "triangle-node", "association", "list", "store", "triangle", "index", "contain", "node", "list", "sort", "node", "index", "each", "node", "node", "list", "record", "index", "its", "first", "triangle", "triangle-node", "association", "list", "number", "triangle", "contain", "scene", "space", "occupy", "pointer", "its", "child", "node", "now", "we", "walk", "through", "major", "step", "rocess", "arge", "ode", "algorithm", "first", "step", "procedure", "group", "all", "triangle", "each", "node", "fixed-sized", "chunk", "currently", "we", "set", "chunk", "size", "256", "large", "fraction", "subsequent", "computation", "parallelize", "over", "all", "triangle", "chunk", "second", "step", "bound", "box", "all", "triangle", "each", "node", "compute", "do", "first", "compute", "bound", "box", "all", "triangles?s", "aabb", "each", "chunk", "use", "reduction", "algorithm", "describe", "Algorithm", "-lsb-", "Popov", "et", "al.", "2007", "-rsb-", "compute", "bound", "box", "all", "node", "perform", "segmented", "reduction", "-lsb-", "Gropp", "et", "al.", "1994", "-rsb-", "sequence", "all", "chunk", "reduction", "result", "segmented", "reduction", "perform", "reduction", "arbitrary", "segment", "input", "sequence", "result", "sequence", "which", "each", "element", "hold", "reduction", "result", "one", "segment", "we", "GPU", "algorithm", "segmented", "reduction", "describe", "Algorithm", "input", "list", "datum", "all", "datum", "element", "belong", "same", "segment", "located", "contiguously", "another", "input", "list", "owner", "owner", "-lsb-", "-rsb-", "indicate", "segment", "index", "datum", "-lsb-", "-rsb-", "reduction", "operator", "op", "associate", "identity", "value", "list", "Table", "algorithm", "take", "multi-pass", "approach", "each", "thread", "take", "two", "element", "two", "element", "have", "same", "owner", "replace", "operation", "result", "otherwise", "one", "element", "accumulate", "result", "other", "retain", "note", "chunk", "datum", "structure", "critical", "optimal", "performance", "within", "each", "chunk", "we", "only", "need", "perform", "unsegmented", "reduction", "all", "triangle", "aabb", "greatly", "reduce", "element", "number", "subsequent", "segmented", "reduction", "although", "possible", "compute", "node", "bound", "box", "perform", "segmented", "reduction", "all", "input", "triangle", "aabb", "directly", "inefficient", "because", "large", "segmented", "reduction", "about", "three", "time", "slower", "than", "large", "unsegmented", "reduction", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "third", "step", "compute", "node", "bound", "box", "large", "node", "split", "parallel", "use", "splitting", "scheme", "describe", "earlier", "note", "we", "repeatedly", "split", "node", "use", "empty", "space", "splitting", "until", "spatial", "median", "split", "reach", "allow", "we", "reuse", "bound", "box", "avoid", "unnecessary", "computation", "after", "empty", "space", "splitting", "fourth", "step", "triangle", "sort", "clip", "child", "node", "Triangle", "sorting", "essentially", "list", "splitting", "each", "chunk", "triangle", "chunk", "first", "check", "generate", "vector", "boolean", "value", "which", "indicate", "whether", "each", "triangle", "child", "node", "triangle", "divide", "two", "group", "all", "triangle", "mark", "true", "left", "side", "output", "vector", "all", "triangle", "mark", "false", "right", "side", "can", "easily", "do", "use", "split", "operation", "describe", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "those", "triangle", "contain", "both", "child", "node", "another", "pass", "need", "clip", "they", "node", "final", "step", "we", "count", "triangle", "number", "all", "child", "node", "use", "segmented", "reduction", "way", "similar", "bound", "box", "computation", "reduction", "operator", "use", "here", "triangle", "number", "node", "less", "threshold", "add", "smalllist", "delete", "from", "nextlist", "3.2", "small", "Node", "Stage", "compare", "large", "node", "stage", "small", "node", "stage", "relatively", "simple", "first", "computation", "parallelize", "over", "node", "rather", "than", "triangle", "workload", "among", "small", "node", "naturally", "balanced", "because", "triangle", "number", "small", "node", "do", "vary", "significantly", "-lrb-", "from", "-rrb-", "second", "unlike", "large", "node", "stage", "we", "choose", "clip", "triangle", "when", "splitting", "small", "node", "although", "clipping", "triangle", "owner", "node", "reduce", "false", "positive", "triangle-in-node", "test", "always", "reduce", "SAH", "cost", "clipping", "may", "also", "cause", "undesirable", "excessive", "split", "because", "SAH", "do", "take", "memory", "cost", "account", "while", "clipping", "effective", "large", "node", "prevent", "false", "positive", "from", "accumulate", "over", "future", "split", "small", "node", "we", "experiment", "indicate", "clipping", "rarely", "improve", "ray", "trace", "performance", "thus", "we", "do", "clip", "triangle", "small", "node", "splitting", "plane", "candidate", "restricted", "those", "determine", "face", "aabb", "triangle", "contain", "initial", "small", "node", "show", "Algorithm", "small", "node", "stage", "consist", "two", "procedure", "reprocess", "mall", "ode", "rocess", "mall", "ode", "first", "procedure", "collect", "all", "split", "candidate", "also", "generate", "triangle", "set", "contain", "both", "side", "each", "splitting", "plane", "candidate", "single", "pass", "over", "triangle", "node", "second", "procedure", "rocess", "mall", "ode", "split", "small", "node", "process", "parallel", "each", "node", "procedure", "first", "get", "its", "triangle", "set", "triangleset", "its", "uppermost", "ancestor", "smallroot", "-lrb-", "also", "small", "node", "-rrb-", "tree", "SAH", "cost", "all", "splitting", "plane", "candidate", "located", "inside", "node", "compute", "finally", "node", "split", "use", "optimal", "split", "plane", "minimal", "cost", "triangle", "sort", "child", "node", "instead", "store", "triangle", "set", "triangle-node", "association", "list", "do", "large", "node", "stage", "we", "now", "store", "triangle", "set", "small", "node", "bit", "mask", "its", "smallroot", "show", "fig.", "note", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "126:5", "algorithm", "small", "Node", "Stage", "procedure", "reprocess", "mall", "ode", "-lrb-", "smalllist", "list", ";-rrb-_NN", "begin", "each", "node", "smalllist", "parallel", "i.splitlist", "list", "all", "split", "candidate", "each", "split", "candidate", "parallel", "leave", "represent", "smaller", "coordinate", "j.lef", "triangle", "set", "left", "j.right", "triangle", "set", "right", "end", "procedure", "rocess", "mall", "ode", "-lrb-", "activelist", "list", "out", "nextlist", "list", "-rrb-", "begin", "each", "node", "activelist", "parallel", "compute", "SAH", "determine", "split", "plane", "i.triangleset", "i.smallroot", "area", "node", "sah", "where", "r.splitlist", "j.triangle", "j.lef", "j.right", "area", "left", "child", "after", "split", "area", "right", "child", "after", "split", "sah", "-lrb-", "-rrb-", "t", "split", "candidate", "yield", "minimal", "SAH", "split", "small", "node", "SAH", "SAH", "Mark", "leaf", "node", "else", "Split", "use", "add", "new", "node", "nextlist", "Sort", "triangle", "new", "node", "end", "triangle", "set", "each", "split", "candidate", "j.lef", "j.right", "also", "store", "bit", "mask", "bit", "mask", "representation", "triangle", "sorting", "sah", "evaluation", "any", "split", "candidate", "can", "efficiently", "do", "use", "bitwise", "operation", "show", "Algorithm", "bit", "mask", "left", "child", "compute", "bitwise", "bit", "mask", "current", "node", "bit", "mask", "left", "side", "split", "candidate", "which", "precompute", "reprocess", "mall", "ode", "parallel", "bit", "count", "routine", "-lsb-", "manku", "2002", "-rsb-", "perform", "result", "bit", "mask", "get", "number", "triangle", "left", "child", "bit", "mask", "representation", "allow", "we", "compute", "optimal", "split", "plane", "-lrb-", "-rrb-", "time", "sort", "triangle", "-lrb-", "-rrb-", "time", "alternative", "method", "compute", "optimal", "splitting", "plane", "-lrb-", "-rrb-", "sort", "all", "split", "candidate", "preprocess", "cost", "function", "all", "split", "candidate", "optimal", "splitting", "plane", "can", "compute", "only", "single", "pass", "over", "sort", "datum", "cost", "-lrb-", "-rrb-", "however", "since", "sort", "order", "can", "represent", "bit", "mask", "triangle", "sorting", "can", "only", "do", "cost", "-lrb-", "-rrb-", "3.3", "Kd-Tree", "output", "stage", "describe", "section", "we", "GPU", "ray", "tracer", "stack-based", "require", "kd-tree", "final", "layout", "preorder", "traversal", "node", "optimal", "cache", "performance", "we", "compute", "preorder", "traversal", "use", "two", "parallel", "bf", "traversal", "-lrb-", "see", "Algorithm", "-rrb-", "first", "pass", "traverse", "tree", "bottom-up", "compute", "require", "memory", "size", "each", "subtree", "second", "pass", "algorithm", "Preorder", "Traversal", "procedure", "reorder", "raversal", "-lrb-", "nodelist", "list", "-rrb-", "begin", "each", "tree", "level", "nodelist", "from", "bottom-up", "ass", "-lrb-", "-rrb-", "allocate", "tree", "use", "root", "node?s", "size", "each", "tree", "level", "nodelist", "from", "top-down", "own", "ass", "-lrb-", "-rrb-", "end", "procedure", "ass", "-lrb-", "activelist", "list", "-rrb-", "begin", "each", "node", "activelist", "parallel", "leaf", "i.size", "i.lef", "t.size", "i.right.size", "else", "i.size", "i.trianglecount", "end", "procedure", "own", "ass", "-lrb-", "activelist", "list", "-rrb-", "begin", "each", "node", "activelist", "parallel", "leaf", "i.lef", "t.address", "i.address", "i.right.address", "i.address", "i.lef", "t.size", "store", "node", "final", "format", "i.address", "end", "-lrb-", "-rrb-", "node", "-lrb-", "-rrb-", "large", "node", "small", "node", "triangle", "set", "node", "split", "plane", "Figure", "store", "triangle", "set", "bit", "mask", "small", "root", "node", "split", "node", "node", "show", "-lrb-", "-rrb-", "triangle", "subset", "small", "root", "a?s", "triangle", "store", "bit", "mask", "show", "-lrb-", "-rrb-", "traverse", "tree", "top-down", "compute", "start", "address", "traversal", "each", "subtree", "distribute", "node", "information", "corresponding", "address", "produce", "final", "tree", "analogous", "parallel", "scan", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "note", "procedure", "reorder", "raversal", "we", "need", "collect", "node", "located", "same", "tree", "level", "fortunately", "information", "already", "available", "each", "while-loop", "algorithm", "after", "preorder", "traversal", "each", "node", "result", "node", "list", "record", "number", "index", "triangle", "contain", "its", "splitting", "plane", "link", "its", "child", "3.4", "implementation", "detail", "we", "implement", "above", "kd-tree", "builder", "use", "nvidia?s", "CUDA", "framework", "-lsb-", "NVIDIA", "2007", "-rsb-", "CUDA", "provide", "general-purpose", "language", "interface", "GPU", "programming", "also", "expose", "some", "important", "new", "hardware", "feature", "which", "useful", "data-parallel", "computation", "example", "allow", "arbitrary", "gather", "scatter", "memory", "access", "from", "GPU", "program", "we", "GPU", "implementation", "heavily", "make", "use", "new", "feature", "all", "algorithm", "listing", "above", "parallel", "primitive", "-lrb-", "e.g.", "segmented", "reduction", "-rrb-", "code", "fragment", "mark", "paral", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "126:6", "K.", "Zhou", "et", "al.", "-lrb-", "-rrb-", "Toys", "-lrb-", "-rrb-", "museum", "-lrb-", "-rrb-", "robot", "-lrb-", "-rrb-", "kitchen", "-lrb-", "-rrb-", "Fairy", "Forest", "-lrb-", "-rrb-", "Dragon", "Figure", "Test", "scene", "kd-tree", "construction", "ray", "trace", "-lrb-", "-rrb-", "11k", "triangle", "light", "-lrb-", "-rrb-", "27k", "triangle", "light", "bounce", "-lrb-", "-rrb-", "71k", "triangle", "light", "bounce", "-lrb-", "-rrb-", "111k", "triangle", "light", "bounce", "-lrb-", "-rrb-", "178k", "triangle", "light", "-lrb-", "-rrb-", "252k", "triangle", "light", "scene", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "off-line", "CPU", "builder", "we", "GPU", "builder", "tree", "trace", "sah", "tree", "trace", "SAH", "0.085", "0.022", "79.0", "0.012", "0.018", "67.9", "0.108", "0.109", "76.6", "0.017", "0.108", "38.3", "0.487", "0.165", "68.6", "0.039", "0.157", "59.7", "0.559", "0.226", "49.6", "0.053", "0.207", "77.8", "1.226", "0.087", "74.4", "0.077", "0.078", "94.6", "1.354", "0.027", "124.2", "0.093", "0.025", "193.9", "off-line", "CPU", "builder", "we", "GPU", "builder", "tree", "trace", "sah", "tree", "trace", "SAH", "0.085", "0.022", "79.0", "0.012", "0.018", "67.9", "0.108", "0.109", "76.6", "0.017", "0.108", "38.3", "0.487", "0.165", "68.6", "0.039", "0.157", "59.7", "0.559", "0.226", "49.6", "0.053", "0.207", "77.8", "1.226", "0.087", "74.4", "0.077", "0.078", "94.6", "1.354", "0.027", "124.2", "0.093", "0.025", "193.9", "Table", "compare", "kd-tree", "construction", "time", "tree", "ray", "trace", "time", "trace", "sah", "cost", "between", "offline", "CPU", "builder", "we", "GPU", "builder", "all", "render", "time", "1024", "1024", "image", "lel", "GPU", "code", "other", "CPU", "code", "we", "also", "need", "specify", "number", "thread", "block", "thread", "per", "block", "parallel", "primitive", "code", "fragment", "mark", "parallel", "we", "current", "implementation", "we", "use", "256", "thread", "each", "block", "block", "number", "compute", "divide", "total", "number", "parallel", "thread", "number", "thread", "per", "block", "during", "kd-tree", "construction", "we", "store", "all", "datum", "dynamic", "list", "linear", "device", "memory", "allocate", "via", "CUDA", "list", "size", "double", "whenever", "more", "memory", "require", "allow", "we", "avoid", "high", "overhead", "CUDA", "memory", "management", "after", "initial", "run", "cost", "more", "memory", "consumption", "structure", "many", "field", "node", "triangle", "we", "use", "structure", "array", "-lrb-", "soa", "-rrb-", "instead", "array", "structure", "-lrb-", "ao", "-rrb-", "optimal", "GPU", "cache", "performance", "from", "its", "description", "reader", "may", "have", "notice", "we", "algorithm", "also", "frequently", "call", "certain", "parallel", "primitive", "reduce", "scan", "many", "primitive", "have", "be", "efficiently", "implement", "expose", "cudpp", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "most", "conditional", "program", "flow", "pseudo", "code", "handle", "use", "list", "splitting", "which", "also", "standard", "GPU", "primitive", "optimize", "implementation", "-lsb-", "sengupta", "et", "al.", "2007", "-rsb-", "conditional", "program", "Algorithm", "-lrb-", "line", "12", "15", "-rrb-", "serialize", "result", "performance", "penalty", "chunk", "structure", "use", "perform", "most", "computation", "per-chunk", "standard", "reduction", "algorithm", "avoid", "conditional", "program", "flow", "compare", "per-chunk", "standard", "reduction", "segmented", "reduction", "Algorithm", "do", "consume", "any", "significant", "processing", "time", "its", "performance", "issue", "can", "thus", "safely", "ignore", "#procs", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "16", "0.037", "0.057", "0.197", "0.260", "0.463", "0.564", "32", "0.022", "0.034", "0.107", "0.139", "0.242", "0.292", "48", "0.018", "0.026", "0.077", "0.098", "0.169", "0.202", "64", "0.016", "0.022", "0.063", "0.079", "0.133", "0.157", "80", "0.015", "0.020", "0.055", "0.068", "0.113", "0.132", "96", "0.014", "0.019", "0.049", "0.060", "0.100", "0.116", "112", "0.013", "0.018", "0.046", "0.056", "0.091", "0.105", "128", "0.012", "0.017", "0.039", "0.053", "0.077", "0.093", "speedup", "3.08", "3.35", "5.05", "4.90", "6.01", "6.06", "#procs", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "16", "0.037", "0.057", "0.197", "0.260", "0.463", "0.564", "32", "0.022", "0.034", "0.107", "0.139", "0.242", "0.292", "48", "0.018", "0.026", "0.077", "0.098", "0.169", "0.202", "64", "0.016", "0.022", "0.063", "0.079", "0.133", "0.157", "80", "0.015", "0.020", "0.055", "0.068", "0.113", "0.132", "96", "0.014", "0.019", "0.049", "0.060", "0.100", "0.116", "112", "0.013", "0.018", "0.046", "0.056", "0.091", "0.105", "128", "0.012", "0.017", "0.039", "0.053", "0.077", "0.093", "speedup", "3.08", "3.35", "5.05", "4.90", "6.01", "6.06", "Table", "scalability", "we", "kd-tree", "construction", "algorithm", "GeForce", "8800", "ULTRA", "graphic", "card", "bottom", "row", "show", "speedup", "go", "from", "16", "128", "processor", "note", "we", "algorithm", "scale", "better", "large", "scene", "however", "scalability", "still", "sublinear", "mainly", "because", "total", "run", "time", "contain", "constant", "portion", "due", "overheard", "CUDA", "API", "Figure", "tree", "construction", "time", "decrease", "quickly", "increase", "number", "GPU", "processor", "before", "reach", "plateau", "3.5", "result", "discussion", "describe", "algorithm", "have", "be", "test", "Intel", "Xeon", "3.7", "GHz", "CPU", "NVIDIA", "GeForce", "8800", "ULTRA", "-lrb-", "768MB", "-rrb-", "graphic", "card", "parameter", "-lrb-", "e.g.", "-rrb-", "use", "during", "tree", "construction", "intentionally", "keep", "same", "all", "scene", "we", "compare", "we", "GPU", "algorithm", "off-line", "CPU", "algorithm", "which", "always", "use", "greedy", "SAH", "cost", "calculate", "optimal", "split", "plane", "clip", "triangle", "child", "node", "-lsb-", "Wald", "Havran", "2006", "-rsb-", "Table", "summarize", "comparison", "result", "several", "publicly", "available", "scene", "show", "fig.", "show", "we", "kd-tree", "construction", "algorithm", "15", "time", "faster", "all", "scene", "quality", "tree", "assess", "two", "way", "first", "we", "compute", "SAH", "cost", "second", "we", "evaluate", "practical", "effect", "tree", "quality", "render", "time", "use", "construct", "tree", "ray", "tracer", "describe", "section", "show", "table", "we", "algorithm", "generate", "lower", "sah", "cost", "Toys", "Museum", "Robots", "higher", "SAH", "cost", "kitchen", "Fairy", "Forest", "Dragon", "all", "case", "we", "tree", "always", "offer", "better", "render", "performance", "which", "attest", "high", "quality", "we", "tree", "practical", "application", "note", "SAH", "cost", "expect", "cost", "ray", "traverse", "entire", "tree", "whereas", "actual", "kdtree", "traversal", "terminate", "first", "node", "intersection", "therefore", "strict", "correlation", "between", "SAH", "cost", "actual", "ray", "trace", "time", "SAH", "cost", "only", "one", "way", "measure", "quality", "kd-tree", "most", "important", "metric", "how", "well", "result", "tree", "accelerate", "ray", "traversal", "which", "ultimate", "goal", "SAH", "tree", "construction", "strategy", "we", "kd-tree", "construction", "algorithm", "also", "scale", "well", "number", "GPU", "processor", "run", "time", "contain", "scalable", "portion", "small", "non-scalable", "portion", "due", "overhead", "CUDA", "API", "driver", "theoretically", "run", "time", "linear", "respect", "reciprocal", "number", "processor", "show", "Table", "Fig.", "we", "run", "algorithm", "GeForce", "8800", "ULTRA", "graphic", "card", "16", "32", "48", "64", "80", "96", "112", "128", "processor", "respectively", "nvstrap", "driver", "RivaTuner", "-lsb-", "Nicolaychuk", "2008", "-rsb-", "use", "disable", "process", "unit", "adjust", "hardware", "mask", "although", "we", "technique", "capable", "construct", "high", "quality", "kdtree", "real-time", "have", "its", "limitation", "small", "scene", "less", "than", "5k", "triangle", "CUDA?s", "API", "overhead", "become", "major", "bottleneck", "case", "more", "efficient", "switch", "complete", "CPU", "method", "also", "we", "method", "consume", "much", "more", "memory", "than", "CPU", "method", "mainly", "due", "use", "double", "list", "extra", "bookkeeping", "BFS", "order", "construction", "we", "system", "support", "scene", "up", "600k", "triangle", "GeForce", "8800", "Ultra", "-lrb-", "768MB", "-rrb-", "graphic", "card", "six", "test", "scene", "peak", "memory", "we", "build", "around", "8mb", "18mb", "50mb", "90mb", "123mb", "178mb", "respectively", "problem", "however", "can", "reduce", "better", "memory", "management", "scheme", "example", "currently", "we", "keep", "many", "temporary", "datum", "structure", "memory", "all", "stage", "avoid", "costly", "CUDA", "API", "call", "free", "temporary", "datum", "we", "implement", "set", "efficient", "CUDA", "memory", "allocation/free", "routine", "we", "able", "free", "temporary", "datum", "reduce", "memory", "consumption", "considerably", "other", "technique", "reduce", "memory", "certainly", "possible", "investigate", "future", "work", "memory", "consumption", "issue", "also", "alleviate", "rapid", "advancement", "graphic", "hardware", "NVIDIA", "recently", "release", "Quadro", "FX", "5600", "which", "support", "CUDA", "have", "1.5", "gb", "memory", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "126:7", "scene", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "-lsb-", "wald07", "-rsb-", "-lsb-", "shevtsov07", "-rsb-", "we", "method", "10.5", "fp", "23.5", "fp", "32.0", "fp", "n/a", "n/a", "8.00", "fp", "n/a", "n/a", "4.96", "fp", "n/a", "n/a", "4.84", "fp", "2.30", "fp", "5.84", "fp", "6.40", "fp", "n/a", "n/a", "8.85", "fp", "-lsb-", "wald07", "-rsb-", "-lsb-", "shevtsov07", "-rsb-", "we", "method", "10.5", "fp", "23.5", "fp", "32.0", "fp", "n/a", "n/a", "8.00", "fp", "n/a", "n/a", "4.96", "fp", "n/a", "n/a", "4.84", "fp", "2.30", "fp", "5.84", "fp", "6.40", "fp", "n/a", "n/a", "8.85", "fp", "Table", "Performance", "comparison", "result", "four", "dynamic", "scene", "all", "image", "render", "resolution", "1024", "1024", "-lsb-", "wald07", "-rsb-", "time", "from", "-lsb-", "Wald", "et", "al.", "2007", "-rsb-", "AMD", "Opteron", "2.6", "GHz", "CPU", "multi-core", "time", "from", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "dual", "Intel", "Core2", "Duo", "3.0", "GHz", "-lrb-", "core", "-rrb-", "GPU", "Ray", "Tracing", "we", "have", "incorporate", "we", "kd-tree", "builder", "GPU", "ray", "tracer", "arbitrary", "dynamic", "scene", "each", "frame", "ray", "tracer", "first", "build", "kd-tree", "from", "scratch", "each", "ray", "trace", "ray", "tracer", "walk", "through", "kd-tree", "until", "reach", "leaf", "node", "associate", "triangle", "front", "back", "order", "while", "exist", "GPU", "ray", "tracer", "-lsb-", "Foley", "Sugerman", "2005", "Horn", "et", "al.", "2007", "Popov", "et", "al.", "2007", "-rsb-", "adopt", "stackless", "scheme", "kdtree", "traversal", "require", "additional", "information", "precompute", "store", "during", "tree", "construction", "extra", "computation", "during", "tree", "traversal", "avoid", "overhead", "we", "choose", "implement", "conventional", "stack-based", "scheme", "GPU", "point", "out", "-lsb-", "Horn", "et", "al.", "2007", "-rsb-", "when", "ray", "pass", "through", "both", "side", "splitting", "plane", "far", "subtree", "push", "stack", "near", "subtree", "traverse", "first", "reason", "stack-based", "scheme", "require", "local", "stack", "each", "thread", "fortunately", "can", "efficiently", "implement", "CUDA", "allocate", "fixed-sized", "array", "thread-local", "memory", "although", "kd-tree", "depth", "unbounded", "theory", "we", "find", "stack", "depth", "50", "enough", "all", "test", "figure", "GPU", "ray", "trace", "dynamic", "subdivision", "surface", "scene", "consist", "47k", "triangle", "armadillo", "model", "directly", "evaluate", "GPU", "through", "subdivision", "displacement", "mapping", "from", "coarse", "control", "mesh", "we", "can", "achieve", "22", "fp", "800", "600", "image", "scene", "paper", "order", "handle", "reflection/refraction", "we", "ray", "tracer", "perform", "follow", "multiple", "pass", "after", "build", "kd-tree", "scene", "spawn", "trace", "eye", "ray", "generate", "list", "hit", "specular", "refractive", "surface", "perform", "list", "compaction", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "eye", "ray", "hit", "point", "spawn", "trace", "reflective", "refractive", "ray", "repeat", "step", "step", "more", "bounce", "handle", "spawn", "trace", "shadow", "ray", "compute", "shade", "after", "shading", "compute", "each", "ray?s", "contribution", "final", "image", "send", "opengl", "pixel", "buffer", "object", "-lrb-", "pbo", "-rrb-", "PBO", "accumulate", "final", "image", "use", "alpha", "blending", "experimental", "result", "we", "test", "we", "GPU", "ray", "tracer", "use", "dynamic", "scene", "show", "fig.", "Table", "compare", "we", "frame", "rate", "those", "report", "two", "recent", "work", "one", "algorithm", "base", "bound", "volume", "hierarchy", "-lrb-", "bvh", "-rrb-", "-lsb-", "Wald", "et", "al.", "2007", "-rsb-", "other", "multi-core", "CPU", "algorithm", "use", "kd-trees", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "performance", "take", "account", "both", "tree", "-lrb-", "bvh", "-rrb-", "construction", "render", "time", "can", "see", "we", "algorithm", "run", "interactively", "shadow", "multi-bounce", "reflection/refraction", "outperform", "other", "two", "algorithm", "result", "suggest", "dynamic", "scene", "GPU", "ray", "trace", "accelerate", "we", "kd-tree", "provide", "competitive", "alternative", "CPU", "ray", "trace", "multi-core", "cpus", "note", "here", "we", "do", "claim", "we", "GPU", "ray", "tracer", "faster", "than", "all", "CPU", "ray", "tracer", "indeed", "implement", "fastest", "CPU", "ray", "tracer", "like", "chase", "move", "target", "because", "various", "optimization", "could", "use", "higher", "performance", "some", "optimization", "hardware", "dependent", "better", "performance", "can", "achieve", "add", "more", "CPU", "core", "example", "-lsb-", "Wald", "2007", "-rsb-", "report", "13", "21", "frame", "per", "second", "explode", "dragon", "scene", "-lrb-", "fig.", "-lrb-", "-rrb-", "-rrb-", "2.6", "GHz", "Clovertown", "system", "core", "note", "Toys", "Fairy", "Forest", "scene", "we", "frame", "rate", "higher", "than", "4-core", "CPU", "algorithm", "-lsb-", "Shevtsov", "et", "al.", "2007", "-rsb-", "both", "scene", "actually", "do", "reveal", "we", "method?s", "advantage", "tree", "quality", "due", "lack", "divergent", "secondary", "ray", "from", "reflection/refraction", "however", "already", "demonstrate", "potential", "ray", "trace", "dynamic", "scene", "gpus", "unique", "feature", "we", "ray", "tracer", "can", "efficiently", "handle", "dynamic", "geometry", "directly", "evaluate", "GPU", "skinned", "mesh", "-lsb-", "Wang", "et", "al.", "2007", "-rsb-", "subdivision", "surface", "-lsb-", "Shiue", "et", "al.", "2005", "-rsb-", "armadillo", "Fig.", "example", "input", "geometry", "sequence", "coarse", "control", "mesh", "provide", "author", "-lsb-", "Zhou", "et", "al.", "2007", "-rsb-", "two", "level", "Loop", "subdivision", "displacement", "mapping", "perform", "GPU", "generate", "detailed", "mesh", "output", "GPU", "subdivision", "displacement", "mapping", "immediately", "send", "we", "GPU", "kd-tree", "builder", "ray", "trace", "directly", "without", "copy", "back", "CPU", "please", "see", "accompany", "video", "live", "demo", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "126:8", "K.", "Zhou", "et", "al.", "GPU", "Photon", "mapping", "section", "we", "first", "show", "how", "adapt", "we", "kd-tree", "builder", "photon", "mapping", "we", "describe", "how", "perform", "k-nearestneighbor", "-lrb-", "knn", "-rrb-", "search", "use", "kd-tree", "GPU", "finally", "we", "show", "how", "use", "kd-tree", "builder", "knn", "search", "render", "caustic", "present", "some", "experimental", "result", "5.1", "Kd-Tree", "Photon", "mapping", "algorithm", "can", "use", "build", "photon", "kd-tree", "after", "several", "modification", "first", "we", "use", "vvh", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "instead", "SAH", "evaluate", "split", "cost", "function", "give", "node", "split", "position", "VVH", "cost", "function", "define", "where", "definition", "t", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "similar", "those", "SAH", "estimate", "KNN", "query", "radius", "describe", "more", "detail", "Appendix", "A.", "-lrb-", "-rrb-", "represent", "volume", "node", "d?s", "cell", "extend", "radius", "three", "axis", "direction", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "left", "right", "child", "node", "respectively", "give", "split", "position", "x.", "large", "node", "hybrid", "scheme", "spatial", "median", "splitting", "empty", "space", "splitting", "still", "employ", "however", "different", "switch", "threshold", "10", "use", "we", "also", "use", "smaller", "threshold", "large/small", "node", "classification", "32", "since", "exact", "vvh", "cost", "evaluation", "more", "expensive", "than", "SAH", "cost", "evaluation", "we", "discover", "through", "experiment", "second", "modification", "unlike", "ray", "trace", "photon", "kdtree", "build", "point", "instead", "triangle", "thus", "we", "do", "need", "compute", "aabb", "initialization", "stage", "clip", "split", "plane", "longer", "require", "large", "node", "split", "plane", "restricted", "initial", "point", "position", "small", "node", "third", "modification", "we", "can", "now", "simplify", "large", "node", "stage", "greatly", "because", "clipping", "need", "most", "computation", "can", "directly", "parallelize", "over", "all", "point", "large", "node", "chunk", "datum", "structure", "longer", "necessary", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "initialization", "stage", "each", "three", "axis", "dimension", "we", "compute", "maintain", "sort", "order", "all", "point", "use", "sort", "primitive", "cudppsort", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "sort", "order", "tight", "bound", "box", "large", "node", "can", "compute", "-lrb-", "-rrb-", "time", "avoid", "use", "segmented", "reduction", "compensate", "overhead", "computing", "maintain", "sort", "order", "also", "sort", "point", "child", "node", "count", "point", "number", "child", "node", "can", "do", "-lrb-", "-rrb-", "time", "single", "pass", "over", "sort", "datum", "we", "store", "point-sorted", "order", "all", "node", "three", "concatenate", "point", "id", "list", "one", "each", "axis", "allow", "efficient", "per-node", "access", "list", "we", "enforce", "two", "property", "-rrb-", "point", "same", "node", "contiguous", "list", "-rrb-", "point", "same", "node", "same", "offset", "three", "list", "property", "allow", "arbitrary", "sub-list", "each", "individual", "node", "index", "use", "head", "pointer", "tail", "pointer", "after", "node", "splitting", "we", "perform", "split", "operation", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "concatenate", "list", "separate", "point", "left", "child", "node", "point", "right", "child", "node", "easy", "verify", "result", "new", "list", "inherit", "two", "aforementioned", "property", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "t", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "algorithm", "KNN", "search", "function", "NN", "earch", "-lrb-", "point", "-rrb-", "begin", "min", "max", "hist", "new", "array", "-lsb-", "hist", "-rsb-", "iter", "max", "max", "min", "set", "all", "element", "hist", "zero", "each", "photon", "via", "range", "search", "increment", "hist", "-lsb-", "max", "-lcb-", "p?q", "min", ",0", "-rcb-", "hist", "-rsb-", "find", "hist", "-lsb-", "-rsb-", "hist", "-lsb-", "-rsb-", "-lrb-", "min", "max", "-rrb-", "-lrb-", "min", "hist", "min", "+1", "hist", "-rrb-", "max", "return", "all", "photon", "via", "range", "search", "end", "sort", "order", "also", "use", "accelerate", "computation", "reprocess", "mall", "ode", "small", "node", "stage", "however", "bit", "mask", "representation", "bitwise", "operation", "small", "node", "still", "employ", "both", "performance", "storage", "efficiency", "section", "3.3", "we", "reorganize", "all", "node", "use", "preorder", "traversal", "each", "node", "result", "node", "list", "record", "number", "index", "photon", "contain", "its", "splitting", "plane", "link", "its", "child", "its", "bound", "box", "5.2", "KNN", "search", "describe", "-lsb-", "Jensen", "2001", "-rsb-", "estimate", "radiance", "surface", "point", "k-nearest", "photon", "need", "located", "filter", "efficiently", "locate", "nearest", "photon", "critical", "good", "performance", "photon", "mapping", "photon", "kd-tree", "build", "last", "subsection", "can", "use", "speed", "up", "nearest", "neighbor", "query", "natural", "choice", "locate", "nearest", "neighbor", "kd-tree", "priority", "queue", "method", "describe", "-lsb-", "Jensen", "2001", "-rsb-", "although", "possible", "implement", "priority", "queue", "use", "cuda?s", "threadlocal", "memory", "implementation", "would", "inefficient", "because", "cuda?s", "local", "memory", "require", "both", "pipeline", "sufficient", "amount", "independent", "arithmetic", "efficient", "latency", "hiding", "thread-wise", "coherent", "access", "pattern", "-lsb-", "NVIDIA", "2007", "-rsb-", "priority", "queue", "operation", "almost", "all", "memory", "access", "arithmetic", "inter-dependent", "difficult", "hardware", "hide", "memory", "latency", "thread-wise", "coherence", "also", "problematic", "since", "photon", "distribution", "usually", "highly", "irregular", "we", "instead", "propose", "iterative", "knn", "search", "algorithm", "base", "range", "search", "-lsb-", "Preparata", "Shamos", "1985", "-rsb-", "show", "Algorithm", "algorithm", "from", "initial", "conservative", "search", "radius", "try", "find", "KNN", "query", "radius", "through", "few", "iteration", "during", "each", "iteration", "fixed-radius", "range", "search", "perform", "construct", "hist", "histogram", "photon", "number", "over", "radius", "range", "search", "radius", "reduce", "accord", "histogram", "finally", "all", "photon", "within", "radius", "return", "three", "parameter", "Algorithm", "hist", "iter", "initial", "search", "radius", "one", "hand", "should", "conservative", "least", "photon", "within", "radius", "other", "hand", "should", "tight", "possible", "limit", "search", "range", "good", "estimation", "critical", "performance", "knn", "search", "appendix", "we", "elaborate", "detail", "estimation", "hist", "size", "histogram", "array", "control", "precision", "gain", "each", "iteration", "hist", "require", "frequent", "random", "update", "we", "store", "cuda?s", "share", "memory", "larger", "hist", "increase", "precision", "each", "iteration", "while", "decrease", "GPU", "occupancy", "we", "find", "hist", "32", "reasonable", "balance", "point", "iter", "number", "iteration", "currently", "we", "take", "iter", "result", "error", "final", "knn", "radius", "less", "than", "0.1", "Range", "search", "perform", "use", "standard", "df", "kd-tree", "traversal", "algorithm", "-lsb-", "Preparata", "Shamos", "1985", "-rsb-", "like", "stack-based", "kd-tree", "traversal", "GPU", "ray", "trace", "algorithm", "can", "efficiently", "implement", "use", "cuda?s", "local", "memory", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "126:9", "5.3", "Caustic", "rendering", "Dynamic", "Scenes", "sample", "application", "photon", "kd-tree", "knn", "search", "we", "develop", "photon", "mapping", "system", "render", "realistic", "caustic", "GPU", "before", "build", "tree", "photon", "must", "emit", "scene", "process", "trace", "eye", "ray", "trace", "photon", "from", "light", "source", "very", "similar", "GPU", "ray", "tracer", "describe", "section", "can", "easily", "adapt", "photon", "trace", "main", "difference", "interaction", "photon", "surface", "material", "different", "from", "ray", "when", "photon", "hit", "surface", "can", "either", "reflect", "transmit", "absorb", "base", "surface", "material", "since", "we", "only", "trace", "caustic", "photon", "photon", "terminate", "store", "once", "hit", "diffuse", "surface", "we", "current", "system", "support", "only", "point", "light", "source", "photon", "emit", "randomly", "use", "projection", "map", "-lsb-", "Jensen", "2001", "-rsb-", "caustic", "render", "only", "specular", "refractive", "object", "identify", "projection", "map", "once", "photon", "trace", "do", "kd-tree", "build", "all", "store", "photon", "caustic", "render", "trace", "eye", "ray", "each", "ray", "its", "first", "intersection", "diffuse", "surface", "knn", "search", "perform", "locate", "nearest", "photon", "which", "filter", "get", "radiance", "value", "experimental", "result", "fig.", "-lrb-", "-rrb-", "show", "cardioid-shaped", "caustic", "form", "table", "due", "light", "reflect", "inside", "metal", "ring", "we", "trace", "200k", "photon", "total", "50", "nearest", "photon", "be", "query", "radiance", "estimate", "both", "lighting", "surface", "material", "can", "change", "fly", "please", "see", "accompany", "video", "live", "demo", "combine", "we", "GPU", "ray", "tracer", "section", "we", "even", "allow", "user", "change", "scene", "geometry", "case", "two", "kd-tree", "need", "build", "fly", "one", "scene", "geometry", "other", "photon", "fig.", "-lrb-", "-rrb-", "demonstrate", "caustic", "from", "glass", "champagne", "caustic", "form", "light", "refract", "through", "several", "layer", "glass", "champagne", "we", "use", "six", "bounce", "refraction", "photon", "trace", "total", "400k", "photon", "be", "trace", "set", "40", "KNN", "search", "again", "both", "lighting", "scene", "geometry", "can", "change", "Table", "summarize", "time", "photon", "kd-tree", "construction", "knn", "search", "use", "both", "CPU", "GPU", "algorithm", "CPU", "KNN", "search", "base", "priority", "queue", "method", "describe", "-lsb-", "Jensen", "2001", "-rsb-", "overall", "both", "we", "GPU", "kd-tree", "builder", "knn", "search", "around", "10", "time", "faster", "than", "CPU", "algorithm", "conclusion", "we", "have", "present", "kd-tree", "algorithm", "capable", "achieve", "realtime", "performance", "GPU", "algorithm", "build", "kd-tree", "BFS", "order", "exploit", "large", "scale", "parallelism", "modern", "gpus", "construct", "kd-tree", "comparable", "quality", "those", "build", "off-line", "CPU", "algorithm", "we", "also", "demonstrate", "potential", "we", "kd-tree", "algorithm", "three", "application", "involve", "dynamic", "scene", "GPU", "ray", "trace", "GPU", "photon", "mapping", "point", "cloud", "modeling", "several", "direction", "future", "investigation", "we", "plan", "incorporate", "packet", "-lsb-", "Wald", "et", "al.", "2001", "-rsb-", "GPU", "ray", "tracer", "further", "performance", "enhancement", "we", "also", "intend", "implement", "Figure", "-lrb-", "-rrb-", "metal", "ring", "-lrb-", "-rrb-", "glass", "champagne", "caustic", "render", "use", "photon", "mapping", "both", "scene", "light", "point", "light", "source", "render", "image", "resolution", "800", "600", "-lrb-", "-rrb-", "cardioid-shaped", "caustic", "cause", "light", "reflection", "inside", "metal", "ring", "scene", "consist", "3k", "triangle", "render", "performance", "12.2", "fp", "-lrb-", "-rrb-", "caustic", "due", "light", "refraction", "through", "several", "layer", "glass", "champagne", "scene", "have", "19k", "triangle", "performance", "about", "7.5", "fp", "scene", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "Table", "CPU", "algorithm", "GPU", "algorithm", "kd-tree", "knn", "kd-tree", "knn", "0.081", "0.508", "0.009", "0.044", "0.237", "0.371", "0.017", "0.050", "compare", "photon", "kd-tree", "construction", "time", "knn", "time", "between", "CPU", "algorithm", "we", "GPU", "algorithm", "global", "photon", "map", "GPU", "use", "general", "photon", "scattering", "scheme", "base", "russian", "roulette", "photon", "map", "would", "allow", "we", "render", "indirect", "illumination", "finally", "we", "interested", "extend", "we", "kd-tree", "algorithm", "higher", "dimension", "application", "texture", "synthesis", "acknowledgement", "author", "would", "like", "thank", "Eric", "Stollnitz", "he", "help", "video", "production", "we", "also", "grateful", "reviewer", "helpful", "comment", "reference", "arr", "N.", "A.", "all", "J.", "D.", "art", "J.", "C.", "2002", "ray", "engine", "Proceedings", "Graphics", "Hardware", "37", "46", "arr", "N.", "A.", "OBEROCK", "J.", "RANE", "K.", "art", "J.", "C.", "2006", "fast", "GPU", "ray", "trace", "dynamic", "mesh", "use", "geometry", "image", "Proceedings", "Graphics", "Interface", "203", "209", "oley", "T.", "UGERMAN", "J.", "2005", "kd-tree", "acceleration", "structure", "GPU", "raytracer", "Graphics", "Hardware", "05", "oldsmith", "J.", "ALMON", "J.", "1987", "Automatic", "creation", "object", "hierarchy", "ray", "trace", "ieee", "cg&a", "14", "20", "ropp", "W.", "USK", "E.", "KJELLUM", "A.", "1994", "use", "MPI", "Portable", "parallel", "program", "Message", "Passing", "Interface", "MIT", "Press", "unther", "J.", "ALD", "I.", "LUSALLEK", "P.", "2004", "realtime", "caustic", "use", "distribute", "photon", "mapping", "Eurographics", "Symposium", "Rendering", "111", "121", "arris", "M.", "WENS", "J.", "engupta", "S.", "hang", "Y.", "avidson", "a.", "2007", "cudpp", "homepage", "http://www.gpgpu.org/developer/cudpp/", "avran", "V.", "2001", "Heuristic", "Ray", "shooting", "algorithm", "phd", "thesis", "Czech", "Technical", "University", "Prague", "OPPE", "H.", "OSE", "T.", "UCHAMP", "T.", "onald", "J.", "TUETZLE", "W.", "1992", "surface", "reconstruction", "from", "unorganized", "point", "Proceedings", "SIGGRAPH", "92", "71", "78", "orn", "D.", "R.", "UGERMAN", "J.", "OUSTON", "M.", "ANRAHAN", "P.", "2007", "interactive", "k-d", "tree", "gpu", "raytracing", "Proceedings", "Symposium", "interactive", "3d", "graphic", "Games", "167", "174", "UNT", "W.", "ark", "W.", "R.", "TOLL", "G.", "2006", "fast", "kd-tree", "construction", "adaptive", "error-bounded", "heuristic", "IEEE", "Symposium", "Interactive", "Ray", "Tracing", "81", "88", "ENSEN", "H.", "W.", "2001", "realistic", "image", "synthesis", "use", "Photon", "mapping", "AK", "Peters", "ac", "onald", "J.", "D.", "OOTH", "K.", "S.", "1990", "heuristic", "ray", "trace", "use", "space", "subdivision", "Vis", "Comput", "153", "166", "anku", "G.", "S.", "2002", "fast", "bit", "count", "routine", "http://infolab.stanford.edu/", "manku/bitcount/bitcount", "html", "ount", "D.", "M.", "RYA", "S.", "2006", "ANN", "library", "approximate", "nearest", "neighbor", "search", "http://www.cs.umd.edu/", "mount/ann", "icolaychuk", "a.", "2008", "RivaTuner", "http://www.guru3d.com/index.php?page=rivatuner", "NVIDIA", "2007", "CUDA", "programming", "guide", "1.0", "http://developer.nvidia.com/object/cuda.html", "auly", "M.", "EISER", "R.", "OBBELT", "L.", "P.", "ross", "M.", "2003", "shape", "modeling", "point-sampled", "geometry", "Proceedings", "SIGGRAPH", "03", "641", "650", "harr", "m.", "umprey", "G.", "2004", "physically", "base", "rendering", "from", "Theory", "Implementation", "Morgan", "Kaufmann", "opov", "S.", "UNTHER", "J.", "eidel", "h.-p.", "lusallek", "P.", "2006", "experience", "streaming", "construction", "SAH", "KDtrees", "IEEE", "Symposium", "Interactive", "Ray", "Tracing", "89", "94", "opov", "S.", "UNTHER", "J.", "eidel", "h.-p.", "lusallek", "P.", "2007", "stackless", "kd-tree", "traversal", "high", "performance", "GPU", "ray", "trace", "eurographic", "07", "415", "424", "repara", "F.", "P.", "HAMOS", "M.", "I.", "1985", "computational", "geometry", "introduction", "Springer-Verlag", "New", "York", "Inc.", "urcell", "T.", "J.", "UCK", "I.", "ark", "W.", "R.", "ANRAHAN", "P.", "2002", "Ray", "trace", "programmable", "graphic", "hardware", "ACM", "Trans", "gr", "21", "703", "712", "urcell", "T.", "J.", "ONNER", "C.", "AMMARANO", "M.", "ENSEN", "H.", "W.", "ANRAHAN", "P.", "2003", "photon", "mapping", "programmable", "graphic", "hardware", "Graphics", "Hardware", "03", "41", "50", "eshetov", "a.", "oupikov", "a.", "urley", "J.", "2005", "multilevel", "ray", "trace", "algorithm", "SIGGRAPH", "05", "1176", "1185", "engupta", "S.", "ARRIS", "M.", "hang", "Y.", "wen", "J.", "D.", "2007", "scan", "primitive", "GPU", "computing", "Graphics", "Hardware", "07", "97", "106", "hevtsov", "m.", "oupikov", "a.", "APUSTIN", "A.", "2007", "highly", "parallel", "fast", "kd-tree", "construction", "interactive", "ray", "trace", "dynamic", "scene", "eurographic", "07", "395", "404", "hiue", "l.-j.", "one", "i.", "eter", "J.", "2005", "realtime", "GPU", "subdivision", "kernel", "ACM", "Trans", "gr", "24", "1010", "1015", "toll", "G.", "2005", "part", "ii", "achieve", "real", "time", "optimization", "technique", "SIGGRAPH", "2005", "Course", "Interactive", "Ray", "Tracing", "ald", "i.", "avran", "V.", "2006", "building", "fast", "kd-tree", "ray", "trace", "do", "-lrb-", "nlog", "-rrb-", "Proceedings", "IEEE", "Symposium", "Interactive", "Ray", "Tracing", "61", "69", "ald", "i.", "lusallek", "P.", "ENTHIN", "C.", "AGNER", "M.", "2001", "interactive", "render", "coherent", "ray", "trace", "Computer", "Graphics", "Forum", "20", "153", "164", "ALD", "I.", "UNTHER", "J.", "LUSALLEK", "P.", "2004", "balance", "consider", "harmful", "faster", "photon", "mapping", "use", "voxel", "volume", "heuristic", "Proceedings", "Eurographics", "04", "595", "603", "ALD", "I.", "ze", "T.", "ENSLER", "A.", "NOLL", "a.", "arker", "S.", "G.", "2006", "Ray", "trace", "animated", "scene", "use", "coherent", "grid", "traversal", "ACM", "Trans", "gr", "25", "485", "493", "ALD", "I.", "OULOS", "S.", "HIRLEY", "P.", "2007", "Ray", "trace", "deformable", "scene", "use", "dynamic", "bound", "volume", "hierarchy", "ACM", "Trans", "gr", "26", "ALD", "I.", "2007", "fast", "construction", "SAH", "base", "bound", "volume", "hierarchy", "IEEE", "Symposium", "Interactive", "Ray", "Tracing", "33", "40", "ang", "R.", "Y.", "ULLI", "K.", "opovus", "J.", "2007", "real-time", "envelop", "rotational", "regression", "ACM", "Trans", "gr", "26", "73", "OON", "S.-E.", "URTIS", "S.", "anocha", "D.", "2007", "Ray", "trace", "dynamic", "scene", "use", "selective", "restructuring", "Eurographics", "Symposium", "Rendering", "HOU", "K.", "UANG", "X.", "W.", "UO", "B.", "hum", "h.-y", "2007", "direct", "manipulation", "subdivision", "surface", "gpus", "ACM", "Trans", "gr", "26", "91", "wicker", "M.", "fister", "H.", "VAN", "AAR", "J.", "ross", "M.", "2001", "surface", "splatting", "SIGGRAPH", "01", "371", "378", "wicker", "M.", "auly", "M.", "NOLL", "O.", "ross", "M.", "2002", "Pointshop", "3d", "interactive", "system", "point-based", "surface", "editing", "SIGGRAPH", "02", "322", "329", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "126:10", "K.", "Zhou", "et", "al.", "initial", "knn", "radius", "Estimate", "mention", "section", "5.2", "good", "estimation", "critical", "performance", "knn", "search", "due", "irregularity", "photon", "distribution", "need", "estimate", "each", "knn", "query", "point", "show", "algorithm", "we", "take", "two-stage", "approach", "first", "each", "render", "frame", "recompute", "adius", "carry", "out", "compute", "KNN", "query", "radius", "set", "node", "center", "do", "run", "knn", "search", "algorithm", "Algorithm", "parameter", "R.", "each", "knn", "query", "point", "stimate", "adius", "perform", "compute", "p?s", "initial", "query", "radius", "from", "KNN", "query", "radius", "node", "contain", "can", "easily", "prove", "result", "query", "radius", "guarantee", "conservative", "conservative", "estimation", "note", "photon", "density", "inversely", "proportional", "square", "knn", "query", "radius", "define", "minimal", "physically", "meaningful", "density", "reasonably", "tight", "estimation", "can", "compute", "from", "also", "use", "estimate", "query", "radius", "VVH", "center", "node", "i?s", "bound", "box", "node", "radius", "compute", "half", "length", "bound", "box", "diagonal", "level", "two", "user-specified", "constant", "which", "determine", "node", "use", "radius", "estimation", "we", "find", "0.5", "level", "work", "well", "all", "example", "show", "paper", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008", "real-time", "kd-tree", "construction", "Graphics", "Hardware", "126:11", "algorithm", "Estimate", "procedure", "recompute", "adius", "-lrb-", "-rrb-", "begin", "compute", "initialize", "all", "node", "work", "new", "list", "each", "kd-tree", "node", "radius", "less", "than", "work.add", "-lrb-", "-rrb-", "each", "node", "work", "i.parent", "work", "work.remove", "-lrb-", "-rrb-", "level", "each", "node", "work", "compute", "KNN", "query", "radius", "node", "i?s", "center", "work", "new", "list", "each", "node", "work", "add", "i?s", "child", "work", "work", "work", "end", "function", "stimate", "adius", "-lrb-", "point", "-rrb-", "begin", "each", "node", "contain", "min", "-lcb-", "-rcb-", "return", "end", "point", "cloud", "model", "kd-tree", "builder", "knn", "search", "algorithm", "describe", "section", "can", "directly", "use", "estimate", "local", "sampling", "density", "normal", "dynamic", "point", "cloud", "well", "update", "deformation", "strength", "field", "free-form", "deformation", "give", "set", "point", "input", "we", "first", "build", "kd-tree", "unlike", "photon", "mapping", "we", "do", "have", "good", "estimate", "initial", "knn", "query", "radius", "we", "thus", "let", "user", "specify", "parameter", "parallel", "each", "point", "we", "find", "k-nearest", "neighbor", "use", "knn", "search", "final", "query", "radius", "can", "use", "determine", "local", "kernel", "size", "surface", "splatting", "-lsb-", "Zwicker", "et", "al.", "2001", "-rsb-", "local", "sampling", "density", "can", "compute", "k/r", "compute", "normal", "-lsb-", "Hoppe", "et", "al.", "1992", "-rsb-", "we", "first", "perform", "principal", "component", "analysis", "-lrb-", "pca", "-rrb-", "covariance", "matrix", "its", "k-nearest", "neighbor", "unit", "eigenvector", "minimal", "eigenvalue", "regard", "normal", "minimum", "span", "tree", "-lrb-", "mst", "-rrb-", "base", "approach", "-lsb-", "Hoppe", "et", "al.", "1992", "-rsb-", "use", "make", "all", "point", "normal", "consistently", "orient", "both", "knn", "search", "pca", "perform", "GPU", "minimum", "span", "tree", "however", "currently", "build", "CPU", "point", "cloud", "deformation", "tool", "-lsb-", "Pauly", "et", "al.", "2003", "-rsb-", "scalar", "value", "range", "from", "compute", "each", "point", "indicate", "deformation", "strength", "point", "each", "point?s", "scalar", "value", "decide", "its", "distance", "current", "active", "handle", "other", "static", "handle", "closer", "point", "active", "handle", "stronger", "deformation", "point", "each", "handle", "consist", "set", "point", "point?s", "distance", "handle", "define", "minimal", "distance", "between", "point", "all", "point", "handle", "efficiently", "calculate", "distance", "two", "kd-tree", "build", "one", "active", "handle", "one", "all", "static", "handle", "each", "point", "its", "nearest", "neighbor", "each", "tree", "search", "distance", "compute", "therefore", "when", "user", "define", "new", "handle", "remove", "old", "handle", "we", "need", "rebuild", "kd-tree", "recompute", "distance", "which", "can", "do", "efficiently", "use", "we", "GPU", "kd-tree", "builder", "knn", "search", "Figure", "sample", "density", "normal", "estimation", "point", "cloud", "from", "leave", "right", "input", "point", "cloud", "-lrb-", "127k", "point", "-rrb-", "render", "use", "surface", "splatting", "sampling", "density", "map", "rest", "pose", "sampling", "density", "map", "deform", "pose", "-lrb-", "blue", "small", "red", "large", "-rrb-", "Figure", "deform", "point", "cloud", "-lrb-", "170k", "point", "-rrb-", "active", "handle", "mark", "blue", "we", "algorithm", "allow", "user", "define", "switch", "new", "handle", "quickly", "experimental", "result", "we", "have", "implement", "describe", "algorithm", "develop", "point", "cloud", "deformation", "tool", "-lsb-", "Pauly", "et", "al.", "2003", "-rsb-", "point", "cloud", "render", "use", "GPU", "implementation", "surface", "splat", "algorithm", "-lsb-", "Zwicker", "et", "al.", "2001", "-rsb-", "please", "see", "accompany", "video", "live", "demo", "fig.", "sampling", "density", "normal", "compute", "dynamic", "point", "cloud", "fly", "we", "GPU", "algorithm", "kdtree", "build", "about", "21", "millisecond", "knn", "search", "-lrb-", "10", "-rrb-", "take", "about", "14", "millisecond", "CPU", "algorithm", "pointshop3d", "-lsb-", "Zwicker", "et", "al.", "2002", "-rsb-", "use", "simple", "midpoint", "splitting", "build", "kdtree", "quickly", "however", "tree", "quality", "poor", "result", "very", "slow", "knn", "search", "same", "datum", "take", "about", "32", "millisecond", "6.5", "seconds", "tree", "construction", "knn", "search", "respectively", "we", "also", "compare", "we", "algorithm", "kd-tree", "algorithm", "ANN", "library", "-lsb-", "Mount", "Arya", "2006", "-rsb-", "same", "datum", "take", "98", "millisecond", "828", "millisecond", "tree", "construction", "knn", "search", "respectively", "overall", "we", "approach", "over", "20", "time", "faster", "than", "ANN", "algorithm", "note", "achieve", "consistent", "normal", "orientation", "minimum", "span", "tree", "build", "initial", "pose", "point", "cloud", "CPU", "less", "than", "30", "millisecond", "Minimum", "span", "tree", "need", "build", "again", "during", "deformation", "since", "we", "make", "use", "temporal", "coherence", "force", "point", "normal", "current", "pose", "consistently", "orient", "those", "precede", "pose", "deformation", "example", "show", "Fig.", "we", "allow", "user", "manipulate", "point", "cloud", "define", "new", "handle", "drag", "they", "we", "algorithm", "can", "provide", "immediate", "response", "user", "since", "deformation", "strength", "field", "compute", "about", "310", "millisecond", "while", "CPU", "algorithm", "base", "ANN", "take", "about", "seconds", "thus", "provide", "better", "user", "experience", "ACM", "transaction", "Graphics", "Vol", "27", "no.", "Article", "126", "publication", "date", "December", "2008" ],
  "content" : "\n  \n    edf5499a3955fc05d4b637f3862dcbdbaeace4f3b69a00795937d36adef7a09a\n    mhw\n    10.1145/1409060.1409079\n    Name identification was not possible. \n  \n  \n    \n      \n        Real-Time KD-Tree Construction on Graphics Hardware\n      \n      Kun Zhou ? ? Qiming Hou ? Rui Wang ? ? Zhejiang University ? Tsinghua University\n      We present an algorithm for constructing kd-trees on GPUs. This algorithm achieves real-time performance by exploiting the GPU?s streaming architecture at all stages of kd-tree construction. Unlike previous parallel kd-tree algorithms, our method builds tree nodes completely in BFS (breadth-first search) order. We also develop a special strategy for large nodes at upper tree levels so as to further exploit the fine-grained parallelism of GPUs. For these nodes, we parallelize the computation over all geometric primitives instead of nodes at each level. Finally, in order to maintain kd-tree quality, we introduce novel schemes for fast evaluation of node split costs. As far as we know, ours is the first real-time kd-tree algorithm on the GPU. The kd-trees built by our algorithm are of comparable quality as those constructed by off-line CPU algorithms. In terms of speed, our algorithm is significantly faster than well-optimized single-core CPU algorithms and competitive with multi-core CPU algorithms. Our algorithm provides a general way for handling dynamic scenes on the GPU. We demonstrate the potential of our algorithm in applications involving dynamic scenes, including GPU ray tracing, interactive photon mapping, and point cloud modeling. Keywords: kd-tree, programable graphics hardware, ray tracing, photon mapping, point cloud modeling\n    \n    \n      \n        1 Introduction\n      \n      The kd-tree is a well-known space-partitioning data structure for organizing points in k-dimensional space. As an acceleration structure, it has been used in a variety of graphics applications, including triangle culling for ray-triangle intersection tests in ray tracing, nearest photon queries in photon mapping, and nearest neighbor search in point cloud modeling and particle-based fluid simulation. Due to its fundamental importance in graphics, fast kd-tree construction has been a subject of much interest in recent years, with several CPU algorithms proposed [Popov et al. 2006; Hunt et al. 2006; Shevtsov et al. 2007]. However, real-time construction of kd-trees on the GPU remains an unsolved problem. In this paper, we present a kd-tree construction algorithm for the GPU that achieves real-time performance by heavily exploiting the hardware. Specifically, our algorithm builds tree nodes in BFS (breadth-first search) order to fully exploit the fine-grained parallelism of modern GPUs at all stages of kd-tree construction. This is an important feature that distinguishes our work from previous parallel kd-tree algorithms including [Popov et al. 2006; Shevtsov et al. 2007], which resort to DFS (depth-first search) for nodes near the\n      ACM Reference Format Zhou, K., Hou, Q., Wang, R., Guo, B. 2008. Real-Time KD-Tree Construction on Graphics Hardware. ACM Trans. Graph. 27, 5, Article 126 (December 2008), 11 pages. DOI = 10.1145/1409060.1409079 http://doi.acm.org/10.1145/1409060.1409079. Copyright Notice Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the fi rst page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2008 ACM 0730-0301/2008/05-ART126 $5.00 DOI 10.1145/1409060.1409079 http://doi.acm.org/10.1145/1409060.1409079\n      Baining Guo ? ? ? Microsoft Research Asia\n      \n        \n        Figure 1:\n      \n      GPU ray tracing and photon mapping for a dynamic scene, where both the scene geometry and the light source can be changed. Two kd-trees are built from scratch for each frame, one for the scene geometry and the other for the photons. Shadows, reflection/refraction, as well as caustics caused by the glass and champagne are rendered at around 8 fps for 800 ? 600 images.\n      bottom of the kd-tree. Our algorithm builds kd-trees of comparable quality as those constructed by off-line CPU algorithms. In terms of speed, our algorithm is 4 ? 7 times faster than well-optimized single-core CPU algorithms [Hunt et al. 2006] and competitive with multi-core CPU algorithms [Shevtsov et al. 2007]. In designing a kd-tree algorithm for the GPU, we must address two challenging issues. The first is how to maximally exploit the GPU?s streaming architecture when parallelizing kd-tree construction. The modern GPU is massively parallel and requires 10 3 ? 10 4 threads for optimal performance [ NVIDIA 2007 ]. By following BFS order, we are well poised to take advantage of this architecture because at each BFS step, every node at the same tree level spawns a new thread and the total number of threads doubles from the preceding step. In addition to following BFS order, we also develop a special strategy for large nodes at upper tree levels so as to further exploit the the large scale parallelism of GPUs. For these nodes, we parallelize the computation over all geometric primitives instead of nodes at each level. This strategy is effective because there are only a relatively small number of large nodes at the upper levels, especially near the top of the tree, which makes parallelizing over nodes inefficient and leaves the massive parallelism of GPUs underexploited. Moreover, the workload among threads is likely to be unbalanced because the number of primitives may vary significantly from node to node. Another issue is the efficient calculation of node split costs, such as the surface area heuristic (SAH) [Goldsmith and Salmon 1987] and voxel volume heuristic (VVH) [Wald et al. 2004] costs. This is critical for maintaining kd-tree quality. The standard practice of precisely evaluating the costs for all tree nodes is prohibitively expensive for real-time techniques. To address this issue, we derive novel schemes for the so-called large and small nodes. A node is deemed as large if the number of triangles in the node is greater than a user-specified threshold; otherwise it is small [Popov et al. 2006; Shevtsov et al. 2007]. For large nodes at upper tree levels, we use two simple and inexpensive heuristics, median splitting and ?empty space maximizing? [Havran 2001; Wald and Havran 2006], to estimate the costs. For small nodes near the bottom of the tree, where exact evaluation of the costs is necessary, we introduce a novel data structure for storing the geometry primitives in these nodes as bit masks, which allows us to efficiently evaluate the exact costs and sort these primitives using bitwise operations. Our real-time kd-tree construction provides a general way of dealing with dynamic scenes on the GPU. We demonstrate the potential of our kd-tree algorithm with a few applications: GPU Ray Tracing We implemented a GPU ray tracer for arbitrary dynamic scenes using our real-time kd-tree construction (Section 4). The ray tracer achieves interactive rates with shadow and multi-bounce reflection/refraction. Our GPU ray tracer can handle general dynamic scenes and outperforms a state-of-the-art multicore CPU ray tracer [Shevtsov et al. 2007]. A unique feature of our ray tracer is that it can efficiently handle dynamic geometries that are directly evaluated on the GPU, such as subdivision surfaces [Shiue et al. 2005] and skinned meshes [Wang et al. 2007]. GPU Photon Mapping We implemented GPU photon mapping, in which photon tracing, photon kd-tree construction and nearest photon query are all performed on the GPU on the fly (Section 5). Combined with our GPU ray tracer, the photon mapping is capable of rendering shadows, reflection/refraction, as well as realistic caustics for dynamic scenes and lighting at interactive rates on a single PC. Such performance has not been achieved in previous work. Point Cloud Modeling Our real-time kd-tree construction can also be used for dynamic point clouds to accelerate nearest neighbor queries (Appendix B). The queried neighbors are used for estimating local sampling densities, calculating the normals and updating the deformation strength field in free-form deformation.\n      ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n      126:2 ? K. Zhou et al.\n      \n        2 Related Work\n        Optimized Kd-trees Early research mainly focused on optimizing kd-trees for triangle culling in ray-triangle intersection. The key for this optimization is determining the splitting plane. A simple but often-used method is spatial median splitting, in which the plane is positioned at the spatial median of the longest axis of the tree node volume. To improve effectiveness, researchers proposed SAH kd-trees [Goldsmith and Salmon 1987; MacDonald and Booth 1990; Havran 2001]. In fact, with the appearance of kd-tree based packet tracing [Wald et al. 2001] and frustum traversal [Reshetov et al. 2005], SAH kd-trees have become the best known acceleration structures for ray tracing of static scenes [Stoll 2005]. In other applications such as photon mapping, kd-trees are mainly used to accelerate nearest neighbor queries, for which different heuristics are employed to achieve better efficiency. For example, VVH kd-trees can better accelerate the photon gathering process than left-balanced trees [Wald et al. 2004]. Fast Kd-tree Construction Construction of high quality kd-trees is expensive due to the evaluation of the SAH cost function. Although an O(n log n) construction algorithm exists [Wald and Havran 2006], the time needed for large animated scenes is still too high. To allow a tradeoff between tree quality and construction speed, fast kd-tree algorithms [Popov et al. 2006; Hunt et al. 2006] approximate SAH using a piecewise linear (or quadric) function. [Popov et al. 2006] also proposed a parallel algorithm by constructing the tree in BFS order up to a certain tree level. However, their goal is to increase the coherence of memory accesses during tree construction and targets small scale parallel architectures like multi-core CPUs. For nodes near the bottom of the tree, DFS order  is used, which is difficult to parallelize and consumes 90% of the construction time. Based on reported timings, the multi-core algorithm in [Popov et al. 2006] is about an order of magnitude slower than our kd-tree algorithm. For trees of comparable quality, the algorithm in [Hunt et al. 2006] is about 4 ? 7 times slower than our algorithm. Shevstov et al. [2007] proposed a parallel kd-tree algorithm for a shared memory architecture with multi-core CPUs. The algorithm first partitions the space into several balanced sub-regions and then builds a sub-tree for each sub-region in parallel and in DFS order. The algorithm cannot be mapped well to GPU architecture because modern GPUs require 10 3 ? 10 4 threads for optimal performance [ NVIDIA 2007 ], orders of magnitude greater than the possible thread number on multi-core CPUs (e.g., four threads tested in the paper). Another problem with this method is that, as noted in [Shevtsov et al. 2007], the kd-trees constructed are of approximately half the quality of those produced by off-line kd-tree builders. For ray-tracing identical dynamic scenes, their performance is lower than our GPU ray tracer. Ray Tracing on GPUs Ray tracing on GPUs has stimulated much interest recently. [Carr et al. 2002] implemented ray-triangle intersection on the GPU. [Purcell et al. 2002] designed the first ray tracer that runs entirely on the GPU, employing a uniform grid for acceleration. [Foley and Sugerman 2005] introduced two stackless kd-tree traversal algorithms, which outperform the uniform grid approach. [Carr et al. 2006] implemented a limited GPU ray tracer for dynamic geometry based on bounding-volume hierarchies and geometry images. None of the above GPU ray tracers outperforms a well-optimized CPU ray tracer. Recently, two techniques [Horn et al. 2007; Popov et al. 2007] achieved better performance than CPU ray tracers. Both techniques use stackless kd-tree traversal and packet tracing. Unfortunately these two techniques work for static scenes only. For dynamic scenes, most existing methods are CPU-based (e.g., [Wald et al. 2006; Yoon et al. 2007]). Our work leads to a GPU ray tracer for general dynamic scenes that outperforms a state-of-the-art multi-core CPU ray tracer [Shevtsov et al. 2007]. Photon mapping has been implemented on GPUs [Purcell et al. 2003]. A uniform grid, instead of a kd-tree, is used to store the photons, greatly degrading the performance of nearest photon queries. [G?nther et al. 2004] presented a framework for real-time distributed photon mapping. Using 9 to 36 CPUs, they achieved frame rates of up to 22 fps at the image resolution of 640 ? 480. As far as we know, kd-tree based photon mapping algorithms have not been implemented on the GPU.\n      \n      \n        3 GPU Kd-Tree Construction\n        In this section, we describe how to build SAH kd-trees for ray tracing on the GPU. We focus on SAH kd-trees to streamline the discussion. The adaption of our algorithm to other kinds of kd-trees is straightforward and will be explained in later sections.  Following conventional kd-tree construction algorithms [Pharr and Humpreys 2004], our technique builds a kd-tree in a greedy, topdown manner by recursively splitting the current node into two subnodes as follows:\n        1. Evaluate the SAH costs for all splitting plane candidates; 2. Pick the optimal candidate with the lowest cost and split the node into two child nodes; 3. Sort triangles and distribute them to the two children;\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        Real-Time KD-Tree Construction on Graphics Hardware ? 126:3\n        Algorithm 1 Kd-Tree Construction procedure B UILD T REE (triangles:list) begin // initialization stage nodelist ? new list activelist ? new list smalllist ? new list nextlist ? new list Create rootnode activelist.add(rootnode) for each input triangle t in parallel Compute AABB for triangle t // large node stage while not activelist.empty() nodelist.append(activelist) nextlist.clear() P ROCESS L ARGE N ODES (activelist, smalllist, nextlist) Swap nextlist and activelist // small node stage P REPROCESS S MALL N ODES (smalllist) activelist ? smalllist while not activelist.empty() nodelist.append(activelist) nextlist.clear() P ROCESS S MALL N ODES (activelist, nextlist) Swap nextlist and activelist // kd-tree output stage P REORDER T RAVERSAL (nodelist) end (a) (b) larger Node Node than C e Cut off empty space Median split Triangles Triangles\n        \n          Figure 2: Two cases of large node split. (a) cut off empty space; (b) spatial median split.\n        \n        The SAH cost function is defined as: C L (x)A L (x) C R (x)A R (x) SAH(x) = C ts + + , A A where C ts is the constant cost of traversing the node itself, C L (x) is the cost of the left child given a split position x, and C R (x) is the cost of the right child given the same split. A L (x) and A R (x) are the surface areas of the left and right child respectively. A is the surface area of the node. Note that C L (x) and C R (x) can only be evaluated after the entire sub-tree has been built. Instead of seeking a globally optimal solution, existing algorithms use a locally greedy approximation by assuming the children are leaf nodes. In this case C L (x) and C R (x) equal the number of elements contained in the left and right child respectively. Algorithm Overview The algorithm takes a triangle soup as input and follows the construction pipeline as shown in Algorithm 1. After an initialization step, the algorithm builds the tree in a BFS manner, for both large nodes and small nodes. Finally, all nodes of the tree are reorganized and stored. The pipeline consists of a set of stream processing steps together with minimal coordination work. The streaming steps are done on the GPU while coordination work is done on the CPU at negligible costs.\n        Algorithm 2 Large Node Stage procedure P ROCESS L ARGE N ODES ( in activelist:list; out smalllist, nextlist:list) begin // group triangles into chunks for each node i in activelist in parallel Group all triangles in node i into fixed size chunks, store chunks in chunklist // compute per-node bounding box for each chunk k in chunklist in parallel Compute the bounding box of all triangles in k, using standard reduction Perform segmented reduction on per-chunk reduction result to compute per-node bounding box // split large nodes for each node i in activelist in parallel for each side j of node i if i contains more than C e empty space on side j then Cut off i?s empty space on side j Split node i at spatial median of the longest axis for each created child node ch nextlist.add(ch) // sort and clip triangles to child nodes for each chunk k in chunklist in parallel i ? k.node() for each triangle t in k in parallel if t is contained in both children of i then t 0 ? t t 1 ? t Sort t 0 and t 1 into two child nodes Clip t 0 and t 1 to their respective owner node else Sort t into the child node containing it // count triangle numbers for child nodes for each chunk k in chunklist in parallel i ? k.node() Count triangle numbers in i?s children, using reduction Perform segmented reduction on per-chunk result to compute per-child-node triangle number // small node filtering for each node ch in nextlist in parallel if ch is small node then smalllist.add(ch) nextlist.delete(ch) end\n        In the initialization stage, global memory is allocated for tree construction and the root node is created. Additionally, a streaming step is performed to compute the AABB (axis aligned bounding box) for each input triangle. In our current implementation, the user-specified threshold for large/small node is set as T = 64.\n      \n      \n        3.1 Large Node Stage\n        As mentioned, the SAH evaluation in the conventional greedy optimization algorithm assumes that the current split produces two leaf nodes. For large nodes, this assumption is almost always untrue. The resulting estimation is far from accurate. Our splitting scheme for large nodes is a combination of spatial median splitting and ?empty space maximizing?, which is highly effective for the upper levels of the tree as noted in [Havran 2001]. Specifically, if\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        126:4 ? K. Zhou et al.\n        Algorithm 3 GPU Segmented Reduction procedure G PU S EG R EDUCE ( in data, owner:list; op: reduction operator; out result:list) begin result ? new list Fill result with op?s identity element // assume there are n elements for d = 0 to log 2 n ? 1 for each i = 0 to (n ? 1)/2 d+1 in parallel w 0 ? owner[2 d+1 i] w 1 ? owner[2 d+1 i + 2 d ] if w 0 = w 1 then result[w 1 ] ? op(result[w 1 ], data[2 d+1 i + 2 d ]) else data[2 d+1 i] ? op(data[2 d+1 i], data[2 d+1 i + 2 d ]) end Operator Identity value Usage min +? compute bounding box max ?? compute bounding box + 0 count triangle number\n        \n          Table 1: Reduction operators and their usage in Algorithm 2.\n        \n        the empty space contained in the current node is larger than a predefined ratio C e along one axis, the empty space is cut off in the next split; otherwise, the split plane is chosen at the spatial median of the node?s longest axis (see Fig. 2 ). Currently, we take C e = 25%. Note that, to apply this splitting scheme, a tight bounding box of all triangles contained in the node has to be computed. The large node processing procedure, P ROCESS L ARGE N ODES , is elaborated in Algorithm 2. This procedure takes activelist as input, and updates smalllist and nextlist as output. Note that we also maintain a triangle-node association list for each node list. The triangle-node association list stores triangle indices contained in the node list, sorted by node index. Each node in the node list records the index of its first triangle in the triangle-node association list and the number of triangles it contains, the scene space it occupies, and the pointers to its child nodes. Now we walk through the major steps of P ROCESS L ARGE N ODES in Algorithm 2. The first step of the procedure is to group all triangles in each node into fixed-sized chunks. Currently we set the chunk size to N = 256. A large fraction of the subsequent computations are parallelized over all triangles in these chunks. In the second step, the bounding box of all triangles in each node is computed. This is done by first computing the bounding box of all triangles?s AABBs in each chunk using the reduction algorithm described in Algorithm 4 of [Popov et al. 2007], and then computing the bounding boxes of all nodes by performing segmented reduction [Gropp et al. 1994] on the sequence of all chunk reduction results. Segmented reduction performs reduction on arbitrary segments of an input sequence. The result is a sequence in which each element holds the reduction result of one segment. Our GPU algorithm for segmented reduction is described in Algorithm 3. In the input list data, all data elements belonging to the same segment are located contiguously. In another input list owner, owner[i] indicates the segment index of data[i]. The reduction operator op is associated with an identity value, as listed in Table 1 . The algorithm takes a multi-pass approach. Each thread takes two elements. If the two elements have the same owner, they are replaced by their operation result. Otherwise, one element is accumulated into result and the other is retained. Note that the chunk data structure is critical for optimal performance. Within each chunk, we only need to perform unsegmented reduction on all triangles? AABBs, greatly reducing the element number in the subsequent segmented reduction. Although it is possible to compute the node bounding boxes by performing segmented reduction on all input triangles? AABBs directly, this is inefficient because large segmented reductions are about three times slower than large unsegmented reductions [Sengupta et al. 2007]. In the third step, with computed node bounding boxes, large nodes are split in parallel using the splitting scheme described earlier. Note that we repeatedly split a node using empty space splitting until a spatial median split is reached. This allows us to reuse the bounding box and avoid unnecessary computations after empty space splitting. In the fourth step, triangles are sorted and clipped into child nodes. Triangle sorting is essentially list splitting. For each chunk, the triangles in the chunk are first checked to generate a vector of boolean values, which indicates whether each triangle is in a child node or not. Then the triangles are divided into two groups, with all the triangles marked true on the left side of the output vector and all the triangles marked false on the right side. This can be easily done using the split operation described in [Sengupta et al. 2007]. For those triangles contained in both child nodes, another pass is needed to clip them into the nodes. In the final step, we count the triangle numbers for all child nodes using segmented reduction in a way similar to bounding box computation. The reduction operator used here is +. If the triangle number of a node is less then the threshold T , it is added to smalllist and deleted from nextlist.\n      \n      \n        3.2 Small Node Stage\n        Compared to the large node stage, the small node stage is relatively simple. First, the computation is parallelized over nodes rather than triangles. The workload among small nodes is naturally balanced because the triangle numbers of small nodes do not vary significantly (from 0 to T ). Second, unlike in the large node stage, we choose not to clip triangles when splitting small nodes. Although clipping triangles to owner nodes reduces false positives of the triangle-in-node test and always reduces the SAH cost, clipping may also cause undesirable excessive splits because SAH does not take memory costs into account. While clipping is effective for large nodes by preventing false positives from accumulating over future splits, for small nodes our experiments indicate that clipping rarely improves ray tracing performance. Thus we do not clip triangles for small nodes, and the splitting plane candidates are restricted to those determined by the faces of the AABBs of triangles contained in the initial small nodes. As shown in Algorithm 4, the small node stage consists of two procedures, P REPROCESS S MALL N ODES and P ROCESS S MALL N ODES . The first procedure collects all split candidates. It also generates the triangle sets contained in both sides of each splitting plane candidate with a single pass over the triangles in a node. The second procedure P ROCESS S MALL N ODES splits small nodes. Processed in parallel for each node i, the procedure first gets its triangle set triangleSet and its uppermost ancestor smallRoot (also a small node) in the tree. Then the SAH costs for all splitting plane candidates located inside the node are computed. Finally the node is split using the optimal split plane with minimal cost, and triangles are sorted into child nodes. Instead of storing the triangle sets in the triangle-node association lists as is done in the large node stage, we now store triangle sets in small nodes as a bit mask of its smallRoot as shown in Fig. 3 . Note\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        Real-Time KD-Tree Construction on Graphics Hardware ? 126:5\n        Algorithm 4 Small Node Stage procedure P REPROCESS S MALL N ODES (smalllist:list;) begin for each node i in smalllist in parallel i.splitList ? list of all split candidates in i for each split candidate j in i in parallel /* ?left? represents smaller coordinate */ j.lef t ? triangle set on the left of j j.right ? triangle set on the right of j end procedure P ROCESS S MALL N ODES ( in activelist:list; out nextlist:list) begin for each node i in activelist in parallel // compute SAH and determine the split plane s ? i.triangleSet r ? i.smallRoot A 0 ? area of node i SAH 0 ? s for j where j ? r.splitList and j.triangle ? s C L ? s ? j.lef t C R ? s ? j.right A L ? area of left child after split j A R ? area of right child after split j SAH j ? (C L A L + C R A R )/A 0 + C ts p ? The split candidate that yields minimal SAH // split small nodes if SAH p ? SAH 0 then Mark i as leaf node else Split i using p, add new nodes to nextlist Sort triangles to new nodes end that the triangle sets of each split candidate j, j.lef t and j.right, are also stored as bit masks.\n        With this bit mask representation, triangle sorting and SAH evaluation for any split candidate can be efficiently done using bitwise operations. As shown in Algorithm 4, the bit mask of the left child is computed as the bitwise AND of the bit mask of the current node s and the bit mask of the left side of the split candidate j, which is precomputed in P REPROCESS S MALL N ODES . Then a parallel bit counting routine [Manku 2002] is performed on the resulting bit mask to get the number of triangles in the left child. The bit mask representation allows us to compute the optimal split plane in O(n) time and sort triangles in O(1) time. An alternative method for computing the optimal splitting plane in O(n) is to sort all split candidates in a preprocess. Then the cost functions of all split candidates and the optimal splitting plane can be computed by only a single pass over the sorted data, at the cost of O(n). However, since the sorted order cannot be represented as a bit mask, triangle sorting can only be done at the cost of O(n).\n      \n      \n        3.3 Kd-Tree Output Stage\n        As described in Section 4, our GPU ray tracer is stack-based and it requires the kd-tree?s final layout to be a preorder traversal of nodes for optimal cache performance. We compute the preorder traversal using two parallel BFS traversals (see Algorithm 5). The first pass traverses the tree bottom-up to compute required memory size for each subtree. The second pass\n        Algorithm 5 Preorder Traversal procedure P REORDER T RAVERSAL (nodelist:list) begin for each tree level l of nodelist from bottom-up U P P ASS (l) Allocate tree using root node?s size for each tree level l of nodelist from top-down D OWN P ASS (l) end procedure U P P ASS (activelist:list) begin for each node i in activelist in parallel if i is not a leaf then i.size ? i.lef t.size + i.right.size + 1 else i.size ? i.triangleCount + 1 end procedure D OWN P ASS (activelist:list) begin for each node i in activelist in parallel if i is not a leaf then i.lef t.address ? i.address + 1 i.right.address ? i.address + 1 + i.lef t.size Store node i in final format to i.address end (a) Node A (b) R R Large node A Small node A triangle set in node A B C B C Split Plane 1 0 0 1 0 1 1 1\n        \n          Figure 3: Storing triangle sets as bit masks of small root. Node A is split into node B and node C as shown in (a). Triangles B and C are subsets of their small root A?s triangles. They are stored as bit masks as shown in (b).\n        \n        traverses the tree top-down to compute the starting address in the traversal for each subtree, and distributes node information to the corresponding address to produce the final tree. This is analogous to the parallel scan in [Sengupta et al. 2007]. Note that, in procedure P REORDER T RAVERSAL , we need to collect nodes located at the same tree level. Fortunately this information is already available in each while-loop in Algorithm 1. After preorder traversal, each node in the resulting node list records the number and indices of the triangles it contains, its splitting plane, and the links to its children.\n      \n      \n        3.4 Implementation Details\n        We implemented the above kd-tree builder using NVIDIA?s CUDA framework [ NVIDIA 2007 ]. CUDA provides a general-purpose C language interface for GPU programming. It also exposes some important new hardware features which are useful for data-parallel computations. For example, it allows arbitrary gather and scatter memory access from GPU programs. Our GPU implementation heavily makes use of these new features. In all the algorithm listings above, the parallel primitives (e.g., segmented reduction) and the code fragments marked by in paral-\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        126:6 ? K. Zhou et al.\n        \n          \n        \n        (a) Toys (b) Museum (c) Robots\n        \n          \n        \n        (d) Kitchen (e) Fairy Forest (f) Dragon\n        \n          Figure 4: Test scenes for kd-tree construction and ray tracing. (a) 11K triangles, 1 light; (b) 27K triangles, 2 lights, 2 bounces; (c) 71K triangles, 3 lights, 1 bounce; (d) 111K triangles, 6 lights, 8 bounces; (e) 178K triangles, 2 lights; (f) 252K triangles, 1 light.\n        \n        Scene\n        \n          Fig. 4(a) Fig. 4(b) Fig. 4(c) Fig. 4(d) Fig. 4(e) Fig. 4(f)\n        \n        \n          \n            \n              \n              \n                \n                   Off-line CPU builder\n                   Our GPU builder\n                \n                \n                   T tree T trace SAH\n                   T tree T trace SAH\n                \n                \n                   0.085s 0.022s 79.0\n                   0.012s 0.018s 67.9\n                \n                \n                   0.108s 0.109s 76.6\n                   0.017s 0.108s 38.3\n                \n                \n                   0.487s 0.165s 68.6\n                   0.039s 0.157s 59.7\n                \n                \n                   0.559s 0.226s 49.6\n                   0.053s 0.207s 77.8\n                \n                \n                   1.226s 0.087s 74.4\n                   0.077s 0.078s 94.6\n                \n                \n                   1.354s 0.027s 124.2\n                   0.093s 0.025s 193.9\n                \n              \n            \n          \n          Off-line CPU builder Our GPU builder T tree T trace SAH T tree T trace SAH 0.085s 0.022s 79.0 0.012s 0.018s 67.9 0.108s 0.109s 76.6 0.017s 0.108s 38.3 0.487s 0.165s 68.6 0.039s 0.157s 59.7 0.559s 0.226s 49.6 0.053s 0.207s 77.8 1.226s 0.087s 74.4 0.077s 0.078s 94.6 1.354s 0.027s 124.2 0.093s 0.025s 193.9\n          Table 2:\n        \n        Comparing kd-tree construction time T tree , ray tracing time T trace and SAH costs between an offline CPU builder and our GPU builder. All rendering times are for 1024 ? 1024 images.\n        lel are GPU code; others are CPU code. We also need to specify the number of thread blocks and threads per block for the parallel primitives and the code fragments marked by in parallel. In our current implementation, we use 256 threads for each block. The block number is computed by dividing the total number of parallel threads by the number of threads per block. During kd-tree construction, we store all data as dynamic lists in linear device memory allocated via CUDA. List size is doubled whenever more memory is required. This allows us to avoid high overhead in CUDA memory management after an initial run, at the cost of more memory consumption. For structures with many fields such as nodes and triangles, we use structure of arrays (SoA) instead of array of structures (AoS) for optimal GPU cache performance. From its description, the reader may have noticed that our algorithm also frequently calls certain parallel primitives such as reduce and scan. Many of these primitives have been efficiently implemented and exposed in CUDPP [Harris et al. 2007]. Most conditional program flows in the pseudo code are handled using list splitting, which is also a standard GPU primitive with optimized implementation [Sengupta et al. 2007]. The conditional programs in Algorithm 3 (lines 12 ? 15) will be serialized and result in performance penalty, but the chunk structure used to perform most computations in the per-chunk standard reduction in Algorithm 2 avoid these conditional program flows. Compared to per-chunk standard reductions, the segmented reduction in Algorithm 3 does not consume any significant processing time, and its performance issues can thus be safely ignored.\n        \n          \n            \n              \n                \n                   #procs\n                   Fig.4(a)\n                   Fig.4(b)\n                   Fig.4(c)\n                   Fig.4(d)\n                   Fig.4(e)\n                   Fig.4(f)\n                \n              \n              \n                \n                   16\n                   0.037s\n                   0.057s\n                   0.197s\n                   0.260s\n                   0.463s\n                   0.564s\n                \n                \n                   32\n                   0.022s\n                   0.034s\n                   0.107s\n                   0.139s\n                   0.242s\n                   0.292s\n                \n                \n                   48\n                   0.018s\n                   0.026s\n                   0.077s\n                   0.098s\n                   0.169s\n                   0.202s\n                \n                \n                   64\n                   0.016s\n                   0.022s\n                   0.063s\n                   0.079s\n                   0.133s\n                   0.157s\n                \n                \n                   80\n                   0.015s\n                   0.020s\n                   0.055s\n                   0.068s\n                   0.113s\n                   0.132s\n                \n                \n                   96\n                   0.014s\n                   0.019s\n                   0.049s\n                   0.060s\n                   0.100s\n                   0.116s\n                \n                \n                   112\n                   0.013s\n                   0.018s\n                   0.046s\n                   0.056s\n                   0.091s\n                   0.105s\n                \n                \n                   128\n                   0.012s\n                   0.017s\n                   0.039s\n                   0.053s\n                   0.077s\n                   0.093s\n                \n                \n                   speedup\n                   3.08\n                   3.35\n                   5.05\n                   4.90\n                   6.01\n                   6.06\n                \n              \n            \n          \n          #procs Fig.4(a) Fig.4(b) Fig.4(c) Fig.4(d) Fig.4(e) Fig.4(f) 16 0.037s 0.057s 0.197s 0.260s 0.463s 0.564s 32 0.022s 0.034s 0.107s 0.139s 0.242s 0.292s 48 0.018s 0.026s 0.077s 0.098s 0.169s 0.202s 64 0.016s 0.022s 0.063s 0.079s 0.133s 0.157s 80 0.015s 0.020s 0.055s 0.068s 0.113s 0.132s 96 0.014s 0.019s 0.049s 0.060s 0.100s 0.116s 112 0.013s 0.018s 0.046s 0.056s 0.091s 0.105s 128 0.012s 0.017s 0.039s 0.053s 0.077s 0.093s speedup 3.08 3.35 5.05 4.90 6.01 6.06\n          Table 3:\n        \n        Scalability of our kd-tree construction algorithm on a GeForce 8800 ULTRA graphics card. The bottom row shows the speedup going from 16 to 128 processors. Note that our algorithm scales better with large scenes. However, the scalability is still sublinear mainly because the total running time contains a constant portion due to the overheard of CUDA API.\n        \n          \n          Figure 5: The tree construction time decreases quickly with the increase in the number of GPU processors before reaching a plateau.\n        \n      \n      \n        3.5 Results and Discussion\n        The described algorithm has been tested on an Intel Xeon 3.7GHz CPU with an NVIDIA GeForce 8800 ULTRA (768MB) graphics card. Parameters (e.g., T and N ) used during tree construction are intentionally kept the same for all scenes.  We compare our GPU algorithm with an off-line CPU algorithm which always uses the greedy SAH cost to calculate optimal split planes and clips triangles into child nodes [Wald and Havran 2006]. Table 2 summarizes the comparison results for several publicly available scenes as shown in Fig. 4 . As shown, our kd-tree construction algorithm is 6 ? 15 times faster for all scenes. The quality of the trees is assessed in two ways. First, we compute the SAH costs. Second, we evaluate the practical effect of tree quality on render time by using the constructed trees in a ray tracer as described in Section 4. As shown in the table, our algorithm generates lower SAH costs for Toys, Museum and Robots, but higher SAH costs for Kitchen, Fairy Forest and Dragon. In all cases, our trees always offer better rendering performance, which attests to the high quality of our trees in practical applications. Note that SAH cost is the expected cost for a ray to traverse the entire tree, whereas actual kdtree traversal terminates at the first node of intersection. Therefore there is no strict correlation between the SAH costs and the actual ray trace time. SAH cost is only one way to measure the quality of kd-trees. The most important metric is how well the resulting tree accelerates ray traversals, which is the ultimate goal of an SAH tree construction strategy. Our kd-tree construction algorithm also scales well with the number of GPU processors. The running time contains a scalable portion and a small non-scalable portion due to the overhead of CUDA API and driver. Theoretically, the running time is linear with respect to the reciprocal of the number of processors. As shown in Table 3 and Fig. 5 , we ran the algorithm on a GeForce 8800 ULTRA graphics card with 16, 32, 48, 64, 80, 96, 112, and 128 processors respectively. The NVStrap driver in RivaTuner [Nicolaychuk 2008] is used to disable processing units by adjusting hardware masks. Although our technique is capable of constructing high quality kdtrees in real-time, it has its limitations. For small scenes with less than 5K triangles, CUDA?s API overhead becomes a major bottleneck. In this case, it is more efficient to switch to a complete CPU method. Also, our method consumes much more memory than a CPU method. This is mainly due to the use of doubling lists and extra bookkeeping for BFS order construction. Our system supports scenes with up to 600K triangles on the GeForce 8800 Ultra (768MB) graphics card. For the six tested scenes, the peak memory in our build is around 8MB, 18MB, 50MB, 90MB, 123MB and 178MB respectively. This problem, however, can be reduced with a better memory management scheme. For example, currently we keep many temporary data structures in memory at all stages to avoid costly CUDA API calls to free these temporary data. If we implement a set of efficient CUDA memory allocation/free routines, we will be able to free temporary data and reduce memory consumption considerably. Other techniques for reducing memory are certainly possible and are to be investigated in future work. The memory consumption issue is also alleviated with the rapid advancements in graphics hardware. NVIDIA recently released Quadro FX 5600 which supports CUDA and has 1.5GB memory.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        Real-Time KD-Tree Construction on Graphics Hardware ? 126:7\n        Scene\n        \n          Fig. 4(a) Fig. 4(b) Fig. 4(c) Fig. 4(d) Fig. 4(e) Fig. 4(f)\n        \n        \n          \n             [Wald07] [Shevtsov07] Our method\n            \n              \n              \n                \n                   10.5fps\n                   23.5fps\n                   32.0fps\n                \n                \n                   n/a\n                   n/a\n                   8.00fps\n                \n                \n                   n/a\n                   n/a\n                   4.96fps\n                \n                \n                   n/a\n                   n/a\n                   4.84fps\n                \n                \n                   2.30fps\n                   5.84fps\n                   6.40fps\n                \n                \n                   n/a\n                   n/a\n                   8.85fps\n                \n              \n            \n          \n          [Wald07] [Shevtsov07] Our method 10.5fps 23.5fps 32.0fps n/a n/a 8.00fps n/a n/a 4.96fps n/a n/a 4.84fps 2.30fps 5.84fps 6.40fps n/a n/a 8.85fps\n          Table 4: Performance comparison results for four dynamic scenes. All images are rendered at resolution 1024 ? 1024. [Wald07] times are from [Wald et al. 2007] on an AMD Opteron 2.6GHz CPU. Multi-core times are from [Shevtsov et al. 2007] on a Dual Intel Core2 Duo 3.0GHz (4 cores).\n        \n      \n      \n        4 GPU Ray Tracing\n        We have incorporated our kd-tree builder into a GPU ray tracer for arbitrary dynamic scenes. For each frame, the ray tracer first builds a kd-tree from scratch. For each ray to be traced, the ray tracer walks through the kd-tree until it reaches leaf nodes and the associated triangles, in front to back order. While existing GPU ray tracers [Foley and Sugerman 2005; Horn et al. 2007; Popov et al. 2007] adopt a stackless scheme for kdtree traversal, they require additional information to be precomputed and stored during tree construction, and extra computation during tree traversal. To avoid such overhead we chose to implement a conventional stack-based scheme on the GPU. As pointed out in [Horn et al. 2007], when a ray passes through both sides of a splitting plane, the ?far? subtree is pushed into the stack and the ?near? subtree is traversed first. For this reason a stack-based scheme requires a local stack for each thread. Fortunately, this can be efficiently implemented in CUDA by allocating a fixed-sized array in thread-local memory. Although kd-tree depth is unbounded in theory, we found that a stack depth of 50 is enough for all test\n        \n          \n          Figure 6:\n        \n        GPU ray tracing of a dynamic subdivision surface. The scene consists of 47K triangles. The armadillo model is directly evaluated on the GPU through subdivision and displacement mapping from a coarse control mesh. We can achieve 22 fps for 800 ? 600 images.\n        scenes in this paper. In order to handle reflection/refraction, our ray tracer performs the following multiple passes after building a kd-tree for the scene: 1. Spawn and trace eye rays; 2. Generate a list of hits on specular and refractive surfaces by performing a list compaction [Harris et al. 2007] on eye ray hit points; 3. Spawn and trace reflective and refractive rays; 4. Repeat Step 2 and Step 3 if there are more bounces to handle; 5. Spawn and trace shadow rays; 6. Compute shading; After the shading is computed, each ray?s contribution to the final image is sent to an OpenGL pixel buffer object (PBO). The PBO is then accumulated to the final image using alpha blending.  Experimental Results We tested our GPU ray tracer using the dynamic scenes shown in Fig. 4 . Table 4 compares our frame rates with those reported in two recent works. One is an algorithm based on bounding volume hierarchies (BVHs) [Wald et al. 2007], and the other is the multi-core CPU algorithm using kd-trees [Shevtsov et al. 2007]. The performance takes into account both the tree (or BVH) construction and rendering time. It can be seen that our algorithm runs interactively with shadow and multi-bounce reflection/refraction, and outperforms the other two algorithms. These results suggest that for dynamic scenes GPU ray tracing accelerated by our kd-trees provides a competitive alternative to CPU ray tracing on multi-core CPUs. Note that here we do not claim that our GPU ray tracer is faster than all CPU ray tracers. Indeed, implementing the fastest CPU ray tracer is like chasing a moving target because various optimizations could be used for higher performance and some optimizations are hardware dependent, and better performance can be achieved by adding more CPU cores. For example, [Wald 2007] reported 13 ? 21 frames per second for the exploding dragon scene ( Fig. 4(f) ) on a 2.6GHz Clovertown system with 8 cores. Note that for the Toys and Fairy Forest scenes, our frame rates are higher than the 4-core CPU algorithm [Shevtsov et al. 2007]. Both scenes actually do not reveal our method?s advantage in tree quality, due to the lack of divergent secondary rays from reflection/refraction. However, this already demonstrates the potential of ray tracing dynamic scenes on GPUs. A unique feature of our ray tracer is that it can efficiently handle dynamic geometries that are directly evaluated on the GPU, such as skinned meshes [Wang et al. 2007] and subdivision surfaces [Shiue et al. 2005]. The armadillo in Fig. 6 is such an example. The input geometry is a sequence of coarse control meshes provided by the authors of [Zhou et al. 2007]. Two levels of Loop subdivision and displacement mapping are performed on the GPU to generate the detailed meshes. The output of GPU subdivision and displacement mapping is immediately sent to our GPU kd-tree builder and then ray traced directly without copying back to the CPU. Please see the accompanying video for live demos.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        126:8 ? K. Zhou et al.\n      \n      \n        5 GPU Photon Mapping\n        In this section we first show how to adapt our kd-tree builder for photon mapping. Then we describe how to perform k-nearestneighbor (KNN) search using kd-trees on the GPU. Finally we show how to use the kd-tree builder and KNN search to render caustics, and present some experimental results.\n      \n      \n        5.1 Kd-Tree for Photon Mapping\n        Algorithm 1 can be used to build photon kd-trees after several modifications. First, we use VVH [Wald et al. 2004] instead of SAH to evaluate the split cost function. Given a node d and a split position x, the VVH cost function is defined as:  where the definitions of C ts , C L (x) and C R (x) are similar to those in SAH. R is an estimated KNN query radius described in more details in Appendix A. V (d ? R) represents the volume of node d?s cell extended by radius R in the three axis directions. d L (x) and d R (x) are the left and right child nodes, respectively, for the given split position x. For large nodes, the hybrid scheme of spatial median splitting and empty space splitting is still employed. However, a different switch threshold C e = 10% is used. We also use a smaller threshold for large/small node classification, T = 32, since exact VVH cost evaluation is more expensive than SAH cost evaluation as we discovered through experiments. The second modification is that, unlike in ray tracing, photon kdtrees are built for points instead of triangles. Thus we do not need to compute AABBs in the initialization stage. Clipping to split planes is no longer required for large nodes. Splitting planes are restricted to initial point positions for small nodes. The third modification is that we can now simplify the large node stage greatly because clipping is not needed. Most computation can be directly parallelized over all points in large nodes, and the chunk data structure is no longer necessary. As in [Wald et al. 2004], in the initialization stage, for each of the three axis dimensions, we compute and maintain a sorted order for all points using a sort primitive cudppSort [Harris et al. 2007]. With the sorted order, tight bounding boxes of large nodes can be computed in O(1) time, avoiding the use of segmented reductions. This compensates for the overhead of computing and maintaining the sorted order. Also sorting points to child nodes and counting point numbers for child nodes can be done in O(n) time with a single pass over the sorted data. We store point-sorted order for all nodes in three concatenated point ID lists, one for each axis. To allow efficient per-node access of these lists, we enforce two properties: 1) points in the same node are contiguous in the lists; 2) points in the same node start at the same offset in three lists. Such properties allow an arbitrary sub-list for each individual node to be indexed using a head pointer and a tail pointer. After node splitting, we perform the split operation of [Sengupta et al. 2007] on the concatenated lists to separate points of left child nodes and points of right child nodes. It is easy to verify that the resulting new lists inherit the two aforementioned properties.\n        C L (x)V (d L (x) ? R) C R (x)V (d R (x) ? R) V V H(x) = C ts + + , V (d ? R) V (d ? R)\n        Algorithm 6 KNN Search function K NN S EARCH (in q:point) begin r min ? 0 r max ? r 0 hist ?new array[0..n hist ? 1] for i = 1 to n iter r ? r max ? r ? r max ? r min Set all elements in hist to zero for each photon p, p ? q < r, via range search Increment hist[? max{ p?q ? r ?r min ,0} n hist ?] Find j, such that hist[j] < k ? hist[j + 1] (r min , r max ) ? (r min + n hist j ? r , r min + n j+1 hist ? r ) r k ? r max return all photons p, p ? q < r k , via range search end\n        The sorted order is also used to accelerate the computation in P REPROCESS S MALL N ODES in the small node stage. However, the bit mask representation and bitwise operations for small nodes are still employed for both performance and storage efficiency. As in Section 3.3, we reorganize all nodes using a preorder traversal. Each node in the resulting node lists records the number and indices of the photons it contains, its splitting plane, the links to its children, and its bounding box.\n      \n      \n        5.2 KNN Search\n        As described in [Jensen 2001], to estimate the radiance at a surface point, the k-nearest photons need to be located and filtered. Efficiently locating the nearest photons is critical for good performance of photon mapping. The photon kd-tree built in the last subsection can be used to speed up nearest neighbor queries. A natural choice to locate the nearest neighbors in a kd-tree is the priority queue method described in [Jensen 2001]. Although it is possible to implement a priority queue using CUDA?s threadlocal memory, such an implementation would be inefficient because CUDA?s local memory requires both pipelining with sufficient amount of independent arithmetic for efficient latency hiding and a thread-wise coherent access pattern [ NVIDIA 2007 ]. In priority queue operations, almost all memory accesses and arithmetic are inter-dependent. It is difficult for the hardware to hide memory latency. Thread-wise coherence is also problematic since photon distribution is usually highly irregular. We instead propose an iterative KNN search algorithm based on range searching [Preparata and Shamos 1985]. As shown in Algorithm 6, the algorithm starts from an initial conservative search radius r 0 , and tries to find the KNN query radius r k through a few iterations. During each iteration, a fixed-radius range search is performed to construct hist, a histogram of photon numbers over radius ranges. The search radius is then reduced according to the histogram. Finally, all photons within radius r k are returned. There are three parameters in Algorithm 6: r 0 , n hist and n iter . r 0 is an initial search radius. On the one hand, it should be conservative such that there are at least k photons within this radius. On the other hand, it should be as tight as possible to limit the search range. A good estimation of r 0 is critical to the performance of KNN search. In Appendix A, we elaborate on the details of r 0 estimation. n hist is the size of the histogram array. It controls the precision gain in each iteration. As hist requires frequent random updates, we store it in CUDA?s shared memory. A larger n hist increases the precision of each iteration while decreasing GPU occupancy. We find n hist = 32 to be a reasonable balance point. n iter is the number of iterations. Currently, we take n iter = 2. The resulting error in the final KNN radius is less than 0.1%. Range searching is performed using the standard DFS kd-tree traversal algorithm [Preparata and Shamos 1985]. Like stack-based kd-tree traversal in GPU ray tracing, this algorithm can be efficiently implemented using CUDA?s local memory.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        Real-Time KD-Tree Construction on Graphics Hardware ? 126:9\n      \n      \n        5.3 Caustic Rendering of Dynamic Scenes\n        As a sample application of the photon kd-tree and KNN search, we develop a photon mapping system for rendering realistic caustics on the GPU. Before building the tree, photons must be emitted into the scene. The process of tracing eye rays and tracing photons from a light source is very similar. The GPU ray tracer described in Section 4 can be easily adapted for photon tracing. The main difference is that the interaction of a photon with a surface material is different from that of a ray. When a photon hits a surface, it can either be reflected, transmitted, or absorbed based on the surface material. Since we only trace caustic photons, a photon will be terminated and stored once it hits a diffuse surface. Our current system supports only point light sources. Photons are emitted randomly using a projection map [Jensen 2001]. For caustic rendering, only specular and refractive objects are identified in the projection map. Once photon tracing is done, a kd-tree is built for all stored photons. Caustics are then rendered by tracing eye rays. For each ray, at its first intersection with a diffuse surface, KNN search is performed to locate the nearest photons, which are then filtered to get the radiance value. Experimental Results Fig. 7(a) shows a cardioid-shaped caustic formed on the table due to light reflected inside a metal ring. We traced 200K photons in total and the 50 nearest photons were queried in the radiance estimate. Both the lighting and the surface material can be changed on the fly. Please see the accompanying video for live demos. Combined with our GPU ray tracer in Section 4, we even allow the user to change the scene geometry. In this case, two kd-trees need to be built on the fly: one for the scene geometry and the other for the photons. Fig. 7(b) demonstrates the caustic from a glass of champagne. The caustic is formed as light is refracted through several layers of glass and champagne. We use six bounces of refraction in photon tracing. In total 400K photons were traced and k is set to 40 in KNN search. Again, both the lighting and scene geometry can be changed. Table 5 summarizes the times for photon kd-tree construction and KNN search, using both CPU and GPU algorithms. The CPU KNN search is based on the priority queue method described in [Jensen 2001]. Overall, both our GPU kd-tree builder and KNN search are around 10 times faster than the CPU algorithms.\n      \n      \n        6 Conclusion\n        We have presented a kd-tree algorithm capable of achieving realtime performance on the GPU. The algorithm builds kd-trees in BFS order to exploit the large scale parallelism of modern GPUs. The constructed kd-trees are of comparable quality as those built by off-line CPU algorithms. We also demonstrated the potential of our kd-tree algorithm in three applications involving dynamic scenes: GPU ray tracing, GPU photon mapping, and point cloud modeling. There are several directions for future investigation. We plan to incorporate packets [Wald et al. 2001] into the GPU ray tracer for further performance enhancements. We also intend to implement\n        \n          \n          Figure 7:\n        \n        (a) A metal ring (b) A glass of champagne Caustic rendering using photon mapping. Both scenes are lit by a point light source and rendered at image resolution 800 ? 600. (a) Cardioid-shaped caustic caused by light reflection inside a metal ring. The scene consists of 3K triangles and the rendering performance is 12.2 fps. (b) Caustics due to light refraction through several layers of glass and champagne. The scene has 19K triangles and the performance is about 7.5 fps.\n        Scene\n        \n          Fig. 7(a) Fig. 7(b)\n        \n        \n          Table 5:\n        \n        CPU algorithm GPU algorithm kd-tree KNN kd-tree KNN 0.081s 0.508s 0.009s 0.044s 0.237s 0.371s 0.017s 0.050s Comparing photon kd-tree construction time and KNN time between a CPU algorithm and our GPU algorithm.\n        global photon maps on the GPU using a general photon scattering scheme based on Russian roulette. Such photon maps would allow us to render indirect illumination. Finally, we are interested in extending our kd-tree algorithm to higher dimensions for applications such as texture synthesis.\n      \n      \n        Acknowledgements\n        The authors would like to thank Eric Stollnitz for his help with video production. We are also grateful to the reviewers for their helpful comments.\n      \n      \n        References\n        \n          C ARR , N. A., H ALL , J. D., AND H ART , J. C. 2002. The ray engine. In Proceedings of Graphics Hardware, 37?46.\n          C ARR , N. A., H OBEROCK , J., C RANE , K., AND H ART , J. C. 2006. Fast GPU ray tracing of dynamic meshes using geometry images. In Proceedings of Graphics Interface, 203?209.\n          F OLEY , T., AND S UGERMAN , J. 2005. Kd-tree acceleration structures for a GPU raytracer. In Graphics Hardware?05.\n          G OLDSMITH , J., AND S ALMON , J. 1987. Automatic creation of object hierarchies for ray tracing. IEEE CG&A 7, 5, 14?20.\n          G ROPP , W., L USK , E., AND S KJELLUM , A. 1994. Using MPI: Portable Parallel Programming with the Message Passing Interface. MIT Press.\n          G UNTHER  ? , J., W ALD , I., AND S LUSALLEK , P. 2004. Realtime caustics using distributed photon mapping. In Eurographics Symposium on Rendering, 111?121.\n          H ARRIS , M., O WENS , J., S ENGUPTA , S., Z HANG , Y., AND D AVIDSON , A., 2007. CUDPP homepage. http://www.gpgpu.org/developer/cudpp/.\n          H AVRAN , V. 2001. Heuristic Ray Shooting Algorithms. PhD thesis, Czech Technical University in Prague.\n          H OPPE , H., D E R OSE , T., D UCHAMP , T., M C D ONALD , J., AND S TUETZLE , W. 1992. Surface reconstruction from unorganized points. In Proceedings of SIGGRAPH?92, 71?78.\n          H ORN , D. R., S UGERMAN , J., H OUSTON , M., AND H ANRAHAN , P. 2007. Interactive k-d tree GPU raytracing. In Proceedings of Symposium on Interactive 3D graphics and Games, 167?174.\n          H UNT , W., M ARK , W. R., AND S TOLL , G. 2006. Fast kd-tree construction with an adaptive error-bounded heuristic. In IEEE Symposium on Interactive Ray Tracing, 81?88.\n          J ENSEN , H. W. 2001. Realistic Image Synthesis Using Photon Mapping. AK Peters.\n          M AC D ONALD , J. D., AND B OOTH , K. S. 1990. Heuristics for ray tracing using space subdivision. Vis. Comput. 6, 3, 153?166.\n          M ANKU , G. S., 2002. Fast bit counting routines. http://infolab.stanford.edu/ manku/bitcount/bitcount.html.\n          M OUNT , D. M., AND A RYA , S., 2006. ANN: A library for approximate nearest neighbor searching. http://www.cs.umd.edu/ ?mount/ANN/.\n          N ICOLAYCHUK , A., 2008. RivaTuner. http://www.guru3d.com/index.php?page=rivatuner.\n          NVIDIA, 2007. CUDA programming guide 1.0. http://developer.nvidia.com/object/cuda.html.\n          P AULY , M., K EISER , R., K OBBELT , L. P., AND G ROSS , M. 2003. Shape modeling with point-sampled geometry. In Proceedings of SIGGRAPH?03, 641?650.\n          P HARR , M., AND H UMPREYS , G. 2004. Physically Based Rendering: From Theory to Implementation. Morgan Kaufmann.\n          P OPOV , S., G UNTHER  ? , J., S EIDEL , H.-P., AND S LUSALLEK , P. 2006. Experiences with streaming construction of SAH KDtrees. In IEEE Symposium on Interactive Ray Tracing, 89?94.\n          P OPOV , S., G UNTHER  ? , J., S EIDEL , H.-P., AND S LUSALLEK , P. 2007. Stackless kd-tree traversal for high performance GPU ray tracing. In Eurographics?07, 415?424.\n          P REPARATA , F. P., AND S HAMOS , M. I. 1985. Computational Geometry: An Introduction. Springer-Verlag New York, Inc.\n          P URCELL , T. J., B UCK , I., M ARK , W. R., AND H ANRAHAN , P. 2002. Ray tracing on programmable graphics hardware. ACM Trans. Gr. 21, 3, 703?712.\n          P URCELL , T. J., D ONNER , C., C AMMARANO , M., J ENSEN , H. W., AND H ANRAHAN , P. 2003. Photon mapping on programmable graphics hardware. In Graphics Hardware?03, 41? 50.\n          R ESHETOV , A., S OUPIKOV , A., AND H URLEY , J. 2005. Multilevel ray tracing algorithm. In SIGGRAPH ?05, 1176?1185.\n          S ENGUPTA , S., H ARRIS , M., Z HANG , Y., AND O WENS , J. D. 2007. Scan primitives for GPU computing. In Graphics Hardware?07, 97?106.\n          S HEVTSOV , M., S OUPIKOV , A., AND K APUSTIN , A. 2007. Highly parallel fast kd-tree construction for interactive ray tracing of dynamic scenes. In Eurographics?07, 395?404.\n          S HIUE , L.-J., J ONES , I., AND P ETERS , J. 2005. A realtime GPU subdivision kernel. ACM Trans. Gr. 24, 3, 1010?1015.\n          S TOLL , G. 2005. Part II: Achieving real time optimization techniques. In SIGGRAPH 2005 Course on Interactive Ray Tracing.\n          W ALD , I., AND H AVRAN , V. 2006. On building fast kd-trees for ray tracing, and on doing that in O(Nlog N). In Proceedings of IEEE Symposium on Interactive Ray Tracing, 61?69.\n          W ALD , I., S LUSALLEK , P., B ENTHIN , C., AND W AGNER , M. 2001. Interactive rendering with coherent ray tracing. Computer Graphics Forum 20, 3, 153?164.\n          W ALD , I., G UNTHER  ? , J., AND S LUSALLEK , P. 2004. Balancing considered harmful ? faster photon mapping using the voxel volume heuristic. In Proceedings of Eurographics?04, 595?603.\n          W ALD , I., I ZE , T., K ENSLER , A., K NOLL , A., AND P ARKER , S. G. 2006. Ray tracing animated scenes using coherent grid traversal. ACM Trans. Gr. 25, 3, 485?493.\n          W ALD , I., B OULOS , S., AND S HIRLEY , P. 2007. Ray tracing deformable scenes using dynamic bounding volume hierarchies. ACM Trans. Gr. 26, 1, 6.\n          W ALD , I. 2007. On fast construction of SAH based bounding volume hierarchies. In IEEE Symposium on Interactive Ray Tracing, 33?40.\n          W ANG , R. Y., P ULLI , K., AND P OPOVI C  ? , J. 2007. Real-time enveloping with rotational regression. ACM Trans. Gr. 26, 3, 73.\n          Y OON , S.-E., C URTIS , S., AND M ANOCHA , D. 2007. Ray tracing dynamic scenes using selective restructuring. In Eurographics Symposium on Rendering.\n          Z HOU , K., H UANG , X., X U , W., G UO , B., AND S HUM , H.-Y. 2007. Direct manipulation of subdivision surfaces on GPUs. ACM Trans. Gr. 26, 3, 91, 9.\n          Z WICKER , M., P FISTER , H., VAN B AAR , J., AND G ROSS , M. 2001. Surface splatting. In SIGGRAPH?01, 371?378.\n          Z WICKER , M., P AULY , M., K NOLL , O., AND G ROSS , M. 2002. Pointshop 3d: an interactive system for point-based surface editing. In SIGGRAPH?02, 322?329.\n        \n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        126:10 ? K. Zhou et al.\n      \n      \n        A Initial KNN Radius Estimate\n        As mentioned in Section 5.2, a good estimation of r 0 is critical to the performance of KNN search. Due to the irregularity of photon distributions, r 0 needs to be estimated for each KNN query point. As shown in Algorithm 7, we take a two-stage approach. First, for each rendering frame, P RECOMPUTE R ADIUS is carried out to compute KNN query radiuses for a set of node centers. This is done by running the KNN search algorithm in Algorithm 6 with parameter r 0 = R. Then, for each KNN query point p, E STIMATE R ADIUS is performed to compute p?s initial query radius from the KNN query radiuses of the nodes containing p. It can be easily proven that the resulting query radius is guaranteed to be conservative. R is a conservative estimation for r 0 . Note that photon density ? is inversely proportional to the square of KNN query radius r k . By defining a minimal physically meaningful density ? ? , a reasonably tight estimation can be be computed from R ? 1 . R is also ? ? used as the estimated query radius in VVH. C i is the center of node i?s bounding box. The node radius is computed as half of the length of the bounding box diagonal. ? and n level are two user-specified constants which determine the nodes used for radius estimation. We find that ? = 0.5 and n level = 3 work well for all examples shown in the paper.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n        Real-Time KD-Tree Construction on Graphics Hardware ? 126:11\n        Algorithm 7 Estimate r 0 procedure P RECOMPUTE R ADIUS () begin Compute R Initialize R i to +?, for all nodes i work ?new list for each kd-tree node i with radius less than ? ? R work.add(i) for each node i in work if i.parent is in work then work.remove(i) for i=1 to n level for each node i in work Compute KNN query radius R i for node i?s center C i work ? ?new list for each node i in work Add i?s children to work ? work ? work ? end function E STIMATE R ADIUS (in p:point) begin r ? R for each node i containing p r ? min{r, p ? C i +R i } return r end\n      \n      \n        B Point Cloud Modeling\n        The kd-tree builder and KNN search algorithm described in Section 5 can be directly used to estimate local sampling density and normals for dynamic point clouds, as well as to update the deformation strength field in free-form deformation. Given a set of points as input, we first build a kd-tree. Unlike in photon mapping, we do not have a good estimate for the initial KNN query radiuses, R and r 0 . We thus let the user specify these parameters. Then in parallel, for each point x i , we find the k-nearest neighbors for x i using KNN search. The final query radius r i can be used to determine the local kernel size in surface splatting [Zwicker et al. 2001]. The local sampling density can be computed as ? i = k/r i 2 . To compute the normal at x i , as in [Hoppe et al. 1992], we first perform principal component analysis (PCA) on the covariance matrix of its k-nearest neighbors. The unit eigenvector n i with minimal eigenvalue is regarded as x i ?s normal. A minimum spanning tree (MST) based approach [Hoppe et al. 1992] is then used to make all point normals consistently oriented. Both the KNN search and PCA are performed on the GPU. The minimum spanning tree, however, is currently built on the CPU. In point cloud deformation tools [Pauly et al. 2003], a scalar value ranging from 0 to 1 is computed for each point to indicate the deformation strength at that point. Each point?s scalar value is decided by its distances to the current ?active? handle and other static handles. The closer a point is to the active handle, the stronger will the deformation be for that point. Each handle consists of a set of points. A point?s distance to a handle is defined as the minimal distance between the point and all points of that handle. To efficiently calculate these distances, two kd-trees are built, one for the active handle and one for all static handles. Then, for each point, its nearest neighbor in each tree is searched and the distance is computed. Therefore, when the user defines new handles or removes old handles, we need to rebuild the kd-trees and recompute the distances, which can be done efficiently using our GPU kd-tree builder and KNN search.\n        \n          \n          Figure 8:\n        \n        Sampling density and normal estimation of a point cloud. From left to right: the input point cloud (127K points) rendered using surface splatting, sampling density map for the rest pose and sampling density map for a deformed pose (blue: small; red: large).\n        \n          \n          Figure 9: Deforming a point cloud (170K points). The active handle is marked in blue. Our algorithm allows the user to define and switch to new handles quickly.\n        \n        Experimental Results We have implemented the described algorithm and developed a point cloud deformation tool as in [Pauly et al. 2003]. Point clouds are rendered using a GPU implementation of the surface splatting algorithm [Zwicker et al. 2001]. Please see the accompanying video for live demos. In Fig. 8 , the sampling density and normals are computed for a dynamic point cloud on the fly. With our GPU algorithm, the kdtree is built in about 21 milliseconds and KNN search (k = 10) takes about 14 milliseconds. The CPU algorithm in Pointshop3D [Zwicker et al. 2002] uses simple midpoint splitting to build kdtrees quickly. However, the tree quality is poor, resulting in very slow KNN search. For the same data, it takes about 32 milliseconds and 6.5 seconds for tree construction and KNN search respectively. We also compare our algorithm with the kd-tree algorithm in the ANN library [Mount and Arya 2006]. For the same data, it takes 98 milliseconds and 828 milliseconds for tree construction and KNN search respectively. Overall, our approach is over 20 times faster than the ANN algorithm. Note that to achieve a consistent normal orientation, a minimum spanning tree is built for the initial pose of the point cloud, on the CPU in less than 30 milliseconds. Minimum spanning trees need not be built again during deformation since we make use of temporal coherence to force the point normals of the current pose to be consistently oriented to those of the preceding pose. In the deformation example shown in Fig. 9 , we allow the user to manipulate the point cloud by defining new handles and dragging them. Our algorithm can provide immediate response to the user since the deformation strength field is computed in about 310 milliseconds, while the CPU algorithm based on ANN takes about 3 seconds, and thus provides better user experience.\n        ACM Transactions on Graphics, Vol. 27, No. 5, Article 126, Publication date: December 2008.\n      \n    \n  ",
  "resources" : [ ]
}