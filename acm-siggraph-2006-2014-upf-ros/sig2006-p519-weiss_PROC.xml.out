{
  "uri" : "sig2006-p519-weiss_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2006/p519-weiss_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Fast Median and Bilateral Filtering",
    "published" : "2006",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ben-Weiss",
      "name" : "Ben",
      "surname" : "Weiss"
    } ]
  },
  "bagOfWords" : [ "provide", "mechanism", "reduce", "image", "noise", "while", "preserve", "edge", "more", "effectively", "than", "linear", "smoothing", "filter", "filter", "exhibit", "roughly", "-lrb-", "-rrb-", "runtime", "per", "pixel", "constraint", "which", "significantly", "reduce", "its", "performance", "large", "filter", "kernel", "we", "algorithm", "overcome", "all", "limitation", "achieve", "-lrb-", "log", "-rrb-", "runtime", "per", "pixel", "8-bit", "datum", "both", "median", "bilateral", "filter", "fully", "vectorizable", "use", "just", "-lrb-", "-rrb-", "storage", "also", "adapt", "-lrb-", "log", "-rrb-", "algorithm", "arbitrary-depth", "image", "which", "run", "up", "twenty", "time", "fast", "photoshop?s", "16-bit", "median", "filter", "Photoshop", "cs2?s", "16-bit", "surface", "blur", "filter", "reflect", "-lrb-", "-rrb-", "complexity", "become", "unusably", "slow", "even", "moderate", "radius", "durand?s", "method", "approximate", "bilateral", "filter", "subsampled", "copy", "image", "discrete", "intensity", "kernel", "recombine", "result", "use", "linear", "interpolation", "we", "bilateral", "filter", "algorithm", "maintain", "high", "resolution", "both", "space", "intensity", "translation-invariant", "derive", "from", "same", "core", "algorithm", "we", "fast", "-lrb-", "log", "-rrb-", "median", "filter", "adapt", "16-bit", "HDR", "datum", "minimal", "loss", "precision", "we", "show", "step", "how", "improve", "first", "constant", "factor", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "algorithm", "from", "-lrb-", "log", "-rrb-", "algorithm", "finally", "we", "show", "how", "algorithm", "can", "adapt", "perform", "bilateral", "filter", "compare", "previous", "method", "consider", "case", "apply", "radius-r", "median", "filter", "8-bit", "image", "assume", "source", "image", "larger", "than", "destination", "pixel", "all", "side", "sidestep", "edge-related", "concern", "-lrb-", "practice", "we", "repeat", "edge", "pixel", "fill", "undefined", "area", "process", "color", "image", "per-channel", "basis", "-rrb-", "because", "median", "filter", "local", "can", "apply", "arbitrary-size", "image", "tile", "fundamental", "property", "concern", "we", "here", "runtime", "per", "pixel", "function", "filter", "radius", "correspond", "performance", "user", "experience", "while", "adjust", "filter", "radius", "primary", "differentiate", "characteristic", "between", "medianfilter", "algorithm", "reference", "brute-force", "implementation", "can", "calculate", "each", "output", "pixel", "-lrb-", "log", "-rrb-", "time", "sort", "corresponding", "-lrb-", "2r", "-rrb-", "pixel", "input", "window", "select", "median", "value", "output", "case", "8-bit", "datum", "we", "use", "256-element", "histogram", "once", "input", "value", "add", "median", "value", "lie", "first", "index", "which", "sum", "value", "index", "reach", "2r", "2r", "median", "index", "can", "find", "integrate", "histogram", "from", "one", "end", "until", "appropriate", "sum", "reach", "however", "window-sliding", "step", "dominate", "calculation", "-lrb-", "-rrb-", "runtime", "per", "pixel", "while", "histogramscanning", "take", "constant", "time", "per", "pixel", "suggest", "we", "should", "look", "way", "make", "window-sliding", "faster", "even", "expense", "make", "histogram-scanning", "slower", "observe", "window", "zigzag", "through", "image", "pass", "through", "each", "region", "several", "time", "perform", "nearly", "same", "operation", "each", "pass", "-lrb-", "Picture", "mow", "you", "lawn", "back", "forth", "shift", "sideways", "one", "centimeter", "each", "time", "-rrb-", "redundancy", "considerable", "mirror", "adjacent-window", "overlap", "lead", "huang?s", "algorithm", "fundamental", "idea", "behind", "paper", "mechanism", "enable", "we", "fast", "algorithm", "observation", "multiple", "column", "process", "once", "aforementioned", "redundant", "calculation", "become", "sequential", "give", "we", "opportunity", "consolidate", "they", "result", "huge", "increase", "performance", "straightforward", "adaptation", "huang?s", "algorithm", "process", "column", "once", "involve", "maintenance", "histogram", "one", "per", "output", "column", "essentially", "just", "rearrangement", "operation", "runtime", "complexity", "unchanged", "each", "input", "pixel", "get", "add", "2r", "histogram", "over", "course", "filter", "image", "lead", "-lrb-", "-rrb-", "runtime", "complexity", "fortunately", "explicit", "maintenance", "each", "histogram", "unnecessary", "due", "distributive", "property", "histogram", "where", "we", "approach", "diverge", "from", "huang?s", "algorithm", "histogram", "distributivity", "mean", "disjoint", "image", "region", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "other", "word", "image", "window", "union", "two", "disjoint", "region", "its", "histogram", "equal", "median", "element", "can", "find", "scan", "implicit", "histogram", "splicing", "together", "from", "fly", "-lrb-", "extend", "sign", "linear", "combination", "etc.", "-rrb-", "case", "median-filtering", "column", "we", "approach", "form", "set", "partial", "histogram", "n-1", "-lrb-", "whose", "element", "may", "sign", "-rrb-", "each", "histogram", "n-1", "representable", "sum", "partial", "histogram", "from", "Figure", "show", "how", "row", "pixel", "2r", "+8", "add", "case", "histogram", "set", "arrange", "like", "tree", "central", "histogram", "-lrb-", "-rrb-", "represent", "input", "window", "central", "column", "other", "partial", "histogram", "represent", "difference", "between", "central", "adjacent", "window", "sum", "each", "partial", "plus", "central", "histogram", "yield", "full", "histogram", "corresponding", "square", "input", "window", "widen", "yellow", "central", "region", "fitting", "partial", "histogram", "its", "edge", "9-column", "technique", "can", "adapt", "perform", "median", "filter", "arbitrary", "radius", "time", "spend", "modify", "still", "-lrb-", "-rrb-", "much", "lower", "constant", "than", "huang?s", "algorithm", "median", "extraction", "time", "from", "remain", "constant", "regardless", "more", "fundamental", "improvement", "efficiency", "come", "when", "we", "allow", "number", "column", "vary", "conceptually", "add", "more", "plane", "Figure", "output", "column", "number", "modification", "per", "output", "pixel", "-lrb-", "4r", "-rrb-", "N.", "-lrb-", "graphic", "Figure", "show", "case", "require", "98", "adjustment", "per", "row", "about", "11", "per", "output", "pixel", "-rrb-", "solve", "minimize", "number", "adjustment", "give", "which", "yield", "-lrb-", "-rrb-", "histogram", "modification", "per", "pixel", "thus", "complexity", "variable-n", "adaptive", "algorithm", "-lrb-", "-rrb-", "Figure", "show", "layout", "processing", "sixty-three", "column", "once", "three-tiered", "analogue", "Figure", "time", "view", "from", "side", "single", "shared", "histogram", "31", "-lsb-", "yellow", "-rsb-", "correspond", "central", "window", "eight", "partial", "histogram", "-lsb-", "orange", "-rsb-", "seven-pixel", "interval", "each", "six", "small", "partial", "histogram", "-lsb-", "red", "-rsb-", "unit", "interval", "sixty-three", "histogram", "altogether", "each", "input", "pixel", "added/subtracted", "each", "histogram", "intersect", "its", "column", "example", "63-by-1", "block", "output", "produce", "each", "iteration", "-lrb-", "-rrb-", "where", "second", "third", "term", "ignore", "match", "earlier", "term", "-lrb-", "e.g.", "24", "31", "24", "-rrb-", "structure", "recursive", "central", "yellow", "histogram", "form", "rough", "approximation", "any", "particular", "orange", "partial", "histogram", "refine", "approximation", "red", "histogram", "provide", "final", "correction", "make", "sum", "exact", "once", "initialize", "full", "histogram", "each", "63", "square", "input", "window", "expressible", "per", "eq", "sum", "one", "red", "histogram", "-lrb-", "none", "-rrb-", "one", "orange", "histogram", "-lrb-", "none", "-rrb-", "yellow", "central", "histogram", "illustrated", "case", "63", "31", "require", "18", "histogram", "modification", "per", "output", "pixel", "median-extraction", "from", "take", "constant", "time", "three", "partial", "histogram", "splice", "together", "fly", "general", "case", "3-tiered", "structure", "process", "column", "once", "tier", "radix", "number", "histogram", "adjustment", "per", "output", "pixel", "become", "-lrb-", "-lrb-", "4r", "-rrb-", "-rrb-", "radius", "solve", "optimal", "yield", "4r", "runtime", "threetiered", "adaptive", "algorithm", "therefore", "-lrb-", "-rrb-", "practice", "three", "tier", "cover", "realistic", "range", "implementation", "-lrb-", "hundred", "-rrb-", "we", "technique", "can", "extend", "arbitrary", "limit", "radius-r", "median", "filter", "can", "compute", "across", "-lrb-", "-rrb-", "column", "once", "use", "histogram", "arrange", "-lrb-", "log", "-rrb-", "tier", "constant", "radix", "example", "radius", "one-million", "median", "filter", "can", "compute", "across", "531,441", "column", "once", "use", "partial", "histogram", "arrange", "seven", "tier", "radix", "occupy", "roughly", "500", "megabyte", "storage", "slide", "window", "from", "one", "row", "next", "require", "-lrb-", "log", "-rrb-", "114", "histogram", "modification", "per", "output", "pixel", "extract", "each", "median", "take", "-lrb-", "log", "-rrb-", "step", "case", "splicing", "up", "seven", "partial", "histogram", "together", "construct", "each", "counterbalance", "-lrb-", "log", "-rrb-", "complexity", "write", "therefore", "overall", "computational", "cost", "per", "pixel", "-lrb-", "log", "-rrb-", "scan", "histogram", "from", "index", "zero", "find", "median", "take", "about", "128", "step", "average", "Huang", "-lsb-", "1981", "-rsb-", "suggest", "use", "each", "output", "value", "pivot", "find", "next", "median", "value", "scan", "find", "we", "keep", "track", "number", "value", "we", "add", "remove", "pixel", "from", "we", "keep", "run", "count", "how", "many", "value", "satisfy", "allow", "we", "scan", "update", "histogram", "start", "from", "which", "typically", "much", "faster", "than", "start", "from", "index", "zero", "heuristic", "adapt", "-lrb-", "log", "-rrb-", "algorithm", "use", "-lrb-", "log", "-rrb-", "pivot", "across", "column", "each", "pivot", "track", "smallest", "median", "value", "its", "respective", "column", "approach", "obtain", "much", "benefit", "heuristic", "while", "preserve", "-lrb-", "log", "-rrb-", "complexity", "since", "pivot", "tracking", "involve", "many", "consecutive", "bytewise", "compare", "ideally", "suit", "vector", "optimization", "finally", "useful", "interleave", "partial", "histogram", "memory", "so", "multiple", "adjacent", "histogram", "can", "modify", "simultaneously", "use", "vector", "load", "store", "greatly", "accelerate", "reading", "writing", "16-bit", "hdr", "image", "have", "already", "become", "mainstream", "so", "important", "we", "median", "filter", "work", "image", "arbitrary", "bitdepth", "direct", "extension", "8-bit", "algorithm", "problematic", "because", "histogram", "must", "stretch", "accommodate", "every", "possible", "value", "grow", "exponentially", "bit-depth", "algorithm", "still", "remain", "-lrb-", "log", "-rrb-", "storage", "consideration", "render", "impractical", "16-bit", "image", "impossible", "floating-point", "image", "reduce", "manageable", "size", "through", "technique", "we", "call", "ordinal", "transform", "involve", "sort", "input", "image", "value", "store", "sort", "list", "replace", "each", "cardinal", "value", "its", "ordinal", "equivalent", "-lrb-", "duplicate", "cardinal", "value", "map", "consecutive", "ordinal", "value", "-rrb-", "median", "filter", "apply", "ordinal", "image", "transform", "invert", "restore", "cardinalvalued", "result", "ordinal", "transform", "operate", "image", "any", "depth", "logarithmic", "constant", "time", "per", "pixel", "operation", "nonlinearity", "median", "filter", "crucial", "any", "linear", "filter", "-lrb-", "e.g.", "gaussian", "blur", "-rrb-", "would", "invariant", "under", "ordinal", "transform", "median", "filter", "because", "rank-order", "preserve", "th", "smallest", "cardinal", "value", "map", "th", "smallest", "ordinal", "value", "after", "ordinal", "transform", "apply", "median", "filter", "proceeds", "section", "time", "use", "single-bit", "histogram", "-lrb-", "sufficient", "here", "because", "each", "ordinal", "value", "unique", "image", "-rrb-", "result", "inversetransform", "yield", "final", "filtered", "image", "recall", "histogram", "element", "can", "go", "negative", "first", "appear", "problematic", "because", "require", "range", "-lsb-", "-1", "-rsb-", "doesn?t", "fit", "single", "bit", "however", "since", "each", "sum", "implicit", "histogram", "value", "-lsb-", "-rsb-", "can", "only", "either", "zero", "one", "only", "lowest", "bit", "from", "each", "partial", "histogram", "must", "participate", "summation", "hence", "single", "bit", "sufficient", "each", "element", "splicing", "accomplish", "through", "bitwise", "xor", "process", "column", "parallel", "approach", "still", "require", "allocation", "maintenance", "single-bit", "histogram", "however", "due", "uniqueness", "value", "ordinal", "image", "we", "can", "take", "advantage", "much", "more", "efficient", "encoding", "consider", "full", "histogram", "obtain", "splicing", "th", "set", "partial", "histogram", "-lrb-", "consist", "central", "histogram", "plus", "one", "partial", "histogram", "from", "each", "tier", "-rrb-", "yield", "single-bit", "histogram", "th", "input", "window", "label", "binary", "histogram", "definition", "single", "bit", "-lsb-", "-rsb-", "indicate", "whether", "ordinal", "value", "lie", "input", "window", "row", "pixel", "-lsb-", "row", "-rsb-", "-lsb-", "col", "-rsb-", "add", "we", "adjust", "follow", "since", "ordinal", "value", "can", "have", "any", "arrangement", "compound", "histogram", "fill", "arbitrary", "order", "row", "pixel", "remove", "corresponding", "element", "zero", "power", "technique", "become", "clear", "when", "come", "time", "scan", "implicit", "histogram", "find", "th", "median", "output", "value", "we", "initial", "approach", "each", "implicit", "histogram", "splice", "together", "from", "-lrb-", "log", "-rrb-", "partial", "histogram", "take", "-lrb-", "log", "-rrb-", "time", "per", "element", "compound", "histogram", "use", "8-bit", "modular", "arithmetic", "element", "can", "now", "compute", "constant", "time", "128", "technique", "extend", "straightforward", "manner", "16-bit", "compound", "histogram", "sufficient", "32768", "so", "computational", "complexity", "independent", "element", "size", "one", "final", "detail", "radius", "increase", "histogram", "size", "scale", "-lrb-", "-rrb-", "which", "directly", "affect", "histogram", "scanning", "distance", "thus", "algorithm?s", "time-complexity", "complication", "address", "compute", "median", "stage", "from", "coarse", "fine", "precision", "Alparone", "et", "al.", "-lsb-", "1994", "-rsb-", "apply", "similar", "technique", "-lrb-", "-rrb-", "algorithm", "employ", "two", "level", "resolution", "process", "10", "12", "14-bit", "image", "faster", "-lrb-", "still", "-lrb-", "-rrb-", "-rrb-", "time", "here", "we", "apply", "analogous", "technique", "we", "log-time", "algorithm", "we", "case", "coarse-to-fine", "calculation", "perform", "rightshift", "ordinal", "image", "bit", "time", "-lrb-", "similar", "radix", "-rrb-", "until", "reach", "fixed", "low", "resolution", "e.g.", "10", "bit", "per", "pixel", "-lrb-", "log", "-rrb-", "algorithm", "from", "section", "apply", "low-resolution", "datum", "-lrb-", "whose", "value", "longer", "unique", "-rrb-", "store", "only", "median", "value", "also", "number", "value", "strictly", "below", "median", "result", "form", "pivot", "from", "which", "we", "calculate", "median", "next-higher", "level", "resolution", "example", "lowest-resolution", "median", "value", "pixel", "0x84", "value", "below", "0x84", "its", "histogram", "value", "below", "0x8400", "next-higher-resolution", "histogram", "median", "-lsb-", "0x8400", "scanning", "bound", "constant", "-lsb-", "256", "-rsb-", "number", "step", "per", "iteration", "each", "iteration", "add", "eight", "bit", "precision", "output", "final", "iteration", "perform", "use", "compound", "histogram", "which", "yield", "full-precision", "ordinal", "result", "entire", "process", "require", "-lrb-", "log", "-rrb-", "level", "recursion", "each", "take", "-lrb-", "log", "-rrb-", "time", "show", "section", "overall", "computational", "complexity", "-lrb-", "log", "-rrb-", "apply", "radius-r", "median", "filter", "ordinal", "image", "can", "output", "any", "lowest", "-lrb-", "2r", "2r", "-rrb-", "ordinal", "value", "because", "definition", "median", "must", "exceed", "many", "value", "filter", "can", "thus", "treat", "all", "value", "single", "low", "constant", "likewise", "-lrb-", "2r", "2r", "-rrb-", "highest", "value", "single", "high", "constant", "without", "affect", "final", "result", "endpoint", "compression", "can", "incorporate", "ordinal", "transform", "allow", "input", "window", "significantly", "larger", "than", "16", "pixel", "filter", "use", "16-bit", "ordinal", "image", "interestingly", "since", "each", "ordinal", "value", "unique", "median", "output", "each", "pixel", "also", "tell", "we", "where", "source", "image", "value", "come", "from", "generate", "vector", "field", "high-frequency", "image", "field", "quite", "noisy", "smoother", "image", "exhibit", "surprising", "structure", "-lrb-", "figure", "14", "last", "page", "emergent", "example", "structure", "-rrb-", "also", "variation", "where", "both", "row", "column", "information", "store", "each", "index", "can", "allow", "histogram", "element", "any", "computable", "region", "-lrb-", "e.g.", "circle", "-rrb-", "determine", "constant", "time", "we", "implement", "range", "radius", "-lsb-", "...", "127", "-rsb-", "compound", "histogram", "efficient", "enough", "require", "coarse-to-fine", "recursion", "all", "except", "carefully-constructed", "worst-case", "datum", "-lrb-", "realworld", "image", "invariably", "close", "best-case", "-rrb-", "fact", "ordinal", "transform", "itself", "often", "performance", "bottleneck", "show", "Figure", "10", "we", "implementation", "outperform", "16-bit", "median", "filter", "Photoshop", "cs2", "up", "factor", "20", "identical", "numerical", "result", "bilateral", "filter", "normalize", "convolution", "which", "weighting", "each", "pixel", "determine", "spatial", "distance", "from", "center", "pixel", "well", "its", "relative", "difference", "intensity", "literature", "-lrb-", "Tomasi", "et", "al.", "-lsb-", "1998", "-rsb-", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "-rrb-", "spatial", "intensity", "weighting", "function", "typically", "gaussian", "Photoshop", "cs2", "implement", "box", "spatial", "filter", "triangular", "intensity", "filter", "function", "multiply", "together", "produce", "weighting", "each", "pixel", "input", "image", "output", "image", "window", "bilateral", "define", "follow", "special", "case", "spatial", "box-filter", "-lrb-", "arbitrary", "intensity", "function", "-rrb-", "worth", "study", "because", "weighting", "function", "become", "constant", "all", "pixel", "give", "intensity", "under", "condition", "histogram", "each", "spatial", "window", "become", "sufficient", "perform", "filter", "operation", "we", "-lrb-", "log", "-rrb-", "median-filtering", "algorithm", "already", "generate", "histogram", "so", "bilateral", "convolution", "can", "append", "constant", "time", "per", "pixel", "scale", "support", "intensity", "function", "g.", "higher-precision", "datum", "one", "can", "either", "dither", "source", "datum", "bit", "before", "processing", "-lrb-", "which", "introduce", "surprisingly", "little", "error", "-rrb-", "else", "downsample", "source", "intensity", "histogram", "-lrb-", "along", "line", "Paris", "et", "al.", "-lsb-", "2006", "-rsb-", "-rrb-", "which", "require", "larger", "histogram", "element", "yield", "better", "accuracy", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "apply", "bilateral", "log-scaled", "image", "re-expand", "result", "approach", "can", "pose", "precision", "problem", "when", "filter", "8-bit", "datum", "fortunately", "logarithmic", "approach", "can", "approximate", "linear", "datum", "scale", "width", "proportion", "intensity", "center", "pixel", "while", "bias", "weight", "toward", "smaller", "value", "yield", "new", "function", "rightmost", "image", "Figure", "11", "show", "result", "logarithmic", "bilateral", "8-bit", "datum", "use", "simple", "variable-width", "triangular", "function", "-lrb-", "note", "improve", "lip", "color", "hair", "detail", "-rrb-", "more", "sophisticated", "intensity", "function", "can", "precompute", "all", "-lrb-", "-rrb-", "we", "linear-data", "approximation", "logarithmic", "bilateral", "follow", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "??", "??", "where", "-lrb-", "-rrb-", "-lrb-", "log", "-rrb-", "x.", "-lrb-", "-rrb-", "one", "potential", "concern", "we", "histogram-based", "method", "imperfect", "frequency", "response", "spatial", "box", "filter", "visual", "artifact", "may", "resemble", "faint", "mach", "band", "artifact", "tend", "drown", "out", "signal", "preserved", "image", "-lrb-", "e.g.", "image", "Figure", "11", "box-filtered", "-rrb-", "still", "smooth", "spatial", "falloff", "achievable", "we", "method", "use", "iterative", "technique", "direct", "iteration", "bilateral", "can", "yield", "unintentionally", "cartoonish", "look", "-lsb-", "tomasi", "1998", "-rsb-", "indirect", "iteration", "more", "effective", "each", "step", "output", "re-filtered", "while", "continue", "use", "original", "datum", "intensity", "window", "homogeneous", "area", "wide", "intensity", "kernel", "converge", "gaussian", "without", "create", "cartoonish", "look", "special", "case", "box-weighted", "bilateral", "we", "technique", "achieve", "discrete-segments", "result", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "similar", "time", "256", "segment", "instead", "10-20", "full", "spatial", "resolution", "make", "result", "translation-invariant", "-lrb-", "avoid", "artifact", "due", "phase", "subsampling", "grid", "-rrb-", "high", "segment", "count", "allow", "high-dynamic-range", "image", "filter", "minimal", "loss", "precision", "slight", "color", "artifact", "may", "introduce", "result", "process", "image", "channel", "we", "have", "find", "also", "imperceptible", "typical", "image", "single", "iteration", "fix", "triangular", "intensity", "function", "-lrb-", "support", "80", "level", "-rrb-", "we", "result", "numerically", "match", "Photoshop?s", "surface", "blur", "output", "up", "twenty-fold", "acceleration", "performance", "bottleneck", "-lrb-", "over", "80", "calculation", "-rrb-", "constant", "time", "spend", "multiply", "each", "window?s", "histogram", "intensity", "function", "which", "account", "flatness", "we", "performance", "curve", "reduce", "we", "implementation", "64", "segment", "should", "nearly", "triple", "its", "speed", "while", "maintain", "very", "high", "quality", "result", "we", "have", "present", "logarithmic-time", "median", "filter", "algorithm", "scalable", "arbitrary", "radius", "adaptable", "image", "any", "bitdepth", "we", "believe", "most", "efficient", "median", "algorithm", "yet", "develop", "both", "term", "theoretical", "complexity", "real-world", "performance", "we", "algorithm", "can", "extend", "perform", "general", "rank-order", "filter", "flexible", "enough", "accomplish", "wide", "variety", "practical", "creative", "task", "significantly", "we", "have", "show", "we", "algorithm", "can", "adapt", "perform", "bilateral", "filter", "where", "become", "highly", "effective", "noise-removal", "tool", "we", "algorithm", "provide", "high-precision", "translation-invariant", "realtime", "implementation", "bilateral", "filter", "support", "nonlinear", "intensity", "scaling", "which", "greatly", "enhance", "quality", "result", "we", "algorithm", "have", "show", "advantage", "only", "high", "radius", "across", "spectrum", "time", "take", "Photoshop", "cs2", "process", "5x5", "median", "bilateral", "filter", "we", "implementation", "can", "process", "any", "kernel", "up", "255x255", "we", "have", "adapt", "we", "algorithm", "multiple", "processor", "near-linear", "performance", "gain", "up", "3.2", "faster", "four-processor", "system", "versus", "single", "processor", "accompany", "video", "demonstrate", "realtime", "performance", "we", "median", "bilateral", "filter", "now", "speed", "median", "filter", "have", "be", "bring", "onto", "par", "workhorse", "filter", "image-processing", "-lrb-", "e.g.", "gaussian", "blur", "fft", "-rrb-", "we", "anticipate", "median", "filter", "its", "derivative", "become", "more", "widely", "use", "part", "standard", "imageprocessing", "repertoire", "we", "hope", "we", "algorithm", "spark", "renew", "interest", "line", "research", "we", "confident", "new", "application", "discovery", "lie", "just", "around", "corner", "special", "thanks", "Paul", "Heckbert", "provide", "invaluable", "feedback", "early", "stage", "also", "thanks", "Blaise", "Ag?era", "Arcas", "Michael", "Herf", "Klaus", "Schauser", "Tobias", "H?llerer", "Ian", "Gilman", "constructive", "critique", "talented", "Gretchen", "Elise", "use", "she", "photo", "reviewer", "time", "insightful", "comment", "finally", "Kai", "Krause", "String", "Theory", "technique", "uang", "T.S.", "1981", "two-dimensional", "signal", "processing", "ii", "transform", "median", "filter", "Berlin", "Springer-Verlag", "pp", "il", "J.", "ERMAN", "M.", "1993", "Computing", "2-D", "Min", "median", "Max", "Filters", "IEEE", "Trans", "pattern", "analysis", "machine", "Intelligence", "Vol", "ABIR", "I.", "1996", "high", "Performance", "Computer", "Imaging", "Greenwich", "CT.", "man", "Publications", "ari", "S.", "URAND", "F.", "2006", "fast", "approximation", "Bilateral", "Filter", "use", "signal", "Processing", "Approach", "eccv", "2006", "ha", "t.", "Q.", "LIET", "L.", "J.", "V.", "2005", "separable", "bilateral", "filter", "fast", "video", "preprocessing", "Multimedia", "Expo", "anka", "S.", "AHNI", "S.", "1989", "efficient", "serial", "parallel", "algorithm", "median", "filtering", "proceed", "1989", "International", "Conference", "parallel", "processing", "iii-56", "iii-62", "erdiman", "P.", "2000", "Radix", "Sort", "Revisited", "http://www.codercorner.com", "radixsortrevisited.htm", "ANIMOTO", "S.", "L.", "1995", "fast", "median", "filtering", "algorithm", "Mesh", "Computers", "pattern", "recognition", "vol", "1965-1972" ],
  "content" : "It provides a mechanism for reducing image noise, while preserving edges more effectively than a linear smoothing filter. This filter exhibits roughly O(r) runtime per pixel, a constraint which significantly reduces its performance for large filtering kernels. Our algorithm overcomes all of these limitations and achieves O(log r) runtime per pixel on 8-bit data, for both median and bilateral filtering. It is fully vectorizable and uses just O(r) storage. It also adapts as an O(log 2 r) algorithm to arbitrary-depth images, on which it runs up to twenty times as fast as Photoshop?s 16-bit Median filter. Photoshop ? CS2?s 16-bit Surface Blur filter reflects this O(r 2 ) complexity, and becomes unusably slow for even moderate radii. Durand?s method approximates the bilateral by filtering subsampled copies of the image with discrete intensity kernels, and recombining the results using linear interpolation. Our bilateral filtering algorithm maintains high resolution in both space and intensity, and is translation-invariant. It is derived from the same core algorithm as our fast O(log r) median filter, and adapts to 16-bit and HDR data with minimal loss of precision. Then we will show in steps how to improve it; first by constant factors, then into O(?r) and O(?r) algorithms, and from there into an O(log r) algorithm. Finally, we will show how the algorithm can be adapted to perform bilateral filtering, and compare it with previous methods. Consider the case of applying a radius-r median filter to an 8-bit image. Assume a source image that is larger than the destination by r pixels on all sides, to sidestep edge-related concerns. (In practice, we repeat edge pixels to fill undefined areas, and process color images on a per-channel basis.) Because the median filter is local, it can be applied to arbitrary-size images in tiles. The fundamental property that concerns us here is runtime per pixel, as a function of filter radius. This corresponds to the performance a user will experience while adjusting the filter radius, and is the primary differentiating characteristic between medianfiltering algorithms. For reference, a brute-force implementation can calculate each output pixel in O(r 2 log r) time, by sorting the corresponding (2r + 1) 2 -pixel input window and selecting the median value as output. In the case of 8-bit data, we use a 256-element histogram, H. Once the input values are added to H, the median value lies in the first index for which the sum of values to that index reaches 2r 2 + 2r + 1. The median index can be found by integrating the histogram from one end until the appropriate sum is reached. However, the window-sliding step dominates the calculation with O(r) runtime per pixel, while the histogramscanning takes constant time per pixel. This suggests that we should look for a way to make the window-sliding faster, even at the expense of making the histogram-scanning slower. Observe that as the window zigzags through the image, it passes through each region several times, performing nearly the same operations on each pass. (Picture mowing your lawn back and forth, shifting sideways one centimeter each time.) This redundancy is considerable, and mirrors the adjacent-window overlap that led to Huang?s algorithm. The fundamental idea behind this paper, and the mechanism that enables our fast algorithm, is the observation that if multiple columns are processed at once, the aforementioned redundant calculations become sequential. This gives us the opportunity to consolidate them, resulting in huge increases in performance. A straightforward adaptation of Huang?s algorithm to process N columns at once involves the maintenance of N histograms, one per output column: H 0 .. This is essentially just a rearrangement of operations; the runtime complexity is unchanged. Each input pixel gets added to 2r + 1 histograms over the course of filtering the image, leading to the O(r) runtime complexity. Fortunately, the explicit maintenance of each histogram H n is unnecessary, due to the distributive property of histograms. This is where our approach diverges from Huang?s algorithm. Histogram distributivity means that for disjoint image regions A and B:\n        H A B [v] ? H A [v] + H B [v] (1)\n        In other words, if an image window W is the union of two disjoint regions A and B, then its histogram H W is equal to H A + H B . The median element of W can then be found by scanning the implicit histogram H W , splicing it together from H A and H B on the fly. (This extends to signed linear combinations; H A ? H W H B , etc.)  In the case of median-filtering N columns, our approach is to form a set H* of partial histograms P 0 .. P N-1 (whose elements may be signed), such that each histogram H 0 .. H N-1 is representable as the sum of T partial histograms from H*. Figure 4 shows how a row of pixels v 0 .. v 2r+8 is added to H*, for the case N = 9, T = 2. The histogram set H* is arranged like a tree, with a central histogram (P 4 ) representing the input window for the central column, and the other partial histograms P n representing the difference between the central and adjacent windows. The sum of each partial plus central histogram yields the full histogram for the corresponding square input window. By widening the yellow central region and fitting the partial histograms to its edges, the 9-column technique can be adapted to perform median filtering of arbitrary radius. The time spent modifying H* is still O(r), but with a much lower constant than Huang?s algorithm. The median extraction time from H* remains constant regardless of r. The more fundamental improvement in efficiency comes when we allow the number of columns N to vary with r, conceptually adding more planes to Figure 4 . For N output columns, the number of modifications to H* per output pixel is (N 2 + 4r + 1) / N. (The graphic in Figure 4 show the case of N = 9, r = 4, requiring 98 adjustments to H* per row or about 11 per output pixel.) Solving for N to minimize the number of adjustments gives N ? 2?r, which yields O(?r) histogram modifications per pixel. Thus, the complexity of the T = 2, variable-N adaptive algorithm is O(?r). Figure 5 shows a layout for processing sixty-three columns at once. It is the three-tiered analogue of Figure 4 , this time ?viewed? from the side. There is a single shared histogram P 31 [yellow] corresponding to the central window; eight partial histograms [orange] at seven-pixel intervals; and for each of these, six small partial histograms [red] at unit intervals; sixty-three histograms altogether. Each input pixel is added/subtracted to each histogram intersecting its column. In this example, a 63-by-1 block of output is produced at each iteration. (2)\n        where the second and third terms are ignored if they match earlier terms (e.g., H 24 = P 31 + P 24 .) The structure of H* is recursive; the central yellow histogram forms a rough approximation to any particular H n ; the orange partial histograms refine that approximation, and the red histograms provide the final correction to make the sums exact. Once H* is initialized, the full histogram of each of the 63 square input windows is expressible per Eq. 2 as the sum  of one red histogram (or none), one orange histogram (or none), and the yellow central histogram. The illustrated case of N = 63, T = 3, r = 31 requires ~18 histogram modifications per output pixel. The median-extraction from H* takes constant time, as the three partial histograms are spliced together on the fly. For the general case of 3-tiered structures, processing N columns at once and with tier radix ?N, the number of histogram adjustments per output pixel becomes ?N + ((4r + 2) / N). For radius r, solving for optimal N yields N ? 4r 2?3 , and the runtime of the threetiered adaptive algorithm is therefore O(?r). In practice, three tiers covers the realistic range of implementation (into the hundreds), but our technique can be extended to arbitrary T. In the limit, a radius-r median filter can be computed across N = O(r) columns at once, using N histograms arranged into T = O(log r) tiers of constant radix. For example, a radius one-million median filter can be computed across N = 9 6 = 531,441 columns at once, using 9 6 partial histograms arranged in seven tiers of radix 9, occupying roughly 500 megabytes of storage. Sliding the window from one row to the next requires O(log r) ? 114 histogram modifications per output pixel. Extracting each median takes O(log r) steps; in this case splicing up to seven partial histograms together to construct each H n , counterbalancing the O(log r) complexity of writing to H*. Therefore, the overall computational cost per pixel is O(log r). Scanning the histogram from index zero to find the median takes about 128 steps on average. Huang [1981] suggested using each output value as a ?pivot? to find the next median value: as H is scanned to find m, we keep track of the number of values v < m in H. Then as we add and remove pixels from H, we keep a running count of how many values satisfy v < m. This allows us to scan the updated histogram starting from m, which is typically much faster than starting from index zero. This heuristic adapts to the O(log r) algorithm by using O(log r) pivots across the N columns, with each pivot tracking the smallest median value in its respective columns. This approach obtains much of the benefit of the heuristic while preserving the O(log r) complexity. Since the pivot tracking involves many consecutive bytewise compares, it is ideally suited for vector optimization. Finally, it is useful to interleave the partial histograms P n in memory, so that multiple adjacent histograms can be modified simultaneously using vector loads and stores. This greatly accelerates the reading and writing of H*. 16-bit and HDR images have already become mainstream, so it is important that our median filter work with images of arbitrary bitdepth. A direct extension of the 8-bit algorithm is problematic, because the histograms must stretch to accommodate every possible value, growing exponentially with bit-depth. The algorithm still remains O(log r), but storage considerations render it impractical for 16-bit images and impossible for floating-point images. H* is reduced to a manageable size through a technique we call the ordinal transform. This involves sorting the input image values, storing the sorted list, and replacing each cardinal value with its ordinal equivalent. (Duplicate cardinal values map to consecutive ordinal values.) The median filter is then applied to the ordinal image, and the transform is inverted to restore the cardinalvalued result. The ordinal transform operates on images of any depth, in logarithmic or constant time per pixel. In this operation, the nonlinearity of the median filter is crucial. Any linear filter (e.g., Gaussian blur) would not be invariant under the ordinal transform, but the median filter is! That is because rank-order is preserved; the k th -smallest cardinal value maps to the k th -smallest ordinal value. After the ordinal transform is applied, the median filtering proceeds as in Section 3, this time using single-bit histograms P n (sufficient here because each ordinal value is unique in the image), and the results are inversetransformed to yield the final filtered image. Recall that the histogram elements in H* can go negative. At first this appears problematic because the required range [-1, 0, 1] doesn?t fit into a single bit. However, since each summed implicit histogram value H n [v] can only be either zero or one, only the lowest bit from each partial histogram must participate in the summation. Hence a single bit is sufficient for each element of P n , and the splicing accomplished through a bitwise XOR. For processing N columns in parallel, this approach still requires the allocation and maintenance of N single-bit histograms. However, due to the uniqueness of values in the ordinal image, we can take advantage of a much more efficient encoding. Consider the full histogram obtained by splicing the n th set of partial histograms in H* (consisting of the central histogram plus one partial histogram from each tier), to yield the single-bit histogram for the n th input window. Label this binary histogram B n . By definition, the single bit B n [v] indicates whether the ordinal value v lies in the input window n. As rows of pixels v = I[row][col] are added, we adjust H c as follows: Since the ordinal values in I can have any arrangement, the compound histogram H c is filled in arbitrary order. As rows of pixels are removed, the corresponding elements of H c are zeroed. The power of this technique becomes clear when it comes time to scan the implicit histogram B n to find the n th median output value. In our initial approach, each implicit histogram B n was spliced together from O(log r) partial histograms, taking O(log r) time per element. With the compound histogram, using 8-bit modular arithmetic, elements of B n can now be computed in constant time: For N > 128, this technique extends in a straightforward manner to 16-bit compound histograms, sufficient for N <= 32768, and so on. The computational complexity is independent of element size. There is one final detail. As the radius increases, the histogram size scales as O(r 2 ), which directly affects the histogram scanning distance and thus the algorithm?s time-complexity. This complication is addressed by computing the median in stages from coarse to fine precision. Alparone et al. [1994] applied a similar technique to the O(r) algorithm, employing two levels of resolution to process 10, 12, or 14-bit images in faster (but still O(r)) time. Here we apply an analogous technique to our log-time algorithm. In our case, the coarse-to-fine calculation is performed by rightshifting the ordinal image 8 bits at a time (or similar radix) until it reaches a fixed low resolution; e.g., 10 bits per pixel. Then the O(log r) algorithm from Section 3 is applied to the low-resolution data (whose values are no longer unique), storing not only the median values, but also the number of values strictly below the median. This result forms a pivot from which we calculate the median at the next-higher level of resolution. For example, if the lowest-resolution median value for a pixel is 0x84, and there are n values below 0x84 in its histogram, then there will be n values below 0x8400 in the next-higher-resolution histogram, and the median will be in [0x8400 .. This scanning is bounded by a constant [256] number of steps per iteration, with each iteration adding eight bits of precision to the output. The final iteration is performed using the compound histogram, which yields the full-precision ordinal result. The entire process requires O(log r) levels of recursion, each taking O(log r) time as shown in Section 3, for an overall computational complexity of O(log 2 r). Applying a radius-r median filter to an ordinal image cannot output any of the lowest (2r 2 + 2r) ordinal values, because by definition the median must exceed that many values. The filter can thus  treat all such values as a single low constant, and likewise the (2r 2 + 2r) highest values as a single high constant, without affecting the final result. This ?endpoint compression? can be incorporated into the ordinal transform, allowing input windows significantly larger than 2 16 pixels to be filtered using 16-bit ordinal images. Interestingly, since each ordinal value is unique, the median output for each pixel also tells us where in the source image that value came from, generating a vector field. On high-frequency images this field is quite noisy, but on smoother images it exhibits surprising structure. ( Figure 14 on the last page is an emergent example of this structure.) Also, a variation of H c where both row and column information is stored at each index can allow histogram elements of any computable region (e.g., a circle) to be determined in constant time. For our implemented range of radii [1... 127], the compound histogram is efficient enough not to require the coarse-to-fine recursion at all, except on carefully-constructed worst-case data. (Realworld images are invariably close to best-case.) In fact, the ordinal transform by itself is often the performance bottleneck. As shown in Figure 10 , our implementation outperforms the 16-bit Median filter in Photoshop ? CS2 by up to a factor of 20, with identical numerical results. The bilateral filter is a normalized convolution in which the weighting for each pixel p is determined by the spatial distance from the center pixel s, as well as its relative difference in intensity. In the literature (Tomasi et al. [1998] and Durand et al. [2002]), the spatial and intensity weighting functions f and g are typically Gaussian; Photoshop ? CS2 implements a box spatial filter and triangular intensity filter. These functions multiply together to produce the weighting for each pixel. For input image I, output image J and window ?, the bilateral is defined as follows: The special case of a spatial box-filter (with arbitrary intensity function) is worth studying, because the weighting function becomes constant for all pixels of a given intensity. Under this condition, the histogram of each spatial window becomes sufficient  to perform the filtering operation. Our O(log r) median-filtering algorithm already generates these histograms, so the bilateral convolution can be appended in constant time per pixel, scaling with the support of the intensity function g. For higher-precision data, one can either dither the source data into 8 bits before processing (which introduces surprisingly little error), or else downsample the source intensities into the histograms (along the lines of Paris et al. [2006]), which requires larger histogram elements but yields better accuracy. Durand et al. [2002] applied the bilateral to log-scaled images and re-expanded the result, but this approach can pose precision problems when filtering 8-bit data. Fortunately, this logarithmic approach can be approximated on linear data by scaling the width of g in proportion to the intensity of the center pixel while biasing the weight toward smaller values, yielding a new function g?. The rightmost image in Figure 11 shows the result of this logarithmic bilateral on 8-bit data, using a simple variable-width triangular function for g?. (Note the improved lip color and hair detail.) More sophisticated intensity functions can be precomputed for all (I p , I s ). Our linear-data approximation to the logarithmic bilateral is as follows: J s = f (p ? s)g (I p /I s )I p f (p ? s)g (I p /I s ). (6) p?? p?? where g (x) = g(log x)/ ? x. (7) One potential concern with our histogram-based method is the imperfect frequency response of the spatial box filter. Visual artifacts may resemble faint mach bands, but these artifacts tend to be drowned out by the signal of the preserved image (e.g., the images in Figure 11 are box-filtered.) Still, smooth spatial falloff is achievable with our method, using an iterative technique. Direct iteration of the bilateral can yield an unintentionally cartoonish look [Tomasi 1998], but indirect iteration is more effective. At each step the output is re-filtered, while continuing to use the original data for the intensity windows. For homogeneous areas or with wide intensity kernels, this converges to a Gaussian without creating the cartoonish look: For the special case of the box-weighted bilateral, our technique achieves the discrete-segments result of Durand et al. [2002] in similar time, but with 256 segments instead of 10-20, and at full spatial resolution. This makes the result translation-invariant (avoiding artifacts due to the phase of the subsampling grid), and the high segment count allows high-dynamic-range images to be filtered with minimal loss of precision. Slight color artifacts may be introduced as a result of processing the image by channel, but we have found these also to be imperceptible on typical images. With a single iteration and a fixed triangular intensity function (support 80 levels), our results numerically match Photoshop?s Surface Blur output, with up to twenty-fold acceleration. The performance bottleneck (over 80% of the calculation) is the constant time spent multiplying each window?s histogram by the intensity function, which accounts for the flatness of our performance curve. Reducing our implementation to 64 segments should nearly triple its speed, while maintaining very high quality results. We have presented a logarithmic-time median filter algorithm, scalable to arbitrary radius and adaptable to images of any bitdepth. We believe this is the most efficient median algorithm yet developed, both in terms of theoretical complexity and real-world performance. Our algorithm can be extended to perform general rank-order filtering, and it is flexible enough to accomplish a wide variety of practical and creative tasks. Significantly, we have shown that our algorithm can be adapted to perform bilateral filtering, where it becomes a highly effective noise-removal tool. Our algorithm provides a high-precision, translation-invariant, realtime implementation of the bilateral filter, and supports nonlinear intensity scaling, which greatly enhances the quality of the result. Our algorithms have shown their advantage not only at high radii but across the spectrum. In the time it takes Photoshop ? CS2 to process a 5x5 median or bilateral filter, our implementation can process any kernel up to 255x255. We have adapted our algorithm to multiple processors with near-linear performance gains, up to 3.2x faster on a four-processor system versus a single processor. The accompanying videos demonstrate the realtime performance of our median and bilateral filters. Now that the speed of the median filter has been brought onto par with the workhorse filters of image-processing (e.g. Gaussian blur and FFT), we anticipate that the median filter and its derivatives will become a more widely used part of the standard imageprocessing repertoire. It is our hope that our algorithms spark renewed interest in this line of research, and we are confident that new applications and discoveries lie just around the corner. Special thanks to Paul Heckbert for providing invaluable feedback in the early stages. Also thanks to Blaise Ag?era y Arcas, Michael Herf, Klaus Schauser, Tobias H?llerer and Ian Gilman for their constructive critiques. To the talented Gretchen Elise for the use of her photo. To the reviewers for their time and insightful comments. Finally to Kai Krause, for the String Theory technique! H UANG , T.S. 1981. Two-Dimensional Signal Processing II: Transforms and Median Filters. Berlin: Springer-Verlag, pp. G IL , J. AND W ERMAN , M. 1993. Computing 2-D Min, Median, and Max Filters. IEEE Trans. Pattern Analysis and Machine Intelligence, Vol. K ABIR , I. 1996. High Performance Computer Imaging. Greenwich, CT. Manning Publications. P ARIS , S. AND D URAND , F. 2006. A Fast Approximation of the Bilateral Filter using a Signal Processing Approach. ECCV 2006. P HA , T. Q. AND V LIET , L. J. V. 2005. Separable bilateral filtering for fast video preprocessing. on Multimedia & Expo. R ANKA , S. AND S AHNI , S. 1989. Efficient Serial and Parallel Algorithms for Median Filtering. Proceeding 1989 International Conference on Parallel Processing, III-56 -III-62. T ERDIMAN , P. 2000. Radix Sort Revisited. <http://www.codercorner.com /RadixSortRevisited.htm> T ANIMOTO , S. L. 1995. Fast Median Filtering Algorithms for Mesh Computers. Pattern Recognition, vol. 1965-1972.",
  "resources" : [ ]
}