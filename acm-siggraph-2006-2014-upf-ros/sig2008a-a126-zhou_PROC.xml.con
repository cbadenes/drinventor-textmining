{
  "uri" : "sig2008a-a126-zhou_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a126-zhou_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-Time KD-Tree Construction on Graphics Hardware",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Qiming-Hou",
      "name" : "Qiming",
      "surname" : "Hou"
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Baining-Guo",
      "name" : "Baining",
      "surname" : "Guo"
    } ]
  },
  "bagOfWords" : [ "describe", "algorithm", "have", "be", "test", "Intel", "Xeon", "3.7", "GHz", "CPU", "NVIDIA", "GeForce", "8800", "ULTRA", "-lrb-", "768MB", "-rrb-", "graphic", "card", "parameter", "-lrb-", "e.g.", "-rrb-", "use", "during", "tree", "construction", "intentionally", "keep", "same", "all", "scene", "we", "compare", "we", "GPU", "algorithm", "off-line", "CPU", "algorithm", "which", "always", "use", "greedy", "SAH", "cost", "calculate", "optimal", "split", "plane", "clip", "triangle", "child", "node", "-lsb-", "Wald", "Havran", "2006", "-rsb-", "Table", "summarize", "comparison", "result", "several", "publicly", "available", "scene", "show", "fig.", "show", "we", "kd-tree", "construction", "algorithm", "15", "time", "faster", "all", "scene", "quality", "tree", "assess", "two", "way", "first", "we", "compute", "SAH", "cost", "second", "we", "evaluate", "practical", "effect", "tree", "quality", "render", "time", "use", "construct", "tree", "ray", "tracer", "describe", "section", "show", "table", "we", "algorithm", "generate", "lower", "sah", "cost", "Toys", "Museum", "Robots", "higher", "SAH", "cost", "kitchen", "Fairy", "Forest", "Dragon", "all", "case", "we", "tree", "always", "offer", "better", "render", "performance", "which", "attest", "high", "quality", "we", "tree", "practical", "application", "note", "SAH", "cost", "expect", "cost", "ray", "traverse", "entire", "tree", "whereas", "actual", "kdtree", "traversal", "terminate", "first", "node", "intersection", "therefore", "strict", "correlation", "between", "SAH", "cost", "actual", "ray", "trace", "time", "SAH", "cost", "only", "one", "way", "measure", "quality", "kd-tree", "most", "important", "metric", "how", "well", "result", "tree", "accelerate", "ray", "traversal", "which", "ultimate", "goal", "SAH", "tree", "construction", "strategy", "we", "kd-tree", "construction", "algorithm", "also", "scale", "well", "number", "GPU", "processor", "run", "time", "contain", "scalable", "portion", "small", "non-scalable", "portion", "due", "overhead", "CUDA", "API", "driver", "theoretically", "run", "time", "linear", "respect", "reciprocal", "number", "processor", "show", "Table", "Fig.", "we", "run", "algorithm", "GeForce", "8800", "ULTRA", "graphic", "card", "16", "32", "48", "64", "80", "96", "112", "128", "processor", "respectively", "nvstrap", "driver", "RivaTuner", "-lsb-", "Nicolaychuk", "2008", "-rsb-", "use", "disable", "process", "unit", "adjust", "hardware", "mask", "although", "we", "technique", "capable", "construct", "high", "quality", "kdtree", "real-time", "have", "its", "limitation", "small", "scene", "less", "than", "5k", "triangle", "CUDA?s", "API", "overhead", "become", "major", "bottleneck", "case", "more", "efficient", "switch", "complete", "CPU", "method", "also", "we", "method", "consume", "much", "more", "memory", "than", "CPU", "method", "mainly", "due", "use", "double", "list", "extra", "bookkeeping", "BFS", "order", "construction", "we", "system", "support", "scene", "up", "600k", "triangle", "GeForce", "8800", "Ultra", "-lrb-", "768MB", "-rrb-", "graphic", "card", "six", "test", "scene", "peak", "memory", "we", "build", "around", "8mb", "18mb", "50mb", "90mb", "123mb", "178mb", "respectively", "problem", "however", "can", "reduce", "better", "memory", "management", "scheme", "example", "currently", "we", "keep", "many", "temporary", "datum", "structure", "memory", "all", "stage", "avoid", "costly", "CUDA", "API", "call", "free", "temporary", "datum", "we", "implement", "set", "efficient", "CUDA", "memory", "allocation/free", "routine", "we", "able", "free", "temporary", "datum", "reduce", "memory", "consumption", "considerably", "other", "technique", "reduce", "memory", "certainly", "possible", "investigate", "future", "work", "memory", "consumption", "issue", "also", "alleviate", "rapid", "advancement", "graphic", "hardware", "NVIDIA", "recently", "release", "Quadro", "FX", "5600", "which", "support", "CUDA", "have", "1.5", "gb", "memory", "we", "have", "present", "kd-tree", "algorithm", "capable", "achieve", "realtime", "performance", "GPU", "algorithm", "build", "kd-tree", "BFS", "order", "exploit", "large", "scale", "parallelism", "modern", "gpus", "construct", "kd-tree", "comparable", "quality", "those", "build", "off-line", "CPU", "algorithm", "we", "also", "demonstrate", "potential", "we", "kd-tree", "algorithm", "three", "application", "involve", "dynamic", "scene", "GPU", "ray", "trace", "GPU", "photon", "mapping", "point", "cloud", "modeling", "several", "direction", "future", "investigation", "we", "plan", "incorporate", "packet", "-lsb-", "Wald", "et", "al.", "2001", "-rsb-", "GPU", "ray", "tracer", "further", "performance", "enhancement", "we", "also", "intend", "implement", "-lrb-", "-rrb-", "metal", "ring", "-lrb-", "-rrb-", "glass", "champagne", "caustic", "render", "use", "photon", "mapping", "both", "scene", "light", "point", "light", "source", "render", "image", "resolution", "800", "600", "-lrb-", "-rrb-", "cardioid-shaped", "caustic", "cause", "light", "reflection", "inside", "metal", "ring", "scene", "consist", "3k", "triangle", "render", "performance", "12.2", "fp", "-lrb-", "-rrb-", "caustic", "due", "light", "refraction", "through", "several", "layer", "glass", "champagne", "scene", "have", "19k", "triangle", "performance", "about", "7.5", "fp", "CPU", "algorithm", "GPU", "algorithm", "kd-tree", "knn", "kd-tree", "knn", "0.081", "0.508", "0.009", "0.044", "0.237", "0.371", "0.017", "0.050", "compare", "photon", "kd-tree", "construction", "time", "knn", "time", "between", "CPU", "algorithm", "we", "GPU", "algorithm", "global", "photon", "map", "GPU", "use", "general", "photon", "scattering", "scheme", "base", "russian", "roulette", "photon", "map", "would", "allow", "we", "render", "indirect", "illumination", "finally", "we", "interested", "extend", "we", "kd-tree", "algorithm", "higher", "dimension", "application", "texture", "synthesis" ],
  "content" : "The described algorithm has been tested on an Intel Xeon 3.7GHz CPU with an NVIDIA GeForce 8800 ULTRA (768MB) graphics card. Parameters (e.g., T and N ) used during tree construction are intentionally kept the same for all scenes. We compare our GPU algorithm with an off-line CPU algorithm which always uses the greedy SAH cost to calculate optimal split planes and clips triangles into child nodes [Wald and Havran 2006]. Table 2 summarizes the comparison results for several publicly available scenes as shown in Fig. 4 . As shown, our kd-tree construction algorithm is 6 ? 15 times faster for all scenes. The quality of the trees is assessed in two ways. First, we compute the SAH costs. Second, we evaluate the practical effect of tree quality on render time by using the constructed trees in a ray tracer as described in Section 4. As shown in the table, our algorithm generates lower SAH costs for Toys, Museum and Robots, but higher SAH costs for Kitchen, Fairy Forest and Dragon. In all cases, our trees always offer better rendering performance, which attests to the high quality of our trees in practical applications. Note that SAH cost is the expected cost for a ray to traverse the entire tree, whereas actual kdtree traversal terminates at the first node of intersection. Therefore there is no strict correlation between the SAH costs and the actual ray trace time. SAH cost is only one way to measure the quality of kd-trees. The most important metric is how well the resulting tree accelerates ray traversals, which is the ultimate goal of an SAH tree construction strategy. Our kd-tree construction algorithm also scales well with the number of GPU processors. The running time contains a scalable portion and a small non-scalable portion due to the overhead of CUDA API and driver. Theoretically, the running time is linear with respect to the reciprocal of the number of processors. As shown in Table 3 and Fig. 5 , we ran the algorithm on a GeForce 8800 ULTRA graphics card with 16, 32, 48, 64, 80, 96, 112, and 128 processors respectively. The NVStrap driver in RivaTuner [Nicolaychuk 2008] is used to disable processing units by adjusting hardware masks. Although our technique is capable of constructing high quality kdtrees in real-time, it has its limitations. For small scenes with less than 5K triangles, CUDA?s API overhead becomes a major bottleneck. In this case, it is more efficient to switch to a complete CPU method. Also, our method consumes much more memory than a CPU method. This is mainly due to the use of doubling lists and extra bookkeeping for BFS order construction. Our system supports scenes with up to 600K triangles on the GeForce 8800 Ultra (768MB) graphics card. For the six tested scenes, the peak memory in our build is around 8MB, 18MB, 50MB, 90MB, 123MB and 178MB respectively. This problem, however, can be reduced with a better memory management scheme. For example, currently we keep many temporary data structures in memory at all stages to avoid costly CUDA API calls to free these temporary data. If we implement a set of efficient CUDA memory allocation/free routines, we will be able to free temporary data and reduce memory consumption considerably. Other techniques for reducing memory are certainly possible and are to be investigated in future work. The memory consumption issue is also alleviated with the rapid advancements in graphics hardware. NVIDIA recently released Quadro FX 5600 which supports CUDA and has 1.5GB memory. We have presented a kd-tree algorithm capable of achieving realtime performance on the GPU. The algorithm builds kd-trees in BFS order to exploit the large scale parallelism of modern GPUs. The constructed kd-trees are of comparable quality as those built by off-line CPU algorithms. We also demonstrated the potential of our kd-tree algorithm in three applications involving dynamic scenes: GPU ray tracing, GPU photon mapping, and point cloud modeling. There are several directions for future investigation. We plan to incorporate packets [Wald et al. 2001] into the GPU ray tracer for further performance enhancements. We also intend to implement (a) A metal ring (b) A glass of champagne Caustic rendering using photon mapping. Both scenes are lit by a point light source and rendered at image resolution 800 ? 600. (a) Cardioid-shaped caustic caused by light reflection inside a metal ring. The scene consists of 3K triangles and the rendering performance is 12.2 fps. (b) Caustics due to light refraction through several layers of glass and champagne. The scene has 19K triangles and the performance is about 7.5 fps. CPU algorithm GPU algorithm kd-tree KNN kd-tree KNN 0.081s 0.508s 0.009s 0.044s 0.237s 0.371s 0.017s 0.050s Comparing photon kd-tree construction time and KNN time between a CPU algorithm and our GPU algorithm. global photon maps on the GPU using a general photon scattering scheme based on Russian roulette. Such photon maps would allow us to render indirect illumination. Finally, we are interested in extending our kd-tree algorithm to higher dimensions for applications such as texture synthesis.",
  "resources" : [ ]
}