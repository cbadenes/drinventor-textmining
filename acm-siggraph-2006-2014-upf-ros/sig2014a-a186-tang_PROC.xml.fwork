{
  "uri" : "sig2014a-a186-tang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2014a/a186-tang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Fast and Exact Continuous Collision Detection with Bernstein Sign Classification",
    "published" : "2014",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Dinesh-Manocha",
      "name" : "Dinesh",
      "surname" : "Manocha"
    } ]
  },
  "bagOfWords" : [ "cr", "category", "i.", "3.5", "-lsb-", "Computer", "Graphics", "-rsb-", "computational", "geometry", "object", "modeling?physically", "base", "modeling", "keyword", "continuous", "collision", "detection", "Bernstein", "sign", "classification", "exact", "geometric", "computation", "physically", "base", "simulation", "have", "also", "be", "propose", "reduce", "number", "elementary", "test", "perform", "between", "mesh", "complex", "model", "we", "represent", "function", "use", "Bernstein", "basis", "exploit", "geometric", "property", "B?zier", "curve", "design", "efficient", "reliable", "Bernstein", "sign", "classification", "-lrb-", "bsc", "-rrb-", "approach", "CCD", "BSC-exact", "exact", "algorithm", "perform", "CCD", "query", "base", "exact", "geometric", "computation", "paradigm", "-lsb-", "yap", "2004", "-rsb-", "susceptible", "false", "positive", "false", "negative", "BSC-float", "finite-precision", "variant", "implement", "use", "floating-point", "arithmetic", "operation", "use", "Bernstein", "basis", "simple", "arithmetic", "operation", "result", "reduced", "error", "improve", "efficiency", "many", "technique", "have", "be", "propose", "CCD", "between", "rigid", "model", "-lsb-", "Redon", "et", "al.", "2002", "Kim", "Rossignac", "2003", "-rsb-", "articulate", "model", "-lsb-", "Zhang", "et", "al.", "2007", "-rsb-", "deformable", "model", "-lsb-", "volino", "Thalmann", "1994", "Govindaraju", "et", "al.", "2005", "Hutter", "Fuhrmann", "2007", "Tang", "et", "al.", "2011", "-rsb-", "all", "method", "prone", "floating-point", "error", "numerical", "tolerance", "Wang", "-lsb-", "2014", "-rsb-", "have", "perform", "forward", "error", "analysis", "elementary", "test", "use", "analysis", "derive", "tight", "error", "bound", "floating-point", "computation", "use", "reduce", "number", "false", "positive", "contrast", "we", "bsc-exact", "algorithm", "approach", "describe", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "reliable", "high-level", "Culling", "many", "high-level", "technique", "have", "be", "propose", "accelerate", "CCD", "computation", "reduce", "number", "elementary", "test", "between", "triangle", "pair", "remove", "redundant", "elementary", "test", "-lsb-", "Curtis", "et", "al.", "2008", "Tang", "et", "al.", "2009a", "Wong", "Baciu", "2006", "-rsb-", "other", "method", "use", "bound", "surface", "normal", "curvature", "-lsb-", "volino", "Thalmann", "1994", "Provot", "1997", "Mezger", "et", "al.", "2003", "-rsb-", "perform", "selfcollision", "culling", "-lsb-", "Schvartzman", "et", "al.", "2010", "Pabst", "et", "al.", "2010", "Zheng", "James", "2012", "-rsb-", "polynomial", "root", "evaluation", "many", "numerical", "iterative", "method", "have", "be", "propose", "compute", "root", "polynomial", "equation", "tend", "use", "tolerance", "can", "result", "false", "positive", "false", "negative", "CCD", "computation", "computer", "graphic", "geometric", "modeling", "polynomial", "represent", "use", "spline", "basis", "root", "can", "compute", "use", "geometric", "subdivision", "method", "de", "casteljau?s", "algorithm", "-lsb-", "Farin", "2002", "-rsb-", "b?zier", "clipping", "-lsb-", "Sederberg", "Nishita", "1990", "-rsb-", "subdivision", "method", "implement", "use", "finite-precision", "arithmetic", "also", "prone", "roundoff", "error", "result", "we", "focus", "reliably", "compute", "yes/no", "answer", "Boolean", "query", "inflection", "point", "occur", "where", "curvature", "vanish", "change", "its", "case", "-lrb-", "-rrb-", "curve", "have", "neither", "inflection", "point", "nor", "extreme", "point", "inside", "test", "Theorem", "VF", "Pair", "give", "triangle", "vertex", "define", "end", "position", "over", "interval", "-lsb-", "-rsb-", "inside", "test", "can", "formulate", "term", "follow", "inequality", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rsb-", "scalar", "which", "can", "calculate", "base", "-lsb-", "...", "3.6", "CCD", "test", "use", "Bernstein", "Polynomials", "formulation", "coplanarity", "inside", "test", "can", "combine", "follow", "system", "equation", "inequality", "term", "Bernstein", "polynomial", "where", "-lsb-", "...", "here", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "define", "equation", "-lrb-", "11", "-rrb-", "equation", "-lrb-", "13", "-rrb-", "respectively", "sign", "-lrb-", "-rrb-", "algorithm", "use", "compute", "sign", "-lrb-", "-rrb-", "can", "directly", "use", "compute", "sign", "-lrb-", "-rrb-", "valid", "collision", "have", "be", "detect", "BSC-float", "floating-point", "Algorithm", "some", "case", "optimize", "library", "extended", "precision-arithmetic", "operation", "available", "certain", "processor", "-lrb-", "e.g.", "gpus", "-rrb-" ],
  "content" : "CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling?Physically based modeling Keywords: Continuous collision detection, Bernstein sign classification, Exact geometric computation, Physically based simulation have also been proposed to reduce the number of elementary tests performed between the meshes of complex models. We represent these functions using the Bernstein basis and exploit geometric properties of B?zier curves to design an efficient and reliable Bernstein sign classification (BSC) approach for CCD. BSC-exact: This is an exact algorithm to perform CCD queries based on the exact geometric computation paradigm [Yap 2004] and is not susceptible to false positives or false negatives. BSC-float: This is a finite-precision variant and is implemented using floating-point arithmetic operations. The use of the Bernstein basis and simple arithmetic operations results in reduced errors and improved efficiency. Many techniques have been proposed for CCD between rigid models [Redon et al. 2002; Kim and Rossignac 2003], articulated models [Zhang et al. 2007], and deformable models [Volino and Thalmann 1994; Govindaraju et al. 2005; Hutter and Fuhrmann 2007; Tang et al. 2011]. All these methods are prone to floating-point errors and numerical tolerances. Wang [2014] has performed forward error analysis for elementary tests and used that analysis to derive tight error bounds for floating-point computation. This is used to reduce the number of false positive. In contrast, our BSC-exact algorithm and the approach described in [Brochu et al. 2012] are reliable. High-level Culling: Many high-level techniques have been proposed to accelerate CCD computations by reducing the number of elementary tests between the triangle pairs, such as removing redundant elementary tests [Curtis et al. 2008; Tang et al. 2009a; Wong and Baciu 2006]. Other methods use bounds on surface normals and curvature [Volino and Thalmann 1994; Provot 1997; Mezger et al. 2003] or perform selfcollision culling [Schvartzman et al. 2010; Pabst et al. 2010; Zheng and James 2012]. Polynomial Root Evaluation: Many numerical iterative methods have been proposed to compute roots of polynomial equations. They tend to use tolerances and can result in false positives or false negatives for CCD computations. In computer graphics and geometric modeling, polynomials are represented using the spline basis, and their roots can be computed using the geometric subdivision methods, such as de Casteljau?s algorithm [Farin 2002] or B?zier clipping [Sederberg and Nishita 1990]. These subdivision methods are implemented using finite-precision arithmetic and are also prone to roundoff errors. As a result, we focus on reliably computing a yes/no answer to the Boolean queries. An inflection point occurs where the curvature vanishes or changes its ? Case (c): The curve has neither an inflection point nor an extreme point. Inside Test Theorem for a VF Pair: Given the triangle and the vertex defined by start and end positions over the interval [0, 1], the inside test can be formulated in terms of the following inequality: ((b t ? p t ) ? (c t ? p t )) ? n t = l 0 ? B 0 4 (t) + l 1 ? B 1 4 (t) 2] are scalars, which can be calculated based on k [0... 3.6 CCD Tests using Bernstein Polynomials\n          The formulations for coplanarity and inside tests can be combined into the following system of equations and inequalities in terms of Bernstein polynomials:  where k [0... Here Y (t) and P (t) are defined by Equation (11) and Equation (13), respectively. Sign of K( t): The algorithm used to compute the sign of L( t) can be directly used to compute the sign of K( t). // A valid collision has been detected. BSC-float: Floating-point Algorithm: In some cases, optimized libraries for extended precision-arithmetic operations are not available on certain processors (e.g. GPUs).",
  "resources" : [ ]
}