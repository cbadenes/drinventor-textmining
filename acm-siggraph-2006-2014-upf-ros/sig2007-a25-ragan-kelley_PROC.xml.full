{
  "uri" : "sig2007-a25-ragan-kelley_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2007/a25-ragan-kelley_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "The Lightspeed Automatic Interactive Lighting Preview System",
    "published" : "2007",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Jonathan-Ragan-Kelley",
      "name" : "Jonathan",
      "surname" : "Ragan-Kelley"
    }, {
      "uri" : "http://drinventor/Charlie-Kilpatrick",
      "name" : "Charlie",
      "surname" : "Kilpatrick"
    }, {
      "uri" : "http://drinventor/Brian W.-Smith",
      "name" : "Brian W.",
      "surname" : "Smith"
    }, {
      "uri" : "http://drinventor/Doug-Epps",
      "name" : "Doug",
      "surname" : "Epps"
    }, {
      "uri" : "http://drinventor/Paul-Green",
      "name" : "Paul",
      "surname" : "Green"
    }, {
      "uri" : "http://drinventor/Christophe-Hery",
      "name" : "Christophe",
      "surname" : "Hery"
    }, {
      "uri" : "http://drinventor/Fr?do-Durand",
      "name" : "Fr?do",
      "surname" : "Durand"
    } ]
  },
  "bagOfWords" : [ "15f37d5a612418bb3317abe0e3bd21e4ff57fb4940e70d0d953f6f8cdf717a13", "mhk", "10.1145", "1239451.1239476", "name", "identification", "possible", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "Jonathan", "Ragan-Kelley", "Charlie", "Kilpatrick", "Brian", "W.", "Smith", "Doug", "Epps", "MIT", "CSAIL", "Industrial", "Light", "Magic", "Figure", "automatically-generated", "preview", "914x389", "resolution", "13x13", "supersampling", "scene", "feature", "42", "spot", "environment", "message-passing", "light", "multiple", "20k", "instruction", "surface", "shader", "upper-left", "half", "image", "render", "we", "approach", "while", "lower", "right", "final", "RenderMan", "frame", "seam", "barely", "visible", "error", "heat", "map", "percentage", "maximum", "8-bit", "pixel", "value", "mostly", "due", "shadow", "map", "artifact", "scene", "render", "interactively", "4x4", "subsampled", "resolution", "9.2", "hz", "while", "refine", "above", "antialiased", "final-quality", "2.7", "seconds", "compare", "57", "minute", "RenderMan", "we", "present", "automated", "approach", "high-quality", "preview", "feature-film", "rendering", "during", "lighting", "design", "similar", "previous", "work", "we", "use", "deep-framebuffer", "shaded", "GPU", "achieve", "interactive", "performance", "we", "first", "contribution", "generate", "deep-framebuffer", "corresponding", "shader", "automatically", "through", "data-flow", "analysis", "compilation", "original", "scene", "cache", "compression", "reduce", "automatically-generated", "deep-framebuffer", "reasonable", "size", "complex", "production", "scene", "shader", "we", "also", "propose", "new", "structure", "indirect", "framebuffer", "decouple", "shade", "sample", "from", "final", "pixel", "allow", "deepframebuffer", "handle", "antialiasing", "motion", "blur", "transparency", "efficiently", "progressive", "refinement", "enable", "fast", "feedback", "coarser", "resolution", "we", "demonstrate", "we", "approach", "real-world", "production", "keyword", "Lighting", "Preview", "Interactive", "Rendering", "Data-flow", "Analysis", "RenderMan", "Programmable", "Shading", "GPUs", "ACM", "Reference", "Format", "Ragan-Kelley", "J.", "Kilpatrick", "C.", "Smith", "B.", "Epps", "D.", "Green", "P.", "Hery", "C.", "Durand", "F.", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "ACM", "Trans", "graph", "26", "Article", "25", "-lrb-", "July", "2007", "-rrb-", "11", "page", "dous", "10.1145", "1239451.1239476", "http://doi.acm.org/10.1145/1239451.1239476", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "direct", "commercial", "advantage", "copy", "show", "notice", "first", "page", "initial", "screen", "display", "along", "full", "citation", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "212", "869-0481", "permissions@acm.org", "2007", "ACM", "0730-0301/2007", "03-art25", "5.00", "DOI", "10.1145", "1239451.1239476", "http://doi.acm.org/10.1145/1239451.1239476", "Paul", "Green", "Christophe", "Hery", "Fr?do", "Durand", "Tippett", "Studio", "introduction", "1.1", "prior", "work", "fast", "relighting", "have", "long", "be", "major", "area", "research", "-lsb-", "Dorsey", "et", "al.", "1995", "Ng", "et", "al.", "2003", "-rsb-", "Software", "renderer", "can", "optimize", "repetitive", "re-rendering", "cache", "intermediate", "result", "various", "stage", "render", "process", "pioneer", "TDI", "1980s", "-lsb-", "Alias", "1999", "Pixar", "2001", "Nvidia", "2005", "Tabellion", "Lamorlette", "2004", "-rsb-", "however", "optimization", "must", "integrate", "core", "system", "still", "far", "from", "interactive", "film", "scene", "s?quin", "smyrl", "-lsb-", "1989", "-rsb-", "introduce", "parameterized", "version", "ray", "trace", "enable", "modification", "some", "material", "light", "property", "after", "precomputation", "-lrb-", "although", "light", "direction", "position", "-rrb-", "also", "perform", "cache", "compression", "Gershbein", "Hanrahan", "create", "system", "lighting", "design", "-lsb-", "2000", "-rsb-", "which", "cache", "intermediate", "result", "deep-framebuffer", "inspire", "G-Buffers", "-lsb-", "Saito", "Takahashi", "1990", "-rsb-", "cache", "fix", "set", "datum", "approximate", "shade", "multitexturing", "Pellacini", "et", "al.", "perform", "shade", "programmable", "graphic", "hardware", "-lsb-", "2005", "-rsb-", "use", "manually-written", "shader", "emulate", "RenderMan", "shader", "system", "require", "manual", "segmentation", "shader", "light-dependent", "light-independent", "component", "manual", "translation", "preview", "shader", "while", "allow", "manual", "optimization", "maximize", "preview", "performance", "significant", "burden", "we", "choose", "potentially", "sacrifice", "performance", "tremendously", "improve", "integration", "maintainability", "automate", "segmentation", "translation", "shader", "furthermore", "we", "extend", "prior", "deep-framebuffer", "system", "enable", "efficient", "rendering", "transparent", "surface", "multisampling", "effect", "motion", "blur", "finally", "we", "approach", "also", "automatically", "support", "editing", "many", "-lrb-", "user-selected", "-rrb-", "surface", "property", "because", "employ", "data-flow", "analysis", "respect", "arbitrary", "parameter", "Wexler", "et", "al.", "implement", "high-quality", "supersampling", "GPU", "-lsb-", "2005", "-rsb-", "focus", "final", "rendering", "while", "we", "optimize", "static", "visibility", "result", "different", "datum", "structure", "we", "build", "recent", "work", "direct-to-indirect", "transfer", "which", "exploit", "linearity", "global", "illumination", "cinematic", "relighting", "-lsb-", "ha", "san", "et", "al.", "2006", "-rsb-", "we", "apply", "similar", "principle", "multisampling", "transparency", "subsurface", "scattering", "Jones", "et", "al.", "segmented", "shader", "static", "dynamic", "subset", "cache", "shade", "information", "texture-space", "accelerate", "render", "same", "scene", "multiple", "time", "under", "similar", "configuration", "-lsb-", "2000", "-rsb-", "however", "technique", "only", "cache", "shade", "computation?not", "tessellation", "displacement", "etc.", "require", "manual", "shader", "segmentation", "we", "goal", "can", "fully", "meet", "pre-computed", "radiance", "transfer", "-lrb-", "prt", "-rrb-", "technique", "-lsb-", "Sloan", "et", "al.", "2002", "Ng", "et", "al.", "2003", "-rsb-", "because", "usually", "make", "assumption", "reflectance", "lighting", "have", "significant", "precomputation", "cost", "contrast", "we", "need", "handle", "effect", "local", "point", "light", "source", "arbitrary", "reflectance", "furthermore", "compute", "illumination", "itself", "large", "part", "we", "run-time", "calculation", "production", "light", "shader", "quite", "complex", "compiler", "specialization", "graphic", "computation", "first", "use", "ray", "trace", "-lsb-", "Hanrahan", "1983", "Mogensen", "1986", "Andersen", "1996", "-rsb-", "Guenter", "Knoblock", "Ruf", "develop", "datum", "specialization", "reduce", "cost", "recomputation", "when", "only", "certain", "shade", "parameter", "vary", "automatically", "segment", "shader", "parameterdependent", "independent", "component", "-lsb-", "1995", "1996", "-rsb-", "we", "leverage", "approach", "context", "lighting", "design", "extend", "analysis", "global", "data-flow", "through", "exist", "real-world", "RenderMan", "shader", "we", "solve", "specialization", "use", "graph", "formulation", "mention", "implement", "Knoblock", "Ruf", "-lsb-", "1996", "-rsb-", "allow", "we", "only", "specialize", "respect", "dynamic", "parameter", "also", "perform", "dead-code", "elimination", "other", "analysis", "all", "from", "single", "dependence", "analysis", "Peercy", "et", "al.", "-lsb-", "2000", "-rsb-", "bleiweiss", "preetham", "-lsb-", "2003", "-rsb-", "address", "compilation", "RenderMan", "shader", "onto", "graphic", "hardware", "we", "too", "exploit", "fact", "large", "subset", "RenderMan", "Shading", "language", "-lrb-", "rsl", "-rrb-", "can", "compile", "GPU", "we", "interest", "however", "use", "RSL", "GPU", "shade", "language", "automatically", "specialize", "final-frame", "shader", "create", "appropriate", "deep", "framebuffer", "interactive", "relighting", "configure", "light", "critical", "bottleneck", "modern", "production", "rendering", "recent", "advance", "have", "seek", "provide", "real-time", "preview", "use", "deep-framebuffer", "graphic", "hardware", "-lsb-", "gershbein", "Hanrahan", "2000", "Pellacini", "et", "al.", "2005", "-rsb-", "deep-framebuffer", "cache", "static", "value", "normal", "texture", "sample", "image", "space", "each", "time", "user", "update", "light", "parameter", "realtime", "shader", "interactively", "recompute", "image", "from", "cache", "unfortunately", "approach", "require", "substantial", "additional", "work", "from", "shader", "author", "example", "lpic", "system", "deploy", "Pixar", "-lsb-", "Pellacini", "et", "al.", "2005", "-rsb-", "least", "two", "version", "each", "shader", "need", "write", "place", "just", "one", "usual", "RenderMan", "shader", "use", "final", "rendering", "-lrb-", "additional", "code", "path", "cache", "datum", "-rrb-", "cg", "version", "use", "real-time", "preview", "we", "alleviate", "need", "author", "multiple", "version", "shader", "automatically", "translate", "unmodified", "RenderMan", "shader", "realtime", "shader", "precomputation", "shader", "translation", "part", "larger", "process", "automatically", "generate", "deep-framebuffer", "datum", "from", "unmodified", "exist", "scene", "theory", "some", "RenderMan", "code", "can", "translate", "GPU", "shader", "we", "have", "find", "practice", "dynamic", "part", "we", "production", "shader", "translate", "well", "contrast", "pure", "static", "compiler", "analysis", "we", "use", "postexecution", "cache", "compression", "supplement", "simple", "compiler", "analysis", "cache", "compression", "effectively", "reduce", "automaticallygenerated", "deep-framebuffer", "reasonable", "size", "complex", "production", "shader", "addition", "transparency", "motion", "blur", "antialiasing", "can", "critical", "judge", "appearance", "we", "introduce", "indirect", "framebuffer", "which", "enable", "effect", "without", "linearly", "scale", "render", "time", "similar", "RenderMan", "decouple", "shade", "from", "visibility", "also", "precompute", "final", "weight", "each", "shade", "sample", "relevant", "final", "pixel", "give", "complexity", "shot", "we", "handle", "we", "also", "use", "progressive", "refinement", "offer", "both", "interactive", "feedback", "-lrb-", "multiple", "frame", "per", "second", "-rrb-", "faithful", "final", "quality", "-lrb-", "potentially", "after", "few", "seconds", "-rrb-", "finally", "important", "facilitate", "implementation", "new", "pass", "preview", "system", "we", "use", "computation", "graph", "directly", "express", "dependency", "data-flow", "between", "pass", "implement", "shadow", "translucency", "we", "describe", "full", "production", "relighting", "system", "be", "deploy", "two", "studio", "different", "render", "workflow", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "25-2", "Ragan-Kelley", "et", "al.", "system", "design", "2.1", "Design", "Goals", "we", "primary", "objective", "give", "fixed", "scene", "geometry", "material", "viewpoint", "enable", "interactive", "manipulation", "all", "light", "source", "parameter", "include", "intensity", "position", "falloff", "well", "create", "remove", "light", "source", "restriction", "light", "come", "first", "from", "current", "production", "workflow", "where", "light", "source", "placement", "separate", "step", "end", "pipeline", "after", "all", "other", "aspect", "have", "be", "freeze", "we", "be", "also", "motivate", "technical", "limitation", "surface", "shader", "tend", "have", "more", "complexity", "could", "prove", "harder", "fully", "map", "graphic", "hardware", "however", "later", "become", "apparent", "we", "approach", "can", "also", "enable", "modification", "many", "all", "material", "appearance", "parameter", "we", "have", "seek", "facilitate", "although", "only", "secondary", "objective", "order", "receive", "widespread", "adoption", "production", "lighting", "design", "system", "must", "meet", "follow", "three", "major", "design", "goal", "high-performance", "preview", "minimize", "feedback", "time", "we", "primary", "goal", "specifically", "we", "wish", "provide", "low-latency", "feedback", "when", "user", "modify", "light", "parameter", "image", "refresh", "must", "instantaneous", "final", "quality", "might", "take", "few", "seconds", "through", "progressive", "refinement", "low-latency", "feedback", "critical", "seamless", "user", "interaction", "fast", "initial", "precomputation", "accept", "artist", "tool", "should", "make", "take", "longer", "begin", "work", "shot", "we", "seek", "keep", "initial", "preprocessing", "time", "short", "render", "one", "frame", "offline", "renderer", "high", "absolute", "render", "speed", "though", "secondary", "latency", "startup", "time", "absolute", "render", "speed", "must", "optimize", "seamless", "integration", "exist", "pipeline", "preview", "system", "should", "transparent", "user", "require", "additional", "work", "use", "within", "existing", "pipeline", "mean", "should", "stand", "exist", "offline", "render", "pipeline", "take", "same", "input", "unmodified", "RenderMan", "scene", "shader", "Producing", "same", "output", "use", "shade", "visibility", "computation", "extremely", "high", "fidelity", "final", "rendering", "include", "antialiasing", "motion", "blur", "transparency", "use", "same", "workflow", "particular", "same", "light", "editing", "GUI", "which", "vary", "from", "studio", "studio", "require", "we", "system", "communicate", "different", "GUI", "software", "ease", "implementation", "maintenance", "production", "render", "pipeline", "complex", "continually", "evolve", "preview", "system", "can", "afford", "same", "implementation", "investment", "should", "require", "major", "re-implementation", "whenever", "finalframe", "renderer", "update", "shader", "change", "pipeline", "alter", "we", "system", "must", "achieve", "effective", "reuse", "we", "system", "seek", "reuse", "exist", "pipeline", "wherever", "possible", "offload", "most", "precomputation", "directly", "exist", "offline", "pipeline", "flexibility", "we", "system", "develop", "two", "independent", "studio", "different", "pipeline", "toolset", "so", "we", "wish", "reuse", "much", "possible", "between", "two", "environment", "extensibility", "should", "easy", "possible", "support", "new", "functionality?from", "use", "new", "shader", "implement", "new", "multipass", "effects?in", "simple", "modular", "fashion", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "25-3", "input", "scene", "automatic", "preprocessor", "computation", "graph", "auxiliary", "datum", "RenderMan", "e.g.", "shadow", "geometry", "translucency", "sample", "cache", "scene", "cache", "compression", "specialize", "compiler", "caching", "surface", "shader", "surface", "shader", "light", "shader", "figure", "we", "system", "take", "input", "original", "RenderMan", "scene", "its", "shader", "we", "specialize", "compiler", "automatically", "separate", "shader", "static", "dynamic", "part", "use", "RenderMan", "cache", "static", "computation", "auxiliary", "datum", "dynamic", "part", "translate", "cg", "cache", "compression", "greatly", "reduce", "size", "cache", "datum", "preprocess", "generate", "computation", "graph", "encapsulate", "computation", "datum", "binding", "necessary", "re-render", "scene", "real-time", "engine", "execute", "graph", "generate", "intermediate", "datum", "-lrb-", "shadow", "map", "etc.", "-rrb-", "run", "dynamic", "shader", "over", "cache", "GPU", "new", "indirect", "framebuffer", "enable", "antialiasing", "transparency", "GUI", "application", "modify", "light", "parameter", "through", "graph", "interface", "2.2", "System", "Architecture", "we", "approach", "-lrb-", "fig.", "-rrb-", "can", "decompose", "automatic", "preprocess", "run-time", "phase", "communicate", "through", "dynamically-generated", "computation", "graph", "we", "take", "input", "same", "RenderMan", "scene", "shader", "use", "final", "rendering", "Automatic", "specialization", "First", "we", "automatically", "slice", "all", "surface", "shader", "static", "component", "can", "cache", "dynamic", "component", "execute", "real-time", "engine", "-lrb-", "section", "-rrb-", "surface", "shader", "we", "generate", "two", "new", "shader", "static", "precomputation", "shader", "which", "execute", "once", "final-frame", "renderer", "generate", "deep-framebuffer", "cache", "dynamic", "re-rendering", "shader", "-lrb-", "cg", "-rrb-", "which", "execute", "repeatedly", "over", "deep-framebuffer", "generate", "interactive", "preview", "we", "directly", "translate", "light", "shader", "execute", "together", "rerender", "surface", "shader", "GPU", "automatic", "specialization", "shader", "can", "expect", "yield", "performance", "penalty", "interactive", "preview", "compare", "manually", "optimize", "simplify", "code", "-lsb-", "gershbein", "Hanrahan", "2000", "Pellacini", "et", "al.", "2005", "-rsb-", "we", "context", "seamless", "integration", "take", "precedence", "over", "final", "performance", "another", "potential", "limitation", "automatic", "translation", "all", "RenderMan", "code", "can", "map", "GPU", "however", "we", "production", "shader", "have", "be", "issue", "indirect", "framebuffer", "we", "core", "real-time", "rendering", "similar", "traditional", "deep-framebuffer", "approach", "use", "cg", "shader", "perform", "computation", "all", "deep-framebuffer", "sample", "GPU", "however", "we", "introduce", "new", "level", "indirection", "through", "indirect", "framebuffer", "decouple", "shade", "sample", "from", "final", "pixel", "value", "thereby", "efficiently", "handle", "antialiasing", "motion", "blur", "transparency", "also", "enable", "progressive", "refinement", "-lrb-", "sec", "-rrb-", "cache", "compression", "we", "rely", "static", "preprocessing", "cache", "datum", "compensate", "overestimate", "compiler", "analysis", "well", "cull", "deep-framebuffer", "indirect", "framebuffer", "base", "visibility", "provide", "over", "order", "magnitude", "reduction", "total", "cached", "datum", "size", "while", "allow", "compiler", "remain", "relatively", "simple", "multipass", "render", "we", "enable", "multipass", "effect", "shadow", "mapping", "subsurface", "scattering", "require", "preprocessor", "also", "output", "auxiliary", "datum", "geometry", "need", "shadow", "mapping", "lighting", "sample", "translucency", "although", "translucency", "currently", "incur", "substantial", "cost", "we", "preview", "demonstrate", "generality", "we", "architecture", "computation", "graph", "overall", "re-rendering", "algorithm", "encode", "computation", "graph", "generate", "during", "preprocess", "from", "original", "scene", "shader", "graph", "provide", "specification", "how", "re-shade", "image", "from", "cache", "under", "new", "lighting", "configuration", "-lrb-", "section", "-rrb-", "computation", "graph", "provide", "two", "critical", "abstraction", "first", "encode", "dependence", "between", "different", "element", "real-time", "rendering", "which", "particularly", "critical", "progressive", "refinement", "multipass", "effect", "second", "graph", "abstract", "preprocessing", "from", "editing", "GUI", "so", "long", "generate", "graph", "conform", "certain", "basic", "convention", "preprocessing", "stage", "can", "update", "extend", "without", "affect", "GUI", "tool", "important", "we", "design", "goal", "integrate", "seamlessly", "multiple", "different", "workflow", "interactive", "preview", "render", "engine", "modeling", "guus", "temp", "render", "image", "deepand", "indirect", "aux", "framebuffer", "cache", "GPU", "dynamic", "cache", "surface", "shader", "dynamic", "light", "shader", "GPU", "parameter", "control", "shader", "Automatic", "Deep-Framebuffer", "Caching", "we", "wish", "automatically", "generate", "deep-framebuffer", "realtime", "preview", "we", "first", "need", "determine", "which", "part", "computation", "static", "vs.", "dynamic", "respect", "light", "parameter", "we", "create", "new", "RenderMan", "Shading", "language", "-lrb-", "rsl", "-rrb-", "shader", "compute", "output", "static", "value", "use", "RenderMan", "create", "deep-framebuffer", "cache", "we", "preprocess", "cache", "output", "RenderMan", "compress", "redundant", "irrelevant", "value", "finally", "we", "translate", "dynamic", "part", "computation", "real-time", "GPU", "shader", "access", "deep", "framebuffer", "texture", "previous", "work", "have", "achieve", "step", "manually", "we", "contribution", "make", "process", "fully", "automatic", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "25-4", "Ragan-Kelley", "et", "al.", "<dynamic>", "<dynamic>", "shader", "parse", "augment", "AST", "reachability", "analysis", "static/dynamic", "caching", "rule", "input", "shader", "abstract", "syntax", "tree", "-lrb-", "AST", "-rrb-", "dependency", "graph", "label", "graph", "figure", "specialize", "compiler", "input", "shader", "represent", "abstract", "syntax", "tree", "-lrb-", "AST", "-rrb-", "we", "augment", "encode", "dependency", "between", "variable", "expression", "decide", "expression", "dynamic", "we", "query", "whether", "depend", "any", "dynamic", "parameter", "once", "shader", "have", "be", "split", "we", "generate", "two", "new", "shader", "caching", "shader", "real-time", "shader", "RenderMan", "execute", "cache", "shader", "over", "scene", "cached", "value", "compress", "generate", "dense", "deep-framebuffer", "which", "read", "dynamic", "shader", "during", "preview", "3.1", "data-flow", "analysis", "specialization", "we", "represent", "string", "token", "include", "message", "pass", "identifier", "encode", "static", "string", "value", "float", "use", "unique", "id", "we", "build", "technique", "from", "data-flow", "analysis", "label", "static", "enable", "runtime", "code", "pass", "compare", "-lrb-", "though", "modify", "-rrb-", "dynamic", "part", "shader", "-lsb-", "Horwitz", "et", "al.", "1990", "rep", "et", "al.", "string", "GPU", "RSL", "also", "use", "string", "represent", "transform", "1995", "-rsb-", "we", "need", "conservatively", "identify", "all", "expression", "texture", "handle", "so", "we", "cg", "string", "type", "include", "necessary", "depend", "directly", "indirectly", "dynamic", "input", "parameter", "texture", "sampler", "matrix", "all", "major", "use", "string", "can", "naturally", "turn", "graph", "reachability", "problem", "expression", "shader", "dynamic", "reachable", "from", "finally", "rsl", "support", "computation", "arbitrary", "derivative", "dynamic", "parameter", "RenderMan", "separate", "surface", "light", "shader", "over", "surface", "cg", "also", "support", "derivative", "its", "fast", "approxand", "we", "focus", "specialize", "surface", "shader", "since", "light", "shader", "imation", "low-quality", "practice", "we", "find", "high", "quality", "mostly", "dynamic", "respect", "light", "parameter", "derivative", "only", "significant", "dynamic", "code", "large", "texture", "filter", "kernel", "primarily", "depend", "surface", "partial", "derivative", "dependence", "analysis", "first", "step", "we", "analysis", "-lrb-", "fig.", "-rrb-", "add", "which", "dynamic", "so", "we", "simply", "cache", "they", "when", "necessary", "global", "dependency", "transform", "abstract", "syntax", "tree", "-lrb-", "AST", "-rrb-", "representation", "shader", "dependency", "graph", "encode", "light", "translation", "while", "surface", "shader", "specialize", "light", "all", "dependency", "between", "expression", "we", "add", "dynamic", "node", "shader", "directly", "translate", "through", "same", "cg", "code", "generator", "connect", "dynamic", "parameter", "specify", "name", "similar", "RenderMan", "we", "generate", "cg", "light", "surface", "shader", "we", "simply", "query", "whether", "each", "expression", "depend", "separately", "combine", "they", "load", "time", "communicate", "dynamic", "parameter", "testing", "can", "reach", "dynamic", "node", "primarily", "through", "cg", "interface", "-lsb-", "Mark", "et", "al.", "2003", "-rsb-", "core", "global", "dependency", "rule", "describe", "separately", "-lsb-", "RaganThis", "approach", "can", "only", "automatically", "translate", "light", "shader", "Kelley", "2007", "-rsb-", "we", "perform", "dead-code", "elimination", "use", "same", "which", "do", "rely", "cache-required", "functionality?namely", "exterdependence", "graph", "connect", "output", "value", "new", "output", "nal", "call", "practice", "we", "light", "only", "call", "dso", "simple", "node", "operation", "like", "fast", "math", "routine", "which", "trivially", "replace", "native", "instruction", "GPU", "so", "we", "do", "find", "problematic", "cache-required", "code", "we", "caching", "analysis", "constrain", "dynamic", "shader", "operation", "can", "execute", "GPU", "we", "can", "force", "certain", "operations?namely", "call", "external", "routine", "unimplemented", "shadeop", "-lrb-", "e.g.", "trace", "-rrb-", "label", "cache", "even", "dependence", "analysis", "label", "they", "dynamic", "static/dynamic", "analysis", "eliminate", "most", "operation", "we", "shader", "we", "can", "recognize", "light-dependent", "cache-required", "node", "error", "we", "find", "simply", "warn", "user", "compute", "value", "statically", "cache", "time", "often", "provide", "usable", "preview", "result", "3.2", "Code", "Generation", "translation", "once", "we", "have", "decide", "which", "computation", "cache", "which", "execute", "dynamically", "during", "preview", "we", "generate", "two", "new", "surface", "shader", "one", "each", "phase", "RenderMan", "precomputation", "Caching", "computation", "emit", "new", "RSL", "shader", "when", "branch", "condition", "dynamic", "control", "flow", "dynamic", "preview", "shader", "may", "differ", "from", "caching", "execution", "value", "cache", "inside", "dynamic", "conditional", "caching", "shader", "must", "execute", "both", "potential", "branch", "finally", "we", "generate", "new", "RenderMan", "scene", "replace", "each", "shader", "its", "caching", "equivalent", "we", "run", "through", "RenderMan", "generate", "deep", "framebuffer", "-lrb-", "fig.", "-rrb-", "cg", "code", "generation", "Dynamic", "surface", "shader", "emit", "new", "cg", "shader", "which", "read", "deep-framebuffer", "cache", "texture", "key", "issue", "translate", "RSL", "Cg", "mimic", "renderman?s", "richer", "data-flow", "execution", "semantics", "communication", "light", "color", "direction", "accomplish", "through", "share", "global", "variable", "RSL", "however", "RSL", "also", "allow", "surface", "light", "access", "each", "other?s", "parameter", "name", "through", "messagepassing", "we", "implement", "communicate", "parameter", "through", "global", "variable", "3.3", "specialization", "result", "Figure", "summarize", "result", "we", "shader", "specialization", "approach", "note", "dynamic", "shader", "complexity", "depend", "both", "light", "surface", "shader", "generic", "surface", "multipurpose", "??", "bershader", "form", "basis", "most", "we", "custom", "shader", "however", "do", "result", "dramatically", "larger", "dynamic", "shader", "than", "simpler", "surface", "because", "most", "code", "static", "dynamic", "code", "dominate", "light", "computation", "rsl", "instruction", "tend", "higher-level", "equivalent", "computation", "require", "larger", "number", "GPU", "instruction", "size", "we", "caching", "shader", "28k", "22k", "rsl", "instruction", "Generic", "surface", "metallic", "paint", "respectively", "Pellacini", "et", "al.", "-lsb-", "2005", "-rsb-", "describe", "challenge", "binding", "overhead", "number", "unique", "surface", "generate", "specialization", "we", "technique", "have", "more", "shader", "than", "original", "shot", "we", "shot", "usually", "use", "most", "dozen", "unique", "shader", "which", "contrast", "thousand", "unique", "shader", "per", "shot", "use", "other", "studio", "-lsb-", "Pellacini", "et", "al.", "2005", "-rsb-", "further", "emphasize", "we", "context", "automatic", "specialization", "primarily", "motivate", "rate", "which", "shader", "change", "-lrb-", "well", "ability", "edit", "surface", "parameter", "-rrb-", "total", "number", "main", "challenge", "specialization", "lie", "number", "value", "need", "cache", "large", "shader", "can", "easily", "reach", "hundred", "scalar", "per", "deep-framebuffer", "element", "potentially", "exceed", "gpu?s", "memory", "make", "cache", "compression", "well", "tiling", "describe", "section", "critical", "give", "increase", "program", "size", "limit", "latest", "gpus", "cg", "codegen", "could", "generate", "single", "compound", "shader", "perform", "dynamic", "dispatch", "subroutine", "implement", "each", "surface", "light", "technique", "already", "use", "effectively", "game", "cache", "RSL", "shader", "cache", "codegen", "RenderMan", "compression", "translation", "texture", "codegen", "lookup", "deep-framebuffer", "dynamic", "cg", "shader", "cache", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "25-5", "Configuration", "RSL", "instr", "GPU", "instr", "GPU", "reg", "generic", "surface", "19,673", "-lrb-", "combine", "surface/light", "-rrb-", "spot", "+1290", "4653", "28", "point", "+626", "3941", "24", "reflection", "+351", "1942", "20", "reflection", "environment", "+733", "2721", "23", "ambient", "environment", "+367", "2724", "22", "occlusion", "msg", "+28", "863", "12", "metallic", "paint", "22274", "spot", "+1290", "4461", "26", "simple", "surface", "4171", "spot", "+1290", "3368", "21", "Figure", "compile", "RenderMan", "-lrb-", "RSL", "-rrb-", "vs.", "compile", "GPU", "assembly", "instruction", "number", "GPU", "register", "note", "indicated", "total", "complexity", "GPU", "dynamic", "shader", "include", "both", "light", "surface", "while", "RenderMan", "instruction", "give", "separately", "3.4", "Cache", "Compression", "static", "code", "analysis", "challenging", "tend", "conservative", "contrast", "we", "find", "apply", "simple", "post-process", "we", "final", "cached", "datum", "provide", "tremendous", "reduction", "cache", "complexity", "sufficient", "enable", "effective", "automatic", "deep-framebuffer", "generation", "simple", "compiler", "after", "cache", "we", "analyze", "all", "channel", "deep-framebuffer", "eliminate", "those", "whose", "value", "constant", "over", "frame", "non-varying", "term", "convert", "static", "constant", "code", "identical", "other", "channel", "non-unique", "term", "replace", "reference", "single", "common", "channel", "optimization", "can", "reduce", "number", "cached", "component", "more", "than", "factor", "-lrb-", "fig.", "-rrb-", "because", "optimization", "inline", "significant", "new", "static", "datum", "dynamic", "cg", "shader", "also", "help", "cg", "compiler", "reduce", "runtime", "shader", "complexity", "through", "constant", "folding", "Figure", "Shader", "dynamic", "vary", "unique", "-lrb-", "caching", "analysis", "-rrb-", "-lrb-", "compress", "-rrb-", "generic", "surface", "402", "145", "97", "metallic", "paint", "450", "150", "97", "number", "-lrb-", "scalar", "-rrb-", "value", "per", "deep-framebuffer", "sample", "scene", "fig.", "under", "compression", "Dynamic", "term", "determine", "initial", "caching", "analysis", "varying", "term", "remain", "after", "elimination", "value", "constant", "over", "frame", "unique", "term", "remain", "after", "further", "elimination", "duplicated", "value", "3.5", "specialize", "surface", "parameter", "key", "advantage", "automatic", "specialization", "allow", "user", "selectively", "tweak", "some", "surface", "well", "light", "parameter", "when", "user", "select", "surface", "parameter", "dynamic", "compiler", "can", "just", "easily", "generate", "code", "configurable", "surface", "parameter", "-lrb-", "fig.", "-rrb-", "many", "most", "commonly", "tune", "parameter", "gain", "factor", "specular", "roughness", "can", "dynamically", "edit", "significantly", "extend", "initially-planned", "range", "from", "light", "look-design", "practice", "main", "overhead", "editing", "surface", "parameter", "require", "reevaluation", "all", "light", "source", "Figure", "editable", "surf", "parameter", "GPU", "instr", "reg", "relative", "perf", "-lrb-", "baseline", "-rrb-", "3518", "21", "100", "18", "-lrb-", "gain", "-rrb-", "3856", "27", "90", "41", "-lrb-", "gain", "specularity", "-rrb-", "3973", "29", "86", "preview", "performance", "function", "number", "editable", "surface", "parameter", "variant", "Generic", "surface", "editing", "41", "scalar", "vector", "surface", "parameter", "do", "significantly", "slow", "render", "compare", "light", "parameter", "alone", "Figure", "Motion", "blur", "transparency", "leave", "Lightspeed", "right", "RenderMan", "difference", "statistically", "insignificant", "-lrb-", "0.1", "-rrb-", "Figure", "Lightspeed", "render", "from", "motion-blurred", "RenderMan", "frame", "13x13", "pixel", "sample", "shade", "rate", "720x306", "RenderMan", "shade", "1.5", "micropolygon", "filter", "21m", "subpixel", "sample", "render", "image", "while", "we", "preprocessing", "distil", "only", "467k", "visible", "shade", "sample", "3.8", "unique", "subpixel", "contribution", "produce", "identical", "result", "shade", "time", "still", "significantly", "dominate", "resampling", "time", "indirect", "framebuffer", "traditional", "deep-framebuffer", "pure", "image-space", "structure", "which", "allow", "they", "scale", "image", "size", "scene", "complexity", "however", "because", "interpret", "pixel", "discrete", "surface", "shade", "sample", "can", "directly", "express", "effect", "where", "multiple", "shade", "sample", "contribute", "pixel", "antialiasing", "motion", "blur", "depth-of-field", "transparency", "direct", "extension", "would", "use", "supersampling", "greatly", "increase", "storage", "shade", "cost", "scale", "poorly", "variable", "depth", "complexity", "introduce", "transparency", "inspire", "decoupling", "between", "shading", "visibility", "computation", "central", "renderman?s", "REYES", "pipeline", "we", "introduce", "layer", "indirection", "between", "deep-framebuffer", "shading", "visibility/display", "sample", "through", "second", "datum", "structure", "we", "call", "indirect", "framebuffer", "we", "first", "review", "multisampling", "approach", "use", "RenderMan", "before", "introduce", "we", "new", "datum", "structure", "background", "renderman?s", "REYES", "architecture", "achieve", "high", "quality", "generality", "antialiasing", "motion", "blur", "depthof-field", "supersample", "visibility", "computation", "while", "reduce", "shade", "cost", "reuse", "shade", "value", "rather", "than", "supersample", "they", "-lsb-", "cook", "et", "al.", "1987", "Apodaca", "Gritz", "2000", "-rsb-", "while", "smooth", "reconstruction", "motion", "blur", "depth-of-field", "fine", "geometry", "may", "require", "100", "more", "visibility", "sample", "shade", "rate", "commonly", "just", "roughly", "one", "shade", "sample", "per", "output", "pixel", "RenderMan", "use", "three", "core", "datum", "structure", "encode", "shading", "visibility", "-lrb-", "fig.", "ii", "-rrb-", "shade", "perform", "object", "space", "surface", "shade", "sample", "call", "micropolygon", "pixel", "contain", "uniform", "density", "subpixel", "sample", "distribute", "screen-space", "-lrb-", "spatial", "antialiasing", "-rrb-", "time", "-lrb-", "motion", "blur", "-rrb-", "aperture", "location", "-lrb-", "depth-of-field", "-rrb-", "each", "subpixel", "sample", "maintain", "depth-ordered", "visible", "point", "list", "pointer", "micropolygon", "visible", "along", "ray", "RenderMan", "first", "tessellate", "all", "primitive", "micropolygon", "shader", "execute", "over", "all", "vertex", "micropolygon", "grid", "pro-", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "25-6", "Ragan-Kelley", "et", "al.", "RenderMan", "REYES", "0.3", "1.0", "1.0", "0.3", "-lrb-", "1.0-0", ".3", "-rrb-", "1.0", "0.3", "0.3", "1.0", "0.3", "0.3", "-lrb-", "1.0-0", ".3", "-rrb-", "-lrb-", "-rrb-", "micropolygon", "-lrb-", "ii", "-rrb-", "pixel-sample", "hit", "list", "Lightspeed", "indirect", "framebuffer", "x4", "x4", "x1", "x3", "x3", "0.175", "0.225", "0.425", "x2", "x2", "shade", "combination", "weighted", "shade", "nal", "pixel", "color", "sample", "Figure", "-lrb-", "iii", "-rrb-", "deep-framebuffer", "-lrb-", "iv", "-rrb-", "indirect", "framebuffer", "indirect", "framebuffer", "densely", "encode", "variablerate", "visibility", "information", "enable", "efficient", "antialiasing", "transparency", "under", "static", "view", "resample", "denselypacked", "deep-framebuffer", "screen-space", "precisely", "reproduce", "renderman?s", "high-quality", "antialiasing", "linearize", "consolidate", "give", "static", "visibility", "configuration", "require", "far", "fewer", "unique", "sample", "same", "result", "duce", "color", "per", "vertex", "-lrb-", "fig.", "-rrb-", "RenderMan", "compute", "visibility", "-lrb-", "hiding", "-rrb-", "test", "each", "micropolygon", "against", "each", "subpixel", "sample", "potentially", "cover", "-lrb-", "rasterization", "-rrb-", "take", "account", "aperture", "time", "value", "sample", "depth", "test", "perform", "transparency", "handle", "maintain", "z-ordered", "list", "micropolygon", "pointer", "each", "subpixel", "sample", "-lrb-", "fig.", "ii", "-rrb-", "color", "subpixel", "sample", "compute", "look", "up", "color", "opacity", "each", "micropolygon", "composit", "they", "depth-order", "final", "pixel", "value", "weighted", "average", "color", "subpixel", "since", "subpixel", "jitter", "space", "time", "aperture", "location", "achieve", "high", "quality", "multisampling", "effect", "while", "keep", "shade", "cost", "tractable", "4.1", "indirect", "Framebuffer", "Data", "structure", "we", "note", "each", "final", "filtered", "pixel", "color", "ultimately", "correspond", "simple", "linear", "combination", "shaded", "color", "all", "micropolygon", "visible", "under", "pixel", "even", "transparency", "which", "traditionally", "present", "challenge", "due", "order-dependence", "ultimately", "factor", "single", "weight", "because", "we", "assume", "fix", "view", "configuration", "consider", "example", "Fig.", "ii", "first", "subpixel?s", "color", "linear", "combination", "shade", "sample", "weight", "give", "transparency", "final", "pixel", "value", "combination", "color", "shade", "sample", "weight", "0.175", "0.225", "0.435", "when", "visibility", "static", "cumulative", "linear", "weight", "similarly", "become", "static", "similar", "principle", "direct-to-indirect", "transfer", "-lsb-", "ha", "san", "et", "al.", "2006", "-rsb-", "context", "multisampling", "transparency", "we", "directly", "exploit", "static", "linearity", "while", "decouple", "shading", "final", "pixel", "value", "we", "first", "use", "standard", "deep", "framebuffer", "instead", "organize", "per", "pixel", "we", "preprocess", "cache", "datum", "each", "shade", "sample", "-lrb-", "fig.", "iii", "-rrb-", "we", "real-time", "dynamic", "shader", "execute", "over", "cache", "output", "per-shading-sample", "color", "we", "indirect", "framebuffer", "encapsulate", "linear", "nature", "RenderMan", "we", "approach", "figure", "resolution", "sample", "shade", "subpix", "shade", "indir", "914x389", "13x13", "2.1", "32m", "633k", "1.6", "720x306", "13x13", "1.5", "21m", "467k", "3.8", "12", "640x376", "4x4", "2.5", "2.3", "327k", "716k", "15", "-lrb-", "0.1", "-rrb-", "720x389", "8x8", "54m", "121m", "21m", "35m", "15", "-lrb-", "0.6", "-rrb-", "720x389", "8x8", "43m", "58m", "11m", "17m", "15", "-lrb-", "1.0", "-rrb-", "720x389", "8x8", "25m", "17m", "3.9", "5.7", "figure", "10", "original", "RenderMan", "micropolygon", "pixelsample", "output", "complexity", "compare", "we", "compress", "indirect", "framebuffer", "number", "sample", "fig.", "15", "12", "static", "visibility", "compression", "losslessly", "reduce", "deep-framebuffer", "shading", "sample", "3-8x", "relative", "renderman?s", "shaded", "micropolygon", "reduce", "number", "unique", "indirect", "framebuffer", "sample", "3-20x", "relative", "renderman?s", "subpixel", "sample", "final", "color", "store", "each", "pixel", "list", "weight", "pointer", "deep-framebuffer", "output", "-lrb-", "fig.", "iv", "-rrb-", "example", "pixel", "Figure", "iii", "correspond", "three", "entry", "indirect", "framebuffer", "we", "need", "efficiently", "represent", "variable-length", "list", "shade", "value", "influence", "each", "pixel", "enable", "progressive", "rendering", "we", "use", "scatter", "strategy", "where", "point", "render", "each", "pixel", "location", "accumulate", "color", "contribution", "each", "indirect", "framebuffer", "entry", "encode", "vertex", "array", "point", "contain", "pointer", "shade", "sample", "-lrb-", "texture", "coordinate", "-rrb-", "weight", "output", "pixel", "coordinate", "-lrb-", "-rrb-", "render", "vertex", "array", "blend", "enable", "scatter", "weighted", "color", "final", "pixel", "note", "one", "entry", "deep", "framebuffer", "result", "shaded", "color", "often", "contribute", "multiple", "neighbor", "pixel", "especially", "presence", "motion", "blur", "highlight", "effectiveness", "we", "decoupling", "-lrb-", "RenderMan", "-rrb-", "where", "complex", "multisampling", "effect", "achieve", "without", "scale", "cost", "shade", "we", "implementation", "currently", "limit", "static", "opacity", "Dynamic", "transparency", "could", "support", "recompute", "weight", "fly", "light-dependent", "transparency", "do", "occur", "we", "shader", "we", "also", "do", "currently", "handle", "color", "transparency", "though", "simply", "require", "store", "rgb", "weight", "independently", "blend", "each", "color", "channel", "4.2", "visibility", "Compression", "use", "static", "visibility", "information", "indirect", "framebuffer", "we", "apply", "two", "key", "transformation", "cache", "datum", "losslessly", "compress", "its", "size", "static", "linearization", "indirect", "framebuffer", "coalesce", "all", "visibility", "sample", "which", "reference", "same", "shade", "sample", "same", "pixel", "single", "combined", "indirect", "framebuffer", "weight", "provide", "3-20x", "reduction", "size", "indirect", "framebuffer", "while", "produce", "same", "output", "-lrb-", "fig.", "10", "-rrb-", "we", "cull", "all", "deep-framebuffer", "shading", "sample", "reference", "least", "one", "indirect", "framebuffer", "sample", "we", "maintain", "local", "neighborhood", "where", "necessary", "derivative", "computation", "optimization", "reduce", "number", "indirect", "framebuffer", "sample", "3-20x", "number", "deep-framebuffer", "sample", "3-8x", "-lrb-", "fig.", "10", "-rrb-", "loss", "generality", "even", "complex", "scene", "involve", "motion", "blur", "-lrb-", "fig.", "-rrb-", "transparent", "hair", "-lrb-", "fig.", "15", "-rrb-", "reduce", "only", "storage", "size", "also", "computation", "because", "shade", "apply", "once", "per-deep-framebuffer", "sample", "resampling", "once", "per-indirect", "framebuffer", "sample", "combine", "dense", "packing", "shade", "value", "optimization", "generally", "allow", "even", "heavily", "multisampled", "shot", "transparency", "require", "little", "more", "storage", "than", "simple", "single-sampled", "image-space", "deepframebuffer", "render", "interactively", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "25-7", "scalability", "progressive", "refinement", "we", "system", "must", "scale", "final-resolution", "preview", "massive", "scene", "complex", "shader", "while", "maintain", "interactivity", "5.1", "Tiling", "High", "resolution", "preview", "more", "complex", "shader", "may", "increase", "cache", "size", "beyond", "GPU", "memory", "we", "divide", "oversized", "cache", "screen-space", "tile", "small", "enough", "all", "hardware", "constraint", "each", "tile", "contain", "indirect", "framebuffer", "couple", "deepframebuffer", "all", "shade", "sample", "visible", "those", "indirect", "framebuffer", "sample", "we", "also", "use", "texture", "atlas", "because", "we", "deepframebuffer", "may", "contain", "more", "channel", "than", "number", "bindable", "texture", "5.2", "progressive", "refinement", "we", "rely", "progressive", "refinement", "offer", "both", "interactive", "feedback", "slower", "yet", "faithful", "final", "image", "quality", "we", "progressively", "refine", "resolution", "typically", "step", "first", "step", "we", "begin", "4x4", "2x2", "pixel", "block", "next", "we", "increase", "full", "resolution", "only", "one", "indirect", "framebuffer", "value", "per", "pixel", "final", "step", "we", "use", "full", "multisample", "highest", "quality", "each", "stage", "represent", "group", "sample", "we", "indirect", "framebuffer", "we", "order", "indirect", "framebuffer", "sample", "give", "pixel", "weight", "accumulate", "they", "progressively", "pass", "simply", "normalize", "subpixel", "weight", "SRC", "ALPHA", "one", "minus", "SRC", "ALPHA", "instead", "additive", "blending", "we", "maintain", "appropriate", "brightness", "shade", "only", "update", "point", "reference", "indirect", "framebuffer", "sample", "give", "refinement", "batch", "also", "help", "guarantee", "performance", "massive", "scene", "because", "first", "few", "refinement", "level", "can", "constrain", "fit", "entirely", "GPU", "finally", "we", "often", "disable", "shadow", "lowest", "refinement", "tile", "we", "deep-framebuffer", "store", "set", "shade", "sample", "group", "surface", "type", "batch", "multiple", "progressive", "refinement", "pass", "Passes", "store", "2d", "texture", "arbitrary", "layout", "-lrb-", "2x2", "quad", "maintain", "derivative", "-rrb-", "practice", "shade", "sample", "store", "accord", "order", "which", "RenderMan", "output", "they", "5.3", "light", "caching", "like", "prior", "lighting", "design", "system", "we", "exploit", "linearity", "-lrb-", "most", "-rrb-", "lighting", "cache", "contribution", "from", "all", "light", "currently", "be", "edit", "user", "we", "store", "light", "cache", "get", "update", "when", "subset", "light", "temporarily", "freeze", "practice", "when", "light", "unfrozen", "its", "contribution", "subtract", "from", "cache", "new", "frozen", "light?s", "contribution", "add", "we", "retain", "old", "parameter", "state", "which", "cache", "generate", "maintain", "correctness", "when", "subtract", "speed", "up", "freezing", "when", "work", "multiple", "ten", "light", "source", "have", "prove", "numerically", "stable", "over", "long", "edit", "session", "when", "use", "32-bit", "floating-point", "cache", "change", "surface", "parameter", "require", "reshade", "surface", "all", "light", "scene", "few", "light", "still", "comfortably", "interactive", "near-final", "shot", "dozen", "light", "may", "subinteractive", "still", "take", "only", "few", "seconds", "useful", "feedback", "light", "caching", "significantly", "complicate", "introduction", "progressive", "refinement", "because", "we", "wish", "provide", "initial", "feedback", "user", "quickly", "possible", "common", "lowest", "refinement", "level", "light", "cache", "valid", "while", "higher", "refinement", "level", "various", "invalid", "state", "order", "update", "cache", "we", "maintain", "table", "cached", "light", "parameter", "each", "light", "every", "refinement", "level", "give", "cache", "level", "valid", "light", "cached", "parameter", "match", "light?s", "current", "parameter", "cache", "update", "reshading", "subtract", "contribution", "old", "configuration", "shade", "add", "new", "contribution", "Multipass", "Rendering", "Management", "so", "far", "we", "have", "focus", "purely", "local", "illumination", "computation", "however", "global", "effect", "shadow", "translucency", "must", "also", "reproduce", "we", "first", "show", "how", "can", "include", "we", "approach", "use", "multipass", "rendering", "discuss", "both", "necessary", "preprocessing", "real-time", "component", "we", "address", "critical", "software", "architecture", "issue", "make", "development", "we", "system", "tractable", "complex", "dependence", "between", "multipass", "effect", "indirect", "framebuffer", "progressive", "refinement", "make", "important", "develop", "abstraction", "facilitate", "inclusion", "new", "effect", "manage", "dependence", "well", "abstract", "key", "low-level", "aspect", "data-flow", "binding", "GPU", "fig.", "11", "summarize", "data-flow", "we", "final", "real-time", "computation", "include", "shadow", "mapping", "translucency", "indirect", "framebuffer", "effect", "...", "...", "shade", "re", "nement", "shadow", "mapping", "light", "shading", "re", "nement", "light", "cache", "shadow", "geometry", "add", "update", "render", "indirect", "shaded", "color", "framebuffer", "shadow", "map", "shade", "main", "shade", "sample", "subsurface", "scatter", "deep-framebuffer", "accumulate", "translucency", "gather", "sample", "deep-framebuffer", "translucency", "image", "shade", "contribution", "index", "shaded", "color", "accumulate", "accumulate", "hierarchy", "figure", "11", "data-flow", "dependency", "multipass", "render", "progressive", "refinement", "we", "abstract", "manage", "dependency", "use", "computation", "graph", "automatically", "generate", "feature", "specific", "scene", "during", "preprocessing", "6.1", "Shadow", "mapping", "Shadow", "map", "illustrate", "how", "multipass", "effect", "from", "final", "render", "pipeline", "can", "include", "we", "architecture", "Shadow", "map", "necessitate", "one", "extra", "pass", "per", "light", "require", "auxiliary", "datum", "from", "preprocessor", "-lrb-", "scene", "geometry", "-rrb-", "real-time", "preview", "shadow", "map", "pass", "communicate", "main", "pass", "through", "texture", "we", "graph", "interface", "-lrb-", "present", "below", "-rrb-", "manage", "communication", "dependence", "when", "parameter", "edit", "during", "caching", "we", "run", "RenderMan", "second", "time", "over", "scene", "extract", "micropolygon", "after", "all", "transform", "displacement", "apply", "we", "store", "object", "id", "support", "selective", "shadow", "casting", "receive", "per-object", "specialization", "RenderMan", "shadow", "map", "call", "flag", "mark", "dynamic", "replace", "dynamic", "code", "cg", "shadow", "map", "lookup", "when", "render", "shadow", "map", "we", "also", "render", "object", "id", "allow", "shadow", "assignment", "modify", "real-time", "per-object", "basis", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "25-8", "Ragan-Kelley", "et", "al.", "6.2", "Translucency", "Subsurface", "scattering", "require", "integral", "incident", "light", "flux", "time", "bssrdf", "diffusion", "kernel", "over", "neighborhood", "each", "visible", "point", "we", "have", "adapt", "Jensen", "Buhler?s", "hierarchical", "two-pass", "approach", "-lsb-", "2002", "-rsb-", "exactly", "use", "we", "exist", "offline", "shader", "real-time", "preview", "method", "first", "create", "hierarchy", "irradiance", "sample", "which", "enable", "fast", "hierarchical", "evaluation", "integral", "we", "scheme", "build", "work", "Ha", "san", "et", "al.", "-lsb-", "2006", "-rsb-", "indirect", "lighting", "instead", "wavelet", "approach", "we", "directly", "use", "Jensen", "Buhler?s", "octree", "hierarchy", "-lsb-", "2002", "-rsb-", "translucency", "we", "must", "distinguish", "shading", "visible", "shade", "sample", "describe", "section", "irradiance", "computation", "gather", "sample", "use", "estimate", "subsurface", "scattering", "-lsb-", "jensen", "Buhler", "2002", "-rsb-", "particular", "latter", "can", "have", "view-dependent", "term", "usually", "only", "require", "albedo", "normal", "information", "we", "bake", "information", "during", "preprocess", "separate", "translucency", "deep-framebuffer", "generate", "simple", "dynamic", "cg", "shader", "base", "we", "offline", "irradiance", "shader", "evaluate", "irradiance", "-lrb-", "diffuse", "shade", "-rrb-", "during", "runtime", "each", "visible", "shade", "sample", "we", "cache", "index", "set", "node", "irradiance", "hierarchy", "contribute", "translucency", "we", "also", "store", "corresponding", "bssrdf", "coefficient", "weight", "-lrb-", "dipole", "kernel", "-rrb-", "-lsb-", "Jensen", "Buhler", "2002", "-rsb-", "distance", "allow", "dynamic", "editing", "scattering", "depth", "interactive", "preview", "we", "first", "evaluate", "irradiance", "each", "gather", "sample", "use", "dynamic", "diffuse", "shader", "translucency", "deep", "framebuffer", "provide", "we", "leaf", "value", "we", "hierarchy", "store", "texture", "we", "use", "iterative", "blend", "pass", "level", "octree", "accumulate", "value", "higher-level", "node", "sum", "child", "all", "octree", "value", "store", "same", "texture", "map", "leaf", "we", "can", "compute", "color", "visible", "shade", "sample", "because", "only", "accumulation", "weight", "actual", "octree", "traversal", "depend", "bssrdf", "coefficient", "lookup", "octree", "record", "statically", "during", "preprocessing", "encode", "vertex", "array", "much", "like", "indirect", "framebuffer", "we", "instead", "store", "static", "bssrdf", "attenuation", "distance", "term", "per-lookup", "albedo", "modulation", "per-visible-point", "we", "dynamically", "compute", "bssrdf", "contribution", "base", "dynamic", "scatter", "depth", "-lrb-", "sigma", "-rrb-", "value", "use", "fragment", "shader", "while", "accumulate", "each", "lookup", "hierarchy?s", "irradiance", "value", "use", "static", "index", "record", "during", "preprocessing", "note", "translucency", "computation", "perform", "granularity", "shade", "sample", "benefit", "from", "decoupling", "we", "indirect", "framebuffer", "both", "progressive", "refinement", "overall", "efficiency", "result", "we", "initial", "result", "-lrb-", "fig.", "12", "-rrb-", "while", "promise", "fidelity", "demonstrate", "need", "progressive", "shading", "technique", "while", "final", "scattering", "contribution", "evaluate", "progressively", "per", "visible", "shade", "point", "static", "octree", "lookup", "require", "translucency", "deep-framebuffer", "completely", "shaded", "prior", "any", "accumulation", "practice", "deep-framebuffer", "can", "even", "larger", "than", "primary", "deep-framebuffer", "1.3", "point", "example", "mean", "while", "change", "scattering", "coefficient", "render", "interactively", "-lrb-", "hz", "-rrb-", "scene", "base", "shader", "render", "2-10", "hz", "initial", "refinement", "exclude", "scattering", "computation", "reevaluate", "subsurface", "scattering", "result", "take", "several", "seconds", "reach", "initial", "refinement", "-lrb-", "though", "subsequent", "refinement", "very", "fast", "because", "octree", "already", "evaluate", "-rrb-", "we", "consider", "subsample", "approximation", "technique", "progressive", "refinement", "leave", "future", "work", "6.3", "Multipass", "Computation", "Graph", "Multipass", "algorithm", "shadow", "mapping", "translucency", "together", "indirect", "framebuffer", "progressive", "refinement", "introduce", "complex", "data-dependency", "between", "computation", "Figure", "12", "subsurface", "scattering", "coefficient", "can", "edit", "interactively", "top", "less", "translucency", "bottom", "more", "translucency", "preview", "render", "initial", "refinement", "hz", "under", "change", "coefficient", "reshade", "1.3", "million-point", "translucency", "buffer", "take", "several", "seconds", "eye", "contain", "multiple", "transparent", "layer", "appear", "black", "without", "indirect", "framebuffer", "furthermore", "make", "we", "system", "extensible", "enforce", "abstraction", "between", "various", "component", "require", "more", "care", "than", "we", "initially", "anticipate", "we", "original", "monolithic", "engine", "quickly", "become", "challenging", "maintain", "we", "therefore", "choose", "abstract", "individual", "algorithm", "from", "overall", "data-flow", "through", "real-time", "rendering", "pipeline", "-lrb-", "fig.", "11", "-rrb-", "use", "dependency", "graph", "structure", "which", "individual", "computation", "encapsulate", "node", "node", "communicate", "through", "port", "which", "abstract", "computation", "from", "dependency", "data-flow", "global", "data-flow", "encode", "edge", "between", "port", "we", "core", "computation", "graph", "library", "also", "abstract", "low-level", "aspect", "shader", "datum", "management", "GPU", "include", "library", "basic", "building", "block", "node", "graph", "instance", "scene", "generate", "automatically", "compiler", "preprocessing", "stage", "we", "pipeline", "use", "internally", "user", "interface", "application", "implementation", "result", "Figure", "13", "summarize", "we", "system?s", "fully-automatic", "performance", "two", "we", "shot", "-lrb-", "fig.", "12", "-rrb-", "cache", "size", "fit", "within", "current", "GPU", "resource", "though", "we", "system", "scale", "support", "out-of-core", "shot", "much", "higher", "resolution", "even", "more", "complex", "shader", "we", "report", "all", "result", "we", "current", "deploy", "artist", "workstation", "dual", "2.6", "GHz", "AMD", "Opteron", "2218", "processor", "8gb", "RAM", "NVIDIA", "Quadro", "FX", "5500", "-lrb-", "g71", "-rrb-", "graphic", "we", "generally", "limit", "capability/performance", "curve", "we", "current", "hardware", "preliminary", "result", "suggest", "major", "performance", "improvement", "next-generation", "hardware", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "25-9", "Figure", "13", "Pirate", "-lrb-", "12", "-rrb-", "robot", "-lrb-", "-rrb-", "resolution", "640x376", "914x389", "supersampling", "4x4", "13x13", "light", "42", "RenderMan", "-lrb-", "total", "-rrb-", "409", "sec", "3406", "sec", "irradiance", "shade", "111", "sec", "material", "shader", "material", "instance", "44", "light", "shader", "light", "instance", "42", "caching", "-lrb-", "total", "-rrb-", "1425", "sec", "931", "sec", "initialization", "sec", "18", "sec", "shader", "specialization", "24", "sec", "63", "sec", "deep-framebuffer", "caching", "627", "sec", "499", "sec", "shadow", "geometry", "caching", "105", "sec", "164", "sec", "cache", "compression", "60", "sec", "187", "sec", "octree", "compression", "600", "sec", "preview", "irradiance", "shading", "-lrb-", "light", "-rrb-", "sec", "interaction", "-lrb-", "irradiance", "cache", "-rrb-", "0.5", "sec", "coarse", "refinement", "4x4", "block", "0.1", "sec", "full", "refinement", "-lrb-", "light", "change", "-rrb-", "10", "sec", "2.7", "sec", "full", "refinement", "-lrb-", "light", "-rrb-", "29", "sec", "-lrb-", "light", "-rrb-", "31.7", "-lrb-", "42", "light", "-rrb-", "deep-framebuffer", "104", "mb", "256", "mb", "indirect", "framebuffer", "33", "mb", "29", "mb", "irradiance", "deep-framebuffer", "83", "mb", "scattering", "index", "buffer", "436", "MB", "System", "performance", "compare", "we", "rendermanbased", "offline", "pipeline", "two", "production", "shot", "-lrb-", "fig.", "12", "-rrb-", "both", "initial", "feedback", "accelerate", "several", "order", "magnitude", "interactive", "rate", "cache", "time", "Robot", "significantly", "less", "than", "even", "single", "offline", "render", "-lrb-", "common", "most", "complex", "shot", "-rrb-", "because", "we", "cache", "light", "turn", "off", "cache", "time", "Pirate", "example", "dominate", "unoptimized", "octree", "caching", "compression", "process", "which", "-lrb-", "unnecessarily", "-rrb-", "read", "write", "multiple", "gb", "octree", "datum", "disk", "several", "time", "during", "caching", "we", "system", "have", "be", "integrate", "pipeline", "two", "special", "effect", "studio", "currently", "initial", "release", "number", "artist", "production", "both", "lighting", "look-design", "we", "have", "focus", "we", "effort", "iron", "out", "major", "previously-unsolved", "technical", "challenge", "system", "some", "technically", "straightforward", "significant", "aspect", "we", "implementation", "shadow", "map", "rendering", "currently", "lack", "extensive", "optimization", "while", "significant", "effort", "have", "be", "pay", "ensure", "fidelity", "scalability", "core", "compiler", "preprocessing", "real-time", "shading", "component", "complex", "scene", "subsurface", "scattering", "only", "proof-of-concept", "require", "further", "optimization", "nevertheless", "initial", "feedback", "have", "be", "extremely", "positive", "example", "artist", "love", "freedom", "experiment", "complex", "feature", "noise", "-lsb-", "we", "-rsb-", "usually", "shy", "away", "from", "noise", "because", "take", "so", "long", "edit", "...", "interactivity", "make", "much", "more", "useful", "general", "strong", "feeling", "interactive", "feedback", "only", "accelerate", "adjustment", "key", "parameter", "-lrb-", "get", "level", "right", "-lsb-", "previously", "-rsb-", "take", "I", "hour", "!?", "-lsb-", "after", "just", "tuning", "light", "match", "background", "under", "10", "seconds", "-rsb-", "-rrb-", "leave", "user", "more", "willing", "experiment", "aggressively", "GPU", "vs.", "specialization", "speedup", "we", "have", "estimate", "gain", "due", "specialization", "vs.", "GPU", "execution", "since", "we", "do", "have", "software", "preview", "runtime", "we", "can", "only", "perform", "back", "envelope", "calculation", "compare", "GPU", "shader", "RenderMan", "shader", "prman", "timing", "real", "vs.", "trivial", "shader", "include", "scene", "we", "estimate", "specialization", "caching", "provide", "100x", "speedup", "while", "execution", "GPU", "bring", "another", "20x", "coarsest", "level", "refinement", "provide", "extra", "10-100x", "Figure", "14", "upper-right", "half", "image", "render", "we", "approach", "while", "lower", "left", "final", "RenderMan", "frame", "initial", "refinement", "render", "over", "20", "hz", "we", "full", "4k", "instruction", "specialize", "surface", "shader", "spot", "light", "include", "shadow", "error", "percentage", "max", "pixel", "value", "Figure", "15", "430k", "transparent", "hair", "-lrb-", "0.6", "opacity", "threshold", "0.96", "-rrb-", "render", "720x389", "8x8", "sampling", "generate", "43m", "micropolygon", "58m", "pixel", "sample", "RenderMan", "condense", "11m", "visible", "shade", "sample", "17m", "unique", "visibility", "sample", "through", "lossless", "visibility", "compression", "render", "12", "hz", "fully", "refining", "33", "sec", "compression", "performance", "even", "better", "1.0", "0.1", "-lrb-", "threshold", "0.996", "-rrb-", "generate", "21m", "visible", "shade", "sample", "overflow", "16m", "sample", "texture", "we", "currently", "use", "-lrb-", "cf.", "Fig.", "10", "-rrb-", "7.1", "Scalability", "Shadow", "geometry", "scale", "scene", "complexity", "main", "scalability", "limitation", "practice", "use", "micropolygon", "instead", "source", "primitive", "design", "decision", "avoid", "re-implementing", "every", "primitive", "support", "prman", "we", "control", "shadow-geometry", "level", "detail", "alter", "shade", "rate", "shadow", "bake", "pass", "additional", "mesh", "decimation", "pass", "could", "useful", "aside", "from", "shadow", "we", "system", "effectively", "scale", "image", "complexity", "indirect", "framebuffer", "cache", "compression", "dramatically", "reduce", "memory", "cost", "transparency", "main", "difference", "from", "previous", "technique", "because", "add", "unbounded", "number", "sample", "we", "create", "complex", "scene", "test", "scalability", "-lrb-", "fig.", "15", "-rrb-", "430k", "transparent", "hair", "fiber", "-lrb-", "0.1", "opacity", "threshold", "0.996", "-rrb-", "result", "55m", "prman", "micropolygon", "20m", "visible", "Lightspeed", "shade", "sample", "render", "720x389", "64x", "supersampling", "overflow", "we", "shade", "sample", "texture", "because", "GPU?s", "4kx4k", "-lrb-", "16m", "-rrb-", "texture", "limit", "however", "reduce", "0.6", "same", "scene", "only", "require", "11m", "shade", "sample", "-lrb-", "vs.", "43m", "prman", "-rrb-", "work", "12", "hz", "-lrb-", "33", "sec", "full", "refinement", "because", "full", "cache", "2gb", "need", "page", "-rrb-", "transparency", "Lightspeed", "shade", "just", "4m", "sample", "-lrb-", "vs.", "25m", "prman", "-rrb-", "22", "hz", "-lrb-", "5.5", "sec", "full", "refinement", "-rrb-", "16m", "limit", "can", "trivially", "increase", "use", "multiple", "texture", "8k", "texture", "DirectX", "10", "we", "production", "scene", "however", "we", "have", "encounter", "extreme", "case", "we", "artist", "avoid", "transparent", "hair", "favor", "smaller", "sub-pixel", "hair", "because", "same", "scalability", "problem", "apply", "prman", "fact", "though", "unbounded", "transparency", "consistently", "contribute", "much", "less", "total", "frame", "complexity", "than", "-lrb-", "bound", "-rrb-", "multisample", "we", "scene", "while", "worst", "case", "scale", "supersampled", "image", "complexity", "-lrb-", "time", "depth", "complexity", "transparency", "-rrb-", "key", "goal", "we", "design?visibility", "compression", "linearization", "visibility", "indirect", "framebuffer?is", "provide", "real-world", "scaling", "much", "closer", "pixel-complexity", "even", "motion", "blur", "-lrb-", "fig.", "-rrb-", "subpixel", "microgeometry", "like", "hair", "-lrb-", "fig.", "15", "-rrb-", "modest", "average", "transparency", "depth", "overall", "conclusion", "we", "test", "ignore", "shadow", "we", "can", "handle", "lot", "fine", "geometry", "handle", "lot", "very", "transparent", "coarse", "geometry", "we", "current", "implementation", "handle", "lot", "very", "transparent", "fine", "geometry", "completely", "fill", "image", "antialiasing", "we", "can", "handle", "lot", "fine", "geometry", "semi-transparent", "even", "fill", "image", "high", "antialiasing", "where", "scene", "complexity", "can", "become", "issue", "indirect", "framebuffer", "during", "caching", "because", "simple", "method", "caching", "-lrb-", "bake3d", "-rrb-", "extract", "all", "shaded", "grid", "from", "prman", "initial", "cache", "size", "can", "very", "large", "compression", "become", "disk", "i/o", "bind", "we", "address", "push", "compression", "in-memory", "renderer", "-lrb-", "dso", "-rrb-", "which", "greatly", "accelerate", "caching", "culling", "number", "unique", "shader", "can", "also", "issue", "however", "give", "surface", "shader", "use", "multiple", "surface", "different", "parameter", "we", "only", "need", "specialize", "once", "total", "number", "dynamic", "shader", "product", "number", "different", "light", "shader", "number", "surface", "shader", "-lrb-", "number", "instance", "-rrb-", "because", "we", "mostly", "use", "bershader", "problem", "we", "workload", "-lrb-", "10-100", "combination", "practice", "Fig.", "13", "-rrb-", "though", "would", "studio", "thousand", "unique", "shader", "shot", "might", "address", "established", "technique", "discuss", "Footnote", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "25-10", "Ragan-Kelley", "et", "al.", "7.2", "challenge", "Limitations", "practice", "we", "find", "we", "approach", "quite", "robust", "major", "challenge", "we", "have", "address", "include", "Dynamic", "call", "external", "routine", "largely", "eliminate", "during", "specialization", "where", "aren?t", "have", "be", "effectively", "emulate", "GPU", "make", "cache-required", "generate", "deep-framebuffer", "compress", "modest", "size", "even", "we", "more", "complicated", "scene", "shader", "GPU", "texture", "limit", "abstract", "through", "tiling", "complex", "visibility", "effectively", "compress", "even", "high", "multisampling", "rate", "interactivity", "maintain", "face", "complexity", "progressive", "refinement", "automatically", "specialize", "shader", "fit", "within", "current", "GPU", "limit", "future", "shader", "surpass", "limit", "we", "current", "hardware", "newer", "gpus", "have", "already", "elevated", "relevant", "program", "register", "size", "limit", "least", "order", "magnitude", "we", "key", "limitation", "same", "face", "any", "GPU", "shade", "system?namely", "operation", "easily", "express", "native", "GPU", "instruction", "require", "special", "handling", "most", "importantly", "nonlocal", "shade", "must", "handle", "explicitly", "use", "multipass", "algorithm", "we", "have", "achieve", "shadow", "translucency", "additional", "implementation", "require", "other", "effect", "still", "number", "feature", "can", "translate", "would", "result", "error", "message", "deem", "dynamic", "fortunately", "feature", "usually", "use", "dynamic", "part", "shader", "we", "studio", "may", "true", "all", "studio", "Ray", "Tracing", "we", "do", "perform", "ray", "casting", "note", "specular", "ray", "trace", "could", "preview", "deep-framebuffer", "use", "indirect", "buffer", "-lrb-", "ray", "intersection", "do", "change", "unless", "index", "refraction", "edit", "transmitted", "ray", "-rrb-", "future", "work", "main", "limitation", "concern", "ray-cast", "shadow", "inter-reflection", "ambient", "occlusion", "Lightspeed", "would", "require", "re-caching", "occlusion", "object-object", "shadow", "assignment", "change", "we", "artist", "only", "edit", "occlusion", "gain", "during", "lighting", "design", "interobject", "occlusion", "itself", "can", "cache", "shadow", "we", "system", "currently", "do", "implement", "deep", "shadow", "serious", "limitation", "scene", "hair", "brickmap", "pointcloud", "memory", "management", "would", "present", "challenge", "implement", "brickmap", "we", "do", "support", "they", "dynamic", "code", "particular", "problem", "brickmap", "use", "light", "shader", "we", "subsurface", "scattering", "implementation", "example", "where", "point", "cloud", "statically", "sample", "cache", "time", "return", "value", "dynamic", "non-linear", "light", "non-linear", "contribution", "easily", "cache", "Dynamic", "loop", "Dynamic", "loop", "contain", "cache", "expression", "limitation", "we", "support", "they", "special", "case", "where", "bound", "since", "we", "statically", "allocate", "space", "deep", "framebuffer", "Figure", "12", "use", "bound", "dynamic", "loop", "layered", "material", "conclusion", "future", "work", "we", "have", "introduce", "system", "real-time", "preview", "RenderMan", "scene", "during", "lighting", "design", "we", "method", "automatically", "specialize", "shader", "static", "RenderMan", "pass", "generate", "deepframebuffer", "dynamic", "cg", "pass", "use", "deep-framebuffer", "enable", "real-time", "preview", "GPU", "cache", "compression", "enable", "automatically", "generate", "deep-framebuffer", "fit", "modest", "GPU", "memory", "complex", "production", "shot", "we", "have", "introduce", "indirect", "framebuffer", "which", "efficiently", "encode", "multisample", "high-quality", "render", "transparency", "motion", "blur", "we", "computation", "graph-based", "system", "architecture", "flexible", "amenable", "multipass", "render", "algorithm", "which", "we", "demonstrate", "shadow", "mapping", "subsurface", "scattering", "we", "be", "surprise", "effectiveness", "cache", "compression", "initially", "we", "assume", "we", "would", "build", "complex", "compiler", "analysis", "control", "cache", "size", "however", "due", "data-parallel", "nature", "shade", "redundancy", "abound", "simple", "post-process", "easily", "uncover", "savings", "which", "static", "analysis", "could", "recognize", "whole", "we", "system", "bring", "level", "automation", "greatly", "simplify", "interactive", "lighting", "preview", "alleviate", "need", "write", "maintain", "different", "shader", "final", "rendering", "preprocessing", "preview", "however", "do", "close", "debate", "between", "manual", "instrumentation", "automatic", "specialization", "manual", "programming", "preview", "shader", "can", "bring", "extra", "level", "flexibility", "particular", "adapt", "level", "detail", "further", "accelerate", "preview", "illustrate", "lpic", "-lsb-", "Pellacini", "et", "al.", "2005", "-rsb-", "though", "Pellacini", "separately", "show", "automatic", "level-of-detail", "can", "help", "-lsb-", "2005", "-rsb-", "long", "run", "we", "believe", "lighting", "preview", "should", "address", "way", "similar", "traditional", "programming", "automatic", "tool", "provide", "compilation", "optimization", "programmer", "can", "provide", "hint", "manually", "optimize", "simplify", "critical", "portion", "code", "base", "profiling", "tool", "still", "greatest", "limitation", "deep-framebuffer", "rendering", "its", "basis", "local", "shading", "global", "illumination", "become", "prevalent", "production", "rendering", "ability", "integrate", "global", "effect", "system", "determine", "its", "future", "success", "fortunately", "we", "technique", "specific", "gpus", "rather", "generally", "useful", "reduce", "complex", "shade", "efficient", "data-parallel", "execution", "include", "future", "manycore", "cpus", "may", "ultimately", "avenue", "through", "which", "global", "effect", "most", "efficiently", "achieve", "Acknowledgments", "numerous", "people", "have", "contribute", "project", "its", "many", "year", "exploration", "implementation", "work", "start", "under", "advise", "Pat", "Hanrahan", "initially", "collaboration", "ujval", "kapasus", "Alex", "Aiken", "John", "Kodumal", "propose", "dependence", "analysis", "graph", "reachability", "provide", "first", "analysis", "library", "we", "use", "Matt", "Pharr", "John", "Owens", "Aaron", "Lefohn", "Eric", "Chan", "many", "member", "Stanford", "MIT", "Graphics", "Labs", "provide", "year", "essential", "advice", "feedback", "Tippett", "Studio", "take", "great", "risk", "actively", "support", "early", "research", "Dan", "Goldman", "introduce", "work", "ILM", "where", "Alan", "Trombla", "Ed", "Hanway", "Steve", "Sullivan", "have", "oversee", "many", "developer", "have", "contribute", "code", "include", "Sebastian", "Fernandez", "Peter", "Murphy", "Simon", "Premo", "ze", "Aaron", "Luk", "Hilmar", "Koch", "Paul", "Churchill", "Tom", "Martinek", "Charles", "Rose", "provide", "critical", "artist?s", "perspective", "early", "design", "Dan", "Wexler", "Larry", "Gritz", "Reid", "Gershbein", "provide", "useful", "explanation", "commercial", "lighting", "technology", "we", "thank", "Michael", "Bay", "graciously", "share", "unreleased", "image", "from", "he", "movie", "Dan", "Piponi", "generate", "we", "hair", "datum", "anonymous", "reviewer", "insightful", "discussion", "criticism", "Sylvain", "Paris", "Ravi", "Ramamoorthi", "Kevin", "Egan", "Aner", "Ben-Artzi", "Kayvon", "Fatahalian", "provide", "critical", "write", "feedback", "work", "support", "NSF", "CAREER", "award", "0447561", "NSF", "Graduate", "Research", "Fellowship", "NVIDIA", "Graduate", "Fellowship", "Ford", "Foundation", "Graduate", "Fellowship", "Microsoft", "Research", "New", "Faculty", "Fellowship", "Sloan", "fellowship", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "25-11", "reference", "lia", "1999", "interactive", "photorealistic", "rendering", "NDERSEN", "P.", "H.", "1996", "partial", "evaluation", "apply", "ray", "trace", "Software", "Engineering", "Scientific", "Computing", "Vieweg", "W.", "Mackens", "S.", "Rump", "Eds.", "78", "85", "podaca", "a.", "a.", "ritz", "l.", "2000", "Advanced", "RenderMan", "create", "CGI", "motion", "picture", "Morgan", "Kaufmann", "leiweiss", "a.", "reetham", "a.", "2003", "ashli?advanced", "shade", "language", "interface", "ACM", "SIGGRAPH", "Course", "Notes", "ook", "R.", "L.", "ARPENTER", "L.", "atmull", "E.", "1987", "reye", "image", "render", "architecture", "Computer", "Graphics", "-lrb-", "Proceedings", "SIGGRAPH", "87", "-rrb-", "95", "102", "orsey", "J.", "RVO", "J.", "REENBERG", "D.", "1995", "interactive", "design", "complex", "time", "dependent", "lighting", "IEEE", "Computer", "Graphics", "application", "15", "-lrb-", "mar.", "-rrb-", "26", "36", "ershbein", "R.", "ANRAHAN", "P.", "M.", "2000", "fast", "relighting", "engine", "interactive", "cinematic", "lighting", "design", "Proceedings", "ACM", "SIGGRAPH", "2000", "Computer", "Graphics", "Proceedings", "annual", "Conference", "Series", "353", "358", "uenter", "B.", "NOBLOCK", "T.", "B.", "uf", "E.", "1995", "specialize", "shader", "Proceedings", "SIGGRAPH", "95", "Computer", "Graphics", "Proceedings", "annual", "Conference", "Series", "343", "350", "anrahan", "P.", "1983", "Ray", "trace", "algebraic", "surface", "Proc", "SIGGRAPH", "1983", "83", "90", "san", "M.", "ellacinus", "F.", "ALA", "K.", "2006", "direct-toindirect", "transfer", "cinematic", "relighting", "ACM", "transaction", "Graphics", "25", "-lrb-", "July", "-rrb-", "1089", "1097", "orwitz", "S.", "EPS", "T.", "INKLEY", "D.", "1990", "interprocedural", "slice", "use", "dependence", "graph", "ACM", "transaction", "Programming", "Languages", "Systems", "12", "26", "60", "ENSEN", "H.", "W.", "UHLER", "J.", "2002", "rapid", "hierarchical", "render", "technique", "translucent", "material", "ACM", "transaction", "Graphics", "21", "-lrb-", "July", "-rrb-", "576", "581", "one", "t.", "R.", "erry", "R.", "N.", "ALLAHAN", "M.", "2000", "Shadermaps", "method", "accelerate", "procedural", "shading", "Tech", "rep.", "Mitsubishi", "Electric", "Research", "Laboratory", "NOBLOCK", "T.", "B.", "uf", "E.", "1996", "datum", "specialization", "Proc", "SIGPLAN", "1996", "215", "225", "ark", "W.", "R.", "LANVILLE", "R.", "S.", "KELEY", "K.", "ILGARD", "M.", "J.", "2003", "Cg", "system", "programming", "graphic", "hardware", "c-like", "language", "ACM", "transaction", "Graphics", "22", "-lrb-", "July", "-rrb-", "896", "907", "ogensen", "t.", "1986", "application", "partial", "evaluation", "raytracing", "master?s", "thesis", "DIKU", "U.", "Copenhagen", "Denmark", "R.", "AMAMOORTHI", "R.", "ANRAHAN", "P.", "2003", "Allfrequency", "shadow", "use", "non-linear", "wavelet", "lighting", "approximation", "ACM", "transaction", "Graphics", "22", "-lrb-", "July", "-rrb-", "376", "381", "vidium", "2005", "Sorbetto", "relighting", "technology", "eercy", "M.", "S.", "LANO", "M.", "IREY", "J.", "NGAR", "P.", "J.", "2000", "interactive", "multi-pass", "programmable", "shading", "Proceedings", "ACM", "SIGGRAPH", "2000", "Computer", "Graphics", "Proceedings", "annual", "Conference", "Series", "425", "432", "ellacinus", "F.", "IDIM", "CE", "K.", "EFOHN", "a.", "ohr", "a.", "eone", "M.", "ARREN", "J.", "2005", "Lpics", "hybrid", "hardwareaccelerate", "relight", "engine", "computer", "cinematography", "ACM", "transaction", "Graphics", "24", "-lrb-", "Aug.", "-rrb-", "464", "470", "ellacinus", "F.", "2005", "user-configurable", "automatic", "shader", "simplification", "ACM", "transaction", "Graphics", "24", "-lrb-", "Aug.", "-rrb-", "445", "452", "ixar", "2001", "Irma", "agan", "ELLEY", "J.", "2007", "Lightspeed", "Automatic", "Interactive", "Lighting", "Preview", "System", "master?s", "thesis", "Massachusetts", "Institute", "Technology", "ep", "T.", "ORWITZ", "S.", "AGIV", "M.", "1995", "precise", "interprocedural", "datum", "flow", "analysis", "via", "graph", "reachability", "Proc", "SPPL", "1995", "49", "61", "aito", "T.", "akahashus", "t.", "1990", "comprehensible", "rendering", "3-d", "shape", "Computer", "Graphics", "-lrb-", "Proceedings", "SIGGRAPH", "90", "-rrb-", "197", "206", "QUIN", "C.", "H.", "MYRL", "E.", "K.", "1989", "parameterize", "ray", "trace", "Computer", "Graphics", "-lrb-", "Proceedings", "SIGGRAPH", "89", "-rrb-", "307", "314", "LOAN", "P.-P.", "AUTZ", "J.", "NYDER", "J.", "2002", "precomputed", "radiance", "transfer", "real-time", "rendering", "dynamic", "lowfrequency", "lighting", "environment", "ACM", "transaction", "Graphics", "21", "-lrb-", "July", "-rrb-", "527", "536", "abellion", "E.", "amorlette", "a.", "2004", "approximate", "global", "illumination", "system", "computer", "generate", "film", "ACM", "transaction", "Graphics", "23", "-lrb-", "Aug.", "-rrb-", "469", "476", "EXLER", "D.", "RITZ", "L.", "NDERTON", "E.", "ice", "J.", "2005", "gpu-accelerated", "high-quality", "hidden", "surface", "removal", "Graphics", "Hardware", "2005", "14", "ACM", "transaction", "Graphics", "Vol", "26", "no.", "Article", "25", "publication", "date", "July", "2007" ],
  "content" : "\n  \n    15f37d5a612418bb3317abe0e3bd21e4ff57fb4940e70d0d953f6f8cdf717a13\n    mhk\n    10.1145/1239451.1239476\n    Name identification was not possible. \n  \n  \n    \n      \n        The Lightspeed Automatic Interactive Lighting Preview System\n      \n      Jonathan Ragan-Kelley ? Charlie Kilpatrick ? Brian W. Smith ? Doug Epps ? ? MIT CSAIL ? Industrial Light & Magic\n      \n        \n        Figure 1: An automatically-generated preview at 914x389 resolution with 13x13 supersampling for a scene featuring 42 spot, environment, and message-passing lights and multiple 20k instruction surface shaders. The upper-left half of the image is rendered with our approach while the lower right is the final RenderMan frame ? the seam is barely visible. The error heat map is in percentage of maximum 8-bit pixel value and is mostly due to shadow map artifacts. This scene renders interactively at 4x4 subsampled resolution at 9.2 Hz, while refining to the above antialiased final-quality in 2.7 seconds, compared to 57 minutes in RenderMan.\n      \n      We present an automated approach for high-quality preview of feature-film rendering during lighting design. Similar to previous work, we use a deep-framebuffer shaded on the GPU to achieve interactive performance. Our first contribution is to generate the deep-framebuffer and corresponding shaders automatically through data-flow analysis and compilation of the original scene. Cache compression reduces automatically-generated deep-framebuffers to reasonable size for complex production scenes and shaders. We also propose a new structure, the indirect framebuffer, that decouples shading samples from final pixels and allows a deepframebuffer to handle antialiasing, motion blur and transparency efficiently. Progressive refinement enables fast feedback at coarser resolution. We demonstrate our approach in real-world production. Keywords: Lighting Preview, Interactive Rendering, Data-flow Analysis, RenderMan, Programmable Shading, GPUs\n    \n    \n      \n        ACM Reference Format\n        Ragan-Kelley, J., Kilpatrick, C., Smith, B., Epps, D., Green, P., Hery, C., Durand, F. 2007. The Lightspeed Automatic Interactive Lighting Preview System. ACM Trans. Graph. 26, 3, Article 25 (July 2007), 11 pages. DOI = 10.1145/1239451.1239476 http://doi.acm.org/10.1145/1239451.1239476.\n      \n      \n        Copyright Notice\n        Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the first page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1\n        \n          212\n          869-0481, or permissions@acm.org.\n        \n        ? 2007 ACM 0730-0301/2007/03-ART25 $5.00 DOI 10.1145/1239451.1239476 http://doi.acm.org/10.1145/1239451.1239476\n        ?\n        Paul Green ? Christophe Hery ? Fr?do Durand ? Tippett Studio\n      \n      \n        1 Introduction\n        \n          1.1 Prior Work\n          Fast relighting has long been a major area of research [Dorsey et al. 1995; Ng et al. 2003]. Software renderers can be optimized for repetitive re-rendering by caching intermediate results at various stages of the rendering process as pioneered by TDI in the 1980s [Alias 1999; Pixar 2001; Nvidia 2005; Tabellion and Lamorlette 2004]. However, such optimizations must be integrated at the core of a system and are still far from interactive for film scenes. S?quin and Smyrl [1989] introduced a parameterized version of ray tracing that enables the modification of some material and light properties after precomputation (although not the light direction or position). They also perform cache compression. Gershbein and Hanrahan created a system for lighting design [2000] which cached intermediate results in a deep-framebuffer inspired by G-Buffers [Saito and Takahashi 1990]. They cached a fixed set of data, and approximated shading with multitexturing. Pellacini et al. performed shading on programmable graphics hardware [2005] using manually-written shaders that emulate RenderMan shaders. These systems require manual segmentation of shaders into light-dependent and light-independent components, and manual translation of preview shaders. While this allows for manual optimization to maximize preview performance, it is a significant burden. We chose to potentially sacrifice performance but tremendously improve integration and maintainability by automating the segmentation and translation of shaders. Furthermore, we extend prior deep-framebuffer systems by enabling the efficient rendering of transparent surfaces and multisampling effects, such as motion blur. Finally, our approach also automatically supports editing many (user-selected) surface properties because it employs data-flow analysis with respect to arbitrary parameters. Wexler, et al. implemented high-quality supersampling on the GPU [2005], but they focus on final rendering, while we optimize for static visibility, resulting in a different data structure. We build on recent work on direct-to-indirect transfer, which exploits linearity for global illumination in cinematic relighting [Ha san et al. 2006]. We apply similar principles to multisampling, transparency and subsurface scattering. Jones et al. segmented shaders into static and dynamic subsets and cached shading information in texture-space to accelerate rendering the same scene multiple times under similar configurations [2000]. However, their technique only cached shading computation?not tessellation, displacement, etc.?and required manual shader segmentation. Our goals cannot be fully met by pre-computed radiance transfer (PRT) techniques [Sloan et al. 2002; Ng et al. 2003], because they usually make assumptions on the reflectance or lighting and have significant precomputation cost. In contrast, we need to handle the effect of local point light sources and arbitrary reflectance. Furthermore, computing illumination itself is a large part of our run-time calculation as production light shaders are quite complex. Compiler specialization of graphics computation was first used for ray tracing [Hanrahan 1983; Mogensen 1986; Andersen 1996].  Guenter, Knoblock & Ruf developed data specialization to reduce the cost of recomputation when only certain shading parameters vary, by automatically segmenting shaders into parameterdependent and -independent components [1995; 1996]. We leverage their approach in the context of lighting design and extend their analyses to global data-flow through existing real-world RenderMan shaders. We solve specialization using a graph formulation, mentioned but not implemented by Knoblock and Ruf [1996]. This allows us to not only specialize with respect to dynamic parameters, but also to perform dead-code elimination and other analyses, all from a single dependence analysis. Peercy et al. [2000] and Bleiweiss and Preetham [2003] addressed the compilation of RenderMan shaders onto graphics hardware. We, too, exploit the fact that a large subset of the RenderMan Shading Language (RSL) can be compiled to a GPU. Our interest, however, is not in using RSL as a GPU shading language, but in automatically specializing final-frame shaders and creating an appropriate deep framebuffer for interactive relighting.\n        \n      \n      Configuring lights is a critical bottleneck in modern production rendering, and recent advances have sought to provide real-time preview using deep-framebuffers and graphics hardware [Gershbein and Hanrahan 2000; Pellacini et al. 2005]. A deep-framebuffer caches static values such as normals and texture samples in image space, and each time the user updates light parameters, realtime shaders interactively recompute the image from the cache. Unfortunately, these approaches require substantial additional work from shader authors. For example, in the lpics system deployed at Pixar [Pellacini et al. 2005], at least two versions of each shader need to be written in place of just one: the usual RenderMan shader used for the final rendering (with additional code paths to cache data), and a Cg version used for real-time preview. We alleviate the need to author multiple versions of a shader by automatically translating unmodified RenderMan shaders into realtime shaders and precomputation shaders. This translation is part of a larger process that automatically generates deep-framebuffer data from unmodified existing scenes. In theory, some RenderMan code cannot be translated into GPU shaders, but we have found that, in practice, the dynamic parts of our production shaders translate well. In contrast to pure static compiler analysis, we use postexecution cache compression to supplement a simple compiler analysis. Cache compression effectively reduces automaticallygenerated deep-framebuffers to reasonable size for complex production shaders. In addition, transparency, motion blur and antialiasing can be critical to judge appearance. We introduce the indirect framebuffer, which enables these effects without linearly scaling rendering time.  Similar to RenderMan, it decouples shading from visibility, but also precomputes the final weight of each shading sample for the relevant final pixels. Given the complexity of shots that we handle, we also use progressive refinement to offer both interactive feedback (multiple frames per second) and faithful final quality (potentially after a few seconds). Finally, it is important to facilitate the implementation of new passes in a preview system. We use a computation graph that directly expresses the dependencies and data-flow between passes to implement shadows and translucency. We describe a full production relighting system that is being deployed in two studios with different rendering workflows.\n      ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n      25-2\n      ?\n      Ragan-Kelley et al.\n      \n        2 System Design\n        \n          2.1 Design Goals\n          Our primary objective is, given a fixed scene geometry, material and viewpoint, to enable the interactive manipulation of all light source parameters, including intensity, position, and falloff, as well as to create and remove light sources. The restriction to lights came first from current production workflow where light source placement is a separate step at the end of the pipeline, after all other aspects have been frozen. We were also motivated by technical limitations: surface shaders tend to have more complexity and could prove harder to fully map to graphics hardware. However, it later became apparent that our approach can also enable the modification of many, but not all, material appearance parameters, and we have sought to facilitate this, although only as a secondary objective. In order to receive widespread adoption in production, a lighting design system must meet the following three major design goals. High-performance preview Minimizing feedback time is our primary goal. Specifically, we wish to provide: ? Low-latency feedback ? When the user modifies a light parameter, image refresh must be instantaneous. Final quality might take a few seconds through progressive refinement, but low-latency feedback is critical to seamless user interaction. ? Fast initial precomputation ? To be accepted by artists, this tool should not make it take longer to begin work on a shot. We seek to keep the initial preprocessing time as short as rendering one frame with the offline renderer. ? High absolute rendering speed ? Though secondary to latency and startup time, absolute rendering speed must be optimized.  Seamless integration with existing pipelines A preview system should be transparent to the user and require no additional work to use within an existing pipeline. This means that it should stand in for the existing offline rendering pipeline by: ? Taking the same input ? unmodified RenderMan scenes and shaders. ? Producing the same output ? using shading and visibility computation with extremely high fidelity to final rendering, including antialiasing, motion blur, and transparency. ? Using the same workflow ? in particular the same light editing GUI, which varies from studio to studio. This requires our system to communicate with different GUI software. Ease of implementation and maintenance Production rendering pipelines are complex and continually evolving. A preview system cannot afford the same implementation investment and should not require major re-implementation whenever the finalframe renderer is updated, the shaders changed, or the pipeline altered. Our system must achieve effective: ? Reuse ? Our system seeks to reuse the existing pipeline wherever possible, offloading most precomputation directly to the existing offline pipeline. ? Flexibility ? Our system is developed for two independent studios, with different pipelines and toolsets, so we wish to reuse as much as possible between these two environments. ? Extensibility ? It should be as easy as possible to support new functionality?from using new shaders to implementing new multipass effects?in a simple, modular fashion.\n          ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n          The Lightspeed Automatic Interactive Lighting Preview System\n          ?\n          25-3\n          input scene automatic preprocessor computation graph auxiliary data RenderMan e.g. shadow geometry, translucency samples caching scene cache compression specializing compiler caching surface shaders surface shaders light shaders\n          \n            Figure 2: Our system takes as input the original RenderMan scene with its shaders. Our specializing compiler automatically separates a shader into static and dynamic parts and uses RenderMan to cache static computation and auxiliary data. The dynamic part is translated into Cg. Cache compression greatly reduces the size of the cached data. The preprocess generates a computation graph that encapsulates the computation and data binding necessary to re-render the scene. The real-time engine executes the graph to generate intermediate data (shadow maps, etc.) and run the dynamic shaders over the cache on the GPU. A new indirect framebuffer enables antialiasing and transparency. The GUI application modifies light parameters through the graph interface.\n          \n        \n        \n          2.2 System Architecture\n          Our approach ( Fig. 2 ) can be decomposed into an automatic preprocess and a run-time phase that communicate through a dynamically-generated computation graph. We take as input the same RenderMan scene and shaders used for final rendering. Automatic specialization First, we automatically slice all surface shaders into a static component that can be cached and a dynamic component that will be executed by the real-time engine (Section 3). For surface shaders, we then generate two new shaders: a static precomputation shader, which is executed once in the final-frame renderer to generate a deep-framebuffer cache, and a dynamic re-rendering shader (in Cg), which is executed repeatedly over the deep-framebuffer to generate interactive previews. We directly translate light shaders to execute together with the rerendering surface shaders on the GPU. The automatic specialization of shaders can be expected to yield a performance penalty for the interactive preview compared to manually optimized and simplified code [Gershbein and Hanrahan 2000; Pellacini et al. 2005], but in our context, seamless integration took precedence over final performance. Another potential limitation of automatic translation is that not all RenderMan code can be mapped to the GPU. However, for our production shaders this has not been an issue. Indirect framebuffer Our core real-time rendering is similar to traditional deep-framebuffer approaches and uses Cg shaders to perform computation on all deep-framebuffer samples on the GPU. However, we introduce a new level of indirection through an indirect framebuffer to decouple shading samples from final pixel values, thereby efficiently handling antialiasing, motion blur, and transparency. It also enables progressive refinement (Sec. 4, 5). Cache compression We rely on static preprocessing of the cached data to compensate for overestimates of the compiler analysis, as well as to cull the deep-framebuffer and indirect framebuffer based on visibility. This provides over an order of magnitude reduction in total cached data sizes while allowing the compiler to remain relatively simple. Multipass rendering We enable multipass effects such as shadow mapping and subsurface scattering. This requires the preprocessor to also output auxiliary data such as geometry needed for shadow mapping or lighting samples for translucency. Although translucency currently incurs substantial cost for our preview, it demonstrates the generality of our architecture. Computation graph The overall re-rendering algorithm is encoded as a computation graph, generated during preprocessing from the original scene and shaders. The graph provides a specification of how to re-shade an image from the cache under new lighting configurations (Section 6). The computation graph provides two critical abstractions. First, it encodes dependences between different elements of real-time rendering, which is particularly critical for progressive refinement and multipass effects. Second, the graph abstracts the preprocessing from the editing GUI. So long as the generated graph conforms to certain basic conventions, the preprocessing stage can be updated and extended without affecting the GUI tool. This is important to our design goal of integrating seamlessly with multiple different workflows.\n          interactive preview rendering engine modeling gui temp rendered image deepand indirect aux framebuffer caches GPU dynamic caches surface shaders dynamic light shaders GPU parameter controls shaders\n        \n      \n      \n        3 Automatic Deep-Framebuffer Caching\n        We wish to automatically generate a deep-framebuffer and realtime preview. We first need to determine which parts of the computation are static vs. dynamic with respect to the light parameters. We then create new RenderMan Shading Language (RSL) shaders that compute and output the static values, and use RenderMan to create a deep-framebuffer cache. We preprocess the cache output by RenderMan to compress redundant and irrelevant values. Finally, we translate the dynamic part of the computation into real-time GPU shaders that access the deep framebuffer as textures. Previous work has achieved these steps manually. Our contribution is to make this process fully automatic.\n        ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n        25-4\n        ?\n        Ragan-Kelley et al.\n        <dynamic> <dynamic> shader parse augment AST reachability with and analysis static/dynamic caching rules input shader abstract syntax tree (AST) dependency graph labeled graph\n        \n          Figure 3: Specializing compiler. The input shader is represented as an abstract syntax tree (AST). We augment it to encode dependency between variables and expressions. To decide if an expression is dynamic, we query whether it depends on any dynamic parameters. Once the shader has been split, we generate two new shaders, a caching shader and a real-time shader. RenderMan executes the caching shader over the scene and the cached values are compressed to generate a dense deep-framebuffer, which is read by the dynamic shader during preview. 3.1 Data-flow Analysis for Specialization We represent string tokens, including message passing identifiers, by encoding static string values in floats using unique IDs, We build on techniques from data-flow analysis to label the static enabling runtime code to pass and compare (though not modify) and dynamic parts of a shader [Horwitz et al. 1990; Reps et al. strings on the GPU. RSL also uses strings to represent transforms 1995]. We need to conservatively identify all expressions that and texture handles, so our Cg string type includes the necessary depend directly or indirectly on dynamic input parameters. This texture samplers and matrices for all major uses of strings. can naturally be turned into a graph reachability problem: an expression in a shader is dynamic if it is ?reachable? from a Finally, RSL supports the computation of arbitrary derivatives dynamic parameter. RenderMan separates surface and light shaders over the surface. Cg also supports derivatives, but its fast approxand we focus on specializing surface shaders, since light shaders are imations are low-quality. In practice, we find that high quality mostly dynamic with respect to light parameters. derivatives are only significant in dynamic code for large texture filter kernels. These primarily depend on surface partial derivatives, Dependence analysis The first step of our analysis ( Fig. 3 ) adds which are not dynamic, so we simply cache them when necessary. global dependencies to transform an abstract syntax tree (AST) representation of the shader into a dependency graph that encodes Light translation While surface shaders are specialized, light all dependencies between expressions. We add a dynamic node shaders are directly translated through the same Cg code generator. and connect it to the dynamic parameters, specified by name. Similar to RenderMan, we generate Cg light and surface shaders We then simply query whether each expression depends on a separately and combine them at load time. They communicate dynamic parameter by testing if it can reach the dynamic node. primarily through Cg interfaces [Mark et al. 2003]. The core global dependency rules are described separately [RaganThis approach can only automatically translate light shaders Kelley 2007]. We perform dead-code elimination using the same which do not rely on cache-required functionality?namely, exterdependence graph by connecting output values to a new output nal C calls. In practice, our lights only call C DSOs for simple node. operations like fast math routines, which are trivially replaced with native instructions on the GPU, so we do not find this problematic. Cache-required code Our caching analysis constrains dynamic\n        \n        shaders to operations that can be executed on the GPU. We can force certain operations?namely calls to external C routines, and unimplemented shadeops (e.g., trace)?to be labeled cached even if the dependence analysis labeled them dynamic. Static/dynamic analysis eliminates most such operations in our shaders. We can recognize light-dependent cache-required nodes as errors, but we find simply warning the user and computing the values statically at cache time often provides usable preview results.\n        3.2 Code Generation and Translation Once we have decided which computations to cache, and which to execute dynamically during preview, we generate two new surface shaders, one for each phase. RenderMan precomputation Caching computations are emitted as a new RSL shader. When branch conditions are dynamic, control flow in the dynamic preview shader may differ from the caching execution. If values are cached inside a dynamic conditional, the caching shader must execute both potential branches. Finally, we generate a new RenderMan scene that replaces each shader by its caching equivalent. We run it through RenderMan to generate the deep framebuffer ( Fig. 3 ). Cg code generation Dynamic surface shaders are emitted as new Cg shaders which read the deep-framebuffer cache as textures. The key issue in translating RSL to Cg is to mimic RenderMan?s richer data-flow and execution semantics. Communication of light color and direction is accomplished through shared global variables, as in RSL. However, RSL also allows surfaces and lights to access each other?s parameters by name through messagepassing. We implement this by communicating parameters through global variables. 3.3 Specialization Results Figure 4 summarizes the results of our shader specialization approach. Note that the dynamic shader complexity depends on both the light and surface shaders. Generic Surface is a multipurpose ??bershader? that forms the basis of most of our custom shaders. However, it does not result in dramatically larger dynamic shaders than a simpler surface because most of the code is static and dynamic code is dominated by lighting computation. RSL instructions tend to be higher-level, and the equivalent computation requires a larger number of GPU instructions. The sizes of our caching shaders are 28k and 22k RSL instructions for Generic Surface and Metallic Paint, respectively. Pellacini et al. [2005] describe challenges with binding overhead for the number of unique surfaces generated by specialization. Our technique has no more shaders than the original shot and our shots usually use at most a dozen unique shaders, which contrasts with the thousands of unique shaders per shot used in other studios [Pellacini et al. 2005] 1 . This further emphasizes that, in our context, automatic specialization is primarily motivated by the rate at which shaders change (as well as the ability to edit surface parameters), not their total number. The main challenge for specialization lies in the number of values that need to be cached for large shaders. It can easily reach hundreds of scalars per deep-framebuffer element, potentially exceeding the GPU?s memory. This makes cache compression, as well as the tiling described in Section 5, critical. 1 Given increased program size limits in latest GPUs, Cg codegen could generate a single compound shader performing dynamic dispatch to subroutines implementing each surface or light. This technique is already used effectively in games.\n        \n          \n        \n        caching RSL shader cache codegen RenderMan compression translation texture & codegen lookup deep-framebuffer dynamic Cg shader cache\n        ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n        The Lightspeed Automatic Interactive Lighting Preview System\n        ?\n        25-5\n        Configuration RSL instr. GPU instr. GPU regs. Generic Surface 19,673 (combined surface/light) spot +1290 4653 28 point +626 3941 24 reflection +351 1942 20 reflection environment +733 2721 23 ambient environment +367 2724 22 occlusion msg +28 863 12 Metallic Paint 22274 spot +1290 4461 26 ?Simple? Surface 4171 spot +1290 3368 21\n        \n          Figure 4: Compiled RenderMan (RSL) vs. compiled GPU assembly instructions, and number of GPU registers. Note that the indicated total complexity of the GPU dynamic shader includes both light and surface, while RenderMan instructions are given separately.\n        \n        \n          3.4 Cache Compression\n          Static code analysis is challenging and tends to be conservative. In contrast, we find that applying simple post-processes to our final cached data provides tremendous reductions in cache complexity, sufficient to enable effective automatic deep-framebuffer generation with a simple compiler. After caching, we analyze all channels in the deep-framebuffer and eliminate those whose values are: ? Constant over the frame ? non-varying terms are converted to static constants in the code. ? Identical to other channels ? non-unique terms are replaced with references to a single common channel. These optimizations can reduce the number of cached components by more than a factor of 4 ( Fig. 5 ). Because these optimizations inline significant new static data in the dynamic Cg shaders, this also helps the Cg compiler reduce runtime shader complexity through constant folding.\n          \n            Figure 5:\n          \n          Shader dynamic varying unique (caching analysis) (compressed) generic surface 402 145 97 metallic paint 450 150 97 The number of (scalar) values per deep-framebuffer sample for the scene in Fig. 1 under compression. Dynamic terms are determined by the initial caching analysis. Varying terms remain after elimination of values that are constant over the frame. Unique terms remain after further elimination of duplicated values.\n          3.5 Specializing for Surface Parameters A key advantage of automatic specialization is to allow users to selectively tweak some surface, as well as light parameters. When users select surface parameters as dynamic, the compiler can just as easily generate code with configurable surface parameters ( Fig. 6 ). Many of the most commonly tuned parameters, such as gain factors and specular roughness can be dynamically edited. This significantly extended the initially-planned range from lighting to look-design. In practice, the main overhead in editing surface parameters is that it requires the reevaluation of all light sources.\n          \n            Figure 6:\n          \n          Editable surf. parameters GPU instr. regs. relative perf. 0 (baseline) 3518 21 100% 18 (gain) 3856 27 90% 41 (gain & specularity) 3973 29 86% Preview performance as a function of the number of editable surface parameters for a variant of Generic Surface. Editing 41 scalar and vector surface parameters does not significantly slow rendering compared to light parameters alone.\n          \n            \n            Figure 7: Motion blur and transparency. Left: Lightspeed. Right: RenderMan. The difference is statistically insignificant (? 0.1%).\n          \n          \n            \n            Figure 8: Lightspeed rendering from a motion-blurred RenderMan frame with 13x13 pixel samples and shading rate 1. At 720x306, RenderMan shades 1.5M micropolygons and filters 21M subpixel samples in rendering this image, while our preprocessing distills this to only 467k visible shading samples and 3.8M unique subpixel contributions to produce identical results. Shading time still significantly dominates resampling time.\n          \n        \n      \n      \n        4 The Indirect Framebuffer\n        Traditional deep-framebuffers are pure image-space structures, which allows them to scale with image size, not scene complexity. However, because they interpret pixels as discrete surface shading samples, they cannot directly express effects where multiple shading samples contribute to a pixel, such as antialiasing, motion blur, depth-of-field, and transparency. A direct extension would use supersampling, but this greatly increases storage and shading cost and scales poorly with variable depth complexity introduced by transparency. Inspired by the decoupling between shading and visibility computation central to RenderMan?s REYES pipeline, we introduce a layer of indirection between deep-framebuffer shading and visibility/display samples through a second data structure we call the indirect framebuffer. We first review the multisampling approach used in RenderMan before introducing our new data structure. Background RenderMan?s REYES architecture achieves high quality and generality of antialiasing, motion blur, and depthof-field by supersampling visibility computation, while reducing shading cost by reusing shading values rather than supersampling them [Cook et al. 1987; Apodaca and Gritz 2000]. While smooth reconstruction of motion blur, depth-of-field, or fine geometry may require 100 or more visibility samples, the shading rate is commonly just roughly one shading sample per output pixel. For this, RenderMan uses three core data structures to encode shading and visibility ( Fig. 9.i ,ii): ? Shading is performed in object space on surface shading samples called micropolygons. ? Pixels contain a uniform density of subpixel samples, distributed in screen-space (spatial antialiasing), time (motion blur), and aperture location (depth-of-field). ? Each subpixel sample maintains a depth-ordered visible point list of pointers to the micropolygons visible along that ?ray?. RenderMan first tessellates all primitives into micropolygons. Shaders execute over all vertices of the micropolygon grids, pro-\n        ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n        25-6\n        ?\n        Ragan-Kelley et al.\n        RenderMan / REYES 1 2 a b b b 1 1 2 ?=0.3 ?=1.0 ?=1.0 b C a 1 *0.3+C b 1 *(1.0-0.3) C b 2 *1.0 a 1 1 2 1 b 2 3 4 4 3 a a b 1 1 2 ?=0.3 ?=0.3 ?=1.0 a C a 1 *0.3 C a 1 *0.3+C b 2 *(1.0-0.3) (i) Micropolygons (ii) Pixel-sample Hit Lists Lightspeed / Indirect Framebuffer x4 x4 x1 x3 x3 0.175 0.225 0.425 N x2 x2 P P P a b b 1 1 2 shading combination weighted shading nal pixel color samples\n        \n          Figure 9:\n        \n        (iii) Deep-framebuffer (iv) Indirect framebuffer The indirect framebuffer densely encodes variablerate visibility information to enable efficient antialiasing and transparency under a static view. It resamples a denselypacked deep-framebuffer into screen-space to precisely reproduce RenderMan?s high-quality antialiasing, but is linearized and consolidated for the given static visibility configuration, requiring far fewer unique samples for the same result.\n        ducing a color per vertex ( Fig. 9.i ). RenderMan then computes visibility (hiding) by testing each micropolygon against each subpixel sample it potentially covers (rasterization), taking into account the aperture and time value of the sample. A depth test is performed and transparency is handled by maintaining a z-ordered list of micropolygon pointers at each subpixel sample ( Fig. 9.ii ). The color of a subpixel sample is then computed by looking up the color and opacity of each micropolygon and compositing them in depth-order. The final pixel value is the weighted average color of the subpixels, and since the subpixels are jittered in space, time, and aperture location, this achieves high quality multisampling effects while keeping shading cost tractable.\n        \n          4.1 Indirect Framebuffer Data Structure\n          We note that each final, filtered pixel color ultimately corresponds to a simple linear combination of the shaded colors of all micropolygons visible under that pixel. Even transparency, which traditionally presents challenges due to order-dependence, ultimately factors into a single weight because we assume a fixed viewing configuration. Consider the example in Fig. 9.ii : the first subpixel?s color is a linear combination of shading samples a 1 and b 1 with weights given by a 1 ?s transparency. The final pixel value is a combination of the colors of shading samples a 1 , b 1 , and b 2 with weights 0.175, 0.225 and 0.435. When visibility is static, these cumulative linear weights similarly become static. This is similar to the principle of the direct-to-indirect transfer [Ha san et al. 2006] but in the context of multisampling and transparency. We directly exploit this static linearity while decoupling shading and final pixel value. We first use a standard deep framebuffer, but instead of organizing it per pixel, our preprocess caches data for each shading sample ( Fig. 9.iii ). Our real-time dynamic shaders execute over this cache and output per-shading-sample colors. Our indirect framebuffer encapsulates the linear nature of the\n          RenderMan our approach Figure resolution samples shade subpix shade indir. 1 914x389 13x13 2.1M 32M 633k 1.6M 8 720x306 13x13 1.5M 21M 467k 3.8M 12 640x376 4x4 2.5M 2.3M 327k 716k 15 (?: 0.1) 720x389 8x8 54M 121M 21M 35M 15 (?: 0.6) 720x389 8x8 43M 58M 11M 17M 15 (?: 1.0) 720x389 8x8 25M 17M 3.9M 5.7M Figure 10 : Original RenderMan micropolygon and pixelsample output complexity compared to our compressed indirect framebuffer, in numbers of samples, for Figs. 1, 8, 15, and 12. Static visibility compression losslessly reduces deep-framebuffer shading samples by 3-8x relative to RenderMan?s shaded micropolygons, and reduces the number of unique indirect framebuffer samples by 3-20x relative to RenderMan?s subpixel samples.\n          final color and stores, for each pixel, a list of weights and pointers to the deep-framebuffer output ( Fig. 9.iv ). For example, the pixel in Figure 9.iii corresponds to three entries in the indirect framebuffer. We need to efficiently represent the variable-length list of shading values influencing each pixel and enable progressive rendering. We use a ?scatter? strategy where points are rendered at each pixel location to accumulate color contribution. Each indirect framebuffer entry is encoded into a vertex array as a point, containing a pointer to a shading sample (a texture coordinate), a weight, and an output pixel coordinate (x, y). Rendering the vertex array with blending enabled scatters the weighted colors into final pixels. Note that one entry in the deep framebuffer and the resulting shaded color often contributes to multiple neighboring pixels, especially in the presence of motion blur. This highlights the effectiveness of our decoupling (and that of RenderMan) where complex multisampling effects are achieved without scaling the cost of shading. Our implementation is currently limited to static opacity. Dynamic transparency could be supported by recomputing the weights on the fly, but light-dependent transparency does not occur in our shaders. We also do not currently handle colored transparency, though it simply requires storing an RGB weight and independently blending each color channel.\n        \n        \n          4.2 Visibility Compression\n          Using the static visibility information of the indirect framebuffer, we apply two key transformations on the cached data to losslessly compress its size: ? The static linearization of the indirect framebuffer coalesces all visibility samples which reference the same shading sample at the same pixel into a single combined indirect framebuffer weight. This provides a 3-20x reduction in the size of the indirect framebuffer while producing the same output ( Fig. 10 ). ? We cull all deep-framebuffer shading samples not referenced by at least one indirect framebuffer sample. We maintain a local neighborhood where necessary for derivative computation. These optimizations reduce the number of indirect framebuffer samples by 3-20x, and the number of deep-framebuffer samples by 3-8x ( Fig. 10 ), with no loss of generality, even for complex scenes involving motion blur ( Fig. 8 ) and transparent hair (Fig. 15). This reduces not only storage size, but also computation, because shading is applied once per-deep-framebuffer sample, and resampling once per-indirect framebuffer sample. Combined with dense packing of shading values, these optimizations generally allow even heavily multisampled shots, with transparency, to require little more storage than a simple, single-sampled image-space deepframebuffer, and to be rendered interactively.\n          ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n          The Lightspeed Automatic Interactive Lighting Preview System\n          ?\n          25-7\n        \n      \n      \n        5 Scalability and Progressive Refinement\n        Our system must scale to final-resolution previews of massive scenes with complex shaders, while maintaining interactivity.\n        \n          5.1 Tiling\n          High resolution previews and more complex shaders may increase cache size beyond GPU memory. We divide oversized caches into screen-space tiles small enough for all hardware constraints. Each tile contains an indirect framebuffer coupled with a deepframebuffer of all shading samples visible at those indirect framebuffer samples. We also use texture atlases because our deepframebuffer may contain more channels than the number of bindable textures.\n        \n        \n          5.2 Progressive Refinement\n          We rely on progressive refinement to offer both interactive feedback and slower yet faithful final image quality. We progressively refine the resolution, typically in 3 steps. In the first step, we begin with 4x4 then 2x2 pixel blocks. Next, we increase to full resolution but with only one indirect framebuffer value per pixel. In the final step, we use full multisampling for the highest quality. Each stage is represented by a group of samples in our indirect framebuffer. We order the indirect framebuffer samples for a given pixel by weight and accumulate them progressively in passes. By simply normalizing subpixel weights for SRC ALPHA,ONE MINUS SRC ALPHA instead of additive blending, we maintain appropriate brightness. Shading is only updated for the points referenced by the indirect framebuffer samples in a given refinement batch. This also helps guarantee performance on massive scenes, because the first few refinement levels can be constrained to fit entirely on the GPU. Finally, we often disable shadows at the lowest refinement. Tiles of our deep-framebuffer are stored as sets of shading samples grouped by surface type, and into batches for multiple progressive refinement passes. Passes are stored in 2D textures with arbitrary layout (2x2 quads are maintained for derivatives). In practice, shading samples are stored according to the order in which RenderMan outputs them.\n        \n        \n          5.3 Light Caching\n          Like prior lighting design systems, we exploit the linearity of (most) lighting by caching the contribution from all lights not currently being edited by the user. We store a light cache that gets updated when a subset of lights is temporarily ?frozen.? In practice, when a light is ?unfrozen?, its contribution is subtracted from the cache, and a new frozen light?s contribution is added. We retain the old parameter state with which the cache was generated to maintain correctness when subtracting. This speeds up freezing when working with multiple tens of light sources, and has proven numerically stable over long edit sessions when using a 32-bit floating-point cache. Changing surface parameters requires reshading the surface with all lights. In scenes with few lights, this is still comfortably interactive. In near-final shots with dozens of lights, it may be subinteractive, but still takes only a few seconds for useful feedback. Light caching is significantly complicated by the introduction of progressive refinement. Because we wish to provide initial feedback to the user as quickly as possible, it is common for the lowest refinement level of the light cache to be valid, while higher refinement levels are in various invalid states. In order to update the cache, we maintain a table of the cached light parameters for each light at every refinement level. A given cache level is valid for a light if the cached parameters match the light?s current parameters.  If not, the cache is updated by reshading and subtracting the contribution of the old configuration, then shading and adding the new contribution.\n        \n      \n      \n        6 Multipass Rendering and Management\n        So far, we have focused on purely local illumination computation. However, global effects such as shadowing and translucency must also be reproduced. We first show how they can be included in our approach using multipass rendering and discuss both the necessary preprocessing and real-time components. We then address critical software architecture issues in making the development of our system tractable. The complex dependences between multipass effects, the indirect framebuffer, and progressive refinement made it important to develop an abstraction to facilitate the inclusion of new effects and manage dependences, as well as abstract key low-level aspects such as data-flow and bindings on the GPU. Fig. 11 summarizes the data-flow for our final real-time computation including shadow mapping, translucency, and indirect framebuffer effects.\n        ... ... shading re nement 2 shadow mapping light 1 shading re nement 1 light cache shadow geometry add update render indirect shaded color framebuffer shadow map shade main shading sample subsurface scattering deep-framebuffer accumulate translucency gather samples deep-framebuffer translucency image shade contribution\n        \n          \n        \n        indices shaded color accumulate accumulate hierarchy\n        \n          Figure 11: Data-flow dependencies in multipass rendering with progressive refinement. We abstract and manage dependencies using a computation graph automatically generated for the features of a specific scene during preprocessing.\n        \n        \n          6.1 Shadow Mapping\n          Shadow mapping illustrates how multipass effects from the final rendering pipeline can be included in our architecture. Shadow maps necessitate one extra pass per light and require auxiliary data from the preprocessor (scene geometry). For real-time preview, the shadow map pass communicates with the main pass through a texture and our graph interface (presented below) manages communication and dependences when parameters are edited. During caching, we run RenderMan a second time over the scene to extract micropolygons after all transforms and displacements are applied. We store object IDs to support selective shadow casting and receiving per-object. For specialization, RenderMan shadow mapping calls are flagged and marked dynamic. They are replaced in the dynamic code by a Cg shadow map lookup. When rendering the shadow map, we also render the object IDs to allow shadow assignments to be modified in real-time on a per-object basis.\n          ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n          25-8\n          ?\n          Ragan-Kelley et al.\n        \n        \n          6.2 Translucency\n          Subsurface scattering requires the integral of incident light flux times a BSSRDF diffusion kernel over a neighborhood at each visible point. We have adapted Jensen and Buhler?s hierarchical two-pass approach [2002], exactly as used in our existing offline shaders, for real-time preview. This method first creates a hierarchy of irradiance samples which enables fast hierarchical evaluation of the integral. Our scheme builds on the work by Ha san et al. [2006] for indirect lighting, but instead of a wavelet approach, we directly use Jensen and Buhler?s octree hierarchy [2002]. For translucency, we must distinguish the shading of visible shading samples as described in Section 4 and the irradiance computation at gather samples used to estimate subsurface scattering [Jensen and Buhler 2002]. In particular, the latter cannot have view-dependent terms and usually only requires albedo and normal information. We ?bake? this information during preprocessing into a separate translucency deep-framebuffer and generate a simple dynamic Cg shader, based on our offline irradiance shader, to evaluate irradiance (diffuse shading) during runtime. For each visible shading sample, we cache the indices of the set of nodes of the irradiance hierarchy that contribute to the translucency. We also store the corresponding BSSRDF coefficient weight (the dipole kernel) [Jensen and Buhler 2002] and distance to allow dynamic editing of the scattering depth. For interactive preview, we first evaluate the irradiance at each gather sample using the dynamic diffuse shader and the translucency deep framebuffer. This provides us with the leaf values of our hierarchy, stored in a texture. We then use d iterative blending passes for the d levels of the octree to accumulate the values of higher-level nodes as a sum of their children. All octree values are stored in the same texture map as the leaves. We can then compute the color of the visible shading samples. Because only the accumulation weights, not the actual octree traversal, depend on the BSSRDF coefficients, lookups into the octree are recorded statically during preprocessing and encoded as vertex arrays, much like the indirect framebuffer. We instead store static BSSRDF attenuation and distance terms per-lookup, and albedo modulation per-visible-point. We then dynamically compute the BSSRDF contribution based on dynamic scattering depth (sigma) values using a fragment shader while accumulating each lookup into the hierarchy?s irradiance values using the static indices recorded during preprocessing. Note that translucency computation is performed at the granularity of shading samples and benefits from the decoupling of our indirect framebuffer, both for progressive refinement and overall efficiency. Results Our initial results ( Fig. 12 ), while promising in their fidelity, demonstrate the need for a progressive shading technique. While final scattering contributions are evaluated progressively, per visible shading point, the static octree lookups require the translucency deep-framebuffer to be completely shaded prior to any accumulation. In practice, these deep-framebuffers can be even larger than the primary deep-framebuffer?1.3M points, in this example. This means that, while changing scattering coefficients render interactively (2 Hz) for this scene, and the base shader renders at 2-10 Hz for initial refinement, excluding scattering computations, reevaluating the subsurface scattering result takes several seconds to reach initial refinement (though subsequent refinement is very fast because the octree is already evaluated). We are considering subsampling and approximation techniques for progressive refinement, but leave this to future work.\n        \n        \n          6.3 The Multipass Computation Graph\n          Multipass algorithms such as shadow mapping and translucency, together with the indirect framebuffer and progressive refinement, introduce complex data-dependencies between and computations.\n          \n            \n            Figure 12:\n          \n          Subsurface scattering coefficients can be edited interactively. Top: less translucency. Bottom: more translucency. The preview renders initial refinement at 2 Hz under changing coefficients, but reshading the 1.3 million-point translucency buffer takes several seconds. The eyes contain multiple transparent layers, and appear black without the indirect framebuffer.\n          Furthermore, making our system extensible, and enforcing abstraction between the various components, required more care than we initially anticipated, and our original, monolithic engine quickly became challenging to maintain. We therefore chose to abstract individual algorithms from the overall data-flow through the real-time rendering pipeline ( Fig. 11 ) by using a dependency graph structure in which individual computations are encapsulated as nodes. Nodes communicate through ports, which abstract computation from dependency and data-flow, and global data-flow is encoded as edges between ports. Our core computation graph library also abstracts low-level aspects of shader and data management on the GPU, and includes a library of basic building block nodes. The graph instance for a scene is generated automatically by the compiler and preprocessing stages of our pipeline, and is used internally by the user interface application.\n        \n      \n      \n        7 Implementation and Results\n         Figure 13 summarizes our system?s fully-automatic performance on two of our shots (Figs. 1, 12). Cache sizes fit within current GPU resources, though our system scales to support out-of-core shots at much higher resolutions or with even more complex shaders. We report all results for our current, deployed artist workstations, with dual 2.6GHz AMD Opteron 2218 processors, 8GB RAM, and NVIDIA Quadro FX 5500 (G71) graphics. We are generally at the limit of the capability/performance curve for our current hardware, but preliminary results suggest major performance improvements on next-generation hardware.\n        ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n        The Lightspeed Automatic Interactive Lighting Preview System\n        ?\n        25-9\n        \n          Figure 13:\n        \n        Pirate (12) Robot (1) resolution 640x376 914x389 supersampling 4x4 13x13 lights 3 42 RenderMan (total) 409 sec 3406 sec irradiance shading 111 sec material shaders 1 2 material instances 4 44 light shaders 1 5 light instances 3 42 Caching (total) 1425 sec 931 sec initialization 8 sec 18 sec shader specialization 24 sec 63 sec deep-framebuffer caching 627 sec 499 sec shadow geometry caching 105 sec 164 sec cache compression 60 sec 187 sec octree compression 600 sec Preview irradiance shading (1 light) 7 sec interaction (irradiance cached) 0.5 sec coarse refinement, 4x4 blocks 0.1 sec full refinement (1 light changed) 10 sec 2.7 sec full refinement (n lights) 29 sec (3 lights) 31.7 (42 lights) deep-framebuffer 104 MB 256 MB indirect framebuffer 33 MB 29 MB irradiance deep-framebuffer 83 MB scattering index buffer 436 MB System performance compared to our RenderManbased offline pipeline for two production shots (Figs. 1 & 12). In both, initial feedback is accelerated several orders of magnitude, to interactive rates. Caching time for Robot is significantly less than even a single offline render (common for most complex shots), because we cache with lights turned off. Caching time for the Pirate example is dominated by unoptimized octree caching and compression processes which (unnecessarily) read and write multiple GB of octree data on disk several times during caching.\n        Our system has been integrated into the pipelines of two special effects studios. It is currently in initial release with a number of artists in production for both lighting and look-design. We have focused our efforts on ironing out the major, previously-unsolved technical challenges with such a system. As such, some technically straightforward but significant aspects of our implementation, such as shadow map rendering, currently lack extensive optimization, while significant effort has been paid to ensure the fidelity and scalability of the core compiler, preprocessing, and real-time shading components on complex scenes. Subsurface scattering is only proof-of-concept and requires further optimization. Nevertheless, initial feedback has been extremely positive. For example, artists love the freedom to experiment with complex features such as noise: ?[we] usually shy away from noise because it takes so long to edit...this interactivity makes it much more useful.? In general, there was a strong feeling that interactive feedback not only accelerated the adjustment of key parameters (?getting that level right [previously] took me an hour!? [after just tuning a light to match the background in under 10 seconds]), but left users more willing to experiment aggressively. GPU vs. specialization speedup We have estimated the gain due to specialization vs. GPU execution. Since we do not have a software preview runtime, we can only perform back of the envelope calculations comparing the GPU shaders to RenderMan shaders, and prman timing with real vs. trivial shaders. For the included scenes, we estimate that specialization and caching provide a 100x speedup while execution on the GPU brings another 20x. The coarsest level of refinement provides an extra 10-100x.\n        \n          \n          Figure 14:\n        \n        The upper-right half of the image is rendered with our approach while the lower left is the final RenderMan frame. Initial refinement renders at over 20 Hz with our full 4k instruction specialized surface shader and spot light, including shadows. Error is in percentage of max pixel value.\n        \n          \n        \n        Figure 15: 430k transparent hairs (? = 0.6, opacity threshold: 0.96) rendered at 720x389 with 8x8 sampling. This generates 43M micropolygons and 58M pixel samples in RenderMan, and condenses to 11M visible shading samples and 17M unique visibility samples through lossless visibility compression, rendering at 12 Hz and fully refining in 33 secs. Compression and performance are even better at ? = 1.0, but ? = 0.1 (threshold: 0.996) generates 21M visible shading samples, overflowing the 16M sample textures we currently use (cf. Fig. 10 ).\n        \n          7.1 Scalability\n          Shadow geometry scales with scene complexity and is the main scalability limitation, in practice. Using micropolygons instead of source primitives was a design decision to avoid re-implementing every primitive supported by prman. We control shadow-geometry level of detail by altering the shading rate of the shadow bake pass. Additional mesh decimation passes could be useful. Aside from shadowing, our system effectively scales with image complexity. The indirect framebuffer and cache compression dramatically reduce memory costs. Transparency is the main difference from previous techniques because it adds an unbounded number of samples. We created a complex scene to test scalability (Fig. 15): 430k transparent hair fibers (? = 0.1, opacity threshold= 0.996), resulting in 55M prman micropolygons and 20M visible Lightspeed shading samples rendered at 720x389 with 64x supersampling. This overflows our shade sample texture because of the GPU?s 4kx4k (16M) texture limit. However, with ? reduced to 0.6, the same scene only requires 11M shade samples (vs. 43M in prman) and works at 12 Hz (33 secs for full refinement because the full cache is 2GB and needs to be paged). With no transparency, Lightspeed shades just 4M samples (vs. 25M for prman) at 22 Hz (5.5 secs for full refinement). The 16M limit can trivially be increased by using multiple textures or 8k textures in DirectX 10.  For our production scenes, however, we have not encountered such extreme cases. Our artists avoid transparent hair in favor of smaller sub-pixel hair because these same scalability problems apply in prman. In fact, though unbounded, transparency consistently contributes much less to total frame complexity than (bounded) multisampling in our scenes. While the worst case scales with supersampled image complexity (times depth complexity for transparency), the key goal of our design?visibility compression and the linearization of visibility into the indirect framebuffer?is to provide real-world scaling much closer to pixel-complexity, even with motion blur ( Fig. 8 ), subpixel microgeometry like hair (Fig. 15), and a modest average transparency depth. The overall conclusion of our tests, ignoring shadowing, is: ? We can handle a lot of fine geometry, or handle a lot of very transparent coarse geometry, but our current implementation will not handle a lot of very transparent and fine geometry that completely fills the image, with antialiasing. ? We can handle a lot of fine geometry that is semi-transparent even if it fills the image, with high antialiasing. Where scene complexity can become an issue for the indirect framebuffer is during caching. Because simple methods of caching (bake3d) extract all shaded grids from prman, initial cache sizes can be very large, and compression becomes disk i/o bound. We addressed this by pushing compression in-memory with the renderer (as a DSO), which greatly accelerates caching and culling. The number of unique shaders can also be an issue. However, if a given surface shader is used for multiple surfaces with different parameters, we only need to specialize it once. The total number of dynamic shaders is the product of the number of different light shaders and the number of surface shaders (not the number of instances). Because we mostly use ?bershaders, this is not a problem for our workloads (?10-100 combinations in practice, Fig. 13 ), though it would be for studios with thousands of unique shaders in a shot. This might be addressed with established techniques, as discussed in Footnote 1.\n          ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n          25-10\n          ?\n          Ragan-Kelley et al.\n        \n        \n          7.2 Challenges and Limitations\n          In practice we find our approach quite robust. Major challenges we have addressed include: ? Dynamic calls to external C routines are largely eliminated during specialization, and, where they aren?t, they have been effectively emulated on the GPU or made cache-required. ? Generated deep-framebuffers are compressed to modest sizes, even for our more complicated scenes and shaders. ? GPU texture limits are abstracted through tiling. ? Complex visibility is effectively compressed, even at high multisampling rates. ? Interactivity is maintained in the face of complexity by progressive refinement. ? Automatically specialized shaders fit within current GPU limits. Future shaders will surpass the limits of our current hardware, but newer GPUs have already elevated the relevant program and register size limits by at least an order of magnitude. Our key limitations are the same faced by any GPU shading system?namely, that operations not easily expressed as native GPU instructions require special handling. Most importantly, nonlocal shading must be handled explicitly using multipass algorithms. We have achieved this for shadows and translucency, but additional implementation is required for other effects. Still, a number of features cannot be translated and would result in an error message if deemed dynamic. Fortunately, such features are usually not used in the dynamic parts of shaders in our studio. This may not be true in all studios.  Ray Tracing We do not perform ray casting. Note that specular ray tracing could be previewed in a deep-framebuffer using indirect buffers (ray intersections do not change unless the index of refraction is edited for transmitted rays). This is future work. The main limitation concerns ray-casting for shadows and inter-reflections. Ambient occlusion Lightspeed would require re-caching of occlusion if object-object shadowing assignments changed. Our artists only edit occlusion gain during lighting design, and interobject occlusion, itself, can be cached. Shadows Our system currently does not implement deep shadows and this is a serious limitation for scenes with hair. Brickmaps and pointclouds Memory management would present challenges for implementing brickmaps. We do not support them in dynamic code. This is a particular problem if brickmaps are used in a light shader. Our subsurface scattering implementation is an example where a point cloud is statically sampled at cache time, but the returned values are dynamic. Non-linear lights Non-linear contributions are not easily cached. Dynamic loops Dynamic loops containing cached expressions are a limitation. We support them in the special case where they are bounded, since we statically allocate space in the deep framebuffer. Figure 12 uses bounded dynamic loops for layered materials.\n        \n      \n      \n        8 Conclusions and Future Work\n        We have introduced a system for the real-time preview of RenderMan scenes during lighting design. Our method automatically specializes shaders into a static RenderMan pass that generates a deepframebuffer, and a dynamic Cg pass that uses the deep-framebuffer to enable real-time preview on a GPU. Cache compression enables automatically generated deep-framebuffers to fit in modest GPU memory for complex production shots. We have introduced the indirect framebuffer which efficiently encodes multisampling for high-quality rendering with transparency and motion blur. Our computation graph-based system architecture is flexible and is amenable to multipass rendering algorithms, which we demonstrate with shadow mapping and subsurface scattering. We were surprised by the effectiveness of cache compression. Initially, we assumed we would build complex compiler analyses to control cache size. However, due to the data-parallel nature of shading, redundancy abounds, and simple post-processes easily uncover savings which static analysis could not recognize. As a whole, our system brings a level of automation that greatly simplifies interactive lighting preview and alleviates the need to write and maintain different shaders for final rendering, preprocessing, and preview. However, it does not close the debate between manual instrumentation and automatic specialization. The manual programming of preview shaders can bring an extra level of flexibility, in particular to adapt the level of detail to further accelerate preview, as illustrated in lpics [Pellacini et al. 2005], though Pellacini separately showed that automatic level-of-detail can help [2005]. In the long run, we believe that lighting preview should be addressed in a way similar to traditional programming: automatic tools are provided for compilation and optimization, and the programmer can provide hints or manually optimize and simplify critical portions of the code based on profiling tools. Still, the greatest limitation to deep-framebuffer rendering is its basis in local shading. As global illumination becomes prevalent in production rendering, the ability to integrate global effects into this system will determine its future success. Fortunately, our techniques are not specific to GPUs. Rather, they are generally useful for reducing complex shading to efficient data-parallel execution, including on future manycore CPUs, and this may ultimately be the avenue through which global effects are most efficiently achieved.  Acknowledgments Numerous people have contributed to this project in its many years of exploration and implementation. This work started under the advising of Pat Hanrahan, initially in collaboration with Ujval Kapasi. Alex Aiken and John Kodumal proposed dependence analysis by graph reachability and provided the first analysis library we used. Matt Pharr, John Owens, Aaron Lefohn, Eric Chan, and many members of the Stanford and MIT Graphics Labs provided years of essential advice and feedback. Tippett Studio took great risk in actively supporting early research. Dan Goldman introduced the work to ILM, where Alan Trombla, Ed Hanway, and Steve Sullivan have overseen it. Many developers have contributed code, including Sebastian Fernandez, Peter Murphy, Simon Premo ze, and Aaron Luk. Hilmar Koch, Paul Churchill, Tom Martinek, and Charles Rose provided a critical artist?s perspective early in design. Dan Wexler, Larry Gritz, and Reid Gershbein provided useful explanations of commercial lighting technologies. We thank Michael Bay for graciously sharing unreleased images from his movie, Dan Piponi for generating our hair data, and the anonymous reviewers for their insightful discussion and criticism. Sylvain Paris, Ravi Ramamoorthi, Kevin Egan, Aner Ben-Artzi, and Kayvon Fatahalian provided critical writing feedback. This work was supported by NSF CAREER award 0447561, an NSF Graduate Research Fellowship, NVIDIA Graduate Fellowship, Ford Foundation Graduate Fellowship, Microsoft Research New Faculty Fellowship and a Sloan fellowship.\n        ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n        The Lightspeed Automatic Interactive Lighting Preview System\n        ?\n        25-11\n      \n      \n        References\n        \n          A LIAS , 1999. Interactive photorealistic rendering.\n          A NDERSEN , P. H. 1996. Partial evaluation applied to ray tracing. In Software Engineering in Scientific Computing, Vieweg, W. Mackens and S. Rump, Eds., 78?85.\n          A PODACA , A. A., AND G RITZ , L. 2000. Advanced RenderMan: creating CGI for motion pictures. Morgan Kaufmann.\n          B LEIWEISS , A., AND P REETHAM , A. 2003. Ashli?Advanced shading language interface. ACM SIGGRAPH Course Notes.\n          C OOK , R. L., C ARPENTER , L., AND C ATMULL , E. 1987. The reyes image rendering architecture. In Computer Graphics (Proceedings of SIGGRAPH 87), 95?102.\n          D ORSEY , J., A RVO , J., AND G REENBERG , D. 1995. Interactive design of complex time dependent lighting. IEEE Computer Graphics & Applications 15, 2 (Mar.), 26?36.\n          G ERSHBEIN , R., AND H ANRAHAN , P. M. 2000. A fast relighting engine for interactive cinematic lighting design. In Proceedings of ACM SIGGRAPH 2000, Computer Graphics Proceedings, Annual Conference Series, 353?358.\n          G UENTER , B., K NOBLOCK , T. B., AND R UF , E. 1995. Specializing shaders. In Proceedings of SIGGRAPH 95, Computer Graphics Proceedings, Annual Conference Series, 343?350.\n          H ANRAHAN , P. 1983. Ray tracing algebraic surfaces. In Proc. of SIGGRAPH 1983, 83?90.\n          H A SAN , M., P ELLACINI , F., AND B ALA , K. 2006. Direct-toindirect transfer for cinematic relighting. ACM Transactions on Graphics 25, 3 (July), 1089?1097.\n          H ORWITZ , S., R EPS , T., AND B INKLEY , D. 1990. Interprocedural slicing using dependence graphs. ACM Transactions on Programming Languages and Systems 12, 1, 26?60.\n          J ENSEN , H. W., AND B UHLER , J. 2002. A rapid hierarchical rendering technique for translucent materials. ACM Transactions on Graphics 21, 3 (July), 576?581.\n          J ONES , T. R., P ERRY , R. N., AND C ALLAHAN , M. 2000. Shadermaps: a method for accelerating procedural shading. Tech. rep., Mitsubishi Electric Research Laboratory.\n          K NOBLOCK , T. B., AND R UF , E. 1996. Data specialization. In Proc. of SIGPLAN 1996, 215?225.\n          M ARK , W. R., G LANVILLE , R. S., A KELEY , K., AND K ILGARD , M. J. 2003. Cg: A system for programming graphics hardware in a C-like language. ACM Transactions on Graphics 22, 3 (July), 896?907.\n          M OGENSEN , T. 1986. The application of partial evaluation to raytracing. Master?s thesis, DIKU, U. of Copenhagen, Denmark.\n          N G , R., R AMAMOORTHI , R., AND H ANRAHAN , P. 2003. Allfrequency shadows using non-linear wavelet lighting approximation. ACM Transactions on Graphics 22, 3 (July), 376?381.\n          N VIDIA , 2005. Sorbetto relighting technology.\n          P EERCY , M. S., O LANO , M., A IREY , J., AND U NGAR , P. J. 2000. Interactive multi-pass programmable shading. In Proceedings of ACM SIGGRAPH 2000, Computer Graphics Proceedings, Annual Conference Series, 425?432.\n          P ELLACINI , F., V IDIM CE ? , K., L EFOHN , A., M OHR , A., L EONE , M., AND W ARREN , J. 2005. Lpics: a hybrid hardwareaccelerated relighting engine for computer cinematography. ACM Transactions on Graphics 24, 3 (Aug.), 464?470.\n          P ELLACINI , F. 2005. User-configurable automatic shader simplification. ACM Transactions on Graphics 24, 3 (Aug.), 445?452.\n          P IXAR , 2001. Irma.\n          R AGAN -K ELLEY , J. 2007. The Lightspeed Automatic Interactive Lighting Preview System. Master?s thesis, Massachusetts Institute of Technology.\n          R EPS , T., H ORWITZ , S., AND S AGIV , M. 1995. Precise interprocedural data flow analysis via graph reachability. In Proc. of SPPL 1995, 49?61.\n          S AITO , T., AND T AKAHASHI , T. 1990. Comprehensible rendering of 3-d shapes. In Computer Graphics (Proceedings of SIGGRAPH 90), 197?206.\n          S ? QUIN , C. H., AND S MYRL , E. K. 1989. Parameterized ray tracing. In Computer Graphics (Proceedings of SIGGRAPH 89), 307?314.\n          S LOAN , P.-P., K AUTZ , J., AND S NYDER , J. 2002. Precomputed radiance transfer for real-time rendering in dynamic, lowfrequency lighting environments. ACM Transactions on Graphics 21, 3 (July), 527?536.\n          T ABELLION , E., AND L AMORLETTE , A. 2004. An approximate global illumination system for computer generated films. ACM Transactions on Graphics 23, 3 (Aug.), 469?476.\n          W EXLER , D., G RITZ , L., E NDERTON , E., AND R ICE , J. 2005. Gpu-accelerated high-quality hidden surface removal. In Graphics Hardware 2005, 7?14.\n        \n        ACM Transactions on Graphics, Vol. 26, No. 3, Article 25, Publication date: July 2007.\n      \n    \n  ",
  "resources" : [ ]
}