{
  "uri" : "sig2006-p494-wonka_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2006/p494-wonka_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Guided Visibility Sampling",
    "published" : "2006",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Peter-Wonka",
      "name" : "Peter",
      "surname" : "Wonka"
    }, {
      "uri" : "http://drinventor/Michael-Wimmer",
      "name" : "Michael",
      "surname" : "Wimmer"
    }, {
      "uri" : "http://drinventor/Kaichi-Zhou",
      "name" : "Kaichi",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Stefan-Maierhofer",
      "name" : "Stefan",
      "surname" : "Maierhofer"
    }, {
      "uri" : "http://drinventor/Gerd-Hesina",
      "name" : "Gerd",
      "surname" : "Hesina"
    }, {
      "uri" : "http://drinventor/Alexander-Reshetov",
      "name" : "Alexander",
      "surname" : "Reshetov"
    } ]
  },
  "bagOfWords" : [ "show", "Figure", "where", "after", "initial", "orthogonal", "sampling", "only", "few", "additional", "ray", "need", "find", "all", "visible", "surface", "alternatively", "boundary", "void", "volume", "-lrb-", "void", "surface", "-lsb-", "Pito", "1999", "-rsb-", "-rrb-", "can", "use", "which", "easy", "sample", "from", "one", "point", "space", "difficult", "manipulate", "use", "we", "can", "define", "visibility", "function", "so", "each", "ray", "map", "triangle", "intersect", "first", "we", "algorithm", "aggressive", "-lrb-", "-lsb-", "Nirenstein", "et", "al.", "2002", "-rsb-", "-rrb-", "i.e.", "calculate", "potentially", "visible", "set", "pv", "ev", "we", "algorithm", "can", "use", "solve", "visibility", "problem", "different", "application", "-lrb-", "see", "Section", "5.6", "-rrb-", "preprocessing", "step", "we", "algorithm", "use", "calculate", "store", "pv", "each", "view", "cell", "-lrb-", "note", "only", "its", "boundary", "polygon", "take", "account", "since", "any", "ray", "leave", "view", "cell", "can", "represent", "ray", "boundary", "-rrb-", "runtime", "view", "cell", "correspond", "current", "observer", "location", "determine", "only", "object", "associate", "pv", "send", "graphic", "hardware", "lead", "significant", "savings", "render", "time", "we", "one", "most", "popular", "sampling", "strategy", "random", "sampling", "-lrb-", "section", "3.1", "-rrb-", "reverse", "sampling", "algorithm", "sample", "region", "space", "likely", "near", "boundary", "visible", "invisible", "space", "i.e.", "void", "surface", "-lrb-", "section", "3.3", "-rrb-", "ray", "have", "start", "point", "-lrb-", "3d", "-rrb-", "direction", "dir", "-lrb-", "2d", "-rrb-", "while", "define", "5d", "set", "ray", "we", "only", "need", "consider", "4d", "set", "ray", "practice", "ray", "start", "boundary", "view", "region", "additionally", "all", "triangle", "intersect", "classify", "visible", "random", "-lrb-", "pseudo-random", "-rrb-", "sampling", "algorithm", "select", "sequence", "random", "sample", "from", "scene", "question", "sampling", "uniformity", "random", "sampling", "have", "be", "explore", "context", "form-factor", "computation", "-lsb-", "Sbert", "1993", "-rsb-", "key", "idea", "sampling", "strategy", "adapt", "sampling", "rate", "geometric", "detail", "surface", "-lrb-", "see", "Figure", "-rrb-", "method", "perform", "especially", "well", "most", "frequent", "case", "connected", "mesh", "do", "assume", "use", "any", "connectivity", "information", "algorithm", "proceed", "follow", "point", "we", "also", "detect", "depth", "discontinuity", "between", "new", "sample", "original", "sample", "triangle", "which", "already", "part", "reverse", "sampling", "describe", "next", "section", "other", "hand", "too", "tight", "hit", "again", "due", "numerical", "precision", "ray", "shooting", "more", "robust", "because", "depend", "neither", "distance", "triangle", "nor", "its", "orientation", "only", "numerical", "precision", "ray", "representation", "practice", "mean", "each", "vertex", "new", "vertex", "put", "plane", "perpendicular", "ray", "each", "vertex", "three", "vertex", "generate", "backface", "triangle", "need", "invert", "adaptive", "border", "sampling", "efficiently", "explore", "connected", "visible", "area", "input", "model", "from", "single", "viewpoint", "along", "1d", "curve", "ray", "space", "-lrb-", "see", "Section", "5.4", "-rrb-", "however", "can", "penetrate", "gap", "visible", "only", "from", "other", "portion", "ray", "space", "handle", "reverse", "sampling", "however", "adaptive", "sampling", "process", "give", "good", "candidate", "location", "further", "sampling", "ray", "namely", "discontinuity", "location", "predict", "hitpoint", "just", "intersection", "ray", "plane", "original", "triangle", "new", "hitpoint", "considerably", "-lrb-", "-rrb-", "closer", "i.e.", "ray", "obviously", "occlude", "closer", "triangle", "note", "we", "do", "check", "reverse", "case", "-lrb-", "jump", "from", "closer", "farther", "triangle", "-rrb-", "detect", "when", "do", "adaptive", "border", "sampling", "farther", "triangle", "we", "calculate", "mutate", "ray", "from", "different", "view", "cell", "position", "predict", "hitpoint", "so", "pass", "occlude", "triangle", "plane", "-lrb-", "hit", "-lrb-", "-rrb-", "hit", "-lrb-", "old", "-rrb-", "-rrb-", "intersect", "newly", "find", "triangle", "-lrb-", "old", "previous", "ray", "from", "which", "generate", "-rrb-", "2d", "example", "Figure", "reverse", "sampling", "correspond", "horizontal", "movement", "ray", "space", "sampling", "strategy", "present", "so", "far", "can", "combine", "extremely", "efficient", "guide", "visibility", "sampling", "algorithm", "its", "two", "main", "component", "sample", "generator", "explore", "ray", "space", "independent", "random", "sample", "sampling", "queue", "propagate", "ray", "use", "adaptive", "border", "sampling", "reverse", "sampling", "depend", "application", "requirement", "several", "option", "regard", "when", "stop", "cast", "ray", "view", "cell", "-rrb-", "fix", "criterion", "allocate", "number", "ray", "amount", "time", "computation", "each", "view", "cell", "-rrb-", "adaptive", "criterion", "terminate", "number", "newly", "find", "triangle", "per", "certain", "number", "sample", "fall", "below", "threshold", "most", "preferably", "-rrb-", "combination", "both", "typical", "example", "criterion", "stop", "iteration", "when", "more", "than", "50", "new", "triangle", "find", "1m", "ray", "when", "total", "10m", "ray", "have", "be", "shoot", "whichever", "come", "first", "compare", "efficiency", "we", "algorithm", "previous", "work", "we", "use", "follow", "algorithm", "gv", "we", "guide", "visibility", "sampling", "algorithm", "adaptive", "border", "sampling", "-lrb-", "ab", "-rrb-", "reverse", "sampling", "-lrb-", "r", "-rrb-", "RAND", "random", "sampling", "-lrb-", "GVS", "value", "epsilon", "5e-5", "use", "enlarge", "triangle", "-rrb-", "we", "have", "dedicate", "separate", "subsection", "comparison", "nir", "main", "other", "exist", "visibility", "sampling", "method", "publish", "Nirenstein", "Blake", "-lsb-", "2004", "-rsb-", "-lrb-", "mainly", "because", "algorithm", "have", "slightly", "different", "goal", "than", "gv", "-rrb-", "EXACT", "Bittner?s", "-lsb-", "2003", "-rsb-", "exact", "visibility", "algorithm", "test", "scene", "select", "-lrb-", "see", "Figure", "Table", "-rrb-", "PPLANT", "complete", "UNC", "Power", "Plant", "model", "CITY", "city", "model", "ancient", "city", "Pompeii", "generate", "use", "cityengine", "-lsb-", "m?ller", "et", "al.", "2006", "-rsb-", "CANYON", "dataset", "Grand", "Canyon", "CUBES", "simple", "scene", "random", "cube", "test", "be", "conduct", "Intel", "pentium4", "3.2", "ghz", "4gb", "main", "memory", "top", "left", "city", "top", "right", "CUBES", "bottom", "leave", "PPLANT", "bottom", "right", "CANYON", "gv", "rand", "we", "use", "intel?s", "multi-level", "ray", "tracer", "-lrb-", "mlrta", "-lsb-", "Reshetov", "et", "al.", "2005", "-rsb-", "-rrb-", "which", "allow", "sampling", "rate", "between", "about", "800k/s", "1200k/s", "peak", "up", "several", "million", "samples/s", "sampling", "rate", "depend", "scene", "type", "-lrb-", "so", "much", "size?pplant", "have", "higher", "sampling", "rate", "than", "CANYON", "example", "-rrb-", "coherence", "ray", "-lrb-", "random", "sample", "ab", "sample", "be", "faster", "depend", "again", "scene", "-rrb-", "overhead", "sampling", "selection", "process", "vary", "between", "15", "depend", "relative", "distribution", "random", "ab", "r", "ray", "since", "we", "do", "have", "exact", "visibility", "algorithm", "run", "reasonable", "time", "larger", "scene", "we", "can", "only", "study", "asymptotic", "behavior", "small", "number", "view", "cell", "black", "dot", "each", "view", "cell", "curve", "show", "when", "we", "termination", "criterion", "terminate", "pv", "search", "-lrb-", "we", "use", "50", "less", "new", "triangle", "find", "per", "1m", "sample", "-rrb-", "can", "see", "happen", "fairly", "well", "converged", "state", "already", "graph", "also", "show", "behavior", "very", "similar", "all", "view", "cell", "length", "linear", "segment", "only", "depend", "final", "pv", "size", "lower", "right", "image", "show", "blue", "view", "cell", "from", "other", "image", "top", "right", "figure", "show", "rand", "comparison", "convergence", "rand", "look", "mainly", "logarithmic", "have", "very", "quick", "falloff", "after", "initial", "strong", "phase", "bottom", "right", "figure", "analyze", "behavior", "even", "larger", "scale", "dark", "blue", "view", "cell", "from", "other", "graph", "figure", "confirm", "quick", "convergence", "gv", "show", "even", "after", "200m", "sample", "rand", "still", "several", "thousand", "triangle", "behind", "gv", "can", "conclude", "would", "take", "rand", "several", "order", "magnitude", "longer", "find", "pv", "GVS", "can", "find", "about", "7M", "8m", "sample", "finally", "bottom", "left", "figure", "prove", "PVS", "size", "correlate", "strongly", "average", "pixel", "error", "termination", "criterion", "discuss", "above", "work", "well", "practice", "bring", "average", "pixel", "error", "below", "30", "pixel", "1000x1000", "screen", "due", "better", "distribution", "initial", "sample", "rand", "show", "lower", "average", "pixel", "error", "phase", "where", "gv", "search", "mainly", "deterministically", "however", "reach", "same", "pixel", "error", "provide", "gv", "converged", "state", "rand", "have", "calculate", "similar", "number", "triangle", "PVS", "lead", "same", "observation", "before", "similar", "pixel", "error", "require", "order", "magnitude", "more", "sample", "than", "gv", "next", "we", "demonstrate", "finding", "generalize", "larger", "number", "scene", "provide", "practical", "analysis", "include", "run", "time", "Table", "summarize", "we", "finding", "we", "use", "same", "convergence", "criterion", "50", "triangle", "per", "1m", "sample", "gv", "constant", "150m", "ray", "rand", "can", "see", "result", "very", "similar", "average", "maximum", "error", "both", "algorithm", "however", "run", "time", "differ", "more", "than", "order", "magnitude", "which", "reflect", "good", "convergence", "behavior", "gv", "respect", "rand", "show", "above", "table", "also", "list", "result", "NIR", "which", "discuss", "follow", "subsection", "addition", "error", "we", "also", "give", "size", "pv", "term", "whole", "model", "size", "-lrb-", "ev", "available", "reasonable", "time", "-rrb-", "512x512", "1024x1024", "resolution", "last", "column", "show", "average", "size", "calculate", "pv", "percentage", "whole", "model", "one", "hand", "both", "base", "same", "atomic", "operation?taking", "visibility", "sample", "because", "sampling", "graphic", "hardware", "ray", "tracer", "functionally", "practically", "equivalent", "due", "available", "sub-pixel", "precision", "-lrb-", "usually", "12", "bit", "-rrb-", "current", "graphic", "hardware", "time", "complexity", "however", "differ", "significantly", "between", "two", "algorithm", "time", "complexity", "ray", "casting", "linear", "number", "ray", "due", "spatial", "datum", "structure", "logarithmic", "number", "object", "practice", "we", "have", "also", "observe", "strong", "dependence", "type", "scene", "implementation", "ray", "tracer", "which", "make", "general", "prediction", "scalability", "respect", "scene", "size", "very", "hard", "graphic", "hardware", "basic", "operation", "item-buffer", "render", "only", "CANYON", "model", "do", "we", "observe", "fill", "rate", "limitation", "-lrb-", "vs.", "12", "hemicubes/s", "512", "vs.", "1024", "resolution", "-rrb-", "whereas", "city", "pplant", "be", "geometry", "limited", "-lrb-", "hemicubes/s", "-rrb-", "efficient", "acceleration", "algorithm", "exist", "both", "architecture", "certain", "amount", "preprocessing", "tolerate", "particular", "importance", "visibility", "processing", "complexity", "scene", "can", "handle", "ray", "trace", "limit", "only", "available", "storage", "space", "ray", "caster", "can", "work", "efficiently", "out", "core", "-lrb-", "e.g.", "Wald", "et", "al.", "-lsb-", "2004", "-rsb-", "have", "demonstrate", "350", "million", "polygon", "model", "can", "ray", "cast", "2-3", "frame", "per", "second", "-rrb-", "recent", "advance", "hardware", "ray", "trace", "-lsb-", "Woop", "et", "al.", "2005", "-rsb-", "promise", "huge", "po", "tential", "improve", "speed", "sampling-based", "algorithm", "like", "gv", "even", "further", "once", "technology", "become", "more", "commonplace", "NIR", "aim", "increase", "render", "speed", "aggressively", "cull", "more", "object", "than", "actually", "occluded", "rationale", "be", "large", "gain", "render", "speed", "can", "obtain", "error", "final", "image", "tolerate", "indeed", "nir", "consistently", "underestimate", "pv", "show", "Table", "-lrb-", "note", "even", "error", "threshold", "significant", "rest-error", "report", "nir", "-lsb-", "nirenstein", "Blake", "2004", "-rsb-", "-rrb-", "where", "GVS", "excel", "gv", "algorithm", "aim", "provide", "most", "accurate", "pv", "possible", "minimum", "number", "sample", "we", "result", "show", "gv", "use", "limited", "number", "sample", "consistently", "find", "largest", "pv", "result", "average", "pixel", "error", "below", "0.005", "should", "note", "result", "Table", "NIR", "result", "derive", "through", "pv", "subdivision", "threshold", "which", "work", "differently", "from", "method", "use", "gv", "rand", "can", "therefore", "compare", "directly", "we", "find", "threshold", "very", "sensitive", "type", "scene", "have", "tune", "so", "lead", "excessive", "subdivision", "too", "early", "termination", "each", "scene", "separately", "-lrb-", "example", "once", "case", "error", "1024", "resolution", "significantly", "worse", "than", "512", "due", "premature", "termination", "-rrb-", "we", "compare", "we", "algorithm", "EXACT", "CUBES", "scene", "from", "view", "cell", "about", "1.5", "x1", ".5", "m.", "EXACT", "take", "19", "piv", "1.7", "GHz", "PC", "find", "3,743", "visible", "triangle", "find", "same", "number", "triangle", "gv", "require", "about", "3", "gv", "screenspace", "error", "0.001", "already", "report", "after", "2", "more", "interesting", "however", "fact", "both", "gv", "rand", "find", "significantly", "more", "visible", "triangle", "than", "EXACT", "give", "enough", "sample", "example", "3,850", "triangle", "be", "find", "after", "only", "15s", "gv", "note", "EXACT", "use", "basis?better", "result", "could", "certainly", "achieve", "tuning", "numerical", "threshold", "intrinsic", "method", "show", "clearly", "accuracy", "visibility", "algorithm", "even", "exact", "one", "ultimately", "limit", "numerical", "issue", "section", "compare", "various", "pect", "propose", "visibility", "sampling", "algorithm", "wider", "class", "from-region", "visibility", "algorithm", "general", "overview", "we", "can", "recommend", "excellent", "survey", "visibility", "problem", "algorithm", "-lsb-", "Durand", "1999", "Cohen-Or", "et", "al.", "2003", "-rsb-", "exact", "solution", "compute", "visibility", "from", "region", "space", "have", "be", "rare", "-lsb-", "Duguet", "Drettakis", "2002", "Durand", "1999", "-rsb-", "recently", "two", "algorithm", "have", "be", "publish", "-lsb-", "Nirenstein", "et", "al.", "2002", "Bittner", "2003", "-rsb-", "further", "improve", "upon", "-lsb-", "Haumont", "et", "al.", "2005", "Mora", "et", "al.", "2005", "-rsb-", "both", "exact", "work", "general", "scene", "while", "exact", "algorithm", "have", "be", "holy", "grail", "visibility", "community", "long", "time", "two", "algorithm", "show", "complexity", "inherent", "visibility", "problem", "may", "obstacle", "make", "exact", "visibility", "widely", "applicable", "several", "author", "stress", "importance", "conservative", "visibility", "computation", "i.e.", "never", "underestimate", "visible", "set", "since", "problem", "almost", "hard", "exact", "visibility", "problem", "practically", "all", "publish", "conservative", "from-region", "algorithm", "simplify", "problem", "impose", "certain", "restriction", "scene", "typical", "restriction", "limitation", "2.5", "visibility", "-lsb-", "Wonka", "et", "al.", "2000", "Bittner", "et", "al.", "2001", "Koltun", "et", "al.", "2001", "-rsb-", "architectural", "scene", "-lsb-", "Airey", "et", "al.", "1990", "Teller", "S?quin", "1991", "-rsb-", "restriction", "volumetric", "occluder", "-lsb-", "Schaufler", "et", "al.", "2000", "-rsb-", "restriction", "larger", "occluder", "close", "view", "cell", "-lsb-", "Leyvand", "et", "al.", "2003", "Durand", "et", "al.", "2000", "-rsb-", "last", "restriction", "imply", "nature", "datum", "structure", "use", "store", "visibility", "information", "while", "can", "argue", "larger", "occluder", "can", "synthesize", "from", "smaller", "one", "-lsb-", "Andujar", "et", "al.", "2000", "-rsb-", "possible", "general", "guarantee", "include", "all", "visible", "geometry", "pv", "may", "important", "some", "application", "ultimately", "sampling-based", "method", "can", "much", "more", "successful", "oppose", "publish", "conservative", "algorithm", "do", "make", "any", "assumption", "about", "scene", "allow", "they", "handle", "much", "larger", "variety", "scene", "numerical", "issue", "often", "make", "conservative", "algorithm", "nonconservative", "practice", "since", "visibility", "fundamental", "problem", "general", "robust", "practical", "tool", "important", "complement", "specialize", "algorithm", "discuss", "before", "tool", "almost", "universally", "base", "sampling", "another", "option", "shoot", "ray", "from", "scene", "triangle", "towards", "view", "cell", "-lsb-", "Gotsman", "et", "al.", "1999", "-rsb-", "which", "lead", "oversampling", "ray", "space", "most", "scene", "Nirenstein", "Blake", "-lsb-", "2004", "-rsb-", "be", "first", "realize", "full", "potential", "sampling", "visibility", "computation", "discuss", "section", "4.4", "algorithm", "aim", "reduce", "render", "time", "cull", "even", "visible", "triangle", "long", "do", "result", "significant", "render", "error", "oppose", "we", "algorithm", "which", "always", "try", "find", "best", "possible", "approximation", "exact", "visible", "set", "Ray", "space", "analysis", "introduction", "Figure", "we", "have", "argue", "desirable", "sample", "ray", "space", "regularly", "right", "image", "figure", "show", "only", "approximately", "1d", "subspace", "ray", "need", "consider", "simple", "2d", "example", "we", "new", "algorithm", "sample", "ray", "space", "more", "intelligently", "random", "sampling", "place", "initial", "seed", "point", "ray", "space", "stochastically", "search", "region", "ray", "space", "have", "be", "explore", "yet", "continue", "example", "2d", "figure", "adaptive", "border", "sampling", "correspond", "vertical", "expansion", "2d", "ray", "space", "-lrb-", "since", "viewpoint", "remain", "fixed", "-rrb-", "which", "only", "proceed", "yet", "unexplored", "area", "particular", "advantage", "adaptive", "border", "sampling", "method", "sampling", "rate", "adapt", "geometric", "complexity", "visible", "surface", "reverse", "sampling", "other", "hand", "movement", "horizontal", "direction", "-lrb-", "since", "hitpoint", "remain", "fixed", "-rrb-", "case", "where", "movement", "promise", "lead", "yet", "explore", "region", "full", "3d", "case", "instructive", "study", "we", "algorithm", "term", "visibility", "complex", "-lsb-", "Durand", "1999", "-rsb-", "visibility", "complex", "describe", "partition", "4d", "ray", "space", "4d", "region", "ray", "hit", "same", "object", "-lrb-", "note", "ray", "space", "strictly", "4d", "because", "we", "only", "interested", "ray", "start", "from", "view", "cell", "-rrb-", "3d", "boundary", "partition", "call", "tangency", "volume", "consist", "ray", "tangent", "scene", "object", "since", "we", "keep", "viewpoint", "-lrb-", "degree", "freedom", "-rrb-", "fix", "during", "deterministic", "ab", "exploration", "phase", "we", "need", "sample", "1d", "set", "only", "without", "ab", "we", "would", "ignore", "tangency", "volume", "have", "sample", "whole", "2d", "subset", "ray", "space", "define", "choose", "viewpoint", "reverse", "sampling", "other", "hand", "look", "line", "tangent", "two", "scene", "edge", "intersection", "call", "bitangent", "only", "2d", "reverse", "sampling", "viewpoint", "allow", "move", "along", "plane", "-lrb-", "1d", "-rrb-", "so", "total", "r", "also", "sample", "1d", "set", "combined", "ab", "r", "strategy", "therefore", "correspond", "exploration", "4d", "ray", "space", "along", "those", "1d", "curve", "most", "likely", "reveal", "new", "object", "explain", "high", "efficiency", "gv", "algorithm", "another", "useful", "interpretation", "ab", "sampling", "strategy", "3d", "base", "visibility", "map", "-lsb-", "Bittner", "2002", "-rsb-", "segment", "can", "characterize", "mainly", "flat", "corner", "-lrb-", "interior", "edge", "mesh", "-rrb-", "shadow", "-lrb-", "depth", "discontinuity", "-rrb-", "ab", "sampling", "strategy", "place", "sample", "all", "edge", "visibility", "map", "-lrb-", "without", "explicitly", "construct", "-rrb-", "sample", "interior", "edge", "mesh", "serve", "find", "connected", "set", "mesh", "-lrb-", "trivially", "adjacent", "region", "visibility", "complex", "-rrb-", "Shadow", "edge", "where", "r", "sampling", "strategy", "use", "refine", "sampling", "-lrb-", "find", "bitangent", "visibility", "complex", "-rrb-", "term", "conservative", "-lrb-", "even", "exact", "-rrb-", "visibility", "actually", "quite", "misleading", "most", "algorithm", "though", "conservative", "theory", "conservative", "practice", "due", "numerical", "robustness", "problem", "especially", "true", "algorithm", "rely", "graphic", "hardware", "due", "much", "improved", "sampling", "efficiency", "magnitude", "error", "introduce", "we", "algorithm", "comparable", "other", "error", "source", "other", "algorithm", "often", "use", "conjunction", "visibility", "processing", "like", "level-of-detail", "algorithm", "shadow", "mapping", "additional", "source", "error", "scene", "complexity", "one", "distinguish", "feature", "we", "samplingbased", "algorithm", "can", "handle", "arbitrary", "type", "scene", "high", "overall", "visual", "complexity", "do", "rely", "occluder", "synthesis", "depend", "mostly", "size", "visible", "set", "total", "scene", "complexity", "although", "guide", "visibility", "sampling", "generally", "find", "major", "part", "PVS", "very", "quickly", "fact", "stochastic", "one", "hand", "guide", "visibility", "scene", "other", "hand", "make", "final", "accuracy", "dependent", "structure", "scene", "also", "ability", "explore", "connected", "ray", "space", "subset", "far", "distance", "limit", "numerical", "precision", "ray", "direction", "vector", "ab", "mean", "triangle", "have", "solid", "angle", "less", "than", "double", "precision", "accuracy", "when", "see", "from", "ray", "origin", "most", "likely", "miss", "worst", "case", "scene", "complexity", "scene", "consist", "large", "set", "small", "disconnect", "triangle", "forest", "scene", "synthetic", "scene", "random", "triangle", "visibility", "scene", "so", "complex", "even", "sampling-based", "solution", "either", "have", "high", "error", "take", "long", "time", "compute", "still", "important", "point", "out", "sampling-based", "algorithm", "only", "one", "able", "even", "process", "scene", "geometric", "lod", "could", "potentially", "increase", "speed", "ray", "tracer", "make", "intersection", "computation", "more", "robust", "because", "small", "triangle", "distance", "get", "replace", "larger", "one", "however", "robust", "geometric", "lod", "available", "all", "scene", "integrate", "lod", "ray", "tracer", "current", "topic", "research", "furthermore", "error", "metric", "use", "create", "lod", "impact", "accuracy", "visibility", "algorithm", "therefore", "usable", "output", "resolution", "one", "important", "strength", "sampling-based", "method", "ease", "application", "we", "discuss", "number", "application", "scenario", "we", "algorithm", "visibility", "preprocessing", "real-time", "rendering", "game", "gv", "can", "use", "all", "stage", "game", "development", "during", "level", "design", "number", "ray", "can", "limit", "so", "coarse", "solution", "can", "provide", "almost", "instantaneously", "final", "production", "pv", "can", "calculate", "high", "accuracy", "addition", "antialiasing", "method", "-lrb-", "supersampling", "multisampling", "-rrb-", "use", "information", "from", "subpixel", "triangle", "so", "virtual", "resolution", "even", "higher", "note", "although", "scene", "computer", "game", "inherently", "dynamic", "major", "part", "scene", "still", "static", "so", "huge", "gain", "render", "speed", "can", "obtain", "online", "networked", "visibility", "show", "result", "reasonable", "approximation", "ev", "low", "pixel", "error", "can", "find", "second", "less", "therefore", "gv", "can", "use", "online", "visibility", "culling", "run", "separate", "processor", "over", "network", "describe", "instant", "visibility", "system", "-lsb-", "Wonka", "et", "al.", "2001", "-rsb-", "case", "transmit", "pv", "per-object", "basis", "improve", "result", "because", "suffice", "one", "triangle", "object", "find", "gv", "order", "classify", "whole", "object", "visible", "give", "better", "distribution", "sample", "initial", "phase", "algorithm", "since", "ab", "systematically", "flood", "fill", "PVS", "around", "its", "seed", "point", "take", "some", "time", "until", "all", "image", "region", "have", "be", "reach", "impostor", "generation", "many", "scene", "visibility", "culling", "sufficient", "guarantee", "high", "frame", "rate", "everywhere", "model", "therefore", "image-based", "method", "can", "use", "replace", "complex", "scene", "part", "so-called", "impostor", "however", "since", "impostor", "trade", "render", "speed", "against", "memory", "consumption", "important", "find", "exact", "visible", "part", "scene", "avoid", "waste", "impostor", "memory", "invisible", "geometry", "-lsb-", "Jeschke", "et", "al.", "2005", "-rsb-", "gv", "ideally", "suit", "purpose", "since", "provide", "accurate", "per-triangle", "visibility", "information", "so", "only", "those", "object", "part", "actually", "visible", "need", "store", "impostor", "visibility", "decision", "basis", "many", "practical", "application", "require", "accurate", "visibility", "information", "part", "decision", "make", "process", "example", "include", "visibility", "analysis", "urban", "planning", "-lrb-", "do", "new", "skyscraper", "impact", "old", "town", "-rrb-", "military", "application", "-lrb-", "line", "sight", "culling", "tactical", "battlefield", "management", "-lsb-", "McDermott", "Gelsey", "1987", "-rsb-", "-rrb-", "telecommunications", "-lrb-", "visibility", "emitter", "-rrb-", "robotic", "many", "more", "gv", "advantageous", "problem", "because", "general", "purpose", "do", "have", "any", "parameter", "tweak", "do", "depend", "any", "special", "property", "scene", "we", "have", "present", "visibility", "sampling", "algorithm", "compute", "full", "3d", "visibility", "solution", "from", "region", "space", "propose", "algorithm", "improve", "efficiency", "previous", "sampling", "strategy", "over", "two", "order", "magnitude", "thereby", "allow", "visibility", "solution", "negligible", "error", "compute", "reasonable", "time", "propose", "algorithm", "work", "arbitrary", "so-called", "polygon", "soup", "do", "require", "any", "memory", "beyond", "use", "ray", "caster", "due", "new", "sampling", "strategy", "employ", "algorithm", "its", "accuracy", "competitive", "even", "exact", "conservative", "approach", "while", "also", "extremely", "simple", "implement", "we", "have", "provide", "evidence", "guided", "visibility", "sample", "close", "important", "gap", "visibility", "research", "combine", "speed", "ease", "implementation", "sampling-based", "special-purpose", "conservative", "algorithm", "most", "accuracy", "exact", "solution", "thus", "gv", "can", "use", "general", "purpose", "visibility", "tool", "we", "thank", "Jiri", "Bittner", "fruitful", "discussion", "research", "also", "support", "EU", "scope", "GameTools", "project", "-lrb-", "ist-2-004363", "-rrb-", "NGA", "grant", "hm1582-05-1-2004" ],
  "content" : "This is shown in Figure 3 , where after an initial orthogonal sampling, only few additional rays are needed to find all visible surfaces. Alternatively, the boundary of the void volume (the void surface [Pito 1999]) can be used, which is easy to sample from one point in space, but difficult to manipulate. Using T S and ?, we can define a visibility function v : ? ? T S, so that each ray in ? maps to the triangle in T S that it intersects first. Our algorithm is aggressive ([Nirenstein et al. 2002]), i.e., it calculates a potentially visible set PV S ? EV S. Our algorithm can be used to solve the visibility problem in different applications (see Section 5.6). In a preprocessing step, our algorithm is used to calculate and store a PVS for each view cell (note that only its boundary polygons are taken into account, since any ray leaving the view cell can be represented by a ray on the boundary). At runtime, the view cell corresponding to the current observer location is determined, and only the objects in the associated PVS are sent to the graphics hardware, leading to significant savings in rendering time. We will start with one of the most popular sampling strategies, random sampling (Section 3.1). Reverse Sampling is an algorithm to sample into regions in space that are likely to be near the boundaries of visible and invisible space, i.e., the void surface (Section 3.3). A ray x has a starting point x p (3D) and a direction x dir (2D). While this defines a 5D set of rays, we only need to consider a 4D set of rays in practice; the rays starting at the boundary ? R of the viewing region. Additionally, all triangles intersecting R are classified as visible. The random (or pseudo-random) sampling algorithm selects a sequence of random samples X = x i from the scene. The question of sampling uniformity for random sampling has been explored in the context of form-factor computation [Sbert 1993]. The key idea of this sampling strategy is that it adapts the sampling rate to the geometric detail of the surface (see Figure 5 ). The method performs especially well for the most frequent case of a connected mesh, but does not assume or use any connectivity information. The algorithm proceeds as follows. At this point, we also detect depth discontinuities between the new samples and the original sample on the triangle, which is already a part of reverse sampling as described in the next section. On the other hand, if it is too tight, t will be hit again due to the numerical precision of ray shooting. This is more robust because it depends neither on the distance of the triangle nor on its orientation, but only on the numerical precision of the ray representation. In practice, this means that for each vertex, the new vertices are put on a plane perpendicular to the ray. For each vertex p i of t, three vertices p i, j on t are generated. For backfacing triangles, the d i, j need to be inverted. Adaptive border sampling efficiently explores connected visible areas of the input model from a single viewpoint along a 1D curve in ray space (see Section 5.4). However, it cannot penetrate into gaps  visible only from other portions of ray space. This is handled by reverse sampling. However, the adaptive sampling process gives good candidate locations for further sampling rays, namely at discontinuity locations. The predicted hitpoint is just the intersection of the ray x with the plane of the original triangle t. If the new hitpoint is considerably (?) closer, i.e., the ray is obviously occluded by a closer triangle. Note that we do not check the reverse case (jump from closer to farther triangle) as this will be detected when doing adaptive border sampling for the farther triangle. We calculate a mutated ray from a different view cell position to the predicted hitpoint so that it passes by the occluding triangle. For this, the plane p = (x p , hit(x), hit(x old )) is intersected with the newly found triangle (x old is the previous ray from which x was generated). For the 2D example in Figure 3 , reverse sampling corresponds to a horizontal movement in ray space. The sampling strategies presented so far can be combined into an extremely efficient guided visibility sampling algorithm. Its two main components are a sample generator for exploring the ray space with independent random samples, and a sampling queue for propagating the ray using adaptive border sampling and reverse sampling. Depending on the application requirements, there are several options regarding when to stop casting rays for a view cell: a) a fixed criterion, allocating a number of rays or an amount of time for the computation of each view cell, or b) an adaptive criterion, terminating if the number of newly found triangles per a certain number of samples falls below a threshold, or most preferably, c) a combination of both. A typical example for such a criterion is: stop the iteration when not more than 50 new triangles are found for 1M rays, or when a total of 10M rays has been shot, whichever comes first. To compare the efficiency of our algorithm to previous work, we use the following algorithms: GVS, our guided visibility sampling algorithm with adaptive border sampling (ABS) and reverse sampling (RS); and RAND, random sampling (in GVS, a value of epsilon of 5e-5 was used for enlarging triangles). We have dedicated separate subsections to the comparisons with NIR, the main other existing visibility sampling method published by Nirenstein and Blake [2004] (mainly because this algorithm has a slightly different goal than GVS); and EXACT, Bittner?s [2003] exact visibility algorithm. The test scenes selected are (see Figure 7 and Table 1 ): PPLANT, the complete UNC Power Plant model; CITY, a city model of the ancient city of Pompeii generated using the CityEngine [M?ller et al. 2006]; CANYON, a dataset of the Grand Canyon; and CUBES, a simple scene of random cubes. The tests were conducted on an Intel Pentium4 3.2GHz with 4GB of main memory. Top left: CITY. Top right: CUBES. Bottom left: PPLANT. Bottom right: CANYON. For GVS and RAND, we used Intel?s multi-level ray tracer (MLRTA [Reshetov et al. 2005]), which allowed sampling rates between about 800K/s and 1200K/s, with peaks up to several million samples/s. The sampling rate depends on the scene type (not so much on the size?PPLANT had a higher sampling rate than CANYON, for example), and on the coherence of the rays (with random samples and ABS samples being faster depending again on the scene). The overhead of the sampling selection process varied between 5 and 15%, depending on the relative distribution of random, ABS and RS rays. Since we do not have an exact visibility algorithm that runs in reasonable time on larger scenes, we can only study their asymptotic behavior on a small number of view cells. The black dot on each view cell curve shows when our termination criteria terminates the PVS search (we used 50 or less new triangles found per 1M samples). It can be seen that this happens in a fairly well converged state already. The graph also shows that the behavior is very similar for all view cells. The length of the linear segment only depends on the final PVS size. the lower right image show the blue view cell from the other images. The top right figure shows RAND in comparison. The convergence of RAND looks mainly logarithmic and has a very quick falloff after an initial strong phase. The bottom right figure analyzes this behavior on an even larger scale for the dark blue view cell from the other graphs. This figure confirms the quick convergence of GVS, and shows that even after 200M samples, RAND is still several thousand triangles behind GVS. It can be concluded that it would take RAND several orders of magnitude longer to find a PVS that GVS can find with about 7M to 8M samples. Finally, the bottom left figure proves that the PVS size correlates strongly to average pixel error, and that the termination criterion discussed above works well in practice, bringing the average pixel error below 30 pixels on a 1000x1000 screen. Due to the better distribution of initial samples, RAND shows lower average pixel error in the phase where GVS searches mainly deterministically. However, to reach the same pixel errors as provided by GVS in a converged state, RAND has to calculate a similar number of triangles in the PVS, leading to the same observation as before, that similar pixel error requires orders of magnitude more samples than with GVS. Next, we demonstrate that these findings generalize to a larger number of scenes, and provide a practical analysis including running times. Table 2 summarizes our findings. We used the same convergence criterion of 50 triangles per 1M samples for GVS, and a constant 150M rays for RAND. It can be seen that this results in very similar average and maximum errors for both algorithms. However, the running times differ by more than an order of magnitude, which reflects the good convergence behavior of GVS with respect to RAND shown above. The table also lists results for NIR, which are discussed in the following subsection. In addition to the error we also give the size of the PVS in terms of the whole model size (an EVS was not available in reasonable time). 512x512 and 1024x1024 resolution. The last column shows the average size of the calculated PVS as a percentage of the whole model. On the one hand, they are both based on the same atomic operation?taking a visibility sample. This is because sampling with graphics hardware and with a ray tracer is functionally practically equivalent due to the available sub-pixel precision (usually 12 bit) in current graphics hardware. The time complexity, however, differs significantly between the two algorithms. The time complexity of ray casting is linear in the number of rays and, due to spatial data structures, logarithmic in the number of objects. In practice, we have also observed a strong dependence on the type of the scene and the implementation of the ray tracer, which makes general predictions on the scalability with respect to scene size very hard. For graphics hardware, the basic operation is an item-buffer render. Only on the CANYON model did we observe a fill rate limitation (9 vs. 12 hemicubes/s for 512 vs. 1024 resolutions), whereas CITY and PPLANT were geometry limited (7 and 2 hemicubes/s). Efficient acceleration algorithms exist for both architectures, if a certain amount of preprocessing is tolerated. Of particular importance for visibility processing is that the complexity of scenes that can be handled by ray tracing is limited only by the available storage space, as ray casters can work efficiently out of core (e.g., Wald et al. [2004] have demonstrated that a 350 million polygon model can be ray cast at 2-3 frames per second). Recent advances in hardware for ray tracing [Woop et al. 2005] promise a huge po tential for improving the speed of sampling-based algorithms like GVS even further, once this technology becomes more commonplace. NIR aims to increase rendering speed by aggressively culling more objects than are actually occluded, the rationale being that large gains in rendering speed can be obtained if errors in the final image are tolerated. Indeed, NIR consistently underestimates the PVS, as shown in Table 2 (note that even for an error threshold of 0, a significant rest-error is reported for NIR [Nirenstein and Blake 2004]). This is where GVS excels. The GVS algorithm aims to provide the most accurate PVS possible with a minimum number of samples. Our results show that GVS, using a limited number of samples, consistently finds the largest PVS, resulting in average pixel errors below 0.005%. It should be noted for the results in Table 2 that NIR results are derived through a PVS subdivision threshold, which works differently from the method used in GVS and RAND and can therefore not be compared directly. We found that this threshold was very sensitive to the type of the scene and had to be tuned so as not to lead to excessive subdivision or too early termination in each scene separately (for example, in once case the error for the 1024 resolution was significantly worse than for 512, due to premature termination). We compared our algorithm to EXACT on the CUBES scene, from a view cell of about 1.5x1.5m. EXACT took 19s on a PIV 1.7GHz PC to find 3,743 visible triangles. To find the same number of triangles, GVS required about 3s. For GVS, a screenspace error of 0.001% was already reported after 2s. More interesting, however, is the fact that both GVS and RAND found significantly more visible triangles than EXACT if given enough samples. For example, 3,850 triangles were found after only 15s by GVS. Note that EXACT was used on an ?as is? basis?better results could certainly be achieved by tuning numerical thresholds intrinsic to the method. This shows clearly that the accuracy of visibility algorithms, even exact ones, is ultimately limited by numerical issues. This section compares various as pects of the proposed visibility sampling algorithm to a wider class of from-region visibility algorithms. For a general overview, we can recommend excellent surveys of visibility problems and algorithms [Durand 1999; Cohen-Or et al. 2003]. Exact solutions to compute visibility from a region in space have been rare [Duguet and Drettakis 2002; Durand 1999], but recently, two algorithms have been published [Nirenstein et al. 2002; Bittner 2003] and further improved upon [Haumont et al. 2005; Mora et al. 2005] that are both exact and work for general scenes. While exact algorithms have been the holy grail of the visibility community for a long time, these two algorithms show that the complexity inherent in the visibility problem may be an obstacle to make exact visibility widely applicable. Several authors stress the importance of conservative visibility computations, i.e., never underestimating the visible set. Since this problem is almost as hard as the exact visibility problem, practically all published conservative from-region algorithms simplify the problem by imposing certain restrictions on the scene. Typical restrictions are the limitation to 2.5D visibility [Wonka et al. 2000; Bittner et al. 2001; Koltun et al. 2001], architectural scenes [Airey et al. 1990; Teller and S?quin 1991], the restriction to volumetric occluders [Schaufler et al. 2000], or the restriction to larger occluders close to the view cell [Leyvand et al. 2003; Durand et al. 2000]?this last restriction is implied by the nature of the data structures used to store visibility information. While it can be argued that larger occluders can be synthesized from smaller ones [Andujar et al. 2000], this is not possible in general. The guarantee to include all visible geometry in the PVS may be important for some applications, but ultimately, sampling-based methods can be much more successful: 1. As opposed to the published conservative algorithms, they do not make any assumptions about the scene, allowing them to handle a much larger variety of scenes. Numerical issues often make conservative algorithms nonconservative in practice. Since visibility is such a fundamental problem, general, robust and practical tools are important to complement the specialized algorithms discussed before. These tools are almost universally based  on sampling. Another option is to shoot rays from the scene triangles towards the view cell [Gotsman et al. 1999], which leads to oversampling of ray space for most scenes. Nirenstein and Blake [2004] were the first to realize the full potential of sampling for visibility computation. As discussed in Section 4.4, this algorithm aims to reduce the rendering time by culling even visible triangles as long as this does not result in significant rendering error. This is opposed to our algorithm, which always tries to find the best possible approximation of the exact visible set. Ray space analysis. In the introduction in Figure 3 , we have argued that it is desirable not to sample the ray space regularly. The right image in this figure shows that only an approximately 1D subspace of rays needs to be considered in this simple 2D example. Our new algorithm samples ray space more intelligently: random sampling places initial seed points in ray space to stochastically search for regions in ray space that have not been explored yet. To continue the example for 2D as in the figure, adaptive border sampling corresponds to a vertical expansion in 2D ray space (since the viewpoint remains fixed) which only proceeds into yet unexplored areas. A particular advantage of the adaptive border sampling method is that the sampling rate is adapted to the geometric complexity of the visible surfaces. Reverse sampling, on the other hand, is a movement in the horizontal direction (since the hitpoint remains fixed) in cases where these movements promise to lead to not yet explored regions. For the full 3D case, it is instructive to study our algorithm in terms of the visibility complex [Durand 1999]. The visibility complex describes a partition of the 4D ray space into 4D regions of rays that hit the same object (note that ray space is strictly 4D because we are only interested in rays starting from the view cell). The 3D boundaries of this partition are called tangency volume and consist of rays tangent to scene objects. Since we keep the viewpoint (2 degrees of freedom) fixed during the deterministic ABS exploration phase, we need to sample a 1D set only. Without ABS, we would ignore the tangency volumes and have to sample the whole 2D subset of ray space defined by the chosen viewpoint. Reverse sampling, on the other hand, looks for lines tangent to two scene edges. These intersections are called bitangents and are only 2D. For reverse sampling, the viewpoint is allowed to move along a plane (1D), so in total RS also samples a 1D set. The combined ABS and RS strategies therefore correspond to explorations of the 4D ray space along those 1D curves that are most likely to reveal new objects. This explains the high efficiency of the GVS algorithm. Another useful interpretation of the ABS sampling strategy in 3D is based on the visibility map [Bittner 2002]. These segments can be characterized mainly as flat and corner (interior edges of a mesh), or shadow (depth discontinuities). The ABS sampling strategy places samples at all edges of the visibility map (without explicitly constructing it). Samples on interior edges of a mesh serve to find connected sets of a mesh (trivially adjacent regions in the visibility complex). Shadow edges are where the RS sampling strategy is used to refine the sampling (by finding the bitangents in the visibility complex). The term conservative (or even exact) visibility is actually quite misleading. Most algorithms, though conservative in theory, are not conservative in practice due to numerical robustness problems. This is especially true for algorithms relying on graphics hardware. Due to the much improved sampling efficiency, the magnitude of error introduced by our algorithm is comparable to that of other error sources. Other algorithms that are often used in conjunction with visibility processing, like level-of-detail algorithms or shadow mapping, are an additional source of errors. Scene complexity. One distinguishing feature of our samplingbased algorithm is that it can handle arbitrary types of scenes with high overall and visual complexity. It does not rely on occluder synthesis, and depends mostly on the size of the visible set, not on the total scene complexity. Although guided visibility sampling generally finds the major part of the PVS very quickly, the fact that it is stochastic on the one hand and guided by the visibility in the scene on the other hand makes the final accuracy dependent on the structure of the scene. Also, the ability to explore connected ray space subsets in the far distance is limited by the numerical precision of the ray direction vector. For ABS, this means that triangles that have a solid angle of less than double precision accuracy when seen from the ray origin will most likely be missed. The worst case of scene complexity is in scenes that consist of a large set of small disconnected triangles, such as forest scenes or synthetic scenes of random triangles. The visibility of such scenes is so complex that even sampling-based solutions will either have high error or take a long time to compute. Still, it is important to point out that sampling-based algorithms are the only ones that are able to even process these scenes. Geometric LODs could potentially increase the speed of the ray tracer, and make intersection computations more robust because small triangles in the distance get replaced by larger ones. However, robust geometric LOD is not available for all scenes, and integrating LODs into ray tracers is a current topic of research. Furthermore, the error metric used to create the LODs impacts the accuracy of the visibility algorithm and therefore the usable output resolutions. One important strength of sampling-based methods is their ease of application. We will discuss a number of application scenarios for our algorithm. Visibility preprocessing for real-time rendering and games. GVS can be used in all stages of game development: During level design, the number of rays can be limited so that a coarse solution can be provided almost instantaneously. For the final production, the PVS can be calculated with high accuracy. In addition, antialiasing methods (supersampling and multisampling) use information from subpixel triangles, so that the virtual resolution is even higher. Note that although scenes in computer games are inherently dynamic, the major part of the scene is still static, so huge gains in rendering speeds can be obtained. Online and networked visibility. As shown in the results, a reasonable approximation to the EVS with low pixel error can be found in a second or less. Therefore, GVS can be used for online visibility culling by running it on a separate processor or over the network, as described in the Instant Visibility system [Wonka et al. 2001]. In this case, transmitting the PVS on a per-object basis will improve results because it suffices for one triangle of an object to be found by GVS in order to classify the whole object as visible. This will give a better distribution of samples in the initial phase of the algorithm, since ABS systematically ?flood fills? the PVS around its seed point, and it takes some time until all image regions have been reached. Impostor generation. In many scenes, visibility culling is not sufficient to guarantee a high frame rate everywhere in the model. Therefore, image-based methods can be used to replace complex scene parts by so-called impostors. However, since impostors trade rendering speed against memory consumption, it is important to find the exact visible parts of the scene to avoid wasting impostor memory on invisible geometry [Jeschke et al. 2005]. GVS is ideally suited for this purpose since it provides accurate per-triangle visibility information, so that only those object parts that are actually visible need to be stored in an impostor. Visibility as decision basis. Many practical applications require accurate visibility information as part of a decision making process. Examples include visibility analysis in urban planning (does the new skyscraper impact old town? ), military applications (line of sight culling, tactical battlefield management [McDermott and Gelsey 1987]), telecommunications (visibility of emitters), robotics and many more. GVS is advantageous for these problems because it is general purpose and does not have any parameters to tweak, and does not depend on any special properties of the scene. We have presented a visibility sampling algorithm to compute a full 3D visibility solution from a region in space. The proposed algorithm improves the efficiency of previous sampling strategies by over two orders of magnitude, thereby allowing visibility solutions with negligible error to be computed in reasonable time. The proposed algorithm works on arbitrary so-called polygon soups and does not require any memory beyond that used by the ray caster. Due to the new sampling strategies employed in the algorithm, its accuracy is competitive even with exact and conservative approaches, while it is also extremely simple to implement. We have provided evidence that Guided Visibility Sampling closes an important gap in visibility research. It combines the speed and ease of implementation of sampling-based and special-purpose conservative algorithms with most of the accuracy of exact solutions. Thus, GVS can be used as a general purpose visibility tool. We thank Jiri Bittner for fruitful discussions. This research was also supported by the EU in the scope of the GameTools project (IST-2-004363), and by the NGA, grant no. HM1582-05-1-2004.",
  "resources" : [ ]
}