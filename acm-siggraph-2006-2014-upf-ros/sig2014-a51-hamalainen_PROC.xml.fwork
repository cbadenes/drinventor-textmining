{
  "uri" : "sig2014-a51-hamalainen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2014/a51-hamalainen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Online Motion Synthesis Using Sequential Monte Carlo",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "strategy", "represent", "each", "sample", "evaluate", "parallel", "use", "causal", "physics", "engine", "cr", "category", "i.", "3.7", "-lsb-", "Computer", "Graphics", "-rsb-", "three-dimensional", "graphic", "realism?animation", "keyword", "animation", "motion", "synthesis", "motion", "planning", "sequential", "Monte", "Carlo", "particle", "filter", "optimization", "we", "score", "potential", "control", "strategy", "objective", "function", "-lrb-", "fitness", "function", "-rrb-", "measure", "goal", "attainment", "physical", "property", "motion", "more", "complete", "review", "we", "refer", "Geijtenbeek", "et", "al.", "-lsb-", "2011", "-rsb-", "we", "focus", "optimization", "base", "animation", "active", "character", "-lrb-", "e.g.", "locomotion", "jump", "dodge", "-rrb-", "instead", "passive", "ragdoll", "trivial", "implement", "use", "off-the-shelf", "physics", "engine", "like", "Open", "Dynamics", "Engine", "Bullet", "other", "hand", "symbolic", "expression", "Jacobians", "Hessians", "available", "which", "motivate", "use", "stochastic", "derivative-free", "optimization", "method", "Reference", "motion", "can", "track", "under", "disturbance", "e.g.", "use", "mpc", "approach", "short-horizon", "qp", "controller", "run", "intermittently", "augment", "proportional-derivate", "-lrb-", "pd", "-rrb-", "controller", "each", "simulation", "step", "-lsb-", "da", "silva", "et", "al.", "2008", "-rsb-", "preprocessing", "motion", "datum", "spacetime", "optimization", "use", "nonlinear", "quadratic", "regulator", "-lsb-", "Muico", "et", "al.", "2009", "-rsb-", "sampling-based", "optimization", "time-varying", "pose", "displacement", "relative", "reference", "trajectory", "-lsb-", "Liu", "et", "al.", "2010", "-rsb-", "subgoal", "quite", "detailed", "move", "lift", "foot", "so", "ground", "projection", "character?s", "center", "mass", "lie", "midway", "between", "foot", "compare", "particle", "filter", "we", "apply", "similar", "prediction", "weight", "update", "resample", "operation", "sample", "formula", "differ", "tree", "structure", "use", "compute", "sample", "weight", "adaptive", "exploration", "variance", "example", "Thrun", "et", "al.", "-lsb-", "2000", "-rsb-", "describe", "bayesian", "mobile", "robot", "localization", "use", "kd-tree", "sample", "weight", "computing", "conditional", "sampling", "from", "precomputed", "model", "joint", "distribution", "pose", "observation", "Rudoy", "Wolfe", "-lsb-", "2006", "-rsb-", "building", "Ihler", "et", "al.", "-lsb-", "2003", "-rsb-", "describe", "efficient", "tree-based", "sampling", "from", "product", "gaussian", "mixture", "track", "probability", "density", "-lrb-", "-rrb-", "approximate", "set", "sample", "which", "iteratively", "weighted", "resampled", "sample", "note", "weight", "depict", "here", "only", "exemplary", "exact", "weighting", "formula", "vary", "between", "method", "multimodality", "objective", "function", "motivate", "sequential", "Monte", "Carlo", "-lrb-", "SMC", "-rrb-", "approach", "contrary", "particle", "filter", "approach", "we", "simply", "treat", "objective", "function", "-lrb-", "-rrb-", "sequence", "unnormalized", "target", "probability", "density", "instead", "modeling", "posterior", "density", "-lrb-", "-rrb-", "marginal", "likelihood", "-lrb-", "-rrb-", "where", "denote", "observation", "relate", "x.", "whereas", "typical", "smc", "weighting", "comprise", "division", "proposal", "density", "we", "use", "kd-tree-based", "estimate", "realize", "sample", "density", "Figure", "give", "example", "objective", "function", "2d", "ball", "throw", "optimization", "basic", "idea", "store", "sample", "coordinate", "objective", "function", "value", "-lcb-", "-lrb-", "-rrb-", "-rcb-", "kd-tree", "build", "over", "domain", "each", "leaf", "node", "hypercube", "volume", "each", "leaf", "give", "approximate", "measure", "local", "density", "sample", "covariance", "diagonal", "element", "jj", "-lrb-", "ij", "-rrb-", "where", "scaling", "parameter", "-lrb-", "we", "use", "0.5", "-rrb-", "ij", "width", "leaf", "hypercube", "along", "dimension", "time", "coordinate", "express", "offset", "from", "previous", "control", "point", "from", "current", "time", "first", "control", "point", "give", "sequence", "objective", "function", "measure", "fitness", "value", "realization", "use", "formula", "give", "section", "4.4", "where", "y-coordinate", "character?s", "normalize", "forward", "vector", "compute", "from", "torso", "priority", "rolling", "example", "real", "human", "typically", "follow", "fly", "object", "gaze", "try", "look", "expect", "landing", "spot", "while", "airborne" ],
  "content" : "The strategies represented by each sample are evaluated in parallel using a causal physics engine. CR Categories: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism?Animation Keywords: animation, motion synthesis, motion planning, sequential Monte Carlo, particle filter, optimization We score the potential control strategies by an objective function (a fitness function) that measures goal attainment and the physical properties of the motion. For a more complete review, we refer to Geijtenbeek et al. [2011]. We focus on optimization based animation of active characters (e.g., locomotion, jumping, dodging) instead of passive ragdolls that are trivial to implement using off-the-shelf physics engines like Open Dynamics Engine or Bullet. On the other hand, symbolic expressions of Jacobians and Hessians are not available, which motivates the use of stochastic, derivative-free optimization methods. Reference motions can be tracked under disturbances, e.g., using an MPC approach with a short-horizon QP controller that is run intermittently and augmented with a proportional-derivate (PD) controller at each simulation step [Da Silva et al. 2008], or preprocessing motion data with spacetime optimization and then using a nonlinear quadratic regulator [Muico et al. 2009], or sampling-based optimization of a time-varying pose displacement relative to the reference trajectory [Liu et al. 2010]. The subgoals are quite detailed, such as moving a lifted foot so that the ground projection of the character?s center of mass lies midway between the feet. Compared to particle filters, we apply similar prediction, weight updating, and resampling operations to the samples, but the formulae differ as the tree structure is used to compute sample weights and adaptive exploration variances. For example, Thrun et al. [2000] describe Bayesian mobile robot localization using a kD-tree for sample weight computing, and for conditional sampling from a precomputed model of the joint distribution of poses and observations. Rudoy and Wolfe [2006], building on Ihler et al. [2003] describe efficient tree-based sampling from products of Gaussian mixtures. The tracked probability density f(x) is approximated by a set of samples, which are iteratively weighted, resampled and sampled. Note that the weights depicted here are only exemplary; the exact weighting formulae vary between methods. Multimodality of the objective function motivates a Sequential Monte Carlo (SMC) approach. Contrary to particle filter approaches, we simply treat the objective function f (x; t) as a sequence of unnormalized target probability densities, instead of modeling the posterior density p(x t |y 1:t ) or the marginal likelihood p(y 1:t ), where y denotes observations related to x. Whereas typical SMC weighting comprises a division by the proposal density, we use a kD-tree-based estimate of the realized sample density. Figure 4 gives an example of the objective function of 2D ball throw optimization. The basic idea is to store the sample coordinates and objective function values {x i , f (x i )} into a kD-tree built over the domain. Each leaf node is a hypercube, and the volume V i of each leaf gives an approximate measure of the local density of samples. The covariance C i is diagonal with elements c jj = (?d ij ) 2 , where ? is a scaling parameter (we use ? = 0.5) and d ij is the width of the leaf hypercube i along dimension j. The time coordinate is expressed as an offset from the previous control point, or from the current time for the first control point. Given the sequence, the objective function then measures the fitness value of the realization using formulae given in Section 4.4. where y f is the y-coordinate of the character?s normalized forward vector computed from the torso, and w r is the priority of the rolling. For example, real humans typically follow flying objects with their gaze, and try to look at the expected landing spot while airborne.",
  "resources" : [ ]
}