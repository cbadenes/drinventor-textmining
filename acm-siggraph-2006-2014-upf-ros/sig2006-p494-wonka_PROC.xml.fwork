{
  "uri" : "sig2006-p494-wonka_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2006/p494-wonka_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Guided Visibility Sampling",
    "published" : "2006",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Peter-Wonka",
      "name" : "Peter",
      "surname" : "Wonka"
    }, {
      "uri" : "http://drinventor/Michael-Wimmer",
      "name" : "Michael",
      "surname" : "Wimmer"
    }, {
      "uri" : "http://drinventor/Kaichi-Zhou",
      "name" : "Kaichi",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Stefan-Maierhofer",
      "name" : "Stefan",
      "surname" : "Maierhofer"
    }, {
      "uri" : "http://drinventor/Gerd-Hesina",
      "name" : "Gerd",
      "surname" : "Hesina"
    }, {
      "uri" : "http://drinventor/Alexander-Reshetov",
      "name" : "Alexander",
      "surname" : "Reshetov"
    } ]
  },
  "bagOfWords" : [ "we", "algorithm", "improve", "sampling", "efficiency", "previous", "work", "over", "two", "order", "magnitude", "cr", "category", "i.", "3.7", "-lsb-", "Computer", "Graphics", "-rsb-", "three-dimensional", "graphic", "realism?visible", "line/surface", "algorithm", "Keywords", "visibility", "occlusion", "culling", "pv", "visibility", "sampling", "number", "excellent", "from-region", "visibility", "algorithm", "exist", "most", "they", "only", "applicable", "limited", "range", "scene", "require", "complex", "computation", "sometimes", "significant", "amount", "memory", "inefficiency", "pure", "regular", "sampling", "approach", "show", "figure", "same", "surface", "sample", "over", "over", "again", "-lrb-", "note", "definition", "regular", "depend", "parameterization", "ray", "space", "second", "key", "aspect", "visibility", "algorithm", "what", "datum", "structure", "use", "store", "visibility", "information", "most", "complete", "also", "complex", "way", "store", "4d", "ray", "space", "algorithm", "require", "little", "memory", "simple", "implement", "accept", "any", "triangular", "test", "scene", "input", "can", "use", "general", "purpose", "visibility", "tool", "exact", "solution", "visibility", "problem", "range", "function", "-lrb-", "-rrb-", "also", "call", "exact", "visible", "set", "ev", "usage", "scenario", "keep", "mind", "follow", "exposition", "visibility", "preprocessing", "system", "real-time", "rendering", "view", "space", "-lrb-", "set", "possible", "observer", "location", "-rrb-", "partition", "view", "cell", "algorithm", "call", "guide", "because", "both", "sampling", "strategy", "guide", "visibility", "information", "scene", "-lrb-", "see", "Section", "5.4", "more", "detailed", "discussion", "-rrb-", "all", "ray", "scene", "form", "5d", "space", "probability", "distribution", "each", "new", "sample", "-lrb-", "-rrb-", "independent", "all", "previous", "sample", "...", "we", "sample", "position", "ray", "direction", "uniformly", "use", "follow", "formula", "??", "arcsin", "where", "independent", "Halton", "sequence", "-lsb-", "Niederreiter", "1992", "-rsb-", "-lrb-", "-rrb-", "normalize", "coordinate", "view", "cell", "face", "while", "random", "sampling", "alone", "suffer", "from", "similar", "inefficiency", "regular", "sampling", "-lrb-", "see", "section", "-rrb-", "use", "seed", "more", "efficient", "strategy", "describe", "next", "sampling", "algorithm", "deterministic", "ray", "mutation", "strategy", "cover", "most", "ground", "work", "make", "we", "system", "successful", "each", "edge", "we", "use", "two", "ray", "corresponding", "sample", "hit", "-lrb-", "-rrb-", "hit", "-lrb-", "-rrb-", "world", "space", "actual", "method", "use", "border", "enlargement", "deserve", "attention", "shape", "choose", "so", "ray", "space", "distance", "fairly", "constant", "third", "midpoint", "other", "two", "push", "away", "from", "along", "angle", "bisector", "+1", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "+1", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "+1", "-rrb-", "+1", "else", "-lrb-", "-lrb-", "-rrb-", "+1", "-lrb-", "-rrb-", "-rrb-", "where", "-lrb-", "-rrb-", "vector", "normalization", "operator", "note", "can", "do", "perfectly", "find", "actual", "void", "volume", "equivalent", "original", "visibility", "problem", "strategy", "work", "change", "start", "point", "ray", "instead", "its", "direction", "algorithm", "describe", "follow", "pseudocode", "graphic", "card", "NIR", "NVIDIA", "GeForce", "7900GTX", "512mb", "we", "first", "analyze", "theoretical", "property", "algorithm", "term", "sampling", "behavior", "i.e.", "sample-by-sample", "basis", "since", "only", "comparison", "do", "depend", "individual", "implementation", "Figure", "provide", "detailed", "analysis", "CANYON", "scene", "graph", "pixel", "error", "-lrb-", "calculate", "count", "false", "pixel", "large", "number", "random", "rendering", "-lsb-", "nirenstein", "Blake", "2004", "-rsb-", "-rrb-", "number", "triangle", "find", "over", "number", "sample", "gv", "rand", "higher", "value", "mean", "more", "accurate", "solution", "intrinsic", "parameter", "have", "adjust", "each", "scene", "obtain", "reasonable", "result", "-lrb-", "see", "comment", "section", "4.4", "-rrb-", "Nirenstein", "Blake", "-lsb-", "2004", "-rsb-", "recently", "publish", "interesting", "adaptive", "regular", "sampling", "algorithm", "which", "use", "graphic", "hardware", "adaptively", "sample", "hemi-cube", "view", "cell", "depend", "whether", "particular", "view", "mostly", "fill", "geometry", "limited", "resolution", "item", "buffer", "have", "more", "less", "impact", "render", "time", "we", "implementation", "NIR", "render", "model", "from", "multiple", "vertex", "buffer", "store", "directly", "video", "memory", "which", "provide", "triangle", "throughput", "near", "theoretical", "maximum", "card", "we", "use", "-lrb-", "between", "130", "190m", "triangles/s", "depend", "how", "many", "vertex", "be", "share", "model?note", "some", "vertex", "have", "duplicated", "allow", "item", "buffer", "rendering", "-rrb-", "therefore", "performance", "metric", "gv", "total", "percentage", "culled", "object", "degree", "which", "actual", "pv", "can", "approximate", "large", "volume", "research", "have", "be", "devote", "visibility", "problem", "due", "importance", "computer", "graphic", "computer", "vision", "robotic", "other", "field", "from-region", "visibility", "algorithm", "usually", "classify", "exact", "-lrb-", "potentially", "visible", "set", "pv", "exact", "visible", "set", "ev", "-rrb-", "conservative", "-lrb-", "pv", "ev", "-rrb-", "aggressive", "-lrb-", "pv", "ev", "-rrb-", "approximate", "-lrb-", "pv", "ev", "-rrb-", "we", "believe", "sampling-based", "method", "exact", "method", "complement", "each", "other", "have", "different", "strength", "weakness", "due", "ease", "implementation", "robustness", "nonconservative", "algorithm", "more", "practical", "commercial", "product", "computer", "game", "-lsb-", "Aila", "Miettinen", "2004", "-rsb-", "already", "use", "context", "two", "most", "popular", "solution", "randomly", "select", "large", "number", "ray", "sample", "visibility", "-lsb-", "Schaufler", "et", "al.", "2000", "Airey", "et", "al.", "1990", "Shade", "et", "al.", "1998", "-rsb-", "first", "sample", "boundary", "view", "cell", "point", "sample", "visibility", "from", "each", "point", "-lsb-", "Levoy", "Hanrahan", "1996", "Stuerzlinger", "1999", "-rsb-", "similar", "algorithm", "also", "use", "generation", "textured", "depth", "mesh", "-lsb-", "Wilson", "Manocha", "2003", "-rsb-", "propose", "new", "approach", "which", "use", "graphic", "hardware", "sampling", "sample", "place", "along", "object", "border", "therefore", "correspond", "sample", "near", "tangency", "volume", "object", "dual", "space", "ray", "space", "line", "near", "intersection", "two", "tangency", "volume", "visibility", "map", "structure", "contain", "all", "visible", "line", "segment", "give", "view", "sample", "shadow", "edge", "serve", "discover", "depth", "discontinuity", "where", "object", "partly", "occlude", "other", "object", "furthermore", "complex", "algorithm", "prone", "implementation", "problem", "error", "usually", "tolerate", "conservative", "algorithm", "-lrb-", "see", "Section", "-rrb-", "scenario", "already", "describe", "overview", "one", "most", "important", "application", "gv", "furthermore", "gv", "work", "arbitrary", "polyhedral", "view", "cell", "so", "view", "space", "can", "choose", "freely" ],
  "content" : "Our algorithm improves the sampling efficiency of previous work by over two orders of magnitude. CR Categories: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism?Visible line/surface algorithms Keywords: visibility, occlusion culling, PVS, visibility sampling A number of excellent from-region visibility algorithms exist, but most of them are only applicable to a limited range of scenes, require complex computations, and sometimes significant amounts of memory. The inefficiency of a pure regular sampling approach as shown in Figure 2 is that the same surfaces are sampled over and over again (note that the definition of regular depends on the parameterization of ray space! The second key aspect of a visibility algorithm is what data structure is used to store visibility information. The most complete, but also complex, way is to store 4D ray space. The algorithm requires little memory, is simple to implement, accepts any triangular test scene as input, and can be used as a general purpose visibility tool. The exact solution of the visibility problem is the range of this function, v(?) ? T S, also called exact visible set EVS. A usage scenario to keep in mind for the following exposition is a visibility preprocessing system for real-time rendering: the view space (set of possible observer locations) is partitioned into view cells. The algorithm is called guided because both sampling strategies are guided by visibility information in the scene (see Section 5.4 for a more detailed discussion). All rays in the scene form a 5D space. The probability distribution for each new sample p(x i ) is independent of all previous samples x 1 , ... We sample the position and ray direction uniformly using the following formulae:\n          u = ? 1 , v = ? 2 , ? = 2 ?? 3 , ? = arcsin ? 4 ,\n          where the ? i are independent Halton sequences [Niederreiter 1992], and (u, v) are the normalized coordinates on a view cell face. While random sampling alone suffers from similar inefficiencies as regular sampling (see Section 1), it will be used to seed the more efficient strategies described next. This sampling algorithm is a deterministic ray mutation strategy that covers most of the ground work to make our system successful. For each edge, we use two rays x l and x r , and the corresponding samples hit(x l ) and hit(x r ) in world space. The actual method used for border enlargement deserves attention. The shape of t is chosen so that the ray space distance to t is fairly constant. The third is the midpoint of the other two, pushed away from t along the angle bisector d i,i : d i,i+1 = N((p i ? x p ) ? (p i+1 ? p i )) d i,i?1 = N((p i ? x p ) ? (p i ? p i?1 )) d i,i = N(d i,i?1 + d i,i+1 ) if d i,i?1 ? d i,i+1 > 0, else: N((p i ? x p ) ? d i,i?1 + d i,i+1 ? (p i ? x p )) p i, j = p i + ? ? |p i ? x p | ? d i, j\n          where N(v) is the vector normalization operator. Note that this cannot be done perfectly: finding the actual void volume is equivalent to the original visibility problem. This strategy works by changing the starting point of the ray instead of its direction. The algorithm is described by the following pseudocode: The graphics card for NIR was an NVIDIA GeForce 7900GTX 512MB. We first analyze the theoretical properties of the algorithms in terms of their sampling behavior, i.e., on a sample-by-sample basis, since this is the only comparison that does not depend on the individual implementation. Figure 8 provides a detailed analysis of the CANYON scene, graphing the pixel error (calculated by counting the false pixels in a large number of random renderings [Nirenstein and Blake 2004]) and the number of triangles found over the number of samples for GVS and RAND. A higher value means a more accurate solution. The intrinsic parameters had to be adjusted for each scene to obtain reasonable results (see the comments in Section 4.4). Nirenstein and Blake [2004] recently published an interesting adaptive regular sampling algorithm which uses graphics hardware to adaptively sample hemi-cubes on the view cell. Depending on whether a particular view is mostly fill or geometry limited, the resolution of this item buffer has more or less impact on the rendering time. Our implementation of NIR rendered models from multiple vertex buffers stored directly in video memory, which provided triangle throughput near the theoretical maximum on the card we used (between 130 and 190M triangles/s, depending on how many vertices were shared in the model?note that some vertices had to be duplicated to allow item buffer rendering). Therefore, the performance metric for GVS is not the total percentage of culled objects, but the degree to which the actual PVS can be approximated. A large volume of research has been devoted to visibility problems due to their importance in computer graphics, computer vision, robotics and other fields. From-region visibility algorithms are usually classified as exact (potentially visible set PVS = exact visible set EVS), conservative (PVS ? EVS), aggressive (PVS ? EVS), or approximate (PVS ? EVS). We believe that sampling-based methods and exact methods complement each other, as they have different strengths and weaknesses. Due to their ease of implementation and robustness, nonconservative algorithms are more practical for commercial products such as computer games [Aila and Miettinen 2004], and are already used in this context. The two most popular solutions are to randomly select a large number of rays to sample visibility [Schaufler et al. 2000; Airey et al. 1990; Shade et al. 1998], or to first sample the boundary of the view cell with points and then sample visibility from each of these points [Levoy and Hanrahan 1996; Stuerzlinger 1999]. A similar algorithm was also used for the generation of textured depth meshes [Wilson and Manocha 2003]. They proposed a new approach which uses graphics hardware for sampling. Samples placed along the object borders therefore correspond to samples near the tangency volume of the object in dual space. In ray space, these lines are near intersections of two tangency volumes. The visibility map is a structure that contains all visible line segments in a given view. Samples at the shadow edges serve to discover depth discontinuities, where objects are partly occluded by other objects. Furthermore, complex algorithms are prone to implementation problems. Such errors are usually tolerated for conservative algorithms (see Section 4). This is the scenario already described in the overview, and one of the most important applications for GVS. Furthermore, GVS works on arbitrary polyhedral view cells, so that the view space can be chosen freely.",
  "resources" : [ ]
}