{
  "uri" : "sig2006-p549-podolak_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2006/p549-podolak_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "A Planar-Reflective Symmetry Transform for 3D Shapes",
    "published" : "2006",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Joshua-Podolak",
      "name" : "Joshua",
      "surname" : "Podolak"
    }, {
      "uri" : "http://drinventor/Philip-Shilane",
      "name" : "Philip",
      "surname" : "Shilane"
    }, {
      "uri" : "http://drinventor/Aleksey-Golovinskiy",
      "name" : "Aleksey",
      "surname" : "Golovinskiy"
    }, {
      "uri" : "http://drinventor/Szymon-Rusinkiewicz",
      "name" : "Szymon",
      "surname" : "Rusinkiewicz"
    }, {
      "uri" : "http://drinventor/Thomas A.-Funkhouser",
      "name" : "Thomas A.",
      "surname" : "Funkhouser"
    } ]
  },
  "bagOfWords" : [ "finally", "we", "demonstrate", "symmetry", "transform", "useful", "several", "application", "computer", "graphic", "include", "shape", "matching", "segmentation", "mesh", "part", "automatic", "viewpoint", "selection", "first", "we", "define", "planar", "reflective", "symmetry", "transform", "-lrb-", "section", "-rrb-", "second", "we", "present", "new", "algorithm", "base", "Monte", "Carlo", "integration", "compute", "discrete", "version", "prst", "-lrb-", "section", "4.3", "-rrb-", "Fifth", "we", "investigate", "use", "prst", "representation", "shape", "matching", "retrieval", "experiment", "-lrb-", "section", "5.2", "-rrb-", "finally", "we", "explore", "use", "local", "symmetry", "segmentation", "viewpoint", "selection", "-lrb-", "section", "5.3", "5.4", "respectively", "-rrb-", "example", "Zabrodsky", "et", "al.", "define", "symmetry", "distance", "shape", "respect", "transformation", "distance", "from", "give", "shape", "closest", "shape", "perfectly", "symmetric", "respect", "transformation", "-lsb-", "Zabrodsky", "et", "al.", "1995", "Zabrodsky", "et", "al.", "1993", "-rsb-", "provide", "algorithm", "find", "symmetry", "distance", "set", "connected", "point", "any", "give", "reflective", "rotational", "transformation", "use", "complete", "outline", "partially-occluded", "2d", "contour", "locate", "face", "image", "determine", "orientation", "3d", "shape", "describe", "efficient", "algorithm", "compute", "descriptor", "from", "3d", "voxel", "representation", "show", "planar", "symmetry", "can", "use", "alignment", "classification", "3d", "mesh", "also", "important", "compute", "prst", "efficiently", "since", "square", "prst", "any", "plane", "reflection", "reduce", "dot", "product", "under", "formulation", "see", "follow", "section", "-lrb-", "function", "grid", "dot", "product", "sum", "product", "each", "pair", "corresponding", "element", "-rrb-", "give", "intuitive", "sense", "information", "provide", "PRST", "visualization", "several", "simple", "2d", "shape", "show", "figure", "first", "we", "see", "dominant", "point", "plane", "symmetry", "match", "we", "human", "intuition", "center", "major", "axis", "object", "general", "local", "maximum", "PRST", "coincide", "axis", "large", "-lrb-", "nearly", "-rrb-", "symmetric", "part", "object", "-lrb-", "figure", "-rrb-", "provable", "property", "can", "see", "empirically", "figure", "i.e.", "prst", "stable", "when", "regular", "polygon", "deform", "circle", "when", "square", "deform", "rectangle", "when", "noise", "add", "boundary", "starfish", "stability", "stark", "contrast", "medial", "axis", "transform", "which", "find", "local", "point", "symmetry", "sensitive", "small", "boundary", "perturbation", "shoot", "off", "new", "branch", "every", "small", "bump", "boundary", "-lrb-", "figure", "-rrb-", "sake", "simplicity", "generality", "we", "focus", "we", "initial", "discussion", "follow", "section", "planar", "symmetry", "3d", "volumetric", "function", "however", "other", "shape", "representation", "can", "trivially", "convert", "representation", "follow", "subsection", "we", "provide", "background", "information", "can", "use", "gain", "insight", "computational", "solution", "we", "describe", "three", "algorithmic", "strategy", "first", "two", "provide", "method", "compute", "discrete", "version", "prst", "volumetric", "function", "surface", "mesh", "respectively", "while", "third", "provide", "continuous", "method", "find", "local", "maximum", "prst", "precisely", "previous", "work", "-lsb-", "Kazhdan", "et", "al.", "2003a", "-rsb-", "have", "observe", "nearest", "symmetric", "function", "simply", "average", "-lrb-", "-rrb-", "sd", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "intuitively", "mean", "prst", "-lrb-", "-rrb-", "single", "plane", "reflection", "relate", "how", "well", "correlate", "-lrb-", "-rrb-", "can", "ume", "compute", "integration", "-lrb-", "-rrb-", "over", "bound", "volin", "order", "apply", "above", "definition", "surface", "necessary", "convert", "they", "volumetric", "function", "while", "we", "could", "simply", "rasterize", "surface", "-lrb-", "binary", "-rrb-", "occupancy", "grid", "would", "result", "sensitivity", "noise", "small", "feature", "instead", "we", "use", "Gaussian", "Euclidean", "Distance", "Transform", "-lrb-", "GEDT", "-rrb-", "previously", "propose", "-lsb-", "Kazhdan", "et", "al.", "2004", "-rsb-", "model", "width", "GEDT", "arbitrary", "point", "space", "define", "-lrb-", "-rrb-", "dist", "-lrb-", "-rrb-", "where", "dist", "-lrb-", "-rrb-", "represent", "distance", "point", "nearest", "point", "allow", "surface", "slightly", "misalign", "-lrb-", "gaussian", "width", "-rrb-", "under", "reflection", "allow", "we", "capture", "imperfect", "symmetry", "surface", "net", "result", "3d", "function", "exactly", "one", "surface", "object", "gradually", "drop", "off", "zero", "both", "interior", "exterior", "point", "similar", "method", "can", "use", "other", "shape", "representation", "background", "we", "can", "propose", "several", "algorithm", "compute", "discrete", "version", "prst", "function", "represent", "acterize", "regular", "all", "planar", "grid", "symmetry", "algorithm", "densely", "efficient", "sample", "volume", "char", "-lrb-", "e.g.", "medical", "imaging", "datum", "-rrb-", "first", "step", "we", "could", "naively", "apply", "equation", "evaluate", "prst", "-lrb-", "-rrb-", "every", "possible", "plane", "reflection", "separately", "however", "since", "prst", "value", "plane", "same", "orientation", "require", "dot", "product", "function", "successively", "shift", "regular", "interval", "respect", "one", "another", "-lrb-", "Figure", "4a", "-rrb-", "we", "can", "compute", "they", "all", "same", "time", "single", "convolution", "since", "convolution", "single", "direction", "take", "-lrb-", "log", "-rrb-", "-lrb-", "-rrb-", "possible", "direction", "through", "grid", "total", "run", "time", "algorithm", "-lrb-", "log", "-rrb-", "equivalently", "we", "can", "consider", "convolution", "over", "rotation", "discrete", "set", "point", "-lrb-", "figure", "4b", "-rrb-", "case", "we", "use", "frequency", "domain", "algorithm", "describe", "-lsb-", "Kazhdan", "et", "al.", "2003a", "-rsb-", "compute", "prst", "all", "plane", "through", "-lrb-", "-rrb-", "point", "-lrb-", "figure", "4b", "-rrb-", "since", "each", "invocation", "Kazhdan", "et", "al.", "algorithm", "take", "-lrb-", "log", "-rrb-", "total", "run", "time", "again", "-lrb-", "log", "-rrb-", "multiresolution", "approximation", "possible", "-lrb-", "log", "-rrb-", "we", "have", "investigate", "all", "three", "approach", "we", "implementation", "we", "discretize", "space", "plane", "match", "resolution", "grid", "-lrb-", "finer", "sampling", "plane", "yield", "additional", "information", "about", "band-limited", "prst", "-rrb-", "when", "work", "2d", "we", "use", "uniform", "parameterization", "set", "line", "angle", "slightly", "-lsb-", "unusual", "-rsb-", "distance", "choice", "from", "angle", "origin", "semicircle", "-lsb-", "max", "max", "both", "-rsb-", "note", "positive", "negative", "radius", "which", "avoid", "singularity", "origin", "similarly", "we", "parameterize", "plane", "3d", "spherical", "coordinate", "gin", "uniform", "-lsb-", "normal", "size", "max", "shrinking", "max", "-rsb-", "-lsb-", "-lrb-", "note", "towards", "-rsb-", "-lsb-", "pole", "bucket", "-rsb-", "sin", "distance", "-rrb-", "plane", "from", "oriof", "we", "find", "convolution", "algorithm", "take", "40", "seconds", "average", "grid", "64", "64", "64", "voxel", "3ghz", "processor", "while", "algorithm", "discuss", "so", "far", "equally", "efficient", "all", "function", "rasterized", "surface", "point", "set", "naturally", "lead", "sparsity", "over", "volume", "section", "we", "describe", "Monte", "Carlo", "algorithm", "compute", "prst", "take", "advantage", "sparsity", "increase", "efficiency", "we", "discussion", "algorithm", "begin", "brute-force", "approach", "present", "section", "4.2", "each", "plane", "each", "point", "prst", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "observe", "sparse", "function", "inefficient", "since", "perform", "useless", "computation", "whenever", "either", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "near", "zero", "instead", "we", "interchange", "order", "computation", "perform", "importance", "sampling", "Monte", "Carlo", "framework", "sample", "point", "sample", "point", "prst", "reflection", "-lrb-", "-rrb-", "plane", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "intuitively", "algorithm", "repeatedly", "pick", "pair", "point", "vote", "plane", "between", "they", "sampling", "perform", "accord", "energy", "function", "allow", "we", "focus", "effort", "computation", "contribute", "final", "answer", "typical", "3d", "surface", "non-negligible", "value", "appear", "only", "-lrb-", "-rrb-", "voxel", "thus", "algorithm", "require", "only", "-lrb-", "-rrb-", "operation", "compute", "entire", "prst", "weighting", "order", "above", "algorithm", "compute", "prst", "correctly", "necessary", "weight", "contribution", "each", "vote", "appropriately", "first", "term", "account", "importance", "sampling", "we", "perform", "simply", "reciprocal", "probability", "have", "select", "samp", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "second", "term", "represent", "change-of-variable", "account", "two", "different", "way", "we", "have", "sampling", "space", "plane", "pair", "point", "-lrb-", "-rrb-", "we", "discretized", "bin", "over", "-lrb-", "-rrb-", "while", "part", "change-of-variables", "term", "intuitive", "-lrb-", "accounting", "sin", "decrease", "bin", "size", "-rrb-", "another", "part", "account", "fact", "bin", "plane", "receive", "more", "vote", "far", "apart", "than", "nearby", "example", "both", "part", "Figure", "consider", "single", "bin", "plane", "however", "fix", "clear", "more", "point", "vote", "bin", "point", "further", "apart", "so", "we", "should", "weight", "contribution", "pair", "lower", "than", "vote", "nearby", "point", "derive", "change-of-variable", "weight", "we", "simply", "compute", "determinant", "Jacobian", "transformation", "between", "parameterization", "plane", "reflection", "reflect", "point", "themselves", "we", "let", "sin", "sin", "cos", "sin", "cos", "normal", "plane", "reflection", "we", "can", "write", "d/2", "d/2", "-lrb-", "-rrb-", "2r", "-lrb-", "-rrb-", "??", "??", "solve", "determinant", "change-of-variable", "sin", "therefore", "we", "have", "-lrb-", "-rrb-", "samp", "change-of-variable", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "sin", "so", "overall", "we", "Monte", "Carlo", "estimator", "-lrb-", "-rrb-", "samp", "samp", "sin", "Computation", "time", "exploit", "sparsity", "volume", "Monte", "Carlo", "algorithm", "able", "compute", "prst", "3d", "surface", "efficiently", "all", "randomize", "algorithm", "noise", "final", "approximation", "decrease", "additional", "sample", "show", "Figure", "algorithm", "converge", "quite", "quickly", "example", "64", "grid", "resolution", "use", "throughout", "paper", "compute", "prst", "noise", "take", "average", "seconds", "ghz", "processor", "correspond", "two", "million", "sample", "point", "pair", "result", "typical", "little", "variation", "computation", "time", "except", "very", "large", "model", "-lrb-", "which", "rasterization", "time", "can", "begin", "dominate", "-rrb-", "while", "prst", "take", "whole", "characterize", "all", "object?s", "symmetry", "its", "local", "maximum", "form", "important", "intuitive", "subset", "may", "correspond", "principal", "symmetry", "whole", "object", "weaker", "partial", "local", "symmetry", "perfect", "symmetry", "part", "due", "intuitive", "nature", "important", "several", "application", "include", "all", "those", "describe", "section", "we", "now", "discuss", "approach", "build", "upon", "algorithm", "present", "previous", "section", "find", "local", "symmetry", "maximum", "precisely", "we", "extract", "candidate", "local", "maximum", "from", "discrete", "prst", "refine", "location", "use", "iterative", "local", "optimization", "algorithm", "algorithm", "able", "find", "local", "maximum", "prst", "arbitrary", "precision", "give", "full", "3d", "symmetry", "transform", "tabulate", "moderate", "resolution", "we", "first", "look", "cell", "higher", "symmetry", "value", "than", "all", "immediate", "neighbor", "first", "we", "apply", "threshold", "strength", "symmetry", "cell", "particular", "we", "use", "threshold", "proportional", "distance", "candidate", "where", "plane", "from", "radius", "center", "object", "mass", "top", "symmetry", "threshold", "we", "also", "discard", "shallow", "maximum", "which", "potentially", "subject", "noise", "we", "impose", "threshold", "discrete", "laplacian", "-lrb-", "sum", "second", "partial", "derivative", "-rrb-", "PRST", "threshold", "set", "automatically", "10", "value", "strongest", "local", "symmetry", "once", "we", "have", "list", "candidate", "local", "maximum", "we", "refine", "they", "find", "plane", "symmetry", "high", "precision", "approach", "find", "maximum", "function", "first", "tabulate", "locally", "refine", "candidate", "maximum", "commonly", "use", "numerical", "maximization", "general", "also", "resemble", "local", "optimization", "perform", "Martinet", "et", "al.", "-lsb-", "2005", "-rsb-", "we", "refinement", "method", "inspire", "Iterative", "Closest", "Points", "algorithm", "-lsb-", "besl", "McKay", "1992", "-rsb-", "commonly", "use", "perform", "pairwise", "alignment", "mesh", "solve", "plane", "reflection", "rather", "than", "rigid-body", "transformation", "we", "iterative", "symmetric", "point", "isp", "algorithm", "begin", "randomly", "sampling", "point", "from", "mesh", "-lrb-", "we", "typically", "use", "around", "10,000", "point", "per", "iteration", "-rrb-", "reflect", "they", "across", "candidate", "plane", "we", "match", "each", "reflect", "point", "closest", "point", "mesh", "solve", "three", "parameter", "reflection", "plane", "minimize", "sum", "distance", "-lrb-", "weighted", "account", "Gaussian", "Euclidean", "Distance", "Transform", "-rrb-", "between", "corresponding", "point", "-lrb-", "note", "minimal", "sum", "weighted", "distance", "provide", "maximum", "equation", "when", "gedt", "surface", "-rrb-", "process", "iterate", "until", "converge", "local", "maximum", "PRST", "Figure", "left", "show", "iteration", "isp", "source", "point", "red", "candidate", "plane", "gray", "reflect", "point", "green", "support", "final", "maximum", "show", "right", "however", "we", "have", "find", "check", "necessary", "since", "different", "point", "sampling", "strategy", "use", "discrete", "iterative", "algorithm", "we", "experiment", "two-stage", "process", "first", "tabulate", "prst", "refine", "candidate", "local", "maximum", "have", "prove", "both", "robust", "efficient", "local", "refinement", "converge", "few", "seconds", "each", "plane", "we", "typically", "find", "10", "20", "strong", "local", "maximum", "symmetry", "model", "moderate", "complexity", "Figure", "show", "four", "strongest", "local", "maximum", "bull", "model", "together", "surface", "support", "each", "plane", "reflection", "-lrb-", "white", "region", "surface", "reflect", "onto", "each", "other", "across", "choose", "plane", "-rrb-", "note", "we", "find", "plane", "capture", "global", "symmetry", "bull", "-lrb-", "-rrb-", "well", "separate", "local", "maximum", "capture", "symmetry", "neck", "-lrb-", "-rrb-", "body", "-lrb-", "-rrb-", "head", "-lrb-", "-rrb-", "prst", "general-purpose", "transform", "potential", "application", "computer", "vision", "medical", "imaging", "variety", "other", "field", "section", "we", "investigate", "four", "application", "computer", "graphic", "alignment", "object", "canonical", "coordinate", "frame", "important", "preprocessing", "step", "variety", "task", "include", "visualization", "study", "variation", "model", "across", "different", "class", "composition", "scene", "indexing", "3d", "model", "database", "typically", "alignment", "type", "compute", "principal", "component", "analysis", "-lrb-", "pca", "-rrb-", "center", "mass", "choose", "origin", "principal", "axis", "use", "determine", "orientation", "-lsb-", "Duda", "et", "al.", "2001", "-rsb-", "however", "well", "know", "pca", "do", "always", "produce", "compatible", "alignment", "object", "same", "class", "-lsb-", "Kazhdan", "et", "al.", "2003b", "-rsb-", "certainly", "do", "produce", "alignment", "similar", "what", "human", "would", "select", "consider", "example", "mug", "show", "figure", "10", "most", "human", "would", "suggest", "central", "axis", "mug", "run", "straight", "up", "down", "through", "middle", "cup", "center", "somewhere", "along", "axis", "however", "center", "mass", "principal", "axis", "-lrb-", "show", "green", "Figure", "-rrb-", "bias", "towards", "handle", "different", "degree", "depend", "size", "shape", "handle", "produce", "alignment", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "inconsistent", "other", "mug", "undesirable", "most", "application", "-lrb-", "e.g.", "placement", "scene", "-rrb-", "section", "we", "investigate", "use", "prst", "produce", "better", "alignment", "specifically", "we", "introduce", "two", "new", "concept", "principal", "symmetry", "axis", "-lrb-", "psa", "-rrb-", "center", "symmetry", "-lrb-", "cos", "-rrb-", "robust", "global", "alignment", "feature", "model", "intuitively", "principal", "symmetry", "axis", "normal", "orthogonal", "set", "plane", "maximal", "symmetry", "center", "symmetry", "intersection", "those", "three", "plane", "specifically", "give", "prst", "we", "select", "first", "principal", "symmetry", "axis", "find", "plane", "maximal", "symmetry", "we", "select", "second", "axis", "search", "plane", "maximal", "symmetry", "among", "those", "perpendicular", "first", "Center", "mass", "PCA", "Center", "symmetry", "principal", "symmetry", "axis", "Center", "mass", "pca", "finally", "we", "choose", "third", "axis", "same", "way", "search", "only", "plane", "perpendicular", "both", "first", "second", "selection", "we", "find", "simple", "method", "produce", "coordinate", "frame", "both", "robust", "semantically", "meaningful", "most", "object", "example", "mug", "show", "figure", "10", "center", "symmetry", "principal", "symmetry", "axis", "appear", "right", "middle", "cylindrical", "cup", "similarly", "mailbox", "show", "Figure", "10", "center", "symmetry", "principal", "symmetry", "axis", "consistently", "reside", "middle", "box", "unlike", "center", "mass", "principal", "axis", "affect", "shape", "stand", "order", "test", "whether", "prst", "robust", "even", "partial", "surface", "we", "experiment", "alignment", "synthetically", "generate", "range", "scan", "experiment", "motivate", "object", "recognition", "application", "which", "-lrb-", "partial-object", "-rrb-", "scan", "acquire", "register", "-lrb-", "whole-object", "-rrb-", "mesh", "store", "database", "hope", "automatically", "recognize", "which", "object", "scan", "-lsb-", "Shan", "et", "al.", "2004", "-rsb-", "application", "useful", "align", "partial", "scan", "complete", "object", "automatically", "experiment", "we", "use", "ray", "tracer", "generate", "eight", "synthetic", "range", "scan", "approximately", "10,000", "point", "-lrb-", "figure", "11", "top", "-rrb-", "907", "mesh", "provide", "part", "Princeton", "shape", "Benchmark", "test", "set", "-lsb-", "shilane", "et", "al.", "2004", "-rsb-", "each", "mesh", "virtual", "scanner", "turn", "place", "each", "eight", "corner", "cube", "surround", "model", "always", "point", "toward", "center", "mesh", "bound", "box", "view", "distance", "twice", "length", "bound", "box", "diagonal", "field", "view", "0.4", "radian", "-lrb-", "figure", "11", "-rrb-", "each", "scan", "we", "voxelize", "point", "cloud", "compute", "PRST", "extract", "principal", "symmetry", "axis", "center", "symmetry", "-lrb-", "figure", "11", "bottom", "left", "-rrb-", "we", "evaluate", "how", "well", "coordinate", "frame", "match", "frame", "compute", "complete", "mesh", "compare", "accuracy", "frame", "compute", "use", "principal", "axis", "center", "mass", "-lrb-", "figure", "11", "bottom", "right", "-rrb-", "Figure", "12", "show", "result", "experiment", "first", "plot", "we", "see", "histogram", "translational", "misalignment", "between", "partial", "range", "scan", "whole", "object", "when", "align", "center", "symmetry", "-lrb-", "blue", "curve", "-rrb-", "center", "mass", "-lrb-", "green", "curve", "-rrb-", "general", "partial", "scan", "be", "sufficient", "recover", "major", "symmetry", "object", "correctly", "lead", "lower", "average", "error", "center-ofsymmetry", "alignment", "compare", "center-of-mass", "907", "model", "test", "center", "symmetry", "scan", "closer", "entire", "model", "90", "time", "average", "be", "closer", "factor", "1.5", "better", "result", "occur", "when", "particular", "viewpoint", "cause", "significant", "portion", "model", "miss", "Figure", "12b", "show", "histogram", "rotational", "misalignment", "partial", "scan", "respect", "full", "object", "when", "align", "principal", "symmetry", "axis", "-lrb-", "psa", "-rrb-", "principal", "axis", "-lrb-", "pca", "-rrb-", "note", "large", "peak", "near", "zero", "blue", "curve", "indicate", "psa", "recover", "rotation", "most", "range", "scan", "within", "few", "degree", "compute", "entire", "object", "contrast", "pca", "provide", "larger", "spread", "misalignment", "angle", "moreover", "even", "though", "less", "than", "half", "surface", "available", "any", "scan", "we", "find", "coordinate", "frame", "choose", "psa", "within", "degree", "human", "choose", "set", "axis", "whole", "object", "70", "scan", "oppose", "only", "50", "PCA", "many", "application", "important", "able", "classify", "3d", "model", "retrieve", "they", "from", "database", "base", "geometric", "property", "goal", "find", "representation", "shape", "-lrb-", "shape", "descriptor", "-rrb-", "can", "compute", "robustly", "match", "efficiently", "use", "discriminate", "different", "class", "object", "effectively", "section", "we", "investigate", "use", "prst", "shape", "descriptor", "we", "effort", "motivate", "observation", "symmetry", "property", "often", "consistent", "within", "class", "object", "example", "although", "chair", "may", "vary", "size", "whether", "have", "arm", "etc.", "reflective", "planar", "symmetry", "almost", "always", "same", "-lrb-", "perfect", "left-right", "symmetry", "weaker", "global", "symmetry", "between", "back", "seat", "local", "symmetry", "through", "seat", "back", "etc.", "-rrb-", "true", "many", "other", "object", "class", "well", "include", "airplane", "table", "people", "etc.", "perhaps", "possible", "classify", "3d", "mesh", "automatically", "compare", "computed", "symmetry", "those", "mesh", "supervised", "training", "set", "previous", "work", "Kazhdan", "et", "al.", "investigate", "approach", "use", "reflective", "symmetry", "descriptor", "employ", "maximum", "difference", "between", "symmetry", "measure", "any", "two", "corresponding", "plane", "through", "center", "mass", "dissimilarity", "measure", "pair", "3d", "mesh", "we", "extend", "previous", "work", "consider", "symmetry", "respect", "all", "plane", "through", "object?s", "bound", "volume", "we", "matching", "method", "we", "measure", "dissimilarity", "between", "pair", "align", "mesh", "distance", "between", "discrete", "prst", "-lrb-", "section", "4.3", "-rrb-", "weighting", "difference", "between", "corresponding", "bin", "prst", "sin", "-lrb-", "where", "polar", "angle", "plane", "represent", "bin", "-rrb-", "account", "different", "bin", "size", "measure", "produce", "large", "distance", "when", "plane", "which", "one", "object", "-lrb-", "nearly", "-rrb-", "symmetric", "while", "other", "order", "evaluate", "prst", "shape", "descriptor", "shape-based", "retrieval", "classification", "application", "we", "run", "set", "leave-oneout", "experiment", "Princeton", "shape", "Benchmark", "test", "set", "-lsb-", "shilane", "et", "al.", "2004", "-rsb-", "database", "907", "polygonal", "model", "partition", "92", "class", "commonly", "use", "shape", "matching", "evaluation", "order", "focus", "we", "study", "shape", "representation", "rather", "than", "alignment", "we", "manually", "register", "all", "model", "common", "coordinate", "frame", "before", "match", "every", "model", "against", "all", "other", "distance", "between", "prst", "be", "use", "produce", "rank", "retrieval", "list", "each", "query", "model", "statistics", "be", "compute", "evaluate", "how", "often", "model", "within", "same", "class", "appear", "front", "computed", "retrieval", "list", "Figure", "13", "show", "average", "precision-recall", "plot", "compare", "we", "retrieval", "performance", "Kazhdan", "et", "al.", "planar", "reflective", "symmetry", "descriptor", "-lrb-", "prsd", "-rrb-", "Gaussian", "Euclidean", "Distance", "Transform", "-lrb-", "GEDT", "-rrb-", "which", "currently", "use", "least", "one", "shape", "base", "search", "engine", "-lsb-", "Funkhouser", "et", "al.", "2003", "-rsb-", "horizontal", "axis", "plot", "represent", "increase", "recall", "value", "-lrb-", "fraction", "query?s", "class", "retrieve", "-rrb-", "while", "vertical", "axis", "represent", "retrieval", "precision", "-lrb-", "fraction", "retrieve", "model", "same", "class", "query", "-rrb-", "higher", "curve", "represent", "better", "performance", "we", "find", "precision", "achieve", "when", "match", "prst", "-lrb-", "thick", "blue", "curve", "-rrb-", "higher", "than", "prsd", "-lrb-", "magenta", "curve", "-rrb-", "every", "recall", "value", "confirm", "expectation", "extra", "information", "provide", "prst", "-lrb-", "symmetry", "off-center", "plane", "-rrb-", "add", "precision", "shape", "matching", "course", "more", "expensive", "store", "-lrb-", "32", "768", "float", "versus", "024", "float", "-rrb-", "compare", "-lrb-", "0.1", "m", "versus", "0.004", "m", "-rrb-", "extra", "cost", "seem", "worth", "improve", "performance", "most", "application", "we", "also", "find", "both", "prsd", "prst", "provide", "less", "matching", "precision", "than", "GEDT", "-lrb-", "green", "curve", "-rrb-", "average", "we", "believe", "because", "many", "object", "class", "within", "Princeton", "shape", "Benchmark", "have", "same", "symmetry", "-lrb-", "e.g.", "almost", "all", "manmade", "object", "have", "perfect", "left-right", "symmetry", "-rrb-", "even", "though", "symmetry", "may", "consistent", "within", "class", "do", "always", "help", "discriminate", "between", "class", "however", "we", "observe", "PRST", "provide", "better", "matching", "result", "some", "type", "object", "-lrb-", "i.e.", "one", "distinctive", "symmetry", "-rrb-", "while", "GEDT", "provide", "better", "result", "other", "-lrb-", "figure", "14", "-rrb-", "so", "we", "find", "combine", "two", "shape", "descriptor", "-lrb-", "simply", "multiply", "distance", "compute", "separately", "two", "descriptor", "-rrb-", "provide", "better", "retrieval", "performance", "than", "either", "alone", "-lrb-", "thick", "red", "curve", "Figure", "13", "-rrb-", "nearest", "neighbor", "classification", "rate", "discount", "cumulative", "gain", "score", "combined", "method", "be", "69.2", "68.6", "respectively", "which", "represent", "good", "retrieval", "performance", "datum", "set", "-lsb-", "shilane", "et", "al.", "2004", "-rsb-", "lead", "we", "conclude", "PRST", "while", "perhaps", "best", "shape", "representation", "retrieval", "type", "datum", "its", "own", "can", "provide", "useful", "information", "shapebased", "matching", "can", "use", "discriminate", "class", "object", "difficult", "distinguish", "other", "method", "although", "prst", "naturally", "represent", "symmetry", "entire", "object", "also", "implicitly", "capture", "symmetry", "its", "part", "we", "propose", "use", "information", "segmentation", "we", "decompose", "mesh", "face", "each", "segment", "have", "same", "distinct", "symmetry", "criterion", "automatic", "decomposition", "part", "quite", "different", "from", "previous", "method", "-lrb-", "e.g.", "-lsb-", "Chazelle", "et", "al.", "1995", "Li", "et", "al.", "2001", "Mangan", "Whitaker", "1999", "-rsb-", "incorporate", "local", "shape", "information", "many", "different", "part", "mesh", "simultaneously", "we", "segmentation", "algorithm", "follow", "recent", "work", "have", "use", "kmean", "clustering", "primitive", "operation", "however", "instead", "clustering", "base", "simplification", "-lsb-", "Garland", "et", "al.", "2001", "-rsb-", "base", "geodesic", "angular", "distance", "between", "point", "-lsb-", "Katz", "Tal", "2003", "-rsb-", "we", "cluster", "base", "support", "local", "maximum", "PRST", "do", "we", "find", "significant", "local", "maximum", "prst", "-lrb-", "section", "4.4", "-rrb-", "compute", "each", "face", "every", "symmetry", "plane", "degree", "which", "face", "contribute", "symmetry", "respect", "plane", "i.e.", "how", "well", "do", "face", "map", "onto", "surface", "after", "reflection", "across", "plane", "-lrb-", "visualization", "measure", "show", "Figure", "-rrb-", "local", "maximum", "PRST", "every", "point", "have", "value", "represent", "its", "support", "symmetry", "respect", "each", "plane", "we", "treat", "value", "feature", "vector", "cluster", "face", "accord", "proximity", "mdimensional", "feature", "space", "intuitively", "method", "cluster", "face", "support", "same", "distinct", "set", "planar", "symmetry", "we", "segmentation", "algorithm", "proceed", "hierarchically", "manner", "similar", "method", "Katz", "Tal", "-lsb-", "2003", "-rsb-", "each", "split", "we", "perform", "k-means", "clustering", "-lrb-", "-rrb-", "establish", "rough", "segmentation", "take", "two", "largest", "connected", "component", "find", "exact", "boundary", "between", "they", "compute", "weighted", "min-cut", "along", "edge", "mesh", "discrete", "prst", "recompute", "its", "local", "maximum", "refine", "after", "every", "split", "segmentation", "terminate", "user-supplied", "depth", "when", "only", "plane", "local", "maximum", "reflect", "either", "more", "than", "90", "less", "than", "10", "surface", "onto", "itself", "result", "process", "segmentation", "tree", "property", "lower", "level", "tree", "capture", "increasingly", "local", "symmetry", "hence", "allow", "strong", "symmetry", "even", "small", "part", "influence", "segmentation", "Figure", "15", "show", "some", "example", "segmentation", "produce", "we", "method", "note", "Teapot", "strongest", "plane", "symmetry", "pass", "through", "body", "pot", "so", "handle", "spout", "top", "remove", "precisely", "because", "symmetric", "respect", "those", "plane", "i.e.", "body", "pot", "remove", "from", "smaller", "part", "rather", "than", "vice-versa", "Octopus", "skeletal", "hand", "model", "local", "symmetry", "part", "important", "obtain", "segmentation", "show", "finally", "weakness", "we", "scheme", "can", "see", "segmentation", "leg", "Dinopet", "Bull", "because", "we", "use", "min-cut", "smooth", "we", "initial", "guess", "final", "segmentation", "seek", "shorter", "cut", "thus", "avoid", "upper", "section", "thigh", "Teapot", "Octopus", "Dinopet", "Bull", "3D", "model", "may", "look", "considerably", "different", "when", "view", "from", "different", "direction", "thus", "compute", "good", "viewpoint", "3d", "model", "have", "always", "be", "important", "application", "rapidly", "view", "large", "number", "model", "generation", "icon", "selection", "viewpoint", "image", "base", "rendering", "robot", "motion", "optimal", "canonical", "view", "model", "may", "differ", "depend", "purpose", "have", "be", "number", "method", "suggest", "find", "viewpoint", "various", "application", "Kamada", "et", "al.", "-lsb-", "1988", "-rsb-", "seek", "minimize", "number", "degenerate", "face", "image", "both", "V?zquez", "et", "al.", "-lsb-", "2001", "-rsb-", "Lee", "et", "al.", "-lsb-", "2005", "-rsb-", "try", "find", "quality", "viewpoint", "maximize", "-lrb-", "interesting", "-rrb-", "information", "content", "view", "Abbasi", "et", "al.", "-lsb-", "2000", "-rsb-", "Lee", "et", "al.", "-lsb-", "2004", "-rsb-", "find", "optimal", "viewpoint", "recognition", "base", "image", "contour", "prune", "various", "imaging", "constraint", "finally", "Blanz", "et", "al.", "-lsb-", "1999", "-rsb-", "perform", "user", "study", "determine", "factor", "influence", "canonical", "view", "use", "display", "3d", "model", "report", "user", "prefer", "off-axis", "view", "front", "side", "axis", "view", "we", "introduce", "method", "choose", "good", "viewpoint", "automatically", "minimize", "symmetry", "see", "intuition", "behind", "we", "approach", "symmetry", "object", "present", "redundant", "information", "user", "therefore", "avoid", "we", "method", "begin", "primary", "symmetry", "object", "use", "local", "maximum", "extract", "from", "prst", "minimize", "amount", "symmetry", "direction", "viewer", "more", "specifically", "each", "plane", "appear", "local", "maximum", "PRST", "preferred", "viewing", "direction", "along", "normal", "plane", "we", "compute", "viewpoint", "score", "plane", "view", "local", "direction", "symmetry", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "u?w", "symmetry", "-lrb-", "-rrb-", "where", "score", "plane", "relatively", "simple", "score", "function", "enough", "do", "exhaustive", "search", "find", "optimal", "viewpoint", "although", "gradient", "decent", "method", "introduce", "-lsb-", "Lee", "et", "al.", "2005", "-rsb-", "may", "use", "accelerate", "computation", "we", "show", "result", "we", "approach", "middle", "column", "Figure", "16", "each", "object?s", "local", "symmetry", "repel", "viewpoint", "final", "select", "view", "off", "major", "axis", "object", "note", "even", "though", "we", "only", "show", "best", "viewpoint", "possible", "extend", "implementation", "produce", "multiple", "interesting", "viewpoint", "user?s", "selection", "-lrb-", "left", "column", "Figure", "16", "-rrb-", "and/or", "viewpoint", "avoid", "-lrb-", "right", "column", "-rrb-", "investigation", "prst", "present", "paper", "first", "step", "we", "implementation", "have", "several", "limitation", "many", "avenue", "future", "research", "first", "we", "have", "investigate", "only", "transform", "map", "3d", "object", "its", "planar", "reflective", "symmetry", "we", "can", "further", "investigate", "mapping", "reflective", "symmetry", "transform", "back", "from", "space", "plane", "space", "point", "store", "each", "point", "function", "symmetry", "distance", "plane", "pass", "through", "motivation", "we", "visualization", "figure", "we", "hypothesize", "average", "maximum", "some", "similar", "function", "symmetry", "distance", "all", "plane", "through", "each", "point", "may", "produce", "3d", "function", "worthy", "future", "investigation", "second", "we", "transform", "measure", "symmetry", "entire", "object", "while", "we", "have", "show", "automatic", "segmentation", "algorithm", "extract", "symmetry", "large", "part", "model", "hierarchically", "interesting", "local", "symmetry", "may", "drown", "find", "during", "process", "multi-resolution", "scheme", "where", "prst", "compute", "local", "section", "model", "would", "interesting", "investigate", "finally", "tion", "whether", "since", "PRST", "transform", "3d", "invertible", "use", "constraint", "we", "can", "already", "show", "transform", "invertible", "1d", "2d", "case", "we", "believe", "we", "can", "extend", "3d", "inversion", "currently", "sensitive", "noise", "however", "so", "further", "research", "necessary", "determine", "additional", "constraint", "stronger", "variational", "relation", "might", "make", "we", "method", "practical", "we", "hypothesize", "ability", "invert", "transform", "lead", "application", "variety", "domain", "ability", "only", "analyze", "also", "synthesize", "symmetry", "summary", "we", "have", "define", "planar", "reflective", "symmetry", "transform", "which", "measure", "symmetry", "object", "respect", "all", "plane", "through", "its", "bound", "volume", "we", "have", "describe", "efficient", "Monte", "Carlo", "algorithm", "compute", "transform", "surface", "mesh", "show", "stable", "under", "small", "perturbation", "investigate", "its", "utility", "several", "geometric", "processing", "application", "particular", "we", "propose", "center", "symmetry", "principal", "symmetry", "axis", "useful", "align", "3d", "object", "common", "coordinate", "frame", "we", "also", "show", "reflective", "symmetry", "transform", "can", "use", "register", "3d", "range", "scan", "common", "coordinate", "system", "match", "3d", "polygonal", "model", "same", "class", "segment", "3d", "model", "part", "find", "good", "viewpoint", "visualization", "mesh", "we", "would", "like", "thank", "Princeton", "Graphics", "group", "especially", "Christopher", "DeCoro", "help", "get", "paper", "ready", "publication", "we", "would", "also", "like", "thank", "Michael", "Kazhdan", "he", "helpful", "comment", "work", "partially", "support", "Air", "Force", "Research", "Lab", "grant", "#fa", "8650-04-1-1718", "NSF", "grant", "#ccf", "0347427", "#ccr", "-0093343", "#iis", "-0121446", "Sloan", "Foundation" ],
  "content" : "Finally, we demonstrate that the symmetry transform is useful for several applications in computer graphics, including shape matching, segmentation of meshes into parts, and automatic viewpoint selection. First, we define the planar reflective symmetry transform (Section 3). Second, we present a new algorithm based on Monte Carlo integration for computing a discrete version of the PRST (Section 4.3). Fifth, we investigate using the PRST as a representation of shape in matching and retrieval experiments (Section 5.2). Finally, we explore the use of local symmetries in segmentation and viewpoint selection (Sections 5.3 and 5.4 respectively). For example, Zabrodsky et al. defined the symmetry distance of a shape with respect to a transformation as the distance from the given shape to the closest shape that is perfectly symmetric with respect to that transformation [Zabrodsky et al. 1995; Zabrodsky et al. 1993]. They provide an algorithm to find the symmetry distance for a set of connected points for any given reflective or rotational transformation, and they use it for completing the outline of partially-occluded 2D contours, for locating faces in an image, and for determining the orientation of a 3D shape. They describe an efficient algorithm for computing the descriptor from a 3D voxel representation, and show that planar symmetries can be used for alignment and classification of 3D meshes. It is also important for computing the PRST efficiently, since the square of the PRST for any plane reflection reduces to a dot product under this formulation, as will be seen in the following section (for functions on a grid, a dot product is the sum of the product of each pair of corresponding elements). To give an intuitive sense for the information provided by the PRST, visualizations for several simple 2D shapes are shown in Figures 1 and 2. First, we see that the dominant points and planes of symmetry match our human intuition of the ?center? and ?major axes? of the object. In general, the local maxima of the PRST coincide with the axes of the large (nearly) symmetric parts of an object (Figure 1). These provable properties can be seen empirically in Figure 2 ? i.e., the PRST is stable when a regular polygon deforms into a circle, when a square deforms into a rectangle, and when noise is added to the boundary of a starfish. This stability is in stark contrast to the medial axis transform, which finds local point symmetries but is sensitive to small boundary perturbations, shooting off a new branch for every small bump on the boundary ( Figure 3 ). For the sake of simplicity and generality, we focus our initial discussion in the following sections on planar symmetries for 3D volumetric functions, however other shape representations can trivially be converted to this representation. In the following subsections, we provide background information that can be used to gain insight into computational solutions, and then we describe three algorithmic strategies. The first two provide methods for computing a discrete version of the PRST for volumetric functions and surface meshes, respectively, while the third provides a continuous method for finding local maxima of the PRST precisely. In previous work, [Kazhdan et al. 2003a] has observed that the nearest symmetric function to f is simply the average of f and ? ( f ): SD( f , ? ) = f ? f + 2 ? ( f ) = f ? 2 ? ( f ) . Intuitively, this means that the PRST 2 ( f , ? ) for a single plane reflection ? is related to how well f correlates with ? ( f ), and it can ume be computed of f . with an integration of f ? ? ( f ) over the bounding volIn order to apply the above definition to surfaces, it is necessary to convert them to volumetric functions. While we could simply rasterize the surfaces into a (binary) occupancy grid, this would result in sensitivity to noise and small features. Instead, we use the Gaussian Euclidean Distance Transform (GEDT), as was previously proposed by [Kazhdan et al. 2004]. For a model M and width ? , the GEDT at an arbitrary point in space x is defined as: f (x, M, ? ) = e ?dist 2 (x,M)/ ? 2 , where dist(x, M) represents the distance of the point x to the nearest point on M. This allows surfaces to be slightly misaligned (by the Gaussian width ? ) under reflection, allowing us to capture imperfect symmetries of the surface. The net result is a 3D function that is exactly one at the surface of the object and gradually drops off to zero at both interior and exterior points. Similar methods can be used for other shape representations. With this background, we can propose several algorithms for computing a discrete version of the PRST for a function f represented acterizing on a regular all n the ? n planar ? n grid. symmetries These algorithms of a densely are efficient sampled for volume char (e.g., medical imaging data). As a first step, we could naively apply Equation 1 to evaluate PRST 2 ( f , ? ) for every possible plane reflection ? separately. However, since the PRST values for planes with the same orientation require dot products of functions successively shifted at regular intervals with respect to one another ( Figure 4a ), we can compute them all at the same time with a single convolution. Since the convolution for a single direction takes O(n 3 log n), and there are O(n 2 ) possible directions through the grid, the total running time of this algorithm is O(n 5 log n). Equivalently, we can consider convolutions over rotations at a discrete set of points ( Figure 4b ). In this case, we use the frequency domain algorithm described in [Kazhdan et al. 2003a] to compute the PRST for all planes through O(n) points ( Figure 4b ). Since each invocation of Kazhdan et al.?s algorithm takes (n 4 log n), the total running time is again O(n 5 log n). A multiresolution approximation is possible in O(n 4 log n). We have investigated all three of these approaches. In our implementation, we discretize the space of planes to match the resolution of the grid (finer sampling of the planes yields no additional information about the band-limited PRST). When working in 2D, we use a uniform parameterization of the set of lines by their angles ? slightly ? [0, ? unusual ] and distance choice from of angles the origin on a semicircle r ? [?r max and , r max both ]. Note positive the and negative radii, which avoids a singularity at the origin. Similarly, we parameterize planes in 3D by the spherical coordinates of gin uniform their r ? [?r normals size, max shrinking , r ? max ? ]. [0, (Note ? towards /2], that ? ? the the [0, poles 2 ?buckets? ? ] and as sin distance of ? ). planes from are the not oriof We find that these convolution algorithms take 40 seconds on average for grids with 64 ? 64 ? 64 voxels on a 3GHz processor. While the algorithms discussed so far are equally efficient for all functions, rasterized surfaces and point sets naturally lead to sparsity over the volume. In this section, we describe a Monte Carlo algorithm for computing the PRST that takes advantage of this sparsity to increase efficiency. Our discussion of the algorithm begins with the brute-force approach presented in Section 4.2:  for each plane ? : for each point x: PRST x ? ? 2 (x) ( f , ? ) += f (x) ? f (x ) We observe that for sparse functions this is inefficient, since it performs useless computation whenever either f (x) or f (x ) is near zero. Instead, we interchange the order of computations and perform importance sampling in a Monte Carlo framework: for sampled points x: for sampled points x : PRST ? ? reflection 2 ( f , ? ) += plane(x, w(x, x x , ? ) ) ? f (x) ? f (x ) Intuitively, this algorithm repeatedly picks a pair of points and ?votes? for the plane between them. The sampling of x and x is performed according to the energy in the function f , allowing us to focus effort on computations that will contribute to the final answer. For a typical 3D surface, non-negligible values appear in only O(n 2 ) voxels, and thus this algorithm requires only O(n 4 ) operations to compute the entire PRST. Weighting: In order for the above algorithm to compute the PRST correctly, it is necessary to weight the contribution of each ?vote? appropriately. The first term accounts for the importance sampling that we perform, and is simply the reciprocal of the probability of having selected x and x : w samp (x, x , ? ) = f (x) ? 1 f (x ) . The second term represents a change-of-variables, accounting for the two different ways we have of sampling the space of planes: as a pair of points (x, x ) and with our discretized bins over (r, ? , ? ). While part of this change-of-variables term is intuitive (accounting for the sin ? decrease in bin size), another part accounts for the fact that bins of planes will receive more votes if x and x are far apart than if they are nearby. For example, both parts of Figure 5 consider a single bin of planes. However, for a fixed x, it is clear that more points x will vote for that bin if the points are further apart, so we should weight the contribution of such pairs lower than votes by nearby points. To derive the change-of-variables weight, we simply compute the determinant of the Jacobian of the transformation between the parameterization of the planes of reflection and the reflected points themselves. If we let n ? = ? sin sin ? ? cos sin ? ? ? ? cos ? ? be the normal of the plane of reflection, then we can write x? d/2 d = x ? x d/2 = 2 (r ? n ? ? x) x x = x + d n ? = x + 2r n ? ? 2 ( n ? ? x) n ? O r ? n J = ? ? ? ? ? ? x r ? ?? ? ? x ? ?? ? ? x ? ? and solve for the determinant: w change-of-variables = |J| = 2 d 2 sin ? . Therefore, we have w(x, x , ? ) = w samp ? w change-of-variables , 1 = f (x) f (x ) 2 d 2 sin ? . So, overall, our Monte Carlo estimator is: D( f , ? ) = N samp 1 N i=1 ? samp 2 d 2 1 sin ?\n        Computation time: By exploiting sparsity in the volume, the Monte Carlo algorithm is able to compute the PRST of 3D surfaces efficiently. As with all randomized algorithms, noise in the final approximation decreases with additional samples, but as shown in Figure 6 , the algorithm converges quite quickly. For example, for the 64 3 grid resolution used throughout this paper, computing the PRST to 1% noise takes an average of 8 seconds on a 3 GHz processor, corresponding to two million sampled point pairs. These results are typical there is little variation in computation time, except for very large models (for which the rasterization time can begin to dominate). While the PRST taken as a whole characterizes all of an object?s symmetries, its local maxima form an important and intuitive subset. They may correspond to the principal symmetries of the whole object, weaker or partial local symmetries, or perfect symmetries of parts. Due to their intuitive nature, they are important for several applications, including all those described in Section 5. We now discuss an approach that builds upon the algorithm presented in the previous section to find local symmetry maxima precisely: we extract candidates for local maxima from the discrete PRST, then refine their locations using an iterative local optimization algorithm. This algorithm is able to find local maxima of the PRST with arbitrary precision. Given the full 3D symmetry transform, tabulated at a moderate resolution, we first look for cells with a higher symmetry value than all their immediate neighbors. First, we apply a threshold on the strength of the symmetry at that cell. In particular, we use a and threshold r is the proportional distance of to the 1 candidate ? r / R , where plane R is from the radius the center of the of object mass. On top of the symmetry threshold, we also discard shallow maxima, which are potentially subject to noise: we impose a threshold on the discrete Laplacian (sum of second partial derivatives) of the PRST. The thresholds are set automatically to 1 / 10 of the values at the strongest local symmetry. Once we have a list of candidate local maxima, we refine them to find the planes of symmetry with high precision. This approach, of finding maxima of a function by first tabulating it then locally refining candidate maxima, is commonly used for numerical maximization in general, and also resembles the local optimization performed by Martinet et al. [2005]. Our refinement method is inspired by the Iterative Closest Points algorithm [Besl and McKay 1992], commonly used to perform pairwise alignment of meshes, but solves for a plane of reflection rather than a rigid-body transformation. Our ?Iterative Symmetric Points? or ISP algorithm begins by randomly sampling points from the mesh (we typically use around 10,000 points per iteration), then reflecting them across the candidate plane. We match each reflected point to the closest point on the mesh, then solve for the three parameters of the reflection plane that minimizes the sum of distances (weighted to account for the Gaussian Euclidean Distance Transform) between corresponding points (note that the minimal sum of weighted distances provides a maximum for Equation 2 when f is the GEDT of the surface). The process is iterated until it converges to a local maximum of the PRST. Figure 7 , left, shows an iteration of ISP, with source points in red, the candidate plane in gray, and reflected points in green. The support of the final maximum is shown at right. However, we have found this check is necessary since different point sampling strategies are used by the discrete and iterative algorithms. In our experiments, this two-stage process of first tabulating the PRST then refining candidate local maxima has proven both robust and efficient. The local refinement converges in a few seconds for each plane, and we typically find 10?20 strong local maxima of symmetry for models of moderate complexity. Figure 8 shows the four strongest local maxima for a bull model, together with the surface support of each plane reflection (white regions of the surface reflect onto each other across the chosen plane). Note that we find planes capturing the global symmetries of the bull (1), as well as separate local maxima capturing symmetries of the neck (2), body (3), and head (4). The PRST is a general-purpose transform with potential applications in computer vision, medical imaging, and a variety of other fields. In this section, we investigate four applications in computer graphics. Alignment of objects into a canonical coordinate frame is an important preprocessing step for a variety of tasks, including visualization, studying the variation of models across different classes, composition of scenes, and indexing of 3D model databases. Typically, alignments of this type are computed with principal component analysis (PCA): the center of mass is chosen as the origin, and the principal axes are used to determine the orientation [Duda et al. 2001]. However, it is well known that PCA does not always produce compatible alignments for objects in the same class [Kazhdan et al. 2003b], and it certainly does not produce alignments similar to what a human would select. Consider, for example, the mugs shown in Figures 9 and 10. Most humans would suggest that the central axis of these mugs runs straight up and down through the middle of the cup, and the center is somewhere along this axis. However, the center of mass and principal axes (shown in green in Figure 9 ) are biased towards the handle to different degrees depending on the size and shape of the handle, producing alignments\n        (1)\n        (2) inconsistent with other mugs and undesirable for most applications (e.g., placement in a scene). In this section, we investigate the use of the PRST to produce better alignments. Specifically, we introduce two new concepts, the principal symmetry axes (PSA) and the center of symmetry (COS), as robust global alignment features of a model. Intuitively, the principal symmetry axes are the normals of the orthogonal set of planes with maximal symmetry, and the center of symmetry is the intersection of those three planes. Specifically, given a PRST we select the first principal symmetry axis by finding the plane with maximal symmetry. We then select the second axis by searching for the plane with maximal symmetry among those perpendicular to the first, and Center of mass and PCA Center of symmetry and principal symmetry axes Center of mass and PCA finally we choose the third axis in the same way, searching only the planes perpendicular to both the first and second selections. We find that this simple method produces coordinate frames that are both robust and semantically meaningful for most objects. For example, for the mugs shown in Figures 9 and 10, the center of symmetry and principal symmetry axes appear right in the middle of the cylindrical cup. Similarly, for the mailboxes shown in Figure 10, the center of symmetry and principal symmetry axes consistently reside in the middle of the box ? unlike the center of mass and principal axes, they are not affected by the shapes of the stands. In order to test whether the PRST is robust, even for partial surfaces, we experimented with alignments of synthetically generated range scans. This experiment is motivated by an object recognition application in which (partial-object) scans are acquired and registered to (whole-object) meshes stored in a database, with the hope of automatically recognizing which object was scanned [Shan et al. 2004]. For this application, it is useful to align the partial scan to the complete object automatically. For the experiment, we used a ray tracer to generate eight synthetic range scans of approximately 10,000 points ( Figure 11 , top) for the 907 meshes provided as part of the Princeton Shape Benchmark test set [Shilane et al. 2004]. For each mesh, the virtual scanner was in turn placed at each of the eight corners of a cube surrounding the model, always pointing toward the center of the mesh bounding box. The view distance was twice the length of the bounding box diagonal, and the field of view was 0.4 radians ( Figure 11 ). For each scan, we voxelized the point cloud, computed the PRST, and extracted the principal symmetry axes and center of symmetry (Figure 11, bottom left). Then, we evaluate how well these coordinate frames match the frames computed for the complete meshes, and compare to the accuracy of the frames computed using the principal axes and center of mass ( Figure 11 , bottom right). Figure 12 shows the results of this experiment. In the first plot, we see histograms of the translational misalignment between the partial range scans and the whole objects when aligned with the center of symmetry (blue curve) and center of mass (green curve). In general, the partial scans were sufficient to recover the major symmetries of the object correctly, leading to lower average errors for center-ofsymmetry alignment as compared to center-of-mass. Of the 907 models tested, the center of symmetry for a scan was closer to that of the entire model 90% of the time. On average, they were closer by a factor of 1.5, with better results occurring when a particular viewpoint caused significant portions of the model to be missing. Figure 12b shows histograms of the rotational misalignment of the partial scans with respect to the full object when aligned with principal symmetry axes (PSA) and with the principal axes (PCA). Note the large peak near zero in the blue curve, indicating that PSA recovered the rotation for most range scans to within a few degrees of that computed for the entire object. In contrast, PCA provided a larger spread of misalignment angles. Moreover, even though less than half of the surface was available in any scan, we found that the coordinate frame chosen with PSA was within 5 degrees of a human chosen set of axes for the whole object in 70% of the scans, as opposed to only 50% for PCA. For many applications, it is important to be able to classify 3D models or retrieve them from a database based on their geometric properties. The goal is to find a representation of shape (a shape descriptor) that can be computed robustly, matched efficiently, and used to discriminate different classes of objects effectively. In this section, we investigate using the PRST as such a shape descriptor. Our efforts are motivated by the observation that symmetry properties are often consistent within a class of objects. For example, although chairs may vary in their size, whether or not they have arms, etc., their reflective planar symmetries are almost always the same (perfect left-right symmetry, a weaker global symmetry between the back and seat, local symmetries through the seat and back, etc.). This is true for many other object classes as well, including airplanes, tables, people, etc. Perhaps it is possible to classify 3D meshes automatically by comparing their computed symmetries to those of meshes in a supervised training set. In previous work, Kazhdan et al. investigated this approach using their reflective symmetry descriptor. They employed the maximum difference between the symmetry measures of any two corresponding planes through the center of mass as a dissimilarity measure for a pair of 3D meshes. We extend that previous work by considering symmetries with respect to all planes through an object?s bounding volume. In our matching method, we measure the dissimilarity between a pair of aligned meshes as the L 2 distance between their discrete PRSTs (Section 4.3), weighting the differences between  corresponding bins of the PRST by ? sin ? (where ? is the polar angle of the plane represented by the bin) to account for different bin sizes. This measure produces a large distance when there are planes for which one object is (nearly) symmetric, while the other is not. In order to evaluate the PRST as a shape descriptor for shape-based retrieval and classification applications, we ran a set of ?leave-oneout? experiments with the Princeton Shape Benchmark test set [Shilane et al. 2004], a database of 907 polygonal models partitioned into 92 classes commonly used for shape matching evaluations. In order to focus our study on shape representation rather than alignment, we manually registered all models into a common coordinate frame before matching every model against all the others. The L 2 distances between PRSTs were used to produce a ranked retrieval list for each ?query? model, and then statistics were computed to evaluate how often models within the same class appear at the front of the computed retrieval lists. Figure 13 shows average precision-recall plots comparing our retrieval performance with that of Kazhdan et al.?s planar reflective symmetry descriptor (PRSD) and the Gaussian Euclidean Distance Transform (GEDT), which is currently used in at least one shape based search engine [Funkhouser et al. 2003]. The horizontal axis of this plot represents increasing recall values (fraction of the query?s class retrieved), while the vertical axis represents retrieval precision (fraction of the retrieved models that are in the same class as the query). Higher curves represent better performance. We find that the precision achieved when matching with the PRST (thick blue curve) is higher than with the PRSD (magenta curve) for every recall value. This confirms the expectation that the extra information provided by the PRST (symmetries for off-center planes) adds precision for shape matching. Of course, it is more expensive to store (32, 768 floats versus 1, 024 floats) and to compare (0.1 ms versus 0.004 ms), but the extra cost seems worth the improved performance for most applications. We also find that both the PRSD and PRST provide less matching precision than the GEDT (green curve) on average. We believe that this is because many object classes within the Princeton Shape Benchmark have the same symmetries (e.g., almost all manmade objects have perfect left-right symmetry). Even though the symmetries may be consistent within a class, they do not always help discriminate between classes. However, we observe that the PRST provides better matching results for some types of objects (i.e., ones with distinctive symmetries), while the GEDT provides better results for others ( Figure 14 ). So, we find that combining the two shape descriptors (by simply multiplying the L 2 distances computed separately for the two descriptors) provides better retrieval performance than either alone (the thick red curve in Figure 13 ). The nearest neighbor classification rate and discounted cumulative gain scores for the combined method were 69.2% and 68.6%, respectively, which represent good retrieval performance for this data set [Shilane et al. 2004]. This leads us to conclude that the PRST, while perhaps not the best shape representation for retrieval of this type of data on its own, can provide useful information for shapebased matching and can be used to discriminate classes of objects that are difficult to distinguish with other methods. Although the PRST naturally represents the symmetries of an entire object, it also implicitly captures the symmetries of its parts. We propose to use this information for segmentation: we decompose a mesh such that the faces with each segment have the same distinct symmetries. This criterion for automatic decomposition into parts is quite different from previous methods (e.g., [Chazelle et al. 1995; Li et al. 2001; Mangan and Whitaker 1999] in that it incorporates local shape information for many different parts of the mesh simultaneously. Our segmentation algorithm follows recent work that has used kmeans clustering as a primitive operation. However, instead of clustering based on a simplification [Garland et al. 2001] or based on geodesic and angular distance between points [Katz and Tal 2003], we cluster based on support for local maxima in the PRST. To do this, we find the significant local maxima of the PRST (Section 4.4) and compute, for each face and for every symmetry plane, the degree to which the face contributes to the symmetry with respect to that plane ? i.e., how well does the face map onto the surface after reflection across the plane (a visualization of this measure is shown in Figure 8 ). If there are m local maxima in the PRST, then every point has m values representing its support for symmetry with respect to each of the m planes. We treat these m values as a feature vector and cluster faces according to their proximity in the mdimensional feature space. Intuitively, this method clusters faces that support the same, distinct set of planar symmetries. Our segmentation algorithm proceeds hierarchically, in a manner similar to the method of Katz and Tal [2003]. For each split, we perform k-means clustering (with k = 2) to establish a rough segmentation, and then take the two largest connected components and find the exact boundary between them by computing a weighted min-cut along the edges of the mesh. The discrete PRST is recomputed and its local maxima are refined after every split. Segmentation is terminated at a user-supplied depth, or when the only planes of local maxima reflect either more than 90% or less than 10% of the surface onto itself. The result of this process is a segmentation tree, with the property that lower levels in the tree capture increasingly local symmetries, hence allowing strong symmetries of even small parts to influence the segmentation. Figure 15 shows some examples of the segmentation produced by our method. Note that for the Teapot the strongest planes of symmetry pass through the body of the pot. So, the handle, spout, and top are removed precisely because they are not symmetric with respect to those planes ? i.e., the body of the pot is removed from the smaller parts, rather than vice-versa. For the Octopus and Skeletal Hand models, local symmetries of parts are important for obtaining the segmentation shown. Finally, a weakness of our scheme can be seen in the segmentation of the legs of the Dinopet and Bull. Because we use a min-cut to smooth our initial guess, the final segmentation will seek a shorter cut, and thus avoid the upper sections of the thigh. Teapot\n        Octopus\n        Dinopet\n        Bull 3D models may look considerably different when viewed from different directions, thus computing good viewpoints for 3D models has always been important for applications such as rapidly viewing a large number of models, generation of icons, selection of viewpoints for Image Based Rendering, and robot motion. The optimal ?canonical view? of a model may differ depending on the purpose, and there have been a number of methods suggested to find such viewpoints for various applications. Kamada et al. [1988] seek to minimize the number of degenerate faces in the image. Both V?zquez et al. [2001] and Lee et al. [2005] try to find quality viewpoints by maximizing the (interesting) information content for a view. Abbasi et al. [2000] and Lee et al. [2004] find optimal viewpoints for recognition based on image contours, pruned by various imaging constraints. Finally, Blanz et al. [1999] performed a user study to determine factors that influence the canonical views used to display 3D models. They report that users prefer off-axis views to front or side axis views. We introduce a method to choose good viewpoints automatically by minimizing the symmetry seen. The intuition behind our approach is that symmetry in an object presents redundant information to the user and is therefore to be avoided. Our method begins with the primary symmetry of the object and then uses the local maxima extracted from the PRST to minimize the amount of symmetry in the direction of the viewer. More specifically, for each plane appearing as a local maximum in the PRST, the preferred viewing direction is along the normal to the plane. We compute the viewpoint score for a plane a view of local direction symmetry v as S(v) and = M(u) ? u?W is |v the ? u| symmetry ? M(u) where score u for ? W that is plane. With this relatively simple scoring function it is enough to do an exhaustive search to find the optimal viewpoint, although a gradient decent method such as introduced by [Lee et al. 2005] may be used to accelerate the computation. We show the results of our approach in the middle column of Figure 16 ? each object?s local symmetries repel the viewpoint, such that the final selected view is off of the major axis of the objects. Note that even though we only show the best viewpoint, it is possible to extend this implementation to produce multiple ?interesting? viewpoints for the user?s selection (left column in Figure 16 ) and/or viewpoints to be avoided (right column). The investigation of the PRST presented in this paper is a first step. Our implementation has several limitations, and there are many avenues for future research. First, we have investigated only the transform that maps a 3D object to its planar reflective symmetries. We can further investigate the mapping of the reflective symmetry transform back from the space of planes to the space of points, by storing with each point a function of the symmetry distances for the planes that  pass through it. This was the motivation for our visualization in Figures 1 and 2. We hypothesize that the average, maximum, or some similar function of symmetry distances for all planes through each point may produce a 3D function worthy of future investigation. Second, our transform measures symmetries of an entire object. While we have shown an automatic segmentation algorithm that extract symmetries of large parts of the model hierarchically, interesting local symmetries may ?be drowned? and not found during this process. A multi-resolution scheme, where the PRST is computed on local sections of the model would be interesting to investigate. Finally, tion of whether since the the PRST transform is a 3D is ? invertible. Using these constraints we can already show that the transform is invertible in the 1D and 2D cases, and we believe we can extend this to 3D. The inversion is currently sensitive to noise however, so further research is necessary to determine if additional constraints or stronger variational relations might make our method practical. We hypothesize that the ability to invert the transform will lead to applications in a variety of domains, with the ability to not only analyze but also synthesize symmetries. In summary, we have defined the planar reflective symmetry transform, which measures the symmetry of an object with respect to all planes through its bounding volume. We have described an efficient Monte Carlo algorithm for computing the transform for surface meshes, shown that it is stable under small perturbations, and investigated its utility for several geometric processing applications. In particular, we propose that the center of symmetry and principal symmetry axes are useful for aligning 3D objects in a common coordinate frame. We also show that the reflective symmetry transform can be used for registering 3D range scans into a common coordinate system, matching 3D polygonal models of the same class, segmenting 3D models into parts, and finding good viewpoints for visualization of meshes. We would like to thank the Princeton Graphics group, especially Christopher DeCoro, for their help in getting this paper ready for publication. We would also like to thank Michael Kazhdan for his helpful comments. This work is partially supported by Air Force Research Lab grant #FA8650-04-1-1718, NSF grants #CCF0347427, #CCR-0093343, #IIS-0121446, and the Sloan Foundation.",
  "resources" : [ ]
}