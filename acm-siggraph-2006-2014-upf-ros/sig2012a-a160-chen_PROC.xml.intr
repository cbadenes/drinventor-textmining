{
  "uri" : "sig2012a-a160-chen_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2012a/a160-chen_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Depth-Presorted Triangle Lists",
    "published" : "2012",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ge-Chen",
      "name" : "Ge",
      "surname" : "Chen"
    }, {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Lei-Yang",
      "name" : "Lei",
      "surname" : "Yang"
    }, {
      "uri" : "http://drinventor/Liang-Hu",
      "name" : "Liang",
      "surname" : "Hu"
    } ]
  },
  "bagOfWords" : [ "real-time", "rendering", "application", "employ", "z-buffer", "visibility", "determination", "-lsb-", "Catmull", "1974", "-rsb-", "still", "many", "scenario", "which", "depth-sorting", "necessary", "desirable", "most", "common", "problem", "depth-sorting", "tightly", "connect", "problem", "visibility", "which", "vast", "amount", "prior", "work", "here", "we", "focus", "method", "we", "believe", "most", "related", "ours", "note", "many", "depth-sorting", "method", "can", "use", "render", "dynamic", "-lrb-", "even", "self-intersecting", "-rrb-", "geometry", "naturally", "when", "compare", "they", "against", "we", "approach", "we", "assume", "target", "application", "do", "require", "functionality", "most", "well-known", "approach", "render", "depth-sorted", "static", "geometry", "BSP", "tree", "-lsb-", "Fuchs", "et", "al.", "1980", "Paterson", "Yao", "1989", "-rsb-", "each", "node", "BSP", "tree", "include", "half-space", "test", "root", "node", "represent", "entirety", "space", "each", "subtree", "represent", "fraction", "parent?s", "space", "reside", "one", "two", "halfspace", "BSP", "tree", "create", "during", "preprocessing", "stage", "much", "like", "we", "extended", "triangle", "list", "render", "from", "bsp", "tree", "traverse", "recursively", "run-time", "back-to-front", "rendering", "when", "visit", "node", "subtree", "represent", "half-space", "contain", "viewpoint", "visit", "last", "we", "method", "half-space", "instead", "use", "separate", "viewpoint", "which", "give", "individual", "triangle", "instance", "must", "draw", "from", "those", "which", "must", "ignore", "other", "than", "BSP", "additional", "data-structure", "use", "depth", "sort", "include", "direct", "acyclic", "graph", "-lsb-", "Williams", "1992", "-rsb-", "feudal", "priority", "tree", "-lsb-", "Chen", "Wang", "1996", "-rsb-", "Voronoi", "diagram", "-lsb-", "fukushige", "Suzuki", "2006", "-rsb-", "contrast", "we", "extend", "list", "flat", "data-structure", "potentially", "include", "multiple", "copy", "each", "triangle", "each", "which", "select", "viewpoint", "we", "method", "therefore", "better", "suit", "modern", "gpus", "where", "recursiveness", "pointer", "manipulation", "difficult", "otherwise", "inefficient", "accomplish", "early", "cpu-based", "approach", "also", "generate", "flat", "semi-flat", "datastructure", "Newell", "et", "al.", "-lsb-", "1972", "-rsb-", "Goad", "-lsb-", "1982", "-rsb-", "both", "describe", "automatic", "procedure", "sort", "triangle", "priority", "order", "give", "viewpoint", "Schumacker", "et", "al.", "-lsb-", "1969", "-rsb-", "propose", "method", "separate", "scene", "convex", "cluster", "during", "preprocessing", "face", "each", "cluster", "can", "assign", "fix", "order", "which", "after", "back-face", "culling", "provide", "correct", "visibility", "from", "any", "viewpoint", "cluster", "must", "mutually", "separable", "plane", "order", "display", "cluster", "compute", "run-time", "we", "method", "leverage", "GPU", "hardware", "order", "render", "model", "use", "single", "draw", "call", "without", "require", "order", "computation", "run-time", "most", "general", "technique", "operate", "pixel", "level", "typical", "strategy", "generate", "per-pixel", "fragment", "list", "sort", "each", "list", "a-buffer", "-lsb-", "Carpenter", "1984", "-rsb-", "challenging", "since", "way", "guess", "total", "number", "fragment", "storage", "need", "number", "fragment", "need", "per", "pixel", "New", "hardware", "capability", "have", "recently", "enable", "use", "dynamic", "link", "list", "collect", "fragment", "blend", "they", "order", "-lsb-", "Yang", "et", "al.", "2010", "-rsb-", "instead", "count", "number", "fragment", "first", "rasterization", "pass", "store", "they", "individual", "array", "during", "second", "pass", "-lsb-", "dx10", "SDK", "2010", "-rsb-", "before", "composit", "they", "parallel", "-lsb-", "patney", "et", "al.", "2010", "-rsb-", "we", "method", "require", "single", "pass", "use", "constant", "memory", "significantly", "faster", "particularly", "when", "multiple", "sample", "per", "pixel", "use", "anti-aliasing", "-lrb-", "e.g.", "msaa", "-rrb-", "many", "modification", "render", "pipeline", "have", "be", "propose", "support", "variation", "a-buffer", "include", "rbuffer", "-lsb-", "wittenbrink", "2001", "-rsb-", "f-buffer", "-lsb-", "Mark", "Proudfoot", "2001", "-rsb-", "Delay", "Streams", "-lsb-", "Aila", "et", "al.", "2003", "-rsb-", "freepipe", "architecture", "-lsb-", "Liu", "et", "al.", "2010", "-rsb-", "we", "method", "run", "standard", "render", "pipeline", "another", "alternative", "render", "scene", "many", "time", "require", "maximum", "depth", "complexity", "each", "pass", "z-buffer", "use", "select", "next", "closest", "fragment", "-lsb-", "mamman", "1989", "Everitt", "2001", "Thibieroz", "2008", "-rsb-", "-lrb-", "much", "like", "selection", "sort", "-rrb-", "performance", "reason", "variation", "idea", "split", "scene", "piece", "presorted", "-lsb-", "Wexler", "et", "al.", "2005", "-rsb-", "peel", "multiple", "layer", "per", "pass", "-lsb-", "Liu", "et", "al.", "2006", "Bavoil", "Myers", "2008", "-rsb-", "exploit", "any", "order", "structure", "may", "already", "present", "-lsb-", "Carr", "et", "al.", "2008", "-rsb-", "algorithm", "exact", "amount", "memory", "need", "fix", "we", "method", "simpler", "depend", "depth-complexity", "significantly", "faster", "many", "method", "rely", "approximation", "performance", "reason", "common", "approach", "limit", "maximum", "number", "fragment", "per", "pixel", "-lsb-", "Jouppi", "Chang", "1999", "Myers", "Bavoil", "2007a", "Bavoil", "et", "al.", "2007", "Liu", "et", "al.", "2009", "Huang", "et", "al.", "2010", "Salvi", "et", "al.", "2011", "-rsb-", "which", "case", "some", "heuristic", "must", "use", "merge", "evict", "overflow", "fragment", "case", "order-independent", "transparency", "ignore", "order", "sometimes", "acceptable", "-lsb-", "meshkin", "2007", "Bavoil", "Myers", "2008", "-rsb-", "another", "method", "avoid", "need", "sorting", "stochastic", "transparency", "-lsb-", "Enderton", "et", "al.", "2010", "Laine", "Karras", "2011", "-rsb-", "refreshing", "new", "take", "screen-door", "transparency", "-lsb-", "Foley", "et", "al.", "1990", "Mulder", "et", "al.", "1998", "-rsb-", "we", "method", "always", "produce", "noisefree", "rendering", "significantly", "faster", "some", "approximation", "work", "particularly", "well", "hair", "volumetric", "datum", "both", "-lsb-", "Kim", "Neumann", "2001", "Callahan", "et", "al.", "2005", "Yuksel", "Keyser", "2008", "Sintorn", "Assarsson", "2008", "2009", "Jansen", "Bavoil", "2010", "Salvi", "et", "al.", "2011", "-rsb-", "we", "method", "suitable", "high", "depth-complexity", "finally", "context", "overdraw", "reduction", "some", "static", "order", "may", "succeed", "eliminate", "most", "overdraw", "-lsb-", "Nehab", "et", "al.", "2006", "Sander", "et", "al.", "2007", "-rsb-" ],
  "content" : "In real-time rendering applications that employ the Z-buffer for visibility determination [Catmull 1974], there are still many scenarios in which depth-sorting is necessary or desirable. The most common is The problem of depth-sorting is tightly connected to the problem of visibility, for which there is a vast amount of prior work. Here, we focus on the methods we believe are most related to ours. Note that many depth-sorting methods can be used to render dynamic (or even self-intersecting) geometry. Naturally, when comparing them against our approach, we assume the target application does not require this functionality. The most well-known approach for rendering depth-sorted static geometry is the BSP tree [Fuchs et al. 1980; Paterson and Yao 1989]. Each node in a BSP tree includes a half-space test. The root node represents the entirety of space, and each subtree represents the fraction of the parent?s space that reside in one of the two halfspaces. The BSP tree is created during a preprocessing stage, much like our extended triangle list. To render from a BSP, the tree is traversed recursively at run-time. For back-to-front rendering, when visiting a node, the subtree representing half-spaces that contain the viewpoint are visited last. In our method, the half-spaces are instead used to separate the viewpoints for which a given individual triangle instance must be drawn from those for which it must be ignored. Other than the BSP, additional data-structures used for depth sorting include directed acyclic graphs [Williams 1992], feudal priority trees [Chen and Wang 1996], and Voronoi diagrams [Fukushige and Suzuki 2006]. In contrast, our extended list is a flat data-structure,  potentially including multiple copies of each triangle, each of which is selected or not by the viewpoint. Our method is therefore better suited for modern GPUs, where recursiveness and pointer manipulation are difficult or otherwise inefficient to accomplish. Early CPU-based approaches also generate flat or semi-flat datastructures. Newell et al. [1972] and Goad [1982] both describe automatic procedures that sort triangles into a priority order for given viewpoints. Schumacker et al. [1969] propose a method that separates the scene into convex clusters during preprocessing. The faces in each cluster can be assigned a fixed order which, after back-face culling, provides correct visibility from any viewpoint. These clusters must be mutually separable by planes, and the order of displaying these clusters is computed at run-time. Our method leverages GPU hardware in order to render the model using a single draw call without requiring ordering computations at run-time. The most general techniques operate at the pixel level. The typical strategy is to generate per-pixel fragments lists and then sort each list, as in the A-buffer [Carpenter 1984]. This is challenging, since there is no way to guess the total number of fragment storage that will be needed, or the number of fragments needed per pixel. New hardware capabilities have recently enabled the use dynamic linked lists to collect fragments and blend them in order [Yang et al. 2010], or instead to count the number of fragments in a first rasterization pass and store them into individual arrays during a second pass [ DX10 SDK 2010 ], before compositing them in parallel [Patney et al. 2010]. Our method requires a single pass, uses constant memory, and is significantly faster, particularly when multiple samples per pixel are used for anti-aliasing (e.g. MSAA). Many modifications to the rendering pipeline have been proposed that support variations of the A-buffer. These include the Rbuffer [Wittenbrink 2001], the F-buffer [Mark and Proudfoot 2001], Delay Streams [Aila et al. 2003], and the FreePipe architecture [Liu et al. 2010]. Our method runs on the standard rendering pipeline. Another alternative is to render the scene as many times as required by the maximum depth complexity. At each pass, the Z-buffer is used to select the next closest fragment [Mammen 1989; Everitt 2001; Thibieroz 2008] (much like selection sort). For performance reasons, variations of this idea split the scene into pieces that are presorted [Wexler et al. 2005], peel multiple layers per pass [Liu et al. 2006; Bavoil and Myers 2008], or exploit any ordered structure that may already be present [Carr et al. 2008]. The algorithms are exact and the amount of memory needed is fixed. Our method is simpler and, depending on the depth-complexity, significantly faster. Many methods rely on approximations for performance reasons. A common approach is to limit the maximum number of fragments per pixel [Jouppi and Chang 1999; Myers and Bavoil 2007a,b; Bavoil et al. 2007; Liu et al. 2009; Huang et al. 2010; Salvi et al. 2011], in which case some heuristic must be used to merge or evict overflowing fragments. In the case of order-independent transparency, ignoring order is sometimes acceptable [Meshkin 2007; Bavoil and Myers 2008]. Another method that avoids the need for sorting is stochastic transparency [Enderton et al. 2010; Laine and Karras 2011], a refreshing new take on screen-door transparency [Foley et al. 1990; Mulder et al. 1998]. Our method always produces noisefree renderings and is significantly faster. Some approximations work particularly well for hair, volumetric data, or both [Kim and Neumann 2001; Callahan et al. 2005; Yuksel and Keyser 2008; Sintorn and Assarsson 2008, 2009; Jansen and Bavoil 2010; Salvi et al. 2011]. Our method is not suitable for such high depth-complexities. Finally, in the context of overdraw reduction, some static orders may succeed in eliminating most of the overdraw [Nehab et al. 2006; Sander et al. 2007].",
  "resources" : [ ]
}