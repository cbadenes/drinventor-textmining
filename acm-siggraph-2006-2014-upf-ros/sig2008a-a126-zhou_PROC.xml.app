{
  "uri" : "sig2008a-a126-zhou_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a126-zhou_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-Time KD-Tree Construction on Graphics Hardware",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Qiming-Hou",
      "name" : "Qiming",
      "surname" : "Hou"
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Baining-Guo",
      "name" : "Baining",
      "surname" : "Guo"
    } ]
  },
  "bagOfWords" : [ "we", "present", "algorithm", "construct", "kd-tree", "gpus", "algorithm", "achieve", "real-time", "performance", "exploit", "gpu?s", "streaming", "architecture", "all", "stage", "kd-tree", "construction", "we", "also", "develop", "special", "strategy", "large", "node", "upper", "tree", "level", "so", "further", "exploit", "fine-grained", "parallelism", "gpus", "node", "we", "parallelize", "computation", "over", "all", "geometric", "primitive", "instead", "node", "each", "level", "finally", "order", "maintain", "kd-tree", "quality", "we", "introduce", "novel", "scheme", "fast", "evaluation", "node", "split", "cost", "far", "we", "know", "ours", "first", "real-time", "kd-tree", "algorithm", "GPU", "term", "speed", "we", "algorithm", "significantly", "faster", "than", "well-optimized", "single-core", "CPU", "algorithm", "competitive", "multi-core", "CPU", "algorithm", "however", "real-time", "construction", "kd-tree", "GPU", "remain", "unsolved", "problem", "paper", "we", "present", "kd-tree", "construction", "algorithm", "GPU", "achieve", "real-time", "performance", "heavily", "exploit", "hardware", "important", "feature", "distinguish", "we", "work", "from", "previous", "parallel", "kd-tree", "algorithm", "include", "-lsb-", "Popov", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "which", "resort", "df", "-lrb-", "depth-first", "search", "-rrb-", "node", "near", "Shadows", "reflection/refraction", "well", "caustic", "cause", "glass", "champagne", "render", "around", "fp", "800", "600", "image", "bottom", "kd-tree", "design", "kd-tree", "algorithm", "GPU", "we", "must", "address", "two", "challenging", "issue", "first", "how", "maximally", "exploit", "gpu?s", "streaming", "architecture", "when", "parallelize", "kd-tree", "construction", "modern", "GPU", "massively", "parallel", "require", "10", "10", "thread", "optimal", "performance", "-lsb-", "NVIDIA", "2007", "-rsb-", "follow", "BFS", "order", "we", "well", "poise", "take", "advantage", "architecture", "because", "each", "bf", "step", "every", "node", "same", "tree", "level", "spawn", "new", "thread", "total", "number", "thread", "double", "from", "preceding", "step", "addition", "follow", "BFS", "order", "we", "also", "develop", "special", "strategy", "large", "node", "upper", "tree", "level", "so", "further", "exploit", "large", "scale", "parallelism", "gpus", "node", "we", "parallelize", "computation", "over", "all", "geometric", "primitive", "instead", "node", "each", "level", "strategy", "effective", "because", "only", "relatively", "small", "number", "large", "node", "upper", "level", "especially", "near", "top", "tree", "which", "make", "parallelizing", "over", "node", "inefficient", "leave", "massive", "parallelism", "gpus", "underexploit", "moreover", "workload", "among", "thread", "likely", "unbalanced", "because", "number", "primitive", "may", "vary", "significantly", "from", "node", "node", "another", "issue", "efficient", "calculation", "node", "split", "cost", "surface", "area", "heuristic", "-lrb-", "sah", "-rrb-", "-lsb-", "Goldsmith", "Salmon", "1987", "-rsb-", "voxel", "volume", "heuristic", "-lrb-", "vvh", "-rrb-", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "cost", "critical", "maintain", "kd-tree", "quality", "standard", "practice", "precisely", "evaluate", "cost", "all", "tree", "node", "prohibitively", "expensive", "real-time", "technique", "address", "issue", "we", "derive", "novel", "scheme", "so-called", "large", "small", "node", "node", "deem", "large", "number", "triangle", "node", "greater", "than", "user-specified", "threshold", "otherwise", "small", "-lsb-", "Popov", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "point", "cloud", "model", "we", "real-time", "kd-tree", "construction", "can", "also", "use", "dynamic", "point", "cloud", "accelerate", "nearest", "neighbor", "query", "-lrb-", "appendix", "-rrb-", "query", "neighbor", "use", "estimate", "local", "sampling", "density", "calculate", "normal", "update", "deformation", "strength", "field", "free-form", "deformation", "key", "optimization", "determine", "splitting", "plane", "other", "application", "photon", "mapping", "kd-tree", "mainly", "use", "accelerate", "nearest", "neighbor", "query", "which", "different", "heuristic", "employ", "achieve", "better", "efficiency", "example", "vvh", "kd-tree", "can", "better", "accelerate", "photon", "gathering", "process", "than", "left-balanced", "tree", "-lsb-", "Wald", "et", "al.", "2004", "-rsb-", "fast", "kd-tree", "construction", "construction", "high", "quality", "kd-tree", "expensive", "due", "evaluation", "SAH", "cost", "function", "however", "goal", "increase", "coherence", "memory", "access", "during", "tree", "construction", "target", "small", "scale", "parallel", "architecture", "like", "multi-core", "cpus", "node", "near", "bottom", "tree", "df", "order", "use", "which", "difficult", "parallelize", "consume", "90", "construction", "time", "algorithm", "first", "partition", "space", "several", "balanced", "sub-region", "build", "sub-tree", "each", "sub-region", "parallel", "df", "order", "algorithm", "can", "map", "well", "GPU", "architecture", "because", "modern", "gpus", "require", "10", "10", "thread", "optimal", "performance", "-lsb-", "NVIDIA", "2007", "-rsb-", "order", "magnitude", "greater", "than", "possible", "thread", "number", "multi-core", "cpus", "-lrb-", "e.g.", "four", "thread", "test", "paper", "-rrb-", "none", "above", "GPU", "ray", "tracer", "outperform", "well-optimized", "CPU", "ray", "tracer", "pick", "optimal", "candidate", "lowest", "cost", "split", "node", "two", "child", "node", "case", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "equal", "number", "element", "contain", "left", "right", "child", "respectively", "streaming", "step", "do", "GPU", "while", "coordination", "work", "do", "CPU", "negligible", "cost", "additionally", "streaming", "step", "perform", "compute", "aabb", "-lrb-", "axis", "align", "bound", "box", "-rrb-", "each", "input", "triangle", "specifically", "now", "we", "walk", "through", "major", "step", "rocess", "arge", "ode", "algorithm", "result", "sequence", "which", "each", "element", "hold", "reduction", "result", "one", "segment", "two", "element", "have", "same", "owner", "replace", "operation", "result", "although", "possible", "compute", "node", "bound", "box", "perform", "segmented", "reduction", "all", "input", "triangle", "aabb", "directly", "inefficient", "because", "large", "segmented", "reduction", "about", "three", "time", "slower", "than", "large", "unsegmented", "reduction", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "each", "chunk", "triangle", "chunk", "first", "check", "generate", "vector", "boolean", "value", "which", "indicate", "whether", "each", "triangle", "child", "node", "traverse", "tree", "top-down", "compute", "start", "address", "traversal", "each", "subtree", "distribute", "node", "information", "corresponding", "address", "produce", "final", "tree", "structure", "many", "field", "node", "triangle", "we", "use", "structure", "array", "-lrb-", "soa", "-rrb-", "instead", "array", "structure", "-lrb-", "ao", "-rrb-", "optimal", "GPU", "cache", "performance", "third", "modification", "we", "can", "now", "simplify", "large", "node", "stage", "greatly", "because", "clipping", "need" ],
  "content" : "We present an algorithm for constructing kd-trees on GPUs. This algorithm achieves real-time performance by exploiting the GPU?s streaming architecture at all stages of kd-tree construction. We also develop a special strategy for large nodes at upper tree levels so as to further exploit the fine-grained parallelism of GPUs. For these nodes, we parallelize the computation over all geometric primitives instead of nodes at each level. Finally, in order to maintain kd-tree quality, we introduce novel schemes for fast evaluation of node split costs. As far as we know, ours is the first real-time kd-tree algorithm on the GPU. In terms of speed, our algorithm is significantly faster than well-optimized single-core CPU algorithms and competitive with multi-core CPU algorithms. However, real-time construction of kd-trees on the GPU remains an unsolved problem. In this paper, we present a kd-tree construction algorithm for the GPU that achieves real-time performance by heavily exploiting the hardware. This is an important feature that distinguishes our work from previous parallel kd-tree algorithms including [Popov et al. 2006; Shevtsov et al. 2007], which resort to DFS (depth-first search) for nodes near the Shadows, reflection/refraction, as well as caustics caused by the glass and champagne are rendered at around 8 fps for 800 ? 600 images. bottom of the kd-tree. In designing a kd-tree algorithm for the GPU, we must address two challenging issues. The first is how to maximally exploit the GPU?s streaming architecture when parallelizing kd-tree construction. The modern GPU is massively parallel and requires 10 3 ? 10 4 threads for optimal performance [ NVIDIA 2007 ]. By following BFS order, we are well poised to take advantage of this architecture because at each BFS step, every node at the same tree level spawns a new thread and the total number of threads doubles from the preceding step. In addition to following BFS order, we also develop a special strategy for large nodes at upper tree levels so as to further exploit the the large scale parallelism of GPUs. For these nodes, we parallelize the computation over all geometric primitives instead of nodes at each level. This strategy is effective because there are only a relatively small number of large nodes at the upper levels, especially near the top of the tree, which makes parallelizing over nodes inefficient and leaves the massive parallelism of GPUs underexploited. Moreover, the workload among threads is likely to be unbalanced because the number of primitives may vary significantly from node to node. Another issue is the efficient calculation of node split costs, such as the surface area heuristic (SAH) [Goldsmith and Salmon 1987] and voxel volume heuristic (VVH) [Wald et al. 2004] costs. This is critical for maintaining kd-tree quality. The standard practice of precisely evaluating the costs for all tree nodes is prohibitively expensive for real-time techniques. To address this issue, we derive novel schemes for the so-called large and small nodes. A node is deemed as large if the number of triangles in the node is greater than a user-specified threshold; otherwise it is small [Popov et al. 2006; Shevtsov et al. 2007]. Point Cloud Modeling Our real-time kd-tree construction can also be used for dynamic point clouds to accelerate nearest neighbor queries (Appendix B). The queried neighbors are used for estimating local sampling densities, calculating the normals and updating the deformation strength field in free-form deformation. The key for this optimization is determining the splitting plane. In other applications such as photon mapping, kd-trees are mainly used to accelerate nearest neighbor queries, for which different heuristics are employed to achieve better efficiency. For example, VVH kd-trees can better accelerate the photon gathering process than left-balanced trees [Wald et al. 2004]. Fast Kd-tree Construction Construction of high quality kd-trees is expensive due to the evaluation of the SAH cost function. However, their goal is to increase the coherence of memory accesses during tree construction and targets small scale parallel architectures like multi-core CPUs. For nodes near the bottom of the tree, DFS order  is used, which is difficult to parallelize and consumes 90% of the construction time. The algorithm first partitions the space into several balanced sub-regions and then builds a sub-tree for each sub-region in parallel and in DFS order. The algorithm cannot be mapped well to GPU architecture because modern GPUs require 10 3 ? 10 4 threads for optimal performance [ NVIDIA 2007 ], orders of magnitude greater than the possible thread number on multi-core CPUs (e.g., four threads tested in the paper). None of the above GPU ray tracers outperforms a well-optimized CPU ray tracer. Pick the optimal candidate with the lowest cost and split the node into two child nodes; 3. In this case C L (x) and C R (x) equal the number of elements contained in the left and right child respectively. The streaming steps are done on the GPU while coordination work is done on the CPU at negligible costs. Additionally, a streaming step is performed to compute the AABB (axis aligned bounding box) for each input triangle. Specifically, if Now we walk through the major steps of P ROCESS L ARGE N ODES in Algorithm 2. The result is a sequence in which each element holds the reduction result of one segment. If the two elements have the same owner, they are replaced by their operation result. Although it is possible to compute the node bounding boxes by performing segmented reduction on all input triangles? AABBs directly, this is inefficient because large segmented reductions are about three times slower than large unsegmented reductions [Sengupta et al. 2007]. For each chunk, the triangles in the chunk are first checked to generate a vector of boolean values, which indicates whether each triangle is in a child node or not. traverses the tree top-down to compute the starting address in the traversal for each subtree, and distributes node information to the corresponding address to produce the final tree. For structures with many fields such as nodes and triangles, we use structure of arrays (SoA) instead of array of structures (AoS) for optimal GPU cache performance. The third modification is that we can now simplify the large node stage greatly because clipping is not needed.",
  "resources" : [ ]
}