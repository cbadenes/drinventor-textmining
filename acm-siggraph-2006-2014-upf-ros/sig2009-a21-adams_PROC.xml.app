{
  "uri" : "sig2009-a21-adams_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a21-adams_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Gaussian KD-Trees for Fast High-Dimensional Filtering",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "we", "propose", "method", "accelerate", "broad", "class", "non-linear", "filter", "include", "bilateral", "non-local", "means", "other", "related", "filter", "value", "pixel", "color", "position", "-lrb-", "-rrb-", "coordinate", "describe", "gaussian", "blur", "we", "instead", "set", "position", "local", "patch", "color", "around", "associate", "pixel", "describe", "non-local", "means", "we", "describe", "monte-carlo", "kdtree", "sampling", "algorithm", "efficiently", "compute", "any", "filter", "can", "express", "way", "along", "GPU", "implementation", "technique", "gaussian", "kd-tree", "fast", "high-dimensional", "filtering", "ACM", "Trans", "28", "Article", "21", "-lrb-", "August", "2009", "-rrb-", "12", "page", "dous", "10.1145", "1531326.1531327", "http://doi.acm.org/10.1145/1531326.1531327", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "use", "any", "component", "work", "other", "work", "require", "prior", "specific", "permission", "and/or", "fee", "permission", "may", "request", "from", "Publications", "Dept.", "ACM", "Inc.", "Penn", "Plaza", "Suite", "701", "New", "York", "NY", "10121-0701", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "permissions@acm.org", "2009", "ACM", "0730-0301/2009", "03-art21", "10.00", "DOI", "10.1145", "1531326.1531327", "http://doi.acm.org/10.1145/1531326.1531327", "we", "present", "framework", "which", "understand", "filter", "acceleration", "datum", "structure", "algorithm", "apply", "broadly", "across", "all", "they", "growth", "manageable", "filter", "size", "both", "space", "color", "large", "which", "turn", "permit", "grid", "coarse", "bilateral", "filter", "can", "alternatively", "rephrase", "nearest", "neighbour", "search", "five", "dimension", "every", "-lrb-", "-rrb-", "point", "image", "we", "would", "like", "gather", "color", "from", "other", "nearby", "point", "unfortunately", "approach", "scale", "poorly", "filter", "size", "large", "filter", "each", "pixel", "may", "near", "every", "other", "pixel", "facilitate", "query", "we", "propose", "new", "type", "kd-tree", "which", "we", "term", "gaussian", "kd-tree", "describe", "section", "since", "gaussian", "kd-tree", "scale", "well", "dimension", "we", "need", "constrain", "ourselves", "three-dimensional", "color", "distance", "ability", "cheaply", "perform", "blur", "weight", "higher", "dimensional", "distance", "we", "can", "also", "accelerate", "non-local", "means", "-lsb-", "buade", "et", "al.", "2005", "-rsb-", "we", "discuss", "non-local", "means", "detail", "section", "3.2", "while", "non-local", "means", "increase", "number", "range", "dimension", "we", "can", "also", "increase", "number", "domain", "dimension", "include", "time", "non-local", "means", "able", "denoise", "dynamic", "scene", "average", "pixel", "value", "over", "time", "without", "require", "explicit", "motion", "model", "value", "need", "lie", "grid", "we", "can", "mix", "they", "accord", "distance", "between", "any", "set", "associate", "vector", "we", "like", "we", "therefore", "need", "restrict", "ourselves", "image", "implementation", "detail", "section", "2.4", "make", "usual", "division", "sum", "weight", "unnecessary", "example", "when", "perform", "gaussian", "blur", "image", "value", "pixel", "color", "have", "-lrb-", "-rrb-", "coordinate", "associate", "they", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "extend", "include", "color", "distance", "term", "equation", "can", "more", "generally", "express", "we", "free", "scale", "position", "arbitrarily", "so", "without", "loss", "generality", "we", "gaussian", "kernel", "always", "have", "standard", "deviation", "one", "-lrb-", "absent", "equation", "-rrb-", "we", "can", "transform", "arbitrary", "elliptical", "ball", "linear", "transform", "position", "vector", "non-local", "means", "-lrb-", "describe", "-lsb-", "Buades", "et", "al.", "2005", "-rsb-", "-rrb-", "which", "average", "pixel", "other", "have", "similar", "local", "neighborhood", "can", "also", "express", "equation", "equal", "neighborhood", "around", "pixel", "i.", "give", "arbitrary", "set", "-lrb-", "-rrb-", "size", "dimension", "lesser", "dimension", "naive", "computation", "equation", "would", "take", "-lrb-", "-rrb-", "time", "every", "value", "interact", "every", "other", "value", "-lrb-", "example", "when", "blur", "image", "filter", "large", "image", "-rrb-", "we", "instead", "accelerate", "computation", "equation", "three", "way", "suggest", "place", "point", "kd-tree", "-lrb-", "grid", "small", "-rrb-", "detail", "section", "2.2", "long", "we", "point", "sample", "space", "densely", "enough", "equivalent", "single", "gaussian", "blur", "size", "memory", "use", "concern", "we", "can", "omit", "blur", "stage", "achieve", "same", "effective", "filter", "increase", "we", "now", "face", "task", "build", "gaussian", "kd-tree", "contain", "point", "cloud", "-lrb-", "blue", "point", "Figure", "-rrb-", "adequate", "density", "around", "region", "where", "we", "intend", "sample", "example", "when", "bilateral", "filter", "we", "construct", "tree", "use", "-lrb-", "-rrb-", "value", "every", "pixel", "scatter", "from", "gather", "those", "location", "five-dimensional", "space", "therefore", "we", "can", "ensure", "adequate", "density", "guarantee", "every", "position", "within", "point", "store", "leaf", "node", "goal", "when", "build", "kd-tree", "usually", "minimize", "expected", "time", "take", "query", "bound", "box", "have", "diagonal", "length", "less", "than", "we", "create", "leaf", "node", "associated", "point", "center", "bound", "box", "otherwise", "we", "split", "halfway", "along", "longest", "bound", "box", "dimension", "divide", "input", "list", "two", "continue", "recursively", "another", "common", "scheme", "generate", "balanced", "tree", "split", "median", "value", "along", "longest", "dimension", "we", "case", "uneven", "distribution", "point", "example", "those", "produce", "from", "image", "which", "mostly", "single", "color", "can", "fact", "cause", "produce", "unbalanced", "tree", "Figure", "illustrate", "process", "number", "sample", "set", "one", "list", "contain", "single", "leaf", "node", "probabilistically", "choose", "from", "all", "leaf", "node", "within", "three", "standard", "deviation", "query", "repeatedly", "ask", "single", "sample", "merge", "result", "list", "produce", "same", "result", "limit", "ask", "infinite", "number", "sample", "from", "single", "query", "we", "can", "think", "we", "sample", "cloud", "point", "normally", "distribute", "around", "query", "give", "standard", "deviation", "although", "we", "do", "explicitly", "represent", "they", "final", "sample", "omit", "rounding", "one", "probabilistically", "assign", "either", "left", "right", "child", "latter", "case", "thread", "continue", "work", "smaller", "two", "result", "task", "place", "other", "back", "pend", "work", "structure", "single", "build", "job", "array", "point", "pointer", "parent", "node", "which", "result", "subtree", "should", "attach", "we", "parallelize", "build", "job", "over", "thread", "block", "rather", "than", "thread", "treat", "each", "thread", "block", "simd", "unit", "which", "each", "thread", "concern", "itself", "single", "dimension", "Runtime", "proportional", "total", "size", "grid", "blur", "stage", "must", "process", "every", "grid", "point", "so", "computational", "cost", "also", "prohibitive", "small", "filter", "size", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "now", "we", "can", "use", "three-dimensional", "color", "distance", "accelerate", "bilateral", "filter", "natural", "ask", "what", "other", "dimension", "we", "could", "add", "position", "vector", "patch", "large", "memory", "limit", "may", "difficult", "explicitly", "construct", "store", "all", "they", "can", "instead", "gather", "from", "input", "image", "need", "during", "splat", "slice" ],
  "content" : "We propose a method for accelerating a broad class of non-linear filters that includes the bilateral, non-local means, and other related filters. If the values are pixel colors and the positions are (x, y) coordinates, this describes a Gaussian blur. If we instead set the positions to local patches of color around the associated pixel, this describes non-local means. We describe a Monte-Carlo kdtree sampling algorithm that efficiently computes any filter that can be expressed in this way, along with a GPU implementation of this technique. Gaussian KD-Trees for Fast High-Dimensional Filtering. ACM Trans. 28, 3, Article 21 (August 2009), 12 pages. DOI = 10.1145/1531326.1531327 http://doi.acm.org/10.1145/1531326.1531327. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept. , ACM, Inc. , 2 Penn Plaza, Suite 701, New York, NY 10121-0701, fax +1 (212) 869-0481, or permissions@acm.org . ? 2009 ACM 0730-0301/2009/03-ART21 $10.00 DOI 10.1145/1531326.1531327 http://doi.acm.org/10.1145/1531326.1531327 We present a framework with which to understand such filters, and an acceleration data structure and algorithm that applies broadly across all of them. This growth is manageable if the filter size in both space and color is large, which in turn permits the grid to be coarse. Bilateral filtering can alternatively be rephrased as a nearest neighbour search in five dimensions. For every (x, y, r, g, b) point in the image, we would like to gather colors from other nearby points. Unfortunately this approach scales poorly with filter size. For a large filter each pixel may be near to every other pixel. To facilitate such queries, we propose a new type of kd-tree, which we term a Gaussian kd-tree, described in Section 2. Since the Gaussian kd-tree scales well with dimension, we need not constrain ourselves to three-dimensional color distances. With the ability to cheaply perform blurs weighted by higher dimensional distances, we can also accelerate non-local means [Buades et al. 2005]. We discuss non-local means in detail in Section 3.2. While non-local means increases the number of range dimensions, we can also increase the number of domain dimensions to include time. Non-local means is able to denoise dynamic scenes by averaging pixel values over time without requiring an explicit motion model. The values need not lie on a grid, and we can mix them according to distances between any set of associated vectors we like. We therefore need not restrict ourselves to images. Implementation details are in Section 2.4. This makes the usual division by the sum of the weights unnecessary. For example, when performing a Gaussian blur on an image, values are pixel colors, and have (x, y) coordinates associated with them (p i = (x i , y i ) T ). By extending p i and p j to include the color distance term, Equation 4 can be more generally expressed as: n We are free to scale the positions arbitrarily, so without loss of generality our Gaussian kernel always has standard deviation of one (? is absent in Equation 5). We can transform it to an arbitrary elliptical ball with a linear transform of the position vectors. Non-local means (described by [Buades et al. 2005]), which averages pixels with others that have a similar local neighborhood, can also be expressed as Equation 5 with p i equal to a neighborhood around pixel i. Given an arbitrary set of (v i , p i ) of size n, with p i of dimension d, and v i of lesser dimension, a naive computation of Equation 5 would take O(n 2 d) time, as every value interacts with every other value (for example when blurring an image with a filter as large as the image). We instead accelerate computation of Equation 5 in three ways. This suggests placing the points in a kd-tree (or a grid if d is small). Details of this are in Section 2.2. As long as our m points sample the space densely enough, this will be equivalent to a single Gaussian blur of size 2? s 2 + ? b 2 . If memory use is a concern, we can omit the blurring stage and achieve the same effective filter by increasing ? s . We are now faced with the task of building a Gaussian kd-tree containing a point cloud (the blue points in Figure 4 ) with adequate density around the regions where we intend to sample. For example when bilateral filtering, we will construct the tree using the (x, y, r, g, b) values of every pixel, and then scatter from and gather to those locations in five-dimensional space. Therefore, we can ensure adequate density by guarantee that every position p i is within ? s /2 of a point stored at a leaf node. The goal when building a kd-tree is usually to minimize the expected time taken by a query. If the bounding box has diagonal length less than ? s we create a leaf node, and an associated point at the center of the bounding box. Otherwise, we split halfway along the longest bounding box dimension, divide the input list into two, and continue recursively. Another common scheme for generating balanced trees is to split on the median value along the longest dimension. In our case, an uneven distribution of points, for example those produced from an image which is mostly a single color, can in fact cause this to produce an unbalanced tree. Figure 4 illustrates the process. If the number of samples is set to one, the list will contain a single leaf node, probabilistically chosen from all leaf nodes within three standard deviations of the query, such that repeatedly asking for a single sample and merging the resulting lists will produce the same result in the limit as asking for an infinite number of samples from a single query. We can think of our samples as a cloud of points normally distributed around the query with the given standard deviation, although we do not explicitly represent them as such. The final sample omitted by the rounding, if there is one, is probabilistically assigned to either the left or the right child. In the latter case, the thread continues working on the smaller of the two resulting tasks, and places the other back into the pending work structure. A single build job is an array of points and a pointer to a parent node to which the resulting subtree should be attached. We parallelize build jobs over thread blocks rather than threads, treating each thread block as a SIMD unit, in which each thread concerns itself with a single dimension. Runtime is proportional to the total size of the grid, as the blur stage must process every grid point, and so the computational cost is also prohibitive for small filter sizes ( Figure 5(a) ). Now that we can use three-dimensional color distances in an accelerated bilateral filter, it is natural to ask what other dimensions we could add to the position vectors. If the patches are large and memory is limited it may be difficult to explicitly construct and store all of them, and they can instead be gathered from the input image as needed during splatting and slicing.",
  "resources" : [ ]
}