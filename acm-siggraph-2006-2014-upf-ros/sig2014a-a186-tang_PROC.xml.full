{
  "uri" : "sig2014a-a186-tang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2014a/a186-tang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Fast and Exact Continuous Collision Detection with Bernstein Sign Classification",
    "published" : "2014",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Dinesh-Manocha",
      "name" : "Dinesh",
      "surname" : "Manocha"
    } ]
  },
  "bagOfWords" : [ "02d2b173b2e0a1067d3aa1672060f36663d5b0860e2087f8b5ee650e2813c7d7", "mjr", "10.1145", "2661229.2661237", "name", "identification", "possible", "fast", "exact", "continuous", "Collision", "detection", "Bernstein", "Sign", "classification", "Min", "Tang", "Ruofeng", "Tong", "Zhendong", "Wang", "Dinesh", "Manocha", "State", "Key", "Lab", "CAD&CG", "Zhejiang", "University", "University", "North", "Carolina", "chapel", "Hill", "http://gamma.cs.unc.edu/bsc/", "we", "present", "fast", "algorithm", "perform", "accurate", "CCD", "query", "between", "triangulated", "model", "we", "formulation", "use", "property", "Bernstein", "basis", "b?zier", "curve", "reduce", "problem", "evaluate", "sign", "polynomial", "we", "present", "geometrically", "exact", "CCD", "algorithm", "base", "exact", "geometric", "computation", "paradigm", "perform", "reliable", "boolean", "collision", "query", "we", "algorithm", "more", "than", "order", "magnitude", "faster", "than", "prior", "exact", "algorithm", "we", "evaluate", "its", "performance", "cloth", "fem", "simulation", "cpus", "gpus", "highlight", "benefit", "cr", "category", "i.", "3.5", "-lsb-", "Computer", "Graphics", "-rsb-", "computational", "geometry", "object", "modeling?physically", "base", "modeling", "keyword", "continuous", "collision", "detection", "Bernstein", "sign", "classification", "exact", "geometric", "computation", "physically", "base", "simulation", "Links", "dl", "pdf", "EB", "introduction", "problem", "fast", "reliable", "collision", "detection", "arise", "physically-based", "simulation", "geometric", "computing", "robotic", "many", "application", "require", "accurate", "algorithm", "do", "miss", "single", "collision", "maintain", "intersection-free", "mesh", "throughout", "simulation", "some", "widely-used", "algorithm", "contact", "computation", "base", "continuous", "collision", "detection", "-lrb-", "CCD", "-rrb-", "give", "two", "discrete", "instance", "configuration", "rigid", "deformable", "model", "CCD", "algorithm", "model", "motion", "each", "object", "mesh", "element", "use", "continuous", "trajectory", "between", "configuration", "check", "collision", "along", "trajectory", "algorithm", "widely", "use", "cloth", "simulation", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "Harmon", "et", "al.", "2008", "Brochu", "et", "al.", "2012", "-rsb-", "rigid-body", "simulation", "-lsb-", "Redon", "et", "al.", "2002", "-rsb-", "hair", "simulation", "-lsb-", "Selle", "et", "al.", "2008", "-rsb-", "FEM", "simulation", "-lsb-", "Tang", "et", "al.", "2011", "-rsb-", "robot", "motion", "planning", "-lsb-", "LaValle", "2006", "Tang", "et", "al.", "2010a", "-rsb-", "dynamic", "solver", "-lsb-", "Stam", "2009", "-rsb-", "etc.", "simplest", "algorithm", "triangular", "mesh", "linearly", "interpolate", "trajectory", "vertex", "case", "contact", "computation", "reduce", "perform", "series", "elementary", "test", "between", "vertex", "edge", "face", "use", "cubic", "polynomial", "root", "solver", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "-rsb-", "many", "high-level", "culling", "technique", "e-mail", "-lcb-", "tang", "trf", "westernseawolf", "-rcb-", "@zju", "edu.cn", "e-mail", "dm@cs.unc.edu", "ACM", "Reference", "Format", "Tang", "M.", "Tong", "R.", "Wang", "Z.", "Manocha", "D.", "2014", "fast", "exact", "continuous", "Collision", "detection", "Bernstein", "Sign", "classification", "ACM", "Trans", "graph", "33", "Article", "186", "-lrb-", "November", "2014", "-rrb-", "page", "dous", "10.1145", "2661229.2661237", "http://doi.acm.org/10.1145/2661229.2661237", "copyright", "Notice", "permission", "make", "digital", "hard", "copy", "all", "part", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "profit", "commercial", "advantage", "copy", "bear", "notice", "full", "citation", "fus", "rst", "page", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "require", "prior", "specific", "permission", "and/or", "fee", "request", "permission", "from", "permissions@acm.org", "copyright", "ACM", "0730-0301/14", "11-art186", "15.00", "DOI", "http://doi.acm.org/10.1145/2661229.2661237", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "benefit", "reliable", "CCD", "Queries", "we", "highlight", "benefit", "we", "exact", "CCD", "algorithm", "cloth", "simulation", "we", "algorithm", "can", "use", "generate", "plausible", "simulation", "-lrb-", "-rrb-", "parameter", "properly", "tune", "floating-point-based", "CCD", "algorithm", "-lrb-", "-rrb-", "can", "result", "penetration", "artifact", "have", "also", "be", "propose", "reduce", "number", "elementary", "test", "perform", "between", "mesh", "complex", "model", "elementary", "test", "typically", "implement", "use", "finiteprecision", "floating-point", "arithmetic", "use", "error", "tolerance", "numerical", "error", "arithmetic", "operation", "along", "tolerance", "can", "impact", "elementary", "test", "accuracy", "-lrb-", "fig.", "-rrb-", "two", "type", "problem", "false", "negative", "when", "CCD", "algorithm", "may", "miss", "collision", "false", "positive", "when", "CCD", "algorithm", "act", "conservatively", "flag", "non-colliding", "configuration", "collision", "order", "overcome", "problem", "Brochu", "et", "al.", "-lsb-", "2012", "-rsb-", "propose", "algorithm", "exact", "CCD", "computation", "can", "perform", "reliable", "collision", "query", "however", "approach", "can", "relatively", "expensive", "due", "use", "large", "number", "exact", "arithmetic", "operation", "moreover", "its", "portability", "may", "limit", "efficient", "implementation", "exact", "computation", "library", "easily", "available", "all", "processor", "-lrb-", "e.g.", "gpus", "-rrb-", "Main", "result", "we", "present", "fast", "accurate", "algorithm", "perform", "reliable", "CCD", "query", "we", "approach", "base", "use", "coplanarity", "inside", "test", "reduce", "computation", "find", "root", "algebraic", "equation", "inequality", "-lrb-", "i.e.", "semi-algebraic", "set", "-rrb-", "we", "represent", "function", "use", "Bernstein", "basis", "exploit", "geometric", "property", "B?zier", "curve", "design", "efficient", "reliable", "Bernstein", "sign", "classification", "-lrb-", "bsc", "-rrb-", "approach", "CCD", "overall", "collision", "query", "reduce", "perform", "series", "sign", "evaluation", "algebraic", "expression", "involve", "simple", "arithmetic", "operation", "we", "also", "present", "conservative", "elementary", "culling", "algorithm", "improve", "algorithm?s", "performance", "we", "use", "BSC", "design", "two", "algorithm", "BSC-exact", "exact", "algorithm", "perform", "CCD", "query", "base", "exact", "geometric", "computation", "paradigm", "-lsb-", "yap", "2004", "-rsb-", "susceptible", "false", "positive", "false", "negative", "we", "use", "extended", "precision", "arithmetic", "operation", "accelerate", "performance", "use", "floating-point", "filter", "compare", "prior", "exact", "CCD", "algorithm", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "we", "observe", "10", "25x", "speedup", "single", "CPU", "core", "BSC-float", "finite-precision", "variant", "implement", "use", "floating-point", "arithmetic", "operation", "we", "have", "evaluate", "its", "performance", "cpus", "gpus", "observe", "considerable", "speedup", "over", "prior", "floating-point", "CCD", "algorithm", "furthermore", "we", "observe", "significant", "improvement", "accuracy", "i.e.", "significant", "reduction", "number", "false", "positive", "false", "negative", "use", "we", "algorithm", "overall", "algorithm", "simple", "implement", "use", "only", "addition", "subtraction", "multiplication", "operation", "use", "Bernstein", "basis", "simple", "arithmetic", "operation", "result", "reduced", "error", "improve", "efficiency", "we", "highlight", "benefit", "algorithm", "use", "cloth", "fem", "simulation", "benchmark", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "186:2", "M.", "Tang", "et", "al.", "related", "work", "section", "we", "give", "brief", "overview", "prior", "work", "CCD", "algorithm", "high-level", "collision", "culling", "computation", "root", "polynomial", "many", "technique", "have", "be", "propose", "CCD", "between", "rigid", "model", "-lsb-", "Redon", "et", "al.", "2002", "Kim", "Rossignac", "2003", "-rsb-", "articulate", "model", "-lsb-", "Zhang", "et", "al.", "2007", "-rsb-", "deformable", "model", "-lsb-", "volino", "Thalmann", "1994", "Govindaraju", "et", "al.", "2005", "Hutter", "Fuhrmann", "2007", "Tang", "et", "al.", "2011", "-rsb-", "lowest", "level", "algorithm", "perform", "elementary", "test", "between", "triangle", "pair", "elementary", "test", "typically", "perform", "compute", "root", "cubic", "polynomial", "other", "CCD", "algorithm", "base", "conservative", "local", "advancement", "-lsb-", "Tang", "et", "al.", "2009b", "-rsb-", "all", "method", "prone", "floating-point", "error", "numerical", "tolerance", "therefore", "can", "result", "false", "negative", "false", "positive", "Wang", "-lsb-", "2014", "-rsb-", "have", "perform", "forward", "error", "analysis", "elementary", "test", "use", "analysis", "derive", "tight", "error", "bound", "floating-point", "computation", "use", "reduce", "number", "false", "positive", "contrast", "we", "bsc-exact", "algorithm", "approach", "describe", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "reliable", "tight", "error", "bound", "-lsb-", "Wang", "2014", "-rsb-", "can", "use", "derive", "tighter", "error", "bound", "bsc-float", "high-level", "Culling", "many", "high-level", "technique", "have", "be", "propose", "accelerate", "CCD", "computation", "reduce", "number", "elementary", "test", "between", "triangle", "pair", "remove", "redundant", "elementary", "test", "-lsb-", "Curtis", "et", "al.", "2008", "Tang", "et", "al.", "2009a", "Wong", "Baciu", "2006", "-rsb-", "simplest", "culling", "algorithm", "use", "bvh", "-lrb-", "bound", "volume", "hierarchy", "-rrb-", "base", "k-dop", "aabb", "other", "method", "use", "bound", "surface", "normal", "curvature", "-lsb-", "volino", "Thalmann", "1994", "Provot", "1997", "Mezger", "et", "al.", "2003", "-rsb-", "perform", "selfcollision", "culling", "-lsb-", "Schvartzman", "et", "al.", "2010", "Pabst", "et", "al.", "2010", "Zheng", "James", "2012", "-rsb-", "many", "algorithm", "implement", "use", "floating-point", "arithmetic", "operation", "prone", "numerical", "error", "polynomial", "root", "evaluation", "many", "numerical", "iterative", "method", "have", "be", "propose", "compute", "root", "polynomial", "equation", "tend", "use", "tolerance", "can", "result", "false", "positive", "false", "negative", "CCD", "computation", "computer", "graphic", "geometric", "modeling", "polynomial", "represent", "use", "spline", "basis", "root", "can", "compute", "use", "geometric", "subdivision", "method", "de", "casteljau?s", "algorithm", "-lsb-", "Farin", "2002", "-rsb-", "b?zier", "clipping", "-lsb-", "Sederberg", "Nishita", "1990", "-rsb-", "subdivision", "method", "implement", "use", "finite-precision", "arithmetic", "also", "prone", "roundoff", "error", "extensive", "literature", "symbolic", "computation", "computational", "geometry", "reliably", "compute", "root", "polynomial", "use", "exact", "arithmetic", "-lsb-", "yap", "2004", "Mourrain", "et", "al.", "2005", "-rsb-", "CCD", "Algebraic", "Formulation", "section", "we", "formulate", "CCD", "query", "term", "algebraic", "equation", "inequality", "we", "assume", "vertex", "mesh", "move", "constant", "velocity", "during", "time", "interval", "CCD", "query", "reduce", "perform", "two", "type", "Boolean", "query", "elementary", "test", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "Brochu", "et", "al.", "2012", "-rsb-", "include", "VF", "query", "which", "check", "whether", "move", "vertex", "intersect", "move", "triangle", "ee", "query", "which", "check", "whether", "move", "edge", "intersect", "another", "move", "edge", "all", "query", "assume", "time", "interval", "-lsb-", "-rsb-", "initial", "configuration", "intersection-free", "Boolean", "query", "return", "positive", "answer", "we", "can", "use", "technique", "base", "interval", "arithmetic", "compute", "intersection", "point", "first", "time", "contact", "desire", "precision", "many", "application", "only", "parity", "number", "collision", "need", "robust", "simulation", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "result", "we", "focus", "reliably", "compute", "yes/no", "answer", "Boolean", "query", "exact", "root", "first", "time", "contact", "can", "compute", "use", "root", "isolation", "interval", "arithmetic", "technique", "we", "first", "introduce", "notation", "use", "rest", "paper", "next", "we", "present", "some", "property", "Bernstein", "basis", "function", "b?zier", "curve", "use", "we", "CCD", "algorithm", "3.1", "notation", "we", "use", "follow", "notation", "rest", "paper", "Lower", "case", "letter", "normal", "font", "-lrb-", "e.g.", "-rrb-", "represent", "scalar", "variable", "Upper", "case", "letter", "-lrb-", "e.g.", "-lrb-", "-rrb-", "-rrb-", "-rrb-", "represent", "scalar", "function", "lower", "case", "letter", "bold", "face", "font", "-lrb-", "e.g.", "-rrb-", "represent", "vector", "quantity", "Upper", "case", "letter", "bold", "face", "font", "-lrb-", "e.g.", "-lrb-", "-rrb-", "-rrb-", "represent", "vector-valued", "function", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "1st", "2nd", "order", "derivative", "scalar", "function", "-lrb-", "-rrb-", "respectively", "operator", "???", "???", "???", "denote", "usual", "scalar", "multiplication", "dot", "product", "cross", "product", "respectively", "operator", "sign", "-lrb-", "-rrb-", "return", "sign", "scalar", "variable", "all", "proof", "lemma", "theorem", "corollary", "supplementary", "material", "3.2", "ezier", "curve", "Bernstein", "Basis", "we", "use", "symbol", "-lrb-", "-rrb-", "represent", "th", "basis", "function", "Bernstein", "polynomial", "degree", "i.e.", "-lrb-", "-rrb-", "-lrb-", "n?i", "-rrb-", "-lrb-", "-rrb-", "n?i", "where", "-lsb-", "-rsb-", "Bernstein", "polynomial", "basis", "widely", "use", "geometric", "modeling", "curve", "surface", "representation", "well", "numerical", "analysis", "computer", "algebra", "root", "computation", "-lsb-", "Mourrain", "et", "al.", "2005", "-rsb-", "well-known", "polynomial", "express", "Bernstein", "basis", "have", "better", "numerical", "stability", "under", "perturbation", "coefficient", "than", "do", "those", "power", "basis", "-lsb-", "Farouki", "Rajan", "1987", "-rsb-", "result", "we", "represent", "semi-algebraic", "set", "use", "CCD", "query", "Bernstein", "basis", "give", "cubic", "polynomial", "-lrb-", "-rrb-", "can", "express", "use", "Bernstein", "basis", "i.e.", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "correspond", "cubic", "b?zier", "curve", "-lrb-", "-rrb-", "plane", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "1/3", "-lrb-", "-rrb-", "2/3", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "exploit", "some", "geometric", "property", "cubic", "b?zier", "curve", "order", "characterize", "inflection", "point", "extreme", "point", "inflection", "point", "occur", "where", "curvature", "vanish", "change", "its", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "fast", "exact", "continuous", "Collision", "detection", "186:3", "-lrb-", "-rrb-", "0 1/3", "2/3", "1.0", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ye", "-lrb-", "-rrb-", "have", "inflection", "point", "ye", "0 1/3", "2/3", "1.0", "-lrb-", "-rrb-", "extreme", "have", "-lrb-", "-rrb-", "point", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "0 1/3", "2/3", "1.0", "-lrb-", "-rrb-", "figure", "B?zier", "Classifications", "we", "classify", "cubic", "b?zier", "curve", "three", "category", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "depend", "whether", "have", "inflection", "point", "extreme", "point", "bend", "direction", "extreme", "point", "correspond", "local", "minimum", "maximum", "every", "cubic", "b?zier", "curve", "can", "classify", "three", "category", "-lrb-", "show", "fig.", "-rrb-", "depend", "whether", "have", "any", "inflection", "point", "extreme", "point", "over", "its", "domain", "-lrb-", "-lsb-", "-rsb-", "-rrb-", "-lsb-", "Farin", "2002", "-rsb-", "case", "-lrb-", "-rrb-", "curve", "have", "inflection", "point", "case", "-lrb-", "-rrb-", "curve", "have", "inflection", "point", "extreme", "point", "case", "-lrb-", "-rrb-", "curve", "have", "neither", "inflection", "point", "nor", "extreme", "point", "existence", "inflection", "point", "extreme", "point", "can", "check", "base", "lemma", "supplementary", "material", "cubic", "Bernstein", "polynomial", "can", "decompose", "lowerdegree", "polynomial", "base", "follow", "theorem", "Polynomial", "Decomposition", "Theorem", "let", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "cubic", "polynomial", "quadratic", "polynomial", "respectively", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "can", "decompose", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "two", "linear", "polynomial", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lsb-", "0,1", "-rsb-", "-lsb-", "0,1", "-rsb-", "can", "calculate", "from", "-lsb-", "...", "-rsb-", "-lsb-", "...", "-rsb-", "3.3", "CCD", "Queries", "CCD", "test", "between", "triangle", "pair", "reduce", "perform", "VF", "query", "ee", "query", "each", "query", "can", "further", "decompose", "two", "part", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "-rsb-", "coplanarity", "test", "VF", "EE", "query", "involve", "use", "four", "deform", "vertex", "order", "collision", "occur", "necessary", "those", "four", "vertex", "coplanar", "inside", "test", "addition", "satisfy", "coplanarity", "condition", "we", "need", "check", "whether", "move", "vertex", "inside", "triangle", "-lrb-", "VF", "-rrb-", "two", "edge", "intersect", "each", "other", "interior", "point", "-lrb-", "ee", "-rrb-", "coplanarity", "test", "VF", "pair", "can", "express", "-lrb-", "-rrb-", "where", "correspond", "move", "vertex", "vertex", "deform", "triangle", "normal", "vector", "triangle", "-lrb-", "i.e.", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "order", "perform", "inside", "test", "VF", "pair", "we", "need", "perform", "three", "one-sided", "test", "i.e.", "need", "inside", "triangle", "can", "express", "base", "follow", "inequality", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "coplanarity", "inside", "test", "can", "combine", "find", "common", "root", "follow", "system", "algebraic", "equation", "inequality", "-lrb-", "i.e.", "semi-algebraic", "set", "-rrb-", "VF", "query", "reduce", "check", "whether", "semi-algebraic", "set", "have", "real", "solution", "-lsb-", "-rsb-", "10", "-lrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-rrb-", "-rrb-", "3.4", "coplanarity", "test", "use", "Bernstein", "Polynomials", "order", "check", "coplanarity", "vertex", "triangle", "-lrb-", "define", "-rrb-", "we", "need", "calculate", "project", "distance", "between", "they", "along", "direction", "distance", "become", "zero", "any", "time", "interval", "four", "vertex", "classify", "coplanar", "base", "follow", "theorem", "coplanarity", "test", "Theorem", "VF", "Pair", "deform", "triangle", "whose", "initial", "final", "position", "give", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "vertex", "initial", "final", "position", "coplanarity", "test", "can", "formulate", "term", "following", "equation", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "11", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lsb-", ".3", "-rsb-", "scalar", "can", "calculate", "from", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "coplanarity", "test", "reduce", "check", "whether", "2d", "cubic", "b?zier", "curve", "-lrb-", "-rrb-", "-lrb-", "equation", "-lrb-", "-rrb-", "-rrb-", "define", "-lrb-", "-rrb-", "plane", "intersect", "x-axis", "we", "can", "also", "formulate", "inside", "test", "use", "Bernstein", "polynomial", "inside", "test", "Theorem", "VF", "Pair", "give", "triangle", "vertex", "define", "end", "position", "over", "interval", "-lsb-", "-rsb-", "inside", "test", "can", "formulate", "term", "follow", "inequality", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "3.5", "inside", "test", "use", "Bernstein", "Polynomials", "12", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lsb-", ".4", "-rsb-", "scalar", "can", "calculate", "from", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "186:4", "M.", "Tang", "et", "al.", "simplify", "inside", "test", "Theorem", "VF", "pair", "base", "combine", "Inequality", "-lrb-", "12", "-rrb-", "equation", "-lrb-", "11", "-rrb-", "algebraic", "elimination", "inside", "test", "can", "reduce", "follow", "degree-two", "formulation", "13", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lsb-", "...", "-rsb-", "scalar", "which", "can", "calculate", "base", "-lsb-", "...", "-rsb-", "-lsb-", "...", "-rsb-", "show", "supplementary", "material", "3.6", "CCD", "test", "use", "Bernstein", "Polynomials", "formulation", "coplanarity", "inside", "test", "can", "combine", "follow", "system", "equation", "inequality", "term", "Bernstein", "polynomial", "where", "-lsb-", "...", "-rsb-", "-lsb-", "...", "-rsb-", "scalar", "define", "above", "-lsb-", "...", "-rsb-", "-lsb-", "...", "-rsb-", "coefficient", "correspond", "other", "inside", "test", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "CCD", "Query", "use", "sign", "evaluation", "section", "we", "use", "formulation", "CCD", "computation", "term", "Bernstein", "polynomial", "present", "accurate", "algorithm", "perform", "CCD", "query", "we", "formulation", "consist", "two", "stage", "geometric", "coplanarity", "test", "deduce", "sign", "polynomial", "its", "extreme", "point", "compare", "sign", "its", "end", "point", "interval", "-lsb-", "-rsb-", "we", "can", "check", "existence", "root", "coplanarity", "equation", "geometric", "inside", "test", "during", "stage", "we", "evaluate", "sign", "inequality", "root", "have", "pass", "coplanarity", "test", "check", "whether", "root", "also", "satisfy", "inside", "test", "we", "goal", "compute", "root", "cubic", "polynomial", "-lrb-", "-rrb-", "-lrb-", "define", "equation", "-lrb-", "11", "-rrb-", "domain", "-lsb-", "-rsb-", "-rrb-", "we", "use", "characterization", "B?zier", "curve", "three", "different", "case", "present", "section", "3.2", "case", "-lrb-", "-rrb-", "section", "3.2", "we", "subdivide", "curve", "its", "inflection", "point", "i.e.", "use", "de", "Casteljau?s", "+3", "algorithm", "two", "subdivide", "curve", "either", "correspond", "case", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "section", "3.2", "we", "discuss", "both", "case", "case", "-lrb-", "-rrb-", "have", "different", "sign", "only", "one", "root", "domain", "otherwise", "we", "use", "follow", "RootFinding", "Lemma", "determine", "whether", "zero", "root", "two", "root", "domain", "case", "-lrb-", "-rrb-", "have", "same", "sign", "root", "otherwise", "one", "root", "its", "domain", "Root-Finding", "Lemma", "cubic", "polynomial", "-lrb-", "-rrb-", "-lrb-", "define", "equation", "-lrb-", "11", "-rrb-", "-rrb-", "extreme", "point", "its", "domain", "its", "1st", "derivative", "-lrb-", "-rrb-", "4.1", "geometric", "coplanarity", "test", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "have", "root", "-lsb-", "-rsb-", "yes", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "have", "root", "-lrb-", "-rrb-", "have", "root", "else", "else", "-lrb-", "-rrb-", "have", "root", "-lrb-", "-rrb-", "have", "root", "else", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "have", "root", "else", "-lrb-", "-rrb-", "have", "root", "Figure", "Computing", "Number", "root", "-lrb-", "-rrb-", "we", "can", "compute", "they", "base", "sign", "evaluation", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "evaluate", "sign", "-lrb-", "-rrb-", "base", "Sign", "Determination", "Theorem", "Sign", "Determination", "Theorem", "II", "we", "can", "evaluate", "sign", "-lrb-", "-rrb-", "we", "decompose", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "two", "linear", "polynomial", "can", "calculate", "Polynomial", "Decomposition", "Theorem", "Section", "3.2", "we", "use", "classification", "Fig.", "compute", "number", "root", "-lrb-", "-rrb-", "base", "formulation", "we", "can", "compute", "number", "root", "case", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "consequently", "case", "-lrb-", "-rrb-", "order", "perform", "specific", "inside", "test", "along", "coplanarity", "test", "we", "need", "test", "follow", "system", "4.2", "geometric", "inside", "test", "14", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "here", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "define", "equation", "-lrb-", "11", "-rrb-", "equation", "-lrb-", "13", "-rrb-", "respectively", "we", "compute", "similar", "system", "other", "two", "inside", "test", "base", "Polynomial", "Decomposition", "Theorem", "Section", "3.2", "we", "can", "express", "15", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "where", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "linear", "polynomial", "let", "root", "-lrb-", "-rrb-", "domain", "-lsb-", "-rsb-", "i.e.", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "from", "equation", "-lrb-", "15", "-rrb-", "we", "obtain", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "therefore", "problem", "compute", "sign", "-lrb-", "-rrb-", "reduce", "compute", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "use", "follow", "theorem", "compute", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "fast", "exact", "continuous", "Collision", "detection", "186:5", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "else", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "else", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "else", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "sign", "-lrb-", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "figure", "rule", "evaluate", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "use", "rule", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "Sign", "Determination", "Theorem", "Sign", "Determination", "Theorem", "II", "respectively", "sign", "Determination", "Theorem", "let", "-lrb-", "-rrb-", "linear", "polynomial", "-lrb-", "-rrb-", "cubic", "polynomial", "which", "correspond", "B?zier", "curve", "case", "-lrb-", "-rrb-", "domain", "-lsb-", "-rsb-", "-lrb-", "fig.", "-lrb-", "-rrb-", "-rrb-", "let", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "we", "can", "use", "rule", "Fig.", "-lrb-", "-rrb-", "evaluate", "sign", "-lrb-", "-rrb-", "-rrb-", "sign", "Determination", "Theorem", "II", "let", "-lrb-", "-rrb-", "linear", "polynomial", "-lrb-", "-rrb-", "cubic", "polynomial", "correspond", "B?zier", "curve", "case", "-lrb-", "-rrb-", "domain", "-lsb-", "-rsb-", "-lrb-", "fig.", "-lrb-", "-rrb-", "fig.", "-lrb-", "-rrb-", "-rrb-", "let", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "1st", "order", "derivative", "-lrb-", "-rrb-", "we", "can", "use", "rule", "Fig.", "-lrb-", "-rrb-", "determine", "sign", "-lrb-", "-rrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "base", "Sign", "Determination", "Theorem", "Sign", "Determination", "Theorem", "II", "we", "can", "determine", "sign", "-lrb-", "-rrb-", "sign", "-lrb-", "-rrb-", "algorithm", "use", "compute", "sign", "-lrb-", "-rrb-", "can", "directly", "use", "compute", "sign", "-lrb-", "-rrb-", "base", "sign", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "can", "compute", "sign", "-lrb-", "-rrb-", "consequently", "check", "whether", "equality", "inequality", "equation", "-lrb-", "14", "-rrb-", "satisfied", "repeat", "other", "two", "inequality", "well", "all", "they", "satisfied", "answer", "CCD", "query", "positive", "4.3", "conservative", "Culling", "Test", "many", "time", "collision", "we", "use", "simple", "culling", "scheme", "accelerate", "algorithm", "similar", "use", "non-penetration", "filter", "-lsb-", "Tang", "et", "al.", "2010b", "-rsb-", "plane-culling", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "we", "goal", "eliminate", "many", "VF", "pair", "do", "satisfy", "coplanarity", "condition", "-lrb-", "see", "equation", "-lrb-", "11", "-rrb-", "-rrb-", "one", "sufficient", "condition", "when", "all", "coefficient", "-lsb-", "...", "-rsb-", "either", "greater", "than", "zero", "less", "than", "zero", "instead", "compute", "-lsb-", "...", "-rsb-", "exactly", "we", "use", "floating-point", "filter", "-lsb-", "Burnikel", "et", "al.", "2001", "-rsb-", "perform", "conservative", "culling", "other", "word", "we", "compute", "-lsb-", "...", "-rsb-", "use", "floatingpoint", "arithmetic", "instead", "compare", "they", "zero", "we", "check", "whether", "all", "greater", "than", "all", "less", "than", "where", "conservative", "error", "bind", "detailed", "method", "computing", "supplementary", "material", "algorithm", "vf-test", "CCD", "test", "VF", "pair", "input", "position", "deform", "triangle", "-lrb-", "-rrb-", "move", "vertex", "-lrb-", "-rrb-", "output", "true", "false", "have", "collision", "collision", "-lsb-", "-rsb-", "getcoefficient", "-lrb-", "-rrb-", "get", "coefficient", "-lrb-", "-rrb-", "-rrb-", "Perform", "conservative", "culling", "test", "ConservativeFilter", "-lrb-", "-rrb-", "return", "false", "end", "ctype", "beziertype", "-lrb-", "-rrb-", "get", "type", "B?zier", "curve", "case", "-lrb-", "-rrb-", "subdivide", "check", "interval", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "here", "correspond", "inflection", "point", "ctype", "case", "10", "subdivide", "two", "interval", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "11", "return", "vf-test", "-lrb-", "-lsb-", "-rsb-", "-rrb-", "vf-test", "-lrb-", "-lsb-", "-rsb-", "-rrb-", "12", "end", "13", "case", "-lrb-", "-rrb-", "case", "-lrb-", "-rrb-", "continue", "check", "14", "perform", "coplanarity", "test", "-lrb-", "section", "4.1", "-rrb-", "15", "coplanaritytest", "-lrb-", "-rrb-", "16", "return", "false", "17", "end", "18", "perform", "inside", "test", "-lrb-", "section", "4.2", "-rrb-", "19", "InsideTest", "-lrb-", "-rrb-", "20", "return", "false", "21", "end", "22", "return", "true", "valid", "collision", "have", "be", "detect", "4.4", "overall", "VF", "Query", "Algorithm", "we", "overall", "algorithm", "VF", "query", "describe", "algorithm", "we", "first", "compute", "coefficient", "-lrb-", "-rrb-", "i.e.", "-lsb-", "...", "-rsb-", "-lrb-", "line", "-rrb-", "perform", "conservative", "culling", "test", "-lrb-", "line", "-rrb-", "cull", "test", "fail", "we", "classify", "type", "B?zier", "curve", "-lrb-", "line", "-rrb-", "case", "-lrb-", "-rrb-", "we", "subdivide", "interval", "-lsb-", "-rsb-", "two", "sub-interval", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "recursively", "perform", "CCD", "test", "sub-interval", "-lrb-", "line", "12", "-rrb-", "case", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "we", "perform", "coplanarity", "test", "-lrb-", "line", "15", "17", "-rrb-", "inside", "test", "-lrb-", "line", "19", "21", "-rrb-", "all", "test", "positive", "response", "VF", "collision", "query", "positive", "-lrb-", "line", "22", "-rrb-", "we", "use", "similar", "algorithm", "ee", "test", "detail", "its", "derivation", "give", "supplementary", "material", "main", "difference", "respect", "VF", "test", "term", "inequality", "use", "inside", "test", "BSC-exact", "exact", "VF", "Computation", "order", "perform", "reliable", "collision", "query", "we", "use", "well-known", "paradigm", "exact", "geometric", "computation", "-lsb-", "yap", "2004", "-rsb-", "which", "widely", "use", "geometric", "computation", "have", "also", "be", "use", "perform", "exact", "boolean", "answer", "CCD", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "underlie", "philosophy", "we", "compute", "correct", "answer", "boolean", "query", "assume", "we", "use", "exact", "arithmetic", "error", "due", "use", "fix", "precision", "floating-point", "arithmetic", "user", "specify", "tolerance", "we", "exact", "algorithm", "bsc-exact", "use", "combination", "extended", "precision", "arithmetic", "operation", "float", "point", "filter", "we", "conservative-culling", "test", "only", "use", "floating", "point", "filter", "do", "perform", "exact", "arithmetic", "operation", "rest", "computation", "include", "many", "expression", "evaluate", "sign", "polynomial", "all", "computation", "can", "accelerate", "use", "float", "point", "filter", "BSC-float", "floating-point", "Algorithm", "some", "case", "optimize", "library", "extended", "precision-arithmetic", "operation", "available", "certain", "processor", "-lrb-", "e.g.", "gpus", "-rrb-", "case", "all", "step", "algorithm", "implement", "use", "floating-point", "arithmetic", "prone", "numerical", "error", "we", "result", "algorithm", "bsc-float", "base", "IEEE", "floating-point", "standard", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "186:6", "M.", "Tang", "et", "al.", "Figure", "benchmark", "we", "use", "five", "different", "benchmark", "arise", "from", "cloth", "fem", "simulation", "implementation", "Performance", "section", "we", "describe", "we", "implementation", "highlight", "performance", "we", "algorithm", "several", "benchmark", "5.1", "implementation", "we", "have", "implement", "we", "algorithm", "standard", "pc", "-lrb-", "Intel", "i73770K", "CPU", "3.5", "GHz", "4GB", "RAM", "64-bits", "window", "os", "NVIDIA", "Tesla", "K40c", "GPU", "-rrb-", "include", "cpu-based", "C++", "implementation", "bsc-exact", "use", "single", "core", "use", "exact", "computation", "library", "base", "interval", "arithmetic", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "we", "have", "also", "implement", "bsc-float", "CPU", "-lrb-", "C++", "-rrb-", "GPU", "-lrb-", "use", "CUDA", "5.5", "-rrb-", "use", "hardware-supported", "floating-point", "operation", "we", "compare", "performance", "we", "algorithm", "follow", "algorithm", "El-Topo-exact", "implementation", "exact", "algorithm", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "make", "available", "author", "also", "use", "plane-based", "culling", "accelerate", "computation", "along", "interval", "arithmetic-based", "filter", "exact", "expansion", "exact", "arithmetic", "operation", "order", "compare", "performance", "bsc-exact", "we", "use", "same", "implementation", "exact", "arithmetic", "operation", "El-Topo-float", "floating-point-based", "cubic", "root", "solver", "CCD", "implementation", "available", "part", "El-Topo", "surfacetrack", "library", "-lsb-", "Brochu", "Bridson", "2009", "-rsb-", "we", "measure", "its", "performance", "use", "single", "thread", "CPU", "bsc-float-gpu", "el-topo-float-gpu", "we", "also", "port", "bsc-float", "el-topo-float", "algorithm", "gpus", "test", "performance", "multiple", "thread", "refer", "bscfloat-gpu", "el-topo-float-gpu", "respectively", "5.3", "relative", "Performance", "CPU", "El-Topo-exact", "implementation", "exact", "algorithm", "-lsb-", "Brochu", "et", "al.", "2012", "-rsb-", "make", "available", "author", "also", "use", "plane-based", "culling", "accelerate", "computation", "along", "interval", "arithmetic-based", "filter", "exact", "expansion", "exact", "arithmetic", "operation", "order", "compare", "performance", "bsc-exact", "we", "use", "same", "implementation", "exact", "arithmetic", "operation", "El-Topo-float", "floating-point-based", "cubic", "root", "solver", "CCD", "implementation", "available", "part", "El-Topo", "surfacetrack", "library", "-lsb-", "Brochu", "Bridson", "2009", "-rsb-", "we", "measure", "its", "performance", "use", "single", "thread", "CPU", "bsc-float-gpu", "el-topo-float-gpu", "we", "also", "port", "bsc-float", "el-topo-float", "algorithm", "gpus", "test", "performance", "multiple", "thread", "refer", "bsc5", ".4", "relative", "Performance", "GPU", "float-gpu", "el-topo-float-gpu", "respectively", "5.2", "Benchmarks", "order", "test", "performance", "we", "algorithm", "we", "use", "five", "different", "benchmark", "arise", "from", "different", "simulation", "scenario", "use", "CCD", "query", "dancer", "dancer", "wear", "simple", "skirt", "5k", "10k", "triangle", "number", "triangle", "change", "during", "simulation", "due", "adaptive", "computation", "benchmark", "have", "high", "number", "self-collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "twist", "cloth", "2k", "50k", "triangle", "twist", "severely", "underlie", "ball", "rotate", "benchmark", "have", "high", "number", "self-collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "Flamenco", "fiery", "Flamenco", "dancer", "wear", "colorful", "skirt", "ruffle", "benchmark", "-lrb-", "49k", "triangle", "-rrb-", "have", "many", "interand", "intra-object", "collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "funnel", "cloth", "2k", "42k", "triangle", "fall", "funnel", "fold", "fit", "funnel", "many", "self-collision", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "crash", "Ford", "Explorer", "1.1", "triangle", "crash", "against", "rigid", "wall", "deformation", "simulated", "use", "finite-element", "meshing", "-lrb-", "figure", "-lrb-", "-rrb-", "-rrb-", "first", "three", "benchmark", "-lrb-", "dancer", "twist", "funnel", "-rrb-", "generate", "integrate", "we", "CCD", "algorithm", "cloth", "simulation", "system", "ArcSim", "-lsb-", "Narain", "et", "al.", "2012", "-rsb-", "input", "Flamenco", "crash", "benchmark", "give", "discrete", "keyframe", "we", "use", "linear", "interpolation", "between", "key-frame", "check", "interobject", "self-collision", "we", "also", "use", "bvh-based", "hierarchical", "culling", "-lrb-", "use", "aabb", "-rrb-", "reduce", "number", "elementary", "test", "worst-case", "Query", "Performance", "collision", "we", "culling", "algorithm", "able", "discard", "many", "those", "instance", "query", "time", "higher", "when", "actual", "contact", "worstcase", "query", "time", "we", "algorithm", "vs.", "prior", "algorithm", "BSC-exact", "worst-case", "time", "ee", "VF", "query", "about", "876", "n", "contrast", "worst-case", "query", "time", "ElTopo-exact", "15", "m", "11", "ee", "ve", "query", "respectively", "BSC-float", "worst-case", "time", "ee", "VF", "query", "about", "105", "n", "contrast", "worst-case", "query", "time", "El-Topo-float", "about", "953", "n", "both", "query", "CPU", "core", "moreover", "we", "observe", "fewer", "incorrect", "query", "result", "use", "bsc-float", "Figure", "highlight", "performance", "we", "algorithm", "bsc-exact", "bsc-float", "compare", "they", "two", "prior", "CCD", "algorithm", "el-topo-exact", "el-topo-float", "single", "CPU", "core", "all", "benchmark", "performance", "bsc-exact", "about", "10", "25x", "faster", "than", "El-Topo-exact", "offer", "similar", "reliability", "furthermore", "we", "observe", "up", "order", "magnitude", "speedup", "float", "point", "implementation", "we", "approach", "bsc-float", "involve", "fewer", "arithmetic", "operation", "compare", "El-Topo-float", "combination", "fewer", "operation", "improve", "numerical", "stability", "property", "Bernstein", "polynomial", "also", "improve", "accuracy", "bscfloat", "i.e.", "fewer", "incorrect", "result", "collision", "query", "term", "false-negative", "false-positive", "we", "have", "also", "evaluate", "performance", "NVIDIA", "Tesla", "K40c", "GPU", "we", "aware", "any", "widely", "optimize", "extended", "precision", "library", "gpus", "so", "we", "only", "evaluate", "relative", "performance", "bsc-float-gpu", "el-topo-float-gpu", "various", "benchmark", "we", "compare", "accuracy", "query", "result", "those", "compute", "exact", "cpu-based", "implementation", "case", "bsc-float-gpu", "result", "much", "fewer", "inaccurate", "collision", "query", "compare", "ElTopo-float-GPU", "internal", "register", "use", "gpus", "may", "have", "different", "precision", "from", "cpus", "so", "we", "may", "observe", "considerable", "difference", "accuracy", "result", "bsc-float-gpu", "el-topo-floatgpu", "compare", "CPU", "counterpart", "example", "many", "Intel", "processor", "use", "80-bit", "internal", "register", "floating-point", "operation", "may", "result", "higher", "accuracy", "cpu-based", "implementation", "we", "have", "also", "integrate", "bsc-float", "el-topo-float", "gpu-based", "cloth", "simulation", "system", "-lsb-", "Tang", "et", "al.", "2013", "-rsb-", "compare", "runtime", "query", "performance", "both", "CCD", "algorithm", "within", "system", "Figure", "highlight", "performance", "bscfloat-gpu", "el-topo-float-gpu", "due", "parallelism", "relative", "performance", "improvement", "bsc-float-gpu", "over", "El-Topo-floatGPU", "less", "than", "those", "cpus", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "fast", "exact", "continuous", "Collision", "detection", "186:7", "bscel-topobscexact", "exact", "float", "Bench", "Avg", "avg", "avg", "mark", "test", "Query", "Query", "Query", "Inaccurate", "Time", "Time", "Time", "Queries", "dancer", "405m", "9n", "274n", "4.4", "n", "twist", "70.3", "12n", "252n", "5.6", "n", "funnel", "58.5", "21n", "293n", "8.8", "n", "Flamenco", "4.2", "20n", "261n", "8.2", "n", "crash", "31.6", "16n", "259n", "7.5", "n", "figure", "Performance", "comparison", "we", "highlight", "performance", "various", "CPU", "gpu-based", "algorithm", "different", "benchmark", "we", "observe", "significant", "speedup", "use", "we", "algorithm", "base", "BSC", "vs.", "prior", "algorithm", "implement", "part", "El", "Topo", "-lsb-", "Provot", "1997", "Bridson", "et", "al.", "2002", "Brochu", "Bridson", "2009", "Brochu", "et", "al.", "2012", "-rsb-", "even", "though", "bsc-float", "guarantee", "reliable", "we", "observe", "very", "high", "accuracy", "we", "benchmark", "i.e.", "very", "few", "incorrect", "answer", "query", "5.5", "analysis", "computational", "cost", "we", "exact", "CCD", "algorithm", "-lrb-", "bsc-exact", "-rrb-", "vary", "respect", "different", "case", "describe", "section", "3.2", "case", "-lrb-", "-rrb-", "operation", "cost", "coplanarity", "test", "involve", "polynomial", "decomposition", "polynomial", "evaluation", "-lrb-", "degree", "-rrb-", "inside", "test", "case", "-lrb-", "-rrb-", "its", "operation", "cost", "include", "polynomial", "decomposition", "polynomial", "evaluation", "-lrb-", "degree", "-rrb-", "coplanarity", "test", "polynomial", "decomposition", "polynomial", "evaluation", "-lrb-", "three", "degree", "three", "degree", "-rrb-", "inside", "test", "case", "-lrb-", "-rrb-", "its", "total", "operation", "cost", "sum", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "overall", "operation", "count", "we", "algorithm", "much", "lower", "than", "eltopo-exact", "result", "considerable", "speedup", "show", "fig.", "furthermore", "we", "only", "perform", "simple", "arithmetic", "operation", "addition", "subtraction", "multiplication", "-lrb-", "see", "detail", "appendix", "-rrb-", "term", "extended", "precision", "computation", "division", "operation", "more", "expensive", "than", "three", "operation", "we", "avoid", "those", "expensive", "operation", "we", "algorithm", "first", "time", "contact", "can", "easily", "compute", "use", "root", "isolation", "we", "perform", "mid-point", "subdivision", "-lrb-", "use", "Bernstein", "formulation", "-rrb-", "recursively", "after", "Algorithm", "return", "true", "subdivision", "terminate", "when", "size", "interval", "contain", "root", "less", "than", "user-threshold", "mid-point", "interval", "use", "compute", "intersection", "point", "take", "about", "30", "40", "ns/query", "we", "also", "compare", "performance", "we", "solver", "JenkinsTraub", "solver", "more", "accurate", "than", "newton-interval", "solver", "-lrb-", "e.g.", "use", "El", "Topo-float", "-rrb-", "about", "3x", "slower", "all", "numeric", "solver", "prone", "floating-point", "error", "can", "result", "falsepositive", "false-negative", "contrast", "we", "bsc-exact", "algorithm", "reliable", "faster", "than", "most", "numeric", "solver", "Limitations", "Conclusions", "Future", "Work", "we", "have", "present", "novel", "algorithm", "perform", "accurate", "CCD", "query", "between", "triangular", "mesh", "we", "exploit", "property", "Bern", "stein", "function", "b?zier", "curve", "reduce", "CCD", "query", "evaluate", "sign", "Bernstein", "polynomial", "algebraic", "expression", "we", "present", "two", "version", "algorithm", "base", "exact", "geometric", "computation", "ieee", "floating-point", "implementation", "we", "have", "implement", "algorithm", "cpus", "gpus", "we", "exact", "algorithm", "more", "than", "order", "magnitude", "faster", "than", "prior", "exact", "algorithm", "furthermore", "we", "floating-point", "variant", "faster", "more", "accurate", "than", "prior", "solver", "elementary", "test", "we", "approach", "have", "some", "limitation", "we", "current", "formulation", "assume", "vertex", "move", "constant", "velocity", "we", "reliable", "algorithm", "assume", "exact", "representation", "vertex", "edge", "face", "do", "take", "account", "any", "error", "input", "we", "floating-point", "variant", "-lrb-", "bsc-float", "-rrb-", "faster", "more", "accurate", "than", "prior", "method", "do", "guarantee", "safe", "reliable", "solution", "we", "perform", "only", "boolean", "collision", "query", "additional", "computation", "base", "root", "isolation", "would", "need", "compute", "first-time-of-contact", "many", "avenue", "future", "work", "besides", "overcome", "limitation", "may", "useful", "derive", "tight", "error", "bind", "we", "floating-point", "variant", "exact", "number", "bit", "need", "extended", "precision", "would", "help", "explain", "its", "high", "accuracy", "we", "benchmark", "would", "useful", "use", "we", "reliable", "CCD", "algorithm", "other", "application", "include", "hair", "simulation", "dynamic", "solver", "-lsb-", "Zhao", "et", "al.", "2012", "-rsb-", "finally", "we", "would", "like", "develop", "reliable", "algorithm", "high-level", "CCD", "culling", "collision-response", "http://www.codeproject.com/articles/552678/polynomial-equation", "Solver", "El-TopoBSCEl-Topofloat", "float-GPU", "float-GPU", "Avg", "Avg", "Avg", "Query", "Inaccurat", "Query", "Inaccurate", "Query", "Inaccurate", "Time", "Queries", "Time", "Queries", "Time", "Queries", "45n", "357", "1.7", "n", "2.1", "n", "412", "48n", "98", "1.8", "n", "2ns", "121", "44n", "131", "2.1", "n", "3.7", "n", "156", "43n", "12", "1.8", "n", "2.5", "n", "54", "45n", "45", "2n", "3.1", "n", "60", "acknowledgement", "research", "support", "part", "nsfc", "-lrb-", "61170140", "-rrb-", "National", "Basic", "Research", "Program", "China", "-lrb-", "2011CB302205", "-rrb-", "National", "Key", "Technology", "R&D", "Program", "China", "-lrb-", "2012bad35b01", "-rrb-", "Doctoral", "Fund", "Ministry", "Education", "China", "-lrb-", "20130101110133", "-rrb-", "Dinesh", "Manocha", "support", "part", "ARO", "Contract", "W911NF-10-1-0506", "Intel", "Office", "director", "National", "Institutes", "Health", "under", "award", "number", "r44od018334", "National", "Thousand", "Talents", "Program", "China", "content", "solely", "responsibility", "author", "do", "necessarily", "represent", "official", "view", "National", "Institutes", "Health", "Ruofeng", "Tong", "partly", "support", "nsfc", "-lrb-", "61170141", "-rrb-", "National", "High-Tech", "Research", "Development", "Program", "-lrb-", "No.", "2013AA013903", "-rrb-", "China", "we", "gratefully", "acknowledge", "support", "NVIDIA", "Corporation", "donation", "Tesla", "k40c", "GPU", "use", "research", "reference", "ridson", "R.", "edkiw", "R.", "NDERSON", "J.", "2002", "robust", "treatment", "collision", "contact", "friction", "cloth", "animation", "ACM", "Trans", "graph", "21", "-lrb-", "July", "-rrb-", "594", "603", "rochu", "T.", "RIDSON", "R.", "2009", "robust", "topological", "operation", "dynamic", "explicit", "surface", "SIAM", "J.", "Sci", "Comput", "31", "-lrb-", "June", "-rrb-", "2472", "2493", "rochu", "T.", "DWARDS", "E.", "RIDSON", "R.", "2012", "efficient", "geometrically", "exact", "continuous", "collision", "detection", "ACM", "Trans", "graph", "31", "-lrb-", "July", "-rrb-", "96:1", "96:7", "urnikel", "C.", "unke", "S.", "EEL", "M.", "2001", "exact", "geometric", "computation", "use", "cascade", "International", "J.", "Comp", "geometry", "application", "11", "245", "266", "special", "issue", "urti", "S.", "amstorf", "R.", "anocha", "D.", "2008", "fast", "collision", "detection", "deformable", "model", "use", "representativetriangle", "si3d", "08", "Proceedings", "2008", "Symposium", "interactive", "3d", "graphic", "game", "61", "69", "arin", "G.", "2002", "curve", "surface", "CAGD", "practical", "guide", "5th", "ed", "Morgan", "Kaufmann", "Publishers", "Inc.", "San", "Francisco", "USA", "aroukus", "R.", "T.", "AJAN", "V.", "T.", "1987", "numerical", "condition", "polynomial", "berstein", "form", "Comput", "aid", "geom", "Des", "-lrb-", "Nov.", "-rrb-", "191", "216", "ovindaraju", "N.", "NOTT", "D.", "AIN", "N.", "ABUL", "I.", "be", "storf", "R.", "AYLE", "R.", "M.", "anocha", "D.", "2005", "interactive", "collision", "detection", "between", "deformable", "model", "use", "chromatic", "decomposition", "ACM", "Trans", "graphic", "-lrb-", "Proc", "ACM", "SIGGRAPH", "-rrb-", "24", "991", "999", "ARMON", "D.", "OUGA", "E.", "amstorf", "R.", "RINSPUN", "E.", "2008", "robust", "treatment", "simultaneous", "collision", "SIGGRAPH", "-lrb-", "ACM", "transaction", "graphic", "-rrb-", "27", "UTTER", "M.", "uhrmann", "a.", "2007", "optimize", "continuous", "collision", "detection", "deformable", "triangle", "mesh", "Proc", "WSCG", "07", "25", "32", "IM", "B.", "ossignac", "J.", "2003", "Collision", "prediction", "polyhedron", "under", "screw", "motion", "Proceedings", "eighth", "acm", "symposium", "solid", "modeling", "application", "sm", "03", "10", "ALLE", "S.", "M.", "2006", "Planning", "Algorithms", "Cambridge", "University", "Press", "ezger", "J.", "IMMERLE", "S.", "tzmu", "O.", "2003", "hierarchical", "technique", "cloth", "detection", "cloth", "animation", "Journal", "WSCG", "11", "322", "329", "ourrain", "B.", "OUILLIER", "F.", "oy", "m.-f", "2005", "Bernstein", "basis", "real", "root", "isolation", "combinatorial", "computational", "geometry", "MSRI", "Publications", "459", "478", "arain", "R.", "AMII", "a.", "o?b", "rien", "J.", "F.", "2012", "adaptive", "anisotropic", "remeshing", "cloth", "simulation", "ACM", "Trans", "graph", "31", "-lrb-", "Nov.", "-rrb-", "152:1", "152:10", "abst", "S.", "OCH", "a.", "trasser", "W.", "2010", "fast", "scalable", "cpu/gpu", "collision", "detection", "rigid", "deformable", "surface", "Computer", "Graphics", "Forum", "29", "1605", "1612", "rovot", "X.", "1997", "Collision", "self-collision", "handling", "cloth", "model", "dedicate", "design", "garment", "Graphics", "Interface", "177", "189", "edon", "S.", "HEDDAR", "a.", "oquillart", "S.", "2002", "fast", "continuous", "collision", "detection", "between", "rigid", "body", "Proc", "eurographic", "-lrb-", "computer", "graphic", "Forum", "-rrb-", "21", "279", "288", "chvartzman", "S.", "C.", "REZ", "A.", "G.", "taduy", "M.", "A.", "2010", "star-contours", "efficient", "hierarchical", "self-collision", "detection", "ACM", "Trans", "graph", "29", "-lrb-", "July", "-rrb-", "80:1", "80:8", "ederberg", "T.", "W.", "ISHITA", "T.", "1990", "curve", "intersection", "use", "b?zier", "clipping", "Comput", "aid", "Des", "22", "538", "549", "elle", "a.", "entine", "m.", "edkiw", "R.", "2008", "mass", "spring", "model", "hair", "simulation", "ACM", "Trans", "graph", "27", "-lrb-", "Aug.", "-rrb-", "64:1", "64:11", "tam", "J.", "2009", "nucleus", "towards", "unify", "dynamics", "solver", "computer", "graphic", "Proceedings", "IEEE", "International", "Conference", "CAD", "CG", "11", "ang", "M.", "URTIS", "S.", "OON", "S.-E.", "anocha", "D.", "2009", "ICCD", "interactive", "continuous", "collision", "detection", "between", "deformable", "model", "use", "connectivity-based", "culling", "IEEE", "transaction", "visualization", "computer", "graphic", "15", "544", "557", "ang", "M.", "IM", "Y.", "J.", "anocha", "D.", "2009", "c2a", "control", "conservative", "advancement", "continuous", "collision", "detection", "polygonal", "model", "Proceedings", "International", "Conference", "Robotics", "automation", "356", "361", "ang", "M.", "IM", "Y.", "J.", "anocha", "D.", "2010", "CCQ", "efficient", "local", "planning", "use", "connection", "collision", "query", "WAFR", "229", "247", "ang", "m.", "anocha", "D.", "ong", "R.", "2010", "fast", "continuous", "collision", "detection", "use", "deform", "non-penetration", "filter", "Proceedings", "ACM", "Symposium", "interactive", "3d", "graphic", "Games", "ACM", "New", "York", "NY", "USA", "13", "ang", "m.", "anocha", "D.", "OON", "S.-E.", "P.", "EO", "J.-P.", "ong", "R.", "2011", "VolCCD", "fast", "continuous", "collision", "culling", "between", "deforming", "volume", "mesh", "ACM", "Trans", "graph", "30", "-lrb-", "May", "-rrb-", "111:1", "111:15", "ang", "M.", "ong", "R.", "ARAIN", "R.", "ENG", "C.", "anocha", "D.", "2013", "gpu-based", "streaming", "algorithm", "high-resolution", "cloth", "simulation", "Computer", "Graphics", "Forum", "32", "21", "30", "olino", "P.", "halmann", "N.", "M.", "1994", "efficient", "selfcollision", "detection", "smoothly", "discretize", "surface", "animation", "use", "geometrical", "shape", "regularity", "Computer", "Graphics", "Forum", "13", "155", "166", "ang", "H.", "2014", "defend", "continuous", "collision", "detection", "against", "error", "ACM", "Trans", "graph", "33", "-lrb-", "July", "-rrb-", "122:1", "122:10", "ONG", "W.", "S.-K.", "ACIU", "G.", "2006", "randomize", "mark", "scheme", "continuous", "collision", "detection", "simulation", "deformable", "surface", "Proc", "ACM", "VRCIA", "181", "188", "ap", "C.", "2004", "robust", "geometric", "computation", "handbook", "Discrete", "Computational", "Geometry", "J.", "E.", "Goodman", "J.", "O?Rourke", "Eds.", "2nd", "ed", "Chapmen", "Hall/CRC", "Boca", "Raton", "fl", "ch", "41", "927", "952", "hang", "X.", "EDON", "S.", "EE", "M.", "IM", "Y.", "J.", "2007", "continuous", "collision", "detection", "articulate", "model", "use", "Taylor", "model", "temporal", "culling", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "SIGGRAPH", "2007", "-rrb-", "26", "15", "hao", "J.", "ang", "m.", "ong", "R.", "2012", "connectivitybased", "segmentation", "gpu-accelerated", "mesh", "decompression", "J.", "Comput", "Sci", "Technol", "27", "1110", "1118", "heng", "C.", "AMES", "D.", "L.", "2012", "energy-based", "self-collision", "culling", "arbitrary", "mesh", "deformation", "ACM", "transaction", "graphic", "-lrb-", "Proceedings", "SIGGRAPH", "2012", "-rrb-", "31", "-lrb-", "Aug.", "-rrb-", "98:1", "98:12", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014", "186:8", "M.", "Tang", "et", "al.", "ACM", "transaction", "Graphics", "Vol", "33", "no.", "Article", "186", "publication", "date", "November", "2014" ],
  "content" : "\n  \n    02d2b173b2e0a1067d3aa1672060f36663d5b0860e2087f8b5ee650e2813c7d7\n    mjr\n    10.1145/2661229.2661237\n    Name identification was not possible. \n  \n  \n    \n      \n        Fast and Exact Continuous Collision Detection with Bernstein Sign Classification\n      \n      Min Tang 1? Ruofeng Tong 1 Zhendong Wang 1 Dinesh Manocha 2? 1. State Key Lab of CAD&CG, Zhejiang University 2. University of North Carolina at Chapel Hill http://gamma.cs.unc.edu/BSC/\n      We present fast algorithms to perform accurate CCD queries between triangulated models. Our formulation uses properties of the Bernstein basis and B?zier curves and reduces the problem to evaluating signs of polynomials. We present a geometrically exact CCD algorithm based on the exact geometric computation paradigm to perform reliable Boolean collision queries. Our algorithm is more than an order of magnitude faster than prior exact algorithms. We evaluate its performance for cloth and FEM simulations on CPUs and GPUs, and highlight the benefits. CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling?Physically based modeling Keywords: Continuous collision detection, Bernstein sign classification, Exact geometric computation, Physically based simulation\n      Links:\n      \n        \n      \n      DL PDF W\n      \n        \n        \n      \n      EB\n    \n    \n      \n        1 Introduction\n      \n      The problem of fast and reliable collision detection arises in physically-based simulation, geometric computing, and robotics. Many applications require accurate algorithms that do not miss a single collision and maintain intersection-free meshes throughout the simulation. Some of the widely-used algorithms for contact computation are based on continuous collision detection (CCD). Given two discrete instances or configurations of rigid or deformable models, CCD algorithms model the motion of each object or a mesh element using a continuous trajectory between the configurations and check for collisions along the trajectory. These algorithms are widely used for cloth simulation [Provot 1997; Bridson et al. 2002; Harmon et al. 2008; Brochu et al. 2012], rigid-body simulation [Redon et al. 2002], hair simulation [Selle et al. 2008], FEM simulation [Tang et al. 2011], robot motion planning [LaValle 2006; Tang et al. 2010a], dynamic solvers [Stam 2009], etc. The simplest algorithms for triangular meshes linearly interpolate the trajectories of the vertices. In this case, contact computation reduces to performing a series of elementary tests between the vertices, edges, and faces using cubic polynomial root solvers [Provot 1997; Bridson et al. 2002]. Many high-level culling techniques\n      ? e-mail:{tang m,trf, westernseawolf}@zju.edu.cn ? e-mail: dm@cs.unc.edu\n      \n        ACM Reference Format\n      \n      Tang, M., Tong, R., Wang, Z., Manocha, D. 2014. Fast and Exact Continuous Collision Detection with Bernstein Sign Classification. ACM Trans. Graph. 33, 6, Article 186 (November 2014), 8 pages. DOI = 10.1145/2661229.2661237 http://doi.acm.org/10.1145/2661229.2661237.\n      \n        Copyright Notice\n      \n      Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the fi rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org . Copyright ? ACM 0730-0301/14/11-ART186 $15.00. DOI: http://doi.acm.org/10.1145/2661229.2661237\n      \n        \n      \n      (a) (b)\n      \n        Figure 1:\n      \n      Benefits of Reliable CCD Queries: We highlight the benefits of our exact CCD algorithm on cloth simulation. Our algorithm can be used to generate a plausible simulation (a). If parameters are not properly tuned, floating-point-based CCD algorithms (b) can result in penetrations and artifacts.\n      have also been proposed to reduce the number of elementary tests performed between the meshes of complex models. The elementary tests are typically implemented using finiteprecision or floating-point arithmetic and use error tolerances. The numerical errors in arithmetic operations along with the tolerances can impact these elementary tests? accuracy ( Fig. 1 ). There are two types of problems: false negatives, when the CCD algorithm may miss a collision; and false positives, when the CCD algorithm, acting conservatively, flags a non-colliding configuration as a collision. In order to overcome these problems, Brochu et al. [2012] proposed algorithms for exact CCD computation that can perform reliable collision queries. However, their approach can be relatively expensive due to use of large number of exact arithmetic operations. Moreover, its portability may be limited as efficient implementations of exact computation libraries are not easily available on all processors (e.g. GPUs). Main Results: We present fast and accurate algorithms to perform reliable CCD queries. Our approach is based on using coplanarity and inside tests and reduces the computation to finding roots of algebraic equations and inequalities (i.e. a semi-algebraic set). We represent these functions using the Bernstein basis and exploit geometric properties of B?zier curves to design an efficient and reliable Bernstein sign classification (BSC) approach for CCD. The overall collision query is reduced to performing a series of sign evaluations of algebraic expressions and involves simple arithmetic operations. We also present a conservative elementary culling algorithm to improve the algorithm?s performance. We use BSC to design two algorithms: 1. BSC-exact: This is an exact algorithm to perform CCD queries based on the exact geometric computation paradigm [Yap 2004] and is not susceptible to false positives or false negatives. We use extended precision arithmetic operations and accelerate the performance using floating-point filters. As compared to prior exact CCD algorithm [Brochu et al. 2012], we observe 10 ? 25X speedup on a single CPU core. 2. BSC-float: This is a finite-precision variant and is implemented using floating-point arithmetic operations. We have evaluated its performance on CPUs and GPUs and observe considerable speedups over prior floating-point CCD algorithms. Furthermore, we observe significant improvement in accuracy, i.e. significant reduction in the number of false positives and false negatives using our algorithm. The overall algorithms are simple to implement, using only addition, subtraction, and multiplication operations. The use of the Bernstein basis and simple arithmetic operations results in reduced errors and improved efficiency. We highlight the benefits of algorithms using cloth and FEM simulation benchmarks.\n      ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n      186:2\n      ?\n      M. Tang et al.\n      \n        2 Related Work\n        In this section, we give a brief overview of prior work on CCD algorithms, high-level collision culling, and the computation of the roots of polynomials.  Many techniques have been proposed for CCD between rigid models [Redon et al. 2002; Kim and Rossignac 2003], articulated models [Zhang et al. 2007], and deformable models [Volino and Thalmann 1994; Govindaraju et al. 2005; Hutter and Fuhrmann 2007; Tang et al. 2011]. At the lowest level, these algorithms perform elementary tests between triangle pairs. The elementary tests are typically performed by computing roots of cubic polynomials. Other CCD algorithms are based on conservative local advancement [Tang et al. 2009b]. All these methods are prone to floating-point errors and numerical tolerances. Therefore, they can result in false negatives and false positives. Wang [2014] has performed forward error analysis for elementary tests and used that analysis to derive tight error bounds for floating-point computation. This is used to reduce the number of false positive. In contrast, our BSC-exact algorithm and the approach described in [Brochu et al. 2012] are reliable. The tight error bounds in [Wang 2014] can be used to derive tighter error bounds for BSC-float. High-level Culling: Many high-level techniques have been proposed to accelerate CCD computations by reducing the number of elementary tests between the triangle pairs, such as removing redundant elementary tests [Curtis et al. 2008; Tang et al. 2009a; Wong and Baciu 2006]. The simplest culling algorithms use BVHs (bounding volume hierarchies) based on k-DOPs or AABBs. Other methods use bounds on surface normals and curvature [Volino and Thalmann 1994; Provot 1997; Mezger et al. 2003] or perform selfcollision culling [Schvartzman et al. 2010; Pabst et al. 2010; Zheng and James 2012]. Many of these algorithms are implemented using floating-point arithmetic operations and are prone to numerical errors. Polynomial Root Evaluation: Many numerical iterative methods have been proposed to compute roots of polynomial equations. They tend to use tolerances and can result in false positives or false negatives for CCD computations. In computer graphics and geometric modeling, polynomials are represented using the spline basis, and their roots can be computed using the geometric subdivision methods, such as de Casteljau?s algorithm [Farin 2002] or B?zier clipping [Sederberg and Nishita 1990]. These subdivision methods are implemented using finite-precision arithmetic and are also prone to roundoff errors. There is extensive literature in symbolic computation and computational geometry on reliably computing the roots of polynomials using exact arithmetic [Yap 2004; Mourrain et al. 2005].\n      \n      \n        3 CCD and Algebraic Formulation\n        In this section, we formulate CCD queries in terms of algebraic equations and inequalities. We assume that the vertices of the mesh move with a constant velocity during the time interval and that the CCD query reduces to performing two types of Boolean queries or elementary tests [Provot 1997; Bridson et al. 2002; Brochu et al. 2012]. These include the VF query, which checks whether a moving vertex intersects with a moving triangle, and the EE query, which checks whether a moving edge intersects with another moving edge. All these queries assume that the time interval is t ? [0, 1] and that the initial configuration at t = 0 is intersection-free. If the Boolean query returns a positive answer, we can use techniques based on interval arithmetic to compute the intersection points or first time of contact to a desired precision. In many applications, only the parity of the number of collisions is needed for robust simulation [Brochu et al. 2012]. As a result, we focus on reliably computing a yes/no answer to the Boolean queries. The exact root and the first time of contact can be computed using root isolation and interval arithmetic techniques. We first introduce the notations used in the rest of the paper. Next, we present some properties of Bernstein basis functions and B?zier curves that are used by our CCD algorithm.\n        \n          3.1 Notations\n          We use following notations in the rest of the paper: Lower case letters in normal fonts (e.g. a, b, a i ,) represent scalar variables. Upper case letters (e.g., L, J(t))) represent scalar functions. Lower case letters in bold face fonts (e.g. a, b t ) represent vector quantities. Upper case letters in bold face fonts (e.g., L, J(t)) represent vector-valued functions. F (t) and F (t) are the 1st and 2nd order of derivatives of a scalar function F (t), respectively. The operators ???, ???, and ??? denote the usual scalar multiplication, dot product, and cross product, respectively. Operator Sign() returns the sign of a scalar variable. All the proofs of the lemmas, theorems and corollaries are in the supplementary material.\n        \n        \n          3.2 B ezier  ? Curves and Bernstein Basis\n          We use the symbol B i n (t) to represent the i th basis function of the Bernstein polynomials of degree n, i.e. B i n (t) = i!(n?i)! n! (1 ? t) n?i t i , where t ? [0, 1] and 0 ? i ? n. The Bernstein polynomial basis is widely used in geometric modeling for curve and surface representation as well as in numerical analysis and computer algebra for root computations [Mourrain et al. 2005]. It is well-known that the polynomials expressed in the Bernstein basis have better numerical stability under perturbation of their coefficients than do those in the power basis [Farouki and Rajan 1987]. As a result, we represent the semi-algebraic set used for CCD queries in Bernstein basis. Given a cubic polynomial Y (t), it can be expressed using the Bernstein basis, i.e.\n          \n            1\n            Y (t) = k 0 ? B 0 3 (t) + k 1 ? B 1 3 (t) + k 2 ? B 2 3 (t) + k 3 ? B 3 3 (t).\n          \n          It corresponds to a cubic B?zier curve F(t) in a plane, where: F(t) = Y t (t) = k 0 0 ? B 0 3 (t) + 1/3 k 1 ? B 1 3 (t)\n          \n            2\n            + 2/3 k 2 ? B 2 3 (t) + k 1 3 ? B 3 3 (t).\n          \n          We exploit some geometric properties of cubic B?zier curves in order to characterize inflection points and extreme points. An inflection point occurs where the curvature vanishes or changes its\n          ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n          Fast and Exact Continuous Collision Detection\n          ?\n          186:3\n          Y (t ) k 1 k 3 0 1/3 2/3 1.0 X (t ) k 0 (a) k 2 Ye s Y (t ) k 1 k 2 Has an inflection point? Ye s 0 1/3 2/3 1.0 X (t ) No extreme Has an k 0 (b) k 2 k 3 k 3 point? Y (t ) k 1 No X (t ) 0 1/3 2/3 1.0 k 0 (c)\n          \n            Figure 2:\n          \n          B?zier Classifications: We classify the cubic B?zier curve into three categories (a)-(c), depending on whether it has an inflection point or an extreme point.\n          bending direction. The extreme points correspond to local minima or maxima. Every cubic B?zier curve can be classified into three categories (as shown in Fig. 2 ), depending on whether it has any inflection point or extreme point over its domain (t ? [0, 1]) [Farin 2002]: ? Case (a): The curve has an inflection point. ? Case (b): The curve has no inflection point, but an extreme point. ? Case (c): The curve has neither an inflection point nor an extreme point. The existence of an inflection point or an extreme point can be checked based on the lemmas in the supplementary material. A cubic Bernstein polynomial can be decomposed into lowerdegree polynomials based on the following theorem: Polynomial Decomposition Theorem: Let G(t) and H(t) be a cubic polynomial and a quadratic polynomial, respectively:\n          G(t) = i 0 ? B 0 3 (t) + i 1 ? B 1 3 (t) + i 2 ? B 2 3 (t) + i 3 ? B 3 3 (t),\n          \n            3\n            H(t) = j 0 ? B 0 2 (t) + j 1 ? B 1 2 (t) + j 2 ? B 2 2 (t).\n          \n          G(t) can be decomposed as:\n          \n            4\n            G(t) = L(t) ? H(t) + K(t),\n          \n          where L(t) and K(t) are two linear polynomials:\n          \n            5\n            L(t) = u 0 ? B 0 1 (t) + u 1 ? B 1 1 (t), K(t) = v 0 ? B 0 1 (t) + v 1 ? B 1 1 (t),\n          \n          where u [0,1] and v [0,1] can be calculated from i [0...3] and j [0...2] . 3.3 CCD Queries\n          The CCD test between a triangle pair reduces to performing 6 VF queries and 9 EE queries. Each of these queries can be further decomposed into two parts [Provot 1997; Bridson et al. 2002]: ? Coplanarity test: The VF and EE queries involve the use of four deforming vertices. In order for a collision to occur, it is necessary that those four vertices be coplanar.  ? Inside test: In addition to satisfy the coplanarity condition, we need to check whether the moving vertex is inside the triangle (VF), or the two edges intersect with each other at an interior point (EE). The coplanarity test for a VF pair can be expressed as:\n          \n            6\n            (p t ? a t ) ? n t = 0,\n          \n          where p t corresponds to the moving vertex, a t , b t , c t are the vertices of the deforming triangle, and n t is the normal vector of the triangle (i.e. n t = (b t ? a t ) ? (c t ? a t )). In order to perform an inside test for a VF pair, we need to perform three one-sided tests, i.e. p t needs to be inside the triangle. This can be expressed based on the following inequalities:\n          \n            9\n            ((b t ? p t ) ? (c t ? p t )) ? n t ? 0, ((c t ? p t ) ? (a t ? p t )) ? n t ? 0, ((a t ? p t ) ? (b t ? p t )) ? n t ? 0.\n          \n          The coplanarity and inside tests can be combined to find a common root of the following system of algebraic equation and inequalities (i.e. a semi-algebraic set). The VF query reduces to checking whether this semi-algebraic set has a real solution for t ? [0, 1].\n          \n            10\n            ? ? ? ? ? (p ((b t t ? ? a p t ) t ) ? ? n t (c = t 0, ? p t )) ? n t ? 0, ? ? ? ? ((a ((c t t ? ? p p t t ) ) ? ? (a (b t t ? ? p p t t )) )) ? ? n n t t ? ? 0, 0.\n          \n          3.4 Coplanarity Tests using Bernstein Polynomials\n          In order to check the coplanarity of a vertex p t and a triangle (defined by a t , b t , and c t ), we need to calculate the projected distance between them along the direction of n t . If this distance becomes zero at any time in the interval, the four vertices are classified as coplanar based on following theorem. Coplanarity Test Theorem for a VF Pair: For a deforming triangle, whose initial and final positions are given as (a 0 , b 0 , c 0 ) and (a 1 , b 1 , c 1 ) and a vertex with initial and final positions as p 0 and p 1 , the coplanarity test can be formulated in terms of the following equation: Y (t) = (p t ? a t ) ? n t = 0\n          \n            11\n            = k 0 ? B 0 3 (t) + k 1 ? B 1 3 (t) + k 2 ? B 2 3 (t) + k 3 ? B 3 3 (t),\n          \n          where k [0..3] are scalars can be calculated from (a 0 ,b 0 , c 0 , p 0 ) and (a 1 , b 1 , c 1 , p 1 ). The coplanarity test reduces to checking whether the 2D cubic B?zier curve F(t) (Equation (2)) defined in the (X, Y ) plane intersects with the X-axis.  We can also formulate the inside tests using Bernstein polynomials. Inside Test Theorem for a VF Pair: Given the triangle and the vertex defined by start and end positions over the interval [0, 1], the inside test can be formulated in terms of the following inequality: ((b t ? p t ) ? (c t ? p t )) ? n t = l 0 ? B 0 4 (t) + l 1 ? B 1 4 (t)\n          3.5 Inside Tests using Bernstein Polynomials\n          \n            12\n            +l 2 ? B 2 4 (t) + l 3 ? B 3 4 (t) + l 4 ? B 4 4 (t) ? 0,\n          \n          where l [0..4] are scalars that can be calculated from (a 0 ,b 0 , c 0 , p 0 ) and (a 1 , b 1 , c 1 , p 1 ).\n          ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n          186:4\n          ?\n          M. Tang et al.\n          Simplified Inside Test Theorem for a VF pair: Based on combining Inequality (12) with Equation (11) and algebraic elimination, this inside test can be reduced to the following degree-two formulation:\n          \n            13\n            P (t) = p 0 ? B 0 2 (t) + p 1 ? B 1 2 (t) + p 2 ? B 2 2 (t) ? 0,\n          \n          where p [0...2] are scalars, which can be calculated based on k [0...3] and l [0...4] , as shown in the supplementary material. 3.6 CCD Tests using Bernstein Polynomials\n          The formulations for coplanarity and inside tests can be combined into the following system of equations and inequalities in terms of Bernstein polynomials:  where k [0...3] and p [0...2] are scalars defined above, q [0...2] and r [0...2] are the coefficients corresponding to 2 other inside tests.\n          ? ? ? ? k 0 ? B 0 3 p (t) 0 ? + B 0 2 k (t) 1 ? + B 1 3 p (t) 1 ? + B 1 2 k (t) 2 ? + B 2 3 p (t) 2 ? + B 2 2 k (t) 3 ? ? B 3 3 0, (t) = 0, q 0 ? B 0 2 (t) + q 1 ? B 1 2 (t) + q 2 ? B 2 2 (t) ? 0, ? ? ? r 0 ? B 0 2 (t) + r 1 ? B 1 2 (t) + r 2 ? B 2 2 (t) ? 0.\n        \n      \n      \n        4 CCD Query Using Sign Evaluations\n        In this section, we use the formulation of CCD computation in terms of Bernstein polynomials and present accurate algorithms to perform CCD queries. Our formulation consists of two stages: ? Geometric Coplanarity Test: By deducing the signs of the polynomials at its extreme points and comparing with the signs of its end points in the interval [0, 1], we can check for the existence of roots for coplanarity equations. ? Geometric Inside Tests: During this stage, we evaluate the signs of the inequalities at the roots that have passed coplanarity tests to check whether these roots also satisfy the inside tests.  Our goal is to compute the roots of a cubic polynomial Y (t) (defined by Equation (11) in domain [0, 1]). We use the characterization of B?zier curves into three different cases presented in Section 3.2. For the Case (a) in Section 3.2, we subdivide the curve at its inflection point, i.e. t = k 2 ?2?k 1 +k 0 , using de Casteljau?s k 0 ?3?k 1 +3?k 2 ?k 3 algorithm. The two subdivided curves either correspond to Case (b) or Case (c) in Section 3.2. We discuss both these cases: ? Case (b): If k 0 and k 3 have different signs, there is only one root in the domain. Otherwise, we use the following RootFinding Lemma to determine whether there are zero roots or two roots in the domain. ? Case (c): If k 0 and k 3 have the same sign, there is no root; otherwise there is one root in its domain. Root-Finding Lemma: For a cubic polynomial Y (t) (defined by Equation (11)) with an extreme point in its domain, its 1st derivative Y (t) is:\n        4.1 Geometric Coplanarity Test\n        Y (t) = 3 ? (k 1 ? k 0 ) ? B 0 2 (t) + 3 ? (k 2 ? k 1 ) ? B 1 2 (t) + 3 ? (k 3 ? k 2 ) ? B 2 2 (t).\n        T(t) has a root t? in [0, 1]? Yes No If Sign(Y?(t?)) = Sign(Y?(0)) If Sign(Y(0)) = Sign(T(0)) If Sign(Y(0)) = Sign(T(1)) Y(t) has no root. Y(t) has no root. Else Else Y(t) has 2 roots. Y(t) has 2 roots. Else If Sign(Y(0)) = Sign(T(0)) Y(t) has no root. Else Y(t) has 2 roots.\n        \n          Figure 3:\n        \n        Computing the Number of Roots of Y (t): We can compute them based on sign evaluations.\n        (a) L (t ) ? t ? 0 1 Y (t ) L (t ) L (t ) Y (t ) Y ( t ) t ? 0 t 0 t ? t 1 1 0 t 0 t ? ? t 1 1 (b) (c)\n        \n          Figure 4:\n        \n        Evaluate the Sign of L( t): Based on Sign Determination Theorem I and Sign Determination Theorem II, we can evaluate the sign of L( t).\n        We decompose Y (t) = Y (t) ? S(t) + T (t), where S(t) and T (t) are two linear polynomials and can be calculated with the Polynomial Decomposition Theorem in Section 3.2. We use the classification in Fig. 3 to compute the number of roots of Y (t). Based on this formulation, we can compute the number of roots for Case (b) and Case (c), and consequently for Case (a). In order to perform a specific inside test, along with the coplanarity test, we need to test the following system:\n        4.2 Geometric Inside Tests\n        \n          14\n          Y (t) = 0, P (t) ? 0.\n        \n        Here Y (t) and P (t) are defined by Equation (11) and Equation (13), respectively. We compute a similar system for the other two inside tests. Based on the Polynomial Decomposition Theorem in Section 3.2, we can express:\n        \n          15\n          Y (t) = L(t) ? P (t) + K(t),\n        \n        where L(t) and K(t) are linear polynomials. Let t be a root of Y (t) in the domain [0, 1], i.e. Y ( t) = 0, t ? [0, 1]. From Equation (15), we obtain P ( t) = ?K( t)/L( t). Therefore, the problem of computing the sign of P ( t) reduces to computing the signs of K( t) and L( t). We use following theorems to compute the signs of K( t) and L( t):\n        ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n        Fast and Exact Continuous Collision Detection\n        ?\n        186:5\n        If Sign(Y(t?)) = Sign(Y(0)) If Sign(Y(t?)) ? Sign(Y(0)) Sign(L( ? )) ? Sign(L(1)) Sign(L( t 0 )) ? Sign(L(0)) Else Sign(L( t 1 )) ? Sign(L(1)) Sign(L( ? )) ? Sign(L(0)) Else If Sign(Y?(t?)) = Sign(Y?(0)) (a) Sign(L( Sign(L( t t 1 0 )) )) ? ? Sign(L(1)) Sign(L(1)) Else Sign(L( t 0 )) ? Sign(L(0)) Sign(L( t 1 )) ? Sign(L(0)) (b)\n        \n          Figure 5:\n        \n        Rules for Evaluating the Sign of L( t), L( t 0 ), and L( t 1 ): We use the rules in (a) and (b) for Sign Determination Theorem I and Sign Determination Theorem II, respectively.\n        Sign Determination Theorem I: Let L(t) be a linear polynomial and Y (t) be a cubic polynomial which corresponds to the B?zier curve of Case (b) in the domain [0, 1] ( Fig. 4(a) ). Let: ? L(t ) = 0, and t ? [0, 1], ? Y ( t) = 0, and t ? [0, 1]. We can use the rules in Fig. 5(a) to evaluate the sign of L( t)). Sign Determination Theorem II: Let L(t) be a linear polynomial and Y (t) be a cubic polynomial that corresponds to the B?zier curve of Case (c) in the domain [0, 1] ( Fig. 4(b) and Fig. 4(c) ). Let: ? L(t ) = 0, and t ? [0, 1], ? Y ( t 0 ) = 0 and Y ( t 1 ) = 0, and t 0 ? [0, 1], t 1 ? [0, 1], t 0 < t 1 , ? Y (t ) = 0, and t ? [0, 1]. Y (t) is the 1st order of derivative of Y (t). We can use the rules in Fig. 5(b) to determine the sign of L( t 0 )) and L( t 1 )). Based on Sign Determination Theorem I and Sign Determination Theorem II, we can determine the sign of L( t). Sign of K( t): The algorithm used to compute the sign of L( t) can be directly used to compute the sign of K( t).\n        Based on the signs of L( t) and K( t), we can compute the sign of P ( t) and consequently check whether the equality and inequality in Equation (14) are satisfied or not. This is repeated for the other two inequalities as well. If all of them are satisfied, then the answer to the CCD query is positive.\n        \n          4.3 Conservative Culling Test\n          Many times there is no collision, and we use a simple culling scheme to accelerate the algorithm. This is similar to using the non-penetration filter [Tang et al. 2010b] or plane-culling [Brochu et al. 2012]. Our goal is to eliminate many VF pairs that do not satisfy the coplanarity condition (see Equation (11)). One sufficient condition is when all the coefficients k [0...3] are either greater than zero or less than zero. Instead of computing k [0...3] exactly, we use floating-point filters [Burnikel et al. 2001] to perform conservative culling. In other words, we compute k [0...3] using floatingpoint arithmetic. Instead of comparing them with zeros, we check whether they are all greater than , or all less than ? , where is a conservative error bound. The detailed method for computing is in the supplementary material.\n          Algorithm 1 VF-Test: CCD test for a VF pair. Input: Positions at t = 0 and t = 1 for a deforming triangle (a 0 , a 1 , b 0 , b 1 , c 0 , c 1 ) and a moving vertex (p 0 , p 1 ). Output: True or False for has a collision or no collision in [0, 1]. 1: GetCoefficients() // Get coefficients of Y (t)). 2: // Perform conservative culling test. 3: if ConservativeFilter() then 4: Return False. 5: end if 6: ctype ? BezierType() // Get type of the B?zier curve. 7: // For case (a), subdivide and check on interval [0, t ] and [t , 1]. 8: // Here t is corresponding to the inflection point. 9: if ctype = Case A then 10: Subdivide into two intervals [0, t ] and [t , 1]. 11: Return VF-Test([0, t ]) OR VF-Test([t , 1]). 12: end if 13: // For case (b) and case (c), continue checking. 14: // Perform Coplanarity Test (Section 4.1). 15: if !CoplanarityTest() then 16: Return False. 17: end if 18: // Perform Inside Test (Section 4.2). 19: if !InsideTest() then 20: Return False. 21: end if 22: Return True. // A valid collision has been detected. 4.4 Overall VF Query Algorithm\n          Our overall algorithm for VF query is described in Algorithm 1. We first compute the coefficients of Y (t), i.e. k [0...3] (Line 1), and perform the conservative culling test (Line 3?5). If the culling test fails, we classify the type of B?zier curves (Line 6). For case (a), we subdivide the interval [0, 1] into two sub-intervals [0, t ] and [t , 1], and recursively perform CCD tests on these sub-intervals (Line 9? 12). For case (b) and (c), we perform the coplanarity test (Line 15?17) and inside tests (Line 19?21). If all these tests are positive, the response to VF collision query is positive (Line 22). We use a similar algorithm for EE tests. The details of its derivation are given in the supplementary material. The main difference with respect to the VF test is in terms of the inequalities used for the inside tests. BSC-exact: Exact VF Computation: In order to perform reliable collision queries, we use the well-known paradigm of Exact Geometric Computation [Yap 2004], which is widely used for geometric computations and has also been used to perform exact Boolean answers for CCD [Brochu et al. 2012]. The underlying philosophy is that we compute the correct answer to these Boolean queries assuming that we use exact arithmetic and there are no errors due to use of fixed precision or floating-point arithmetic or user specified tolerances. Our exact algorithm, BSC-exact, uses a combination of extended precision arithmetic operations and floating point filters. Our conservative-culling test only uses floating point filters and does not perform exact arithmetic operations. The rest of the computations include many expressions and evaluating signs of polynomials. All these computations can be accelerated using floating point filters. BSC-float: Floating-point Algorithm: In some cases, optimized libraries for extended precision-arithmetic operations are not available on certain processors (e.g. GPUs). In this case, all the steps of Algorithm 1 are implemented using floating-point arithmetic and are prone to numerical errors. Our resulting algorithm, BSC-float, is based on the IEEE floating-point standard.\n          ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n          186:6\n          ?\n          M. Tang et al.\n          \n            \n            Figure 6: Benchmarks: We use five different benchmarks arising from cloth and FEM simulations.\n          \n        \n      \n      \n        5 Implementation and Performance\n        In this section, we describe our implementation and highlight the performance of our algorithm on several benchmarks.\n        \n          5.1 Implementation\n          We have implemented our algorithms on a standard PC (Intel i73770K CPU @3.5GHz, 4GB RAM, 64-bits Window 7 OS, NVIDIA Tesla K40c GPU). This includes a CPU-based C++ implementation of BSC-exact that uses a single core and uses an exact computation library based on interval arithmetic [Brochu et al. 2012]. We have also implemented BSC-float on a CPU (with C++) and a GPU (using CUDA 5.5) using hardware-supported floating-point operations. We compare the performance of our algorithms with the following algorithms:\n          1. El-Topo-exact: This is the implementation of the exact algorithm of [Brochu et al. 2012], made available by the authors. It also uses plane-based culling to accelerate the computation, along with interval arithmetic-based filters and exact expansions for exact arithmetic operations. In order to compare the performance with BSC-exact, we use the same implementation of exact arithmetic operations. 2. El-Topo-float: This is a floating-point-based cubic root solver CCD implementation, available as part of El-Topo surfacetracking library [Brochu and Bridson 2009]. We measured its performance using a single thread on the CPU. 3. BSC-float-GPU and El-Topo-float-GPU: We also ported BSC-float and El-Topo-float algorithms to GPUs and tested their performance with multiple threads, referred to as BSCfloat-GPU and El-Topo-float-GPU, respectively.\n        \n        \n          5.3 Relative Performance on a CPU 1. El-Topo-exact: This is the implementation of the exact algorithm of [Brochu et al. 2012], made available by the authors. It also uses plane-based culling to accelerate the computation, along with interval arithmetic-based filters and exact expansions for exact arithmetic operations. In order to compare the performance with BSC-exact, we use the same implementation of exact arithmetic operations. 2. El-Topo-float: This is a floating-point-based cubic root solver CCD implementation, available as part of El-Topo surfacetracking library [Brochu and Bridson 2009]. We measured its performance using a single thread on the CPU. 3. BSC-float-GPU and El-Topo-float-GPU: We also ported BSC-float and El-Topo-float algorithms to GPUs and tested their performance with multiple threads, referred to as BSC5.4 Relative Performance on a GPU float-GPU and El-Topo-float-GPU, respectively. 5.2 Benchmarks\n          In order to test the performance of our algorithms, we used five different benchmarks arising from different simulation scenarios that use CCD queries. ? Dancer: A dancer wearing a simple skirt with 5K ? 10K triangles, the number of triangles change during the simulation due to adaptive computations. This benchmark has a high number of self-collisions ( Figure 6(d) ). ? Twisting: A cloth with 2K ? 50K triangles twists severely as the underlying ball is rotating. This benchmark has a high number of self-collisions ( Figure 6(a) ). ? Flamenco: A fiery Flamenco dancer wearing a colorful skirt with ruffles. This benchmark (49K triangles) has many interand intra-object collisions ( Figure 6(c) ). ? Funnel: A cloth with 2K ? 42K triangles falls into a funnel and folds to fit into the funnel with many self-collisions ( Figure 6(b) ). ? Crashing: A Ford Explorer with 1.1M triangles crashes against a rigid wall and the deformation is simulated using finite-element meshing ( Figure 6(e) ). The first three benchmarks (Dancer, Twisting, and Funnel) are generated by integrating our CCD algorithm into a cloth simulation system, ArcSim [Narain et al. 2012]. The input for the Flamenco and the Crashing benchmarks is given as discrete keyframes. We use linear interpolation between key-frames and check for interobject and self-collisions. We also use BVH-based hierarchical culling (using AABBs) to reduce the number of elementary tests. Worst-Case Query Performance: If there is no collision, our culling algorithm is able to discard many of those instances. The query time is higher when there is an actual contact. The worstcase query times for our algorithm vs. prior algorithms are: ? BSC-exact: The worst-case time for EE and VF queries are about 876 ns. In contrast, the worst-case query times for ElTopo-exact are 15 ms and 11?s for EE and VE queries, respectively. ? BSC-float: The worst-case time for EE and VF queries are about 105 ns. In contrast, the worst-case query times for El-Topo-float are about 953 ns for both queries on a CPU core. Moreover, we observe fewer incorrect query results using BSC-float.  Figure 7 highlights the performance of our algorithms, BSC-exact and BSC-float, and compares them with two prior CCD algorithms, El-Topo-exact and El-Topo-float, on a single CPU core. For all these benchmarks, the performance of BSC-exact is about 10?25X faster than El-Topo-exact, and offers similar reliability. Furthermore, we observe up to an order of magnitude speedup in the floating point implementations. Our approach, BSC-float, involves fewer arithmetic operations, as compared to El-Topo-float. The combination of fewer operations and improved numerical stability properties of Bernstein polynomials also improves the accuracy of BSCfloat, i.e. fewer incorrect results to the collision queries in terms of false-negatives or false-positives. We have also evaluated the performance on the NVIDIA Tesla K40c GPU. We are not aware of any widely optimized extended precision libraries on GPUs, so we only evaluated the relative performance of BSC-float-GPU and El-Topo-float-GPU on various benchmarks. We compared the accuracy of query results with those computed by exact CPU-based implementations. In this case, BSC-float-GPU results in much fewer inaccurate collision queries as compared to ElTopo-float-GPU. The internal registers used in GPUs may have different precision from CPUs, so we may observe considerable differences in the accuracy results of BSC-float-GPU and El-Topo-floatGPU, as compared to their CPU counterparts. For example, many Intel processors use 80-bit internal registers for floating-point operations, and this may result in higher accuracy for CPU-based implementations. We have also integrated BSC-float and El-Topo-float into a GPU-based cloth simulation system [Tang et al. 2013] and compared the runtime query performance of both CCD algorithms within that system. Figure 7 highlights the performance of BSCfloat-GPU and El-Topo-float-GPU. Due to parallelism, the relative performance improvement of BSC-float-GPU over El-Topo-floatGPU is less than those on the CPUs.\n          ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n          Fast and Exact Continuous Collision Detection\n          ?\n          186:7\n          BSCEl-TopoBSCexact exact float Bench# of Avg. Avg. Avg. # of marks Tests Query Query Query Inaccurate Time Time Time Queries Dancer 405M 9ns 274ns 4.4ns 1 Twisting 70.3M 12ns 252ns 5.6ns 0 Funnel 58.5M 21ns 293ns 8.8ns 0 Flamenco 4.2M 20ns 261ns 8.2ns 0 Crashing 31.6M 16ns 259ns 7.5ns 2\n          \n            Figure 7: Performance and Comparison: We highlight the performance of various CPU and GPU-based algorithms on different benchmarks. We observe significant speedups using our algorithms based on BSC vs. prior algorithms implemented as part of El Topo [Provot 1997; Bridson et al. 2002; Brochu and Bridson 2009; Brochu et al. 2012]. Even though BSC-float is not guaranteed to be reliable, we observe very high accuracy in our benchmarks, i.e. very few incorrect answers to the queries.\n          \n        \n        \n          5.5 Analysis\n          The computational costs of our exact CCD algorithm (BSC-exact) varies with respect to different cases described in Section 3.2: ? Case (c): No operation cost for the coplanarity test; involves 3 polynomial decompositions and 3 polynomial evaluations (of degree 3) for inside tests. ? Case (b): Its operation cost includes 1 polynomial decomposition and 1 polynomial evaluation (of degree 2) for the coplanarity test; 3 polynomial decompositions and 6 polynomial evaluations (three of degree 2 and three of degree 3) for the inside test. ? Case (a): Its total operation cost is the sum of (c) and (b). The overall operation count of our algorithm is much lower than Eltopo-exact and this results in considerable speedups, as shown in Fig. 7 . Furthermore, we only perform simple arithmetic operations such as additions, subtractions, and multiplications (see details in the appendix). In terms of extended precision computations, the division operations are more expensive than these three operations and we avoid those expensive operations in our algorithm. The first time of contact can be easily computed using root isolation We perform mid-point subdivision (using Bernstein formulation) recursively, after Algorithm 1 returns true. The subdivision terminates when the size of the interval containing the root is less than a user-threshold. The mid-point of the interval is used to compute the intersection points. This takes about 30 ? 40 ns/query. We also compared the performance of our solver with the JenkinsTraub solver 1 . It is more accurate than Newton-interval solver (e.g. used in El Topo-float), but about 3X slower. All such numeric solvers are prone to floating-point errors and can result in falsepositives and false-negatives. In contrast, our BSC-exact algorithm is reliable and faster than most of these numeric solvers.\n        \n      \n      \n        6 Limitations, Conclusions and Future Work\n        We have presented novel algorithms to perform accurate CCD queries between triangular meshes. We exploit properties of Bern stein functions and B?zier curves, reducing the CCD queries to evaluating signs of Bernstein polynomials and algebraic expressions. We present two versions of the algorithm based on exact geometric computation and IEEE floating-point implementations. We have implemented these algorithms on CPUs and GPUs. Our exact algorithm is more than an order of magnitude faster than prior exact algorithms. Furthermore, our floating-point variant is faster and more accurate than prior solvers for elementary tests. Our approach has some limitations. Our current formulation assumes that the vertices move with a constant velocity. Our reliable algorithm assumes exact representation of vertices, edges, and faces and does not take into account any errors in the input. Our floating-point variant (BSC-float) is faster and more accurate than prior methods, but it does not guarantee a safe and reliable solution. We perform only Boolean collision queries; and additional computations based on root isolation would be needed to compute the first-time-of-contact. There are many avenues for future work. Besides overcoming these limitations, it may be useful to derive a tight error bound on our floating-point variant and the exact number of bits needed for extended precision. This would help explain its high accuracy in our benchmarks. It would be useful to use our reliable CCD algorithm for other applications including hair simulation and dynamic solvers [Zhao et al. 2012]. Finally, we would like to develop reliable algorithms for high-level CCD culling and collision-response.\n        1 http://www.codeproject.com/Articles/552678/Polynomial-Equation- Solver\n        El-TopoBSCEl-Topofloat float-GPU float-GPU Avg. # of Avg. # of Avg. # of Query Inaccurat Query Inaccurate Query Inaccurate Time e Queries Time Queries Time Queries 45ns 357 1.7ns 5 2.1ns 412 48ns 98 1.8ns 1 2ns 121 44ns 131 2.1ns 1 3.7ns 156 43ns 12 1.8ns 2 2.5ns 54 45ns 45 2ns 5 3.1ns 60\n      \n      \n        7 Acknowledgements\n        This research is supported in part by NSFC (61170140), the National Basic Research Program of China (2011CB302205), the National Key Technology R&D Program of China (2012BAD35B01), the Doctoral Fund of Ministry of Education of China (20130101110133). Dinesh Manocha is supported in part by ARO Contract W911NF-10-1-0506, Intel and the Office Of The Director, National Institutes Of Health under Award Number R44OD018334, and the National Thousand Talents Program of China. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health. Ruofeng Tong is partly supported by NSFC (61170141), the National High-Tech Research and Development Program (No.2013AA013903) of China. We gratefully acknowledge the support of NVIDIA Corporation with the donation of the Tesla K40c GPU used for this research.\n      \n      \n        References\n        \n          B RIDSON , R., F EDKIW , R., AND A NDERSON , J. 2002. Robust  treatment of collisions, contact and friction for cloth animation. ACM Trans. Graph. 21, 3 (July), 594?603. B ROCHU , T., AND B RIDSON , R. 2009. Robust topological operations for dynamic explicit surfaces. SIAM J. Sci. Comput. 31, 4 (June), 2472?2493.\n          B ROCHU , T., E DWARDS , E., AND B RIDSON , R. 2012. Efficient geometrically exact continuous collision detection. ACM Trans. Graph. 31, 4 (July), 96:1?96:7.\n          B URNIKEL , C., F UNKE , S., AND S EEL , M. 2001. Exact geometric computation using cascading. International J. Comp. Geometry and Applications 11, 3, 245?266. Special Issue.\n          C URTIS , S., T AMSTORF , R., AND M ANOCHA , D. 2008. Fast collision detection for deformable models using representativetriangles. In SI3D ?08: Proceedings of the 2008 Symposium on Interactive 3D graphics and games, 61?69.\n          F ARIN , G. 2002. Curves and surfaces for CAGD: a practical guide, 5th ed. Morgan Kaufmann Publishers Inc., San Francisco, USA.\n          F AROUKI , R. T., AND R AJAN , V. T. 1987. On the numerical condition of polynomials in berstein form. Comput. Aided Geom. Des. 4, 3 (Nov.), 191?216.\n          G OVINDARAJU , N., K NOTT , D., J AIN , N., K ABUL , I., T AM STORF , R., G AYLE , R., L IN , M., AND M ANOCHA , D. 2005. Interactive collision detection between deformable models using chromatic decomposition. ACM Trans. on Graphics (Proc. of ACM SIGGRAPH) 24, 3, 991?999.\n          H ARMON , D., V OUGA , E., T AMSTORF , R., AND G RINSPUN , E. 2008. Robust treatment of simultaneous collisions. SIGGRAPH (ACM Transactions on Graphics) 27, 3, 1?4.\n          H UTTER , M., AND F UHRMANN , A. 2007. Optimized continuous collision detection for deformable triangle meshes. In Proc. WSCG ?07, 25?32.\n          K IM , B., AND R OSSIGNAC , J. 2003. Collision prediction for polyhedra under screw motions. In Proceedings of the eighth ACM symposium on Solid modeling and applications, SM ?03, 4?10.\n          L A V ALLE , S. M. 2006. Planning Algorithms. Cambridge University Press.\n          M EZGER , J., K IMMERLE , S., AND E TZMU ?, O. 2003. Hierarchical techniques in cloth detection for cloth animation. Journal of WSCG 11, 1, 322?329.\n          M OURRAIN , B., R OUILLIER , F., AND R OY , M.-F. 2005. The Bernstein basis and real root isolation. In Combinatorial and Computational Geometry, MSRI Publications, 459?478.\n          N ARAIN , R., S AMII , A., AND O?B RIEN , J. F. 2012. Adaptive anisotropic remeshing for cloth simulation. ACM Trans. Graph. 31, 6 (Nov.), 152:1?152:10.\n          P ABST , S., K OCH , A., AND S TRASSER , W. 2010. Fast and scalable CPU/GPU collision detection for rigid and deformable surfaces. Computer Graphics Forum 29, 5, 1605?1612.\n          P ROVOT , X. 1997. Collision and self-collision handling in cloth model dedicated to design garments. In Graphics Interface, 177? 189.\n          R EDON , S., K HEDDAR , A., AND C OQUILLART , S. 2002. Fast continuous collision detection between rigid bodies. Proc. of Eurographics (Computer Graphics Forum) 21, 3, 279?288.\n          S CHVARTZMAN , S. C., P ? REZ , A. G., AND O TADUY , M. A. 2010. Star-contours for efficient hierarchical self-collision detection. ACM Trans. Graph. 29, 4 (July), 80:1?80:8.\n          S EDERBERG , T. W., AND N ISHITA , T. 1990. Curve intersection using B?zier clipping. Comput. Aided Des. 22, 9, 538?549.\n          S ELLE , A., L ENTINE , M., AND F EDKIW , R. 2008. A mass spring model for hair simulation. ACM Trans. Graph. 27, 3 (Aug.), 64:1?64:11.\n          S TAM , J. 2009. Nucleus: Towards a unified dynamics solver for computer graphics. In Proceedings of IEEE International Conference on CAD & CG, 1?11.\n          T ANG , M., C URTIS , S., Y OON , S.-E., AND M ANOCHA , D. 2009. ICCD: interactive continuous collision detection between deformable models using connectivity-based culling. IEEE Transactions on Visualization and Computer Graphics 15, 544?557.\n          T ANG , M., K IM , Y. J., AND M ANOCHA , D. 2009. C2A: Controlled conservative advancement for continuous collision detection of polygonal models. Proceedings of International Conference on Robotics and Automation, 356?361.\n          T ANG , M., K IM , Y. J., AND M ANOCHA , D. 2010. CCQ: Efficient local planning using connection collision query. In WAFR, 229? 247.\n          T ANG , M., M ANOCHA , D., AND T ONG , R. 2010. Fast continuous collision detection using deforming non-penetration filters. In Proceedings of ACM Symposium on Interactive 3D Graphics and Games, ACM, New York, NY, USA, 7?13.\n          T ANG , M., M ANOCHA , D., Y OON , S.-E., D U , P., H EO , J.-P., AND T ONG , R. 2011. VolCCD: Fast continuous collision culling between deforming volume meshes. ACM Trans. Graph. 30 (May), 111:1?111:15.\n          T ANG , M., T ONG , R., N ARAIN , R., M ENG , C., AND M ANOCHA , D. 2013. A GPU-based streaming algorithm for high-resolution cloth simulation. Computer Graphics Forum 32, 7, 21?30.\n          V OLINO , P., AND T HALMANN , N. M. 1994. Efficient selfcollision detection on smoothly discretized surface animations using geometrical shape regularity. Computer Graphics Forum 13, 3, 155?166.\n          W ANG , H. 2014. Defending continuous collision detection against errors. ACM Trans. Graph. 33, 4 (July), 122:1?122:10.\n          W ONG , W. S.-K., AND B ACIU , G. 2006. A randomized marking scheme for continuous collision detection in simulation of deformable surfaces. Proc. of ACM VRCIA, 181?188.\n          Y AP , C. 2004. Robust geometric computation. In Handbook of Discrete and Computational Geometry, J. E. Goodman and J. O?Rourke, Eds., 2nd ed. Chapmen & Hall/CRC, Boca Raton, FL, ch. 41, 927?952.\n          Z HANG , X., R EDON , S., L EE , M., AND K IM , Y. J. 2007. Continuous collision detection for articulated models using Taylor models and temporal culling. ACM Transactions on Graphics (Proceedings of SIGGRAPH 2007) 26, 3, 15.\n          Z HAO , J., T ANG , M., AND T ONG , R. 2012. Connectivitybased segmentation for GPU-accelerated mesh decompression. J. Comput. Sci. Technol. 27, 6, 1110?1118.\n          Z HENG , C., AND J AMES , D. L. 2012. Energy-based self-collision culling for arbitrary mesh deformations. ACM Transactions on Graphics (Proceedings of SIGGRAPH 2012) 31, 4 (Aug.), 98:1? 98:12.\n        \n        ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n        186:8\n        ?\n        M. Tang et al.\n        ACM Transactions on Graphics, Vol. 33, No. 6, Article 186, Publication Date: November 2014\n      \n    \n  ",
  "resources" : [ ]
}