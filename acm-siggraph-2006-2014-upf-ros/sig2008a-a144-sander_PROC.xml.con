{
  "uri" : "sig2008a-a144-sander_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a144-sander_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Efficient Traversal of Mesh Edges using Adjacency Primitives",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Eden-Chlamtac",
      "name" : "Eden",
      "surname" : "Chlamtac"
    }, {
      "uri" : "http://drinventor/Hugues-Hoppe",
      "name" : "Hugues",
      "surname" : "Hoppe"
    } ]
  },
  "bagOfWords" : [ "Table", "show", "result", "we", "traversal", "construction", "assortment", "practical", "mesh", "c/b", "column", "represent", "ratio", "between", "cover", "result", "-lrb-", "-rrb-", "we", "compute", "lower", "bind", "result", "-lrb-", "-rrb-", "remarkably", "c/b", "indicate", "Grosso", "et", "al.", "-lsb-", "2007", "-rsb-", "can", "find", "cover", "solution", "only", "worse", "than", "lower", "bind", "therefore", "most", "worse", "than", "optimal", "practice", "both", "cover", "assignment", "step", "can", "perform", "efficiently", "-lrb-", "seconds", "small", "model", "minute", "large", "model", "-rrb-", "note", "pre-processing", "algorithm", "therefore", "time-critical", "show", "later", "application", "excellent", "cover", "assignment", "result", "translate", "significant", "speedup", "practical", "render", "scenario", "Figure", "plot", "cache", "efficiency", "function", "cache", "size", "efficiency", "denote", "cm/v", "give", "number", "cache", "miss", "divide", "number", "vertex", "lower", "value", "better", "optimal", "minimum", "value", "give", "each", "vertex", "must", "process", "least", "once", "note", "substantial", "reduction", "number", "cache", "miss", "per", "vertex", "both", "we", "careful", "fast", "scheme", "compare", "order", "produce", "representative", "prior", "algorithm", "design", "triangle", "primitive", "without", "adjacency", "show", "Table", "fast", "scheme", "order", "magnitude", "faster", "than", "careful", "scheme", "like", "-lsb-", "Sander", "et", "al.", "2007", "-rsb-", "its", "processing", "time", "independent", "cache", "size", "figure", "show", "visualization", "result", "mesh", "from", "Table", "spatial", "distribution", "cache", "efficiency", "convey", "color", "each", "mesh", "vertex", "accord", "its", "total", "number", "cache", "miss", "color", "white", "correspond", "optimal", "single", "cache", "miss", "per", "vertex", "darker", "shades", "gray", "indicate", "progressively", "more", "cache", "miss", "per", "vertex", "we", "demonstrate", "practical", "advantage", "we", "efficient", "edgeprocess", "traversal", "three", "application", "-lrb-", "see", "Figure", "-rrb-", "Shadow", "volume", "mesh", "render", "shadow", "volume", "screen-space", "stencil", "buffer", "-lsb-", "Heidmann", "1991", "-rsb-", "shadow", "volume", "form", "within", "geometry", "shader", "displace", "triangle", "form", "front", "cap", "rear", "cap", "-lrb-", "depend", "whether", "face", "light", "-rrb-", "extrude", "silhouette", "edge", "-lrb-", "respect", "light", "-rrb-", "form", "quadrilateral", "span", "cap", "baseline", "we", "use", "sample", "program", "shadowvolume10", "DirectX", "10", "SDK", "modify", "use", "we", "optimize", "set", "cover", "primitive", "-lrb-", "figure", "8a", "-rrb-", "note", "we", "geometry", "shader", "output", "triangle", "strip", "rather", "than", "independent", "triangle", "-lrb-", "figure", "10", "-rrb-", "result", "small", "speed", "improvement", "10", "20", "apply", "all", "measurement", "Line", "illustration", "many", "render", "technique", "enhance", "object", "appearance", "emphasize", "silhouette", "other", "important", "contour", "e.g.", "-lsb-", "Gooch", "Gooch", "2001", "DeCarlo", "et", "al.", "2003", "-rsb-", "geometry", "shader", "silhouette", "rendering", "some", "sense", "ideal", "scenario", "highlight", "efficiency", "GPU", "edge-processing", "because", "output", "silhouette", "often", "have", "sub-linear", "complexity", "we", "develop", "simple", "prototype", "render", "both", "silhouette", "sharp", "feature", "-lrb-", "figure", "8b", "-rrb-", "again", "we", "use", "baseline", "basic", "approach", "process", "all", "face", "triangle", "adjacency", "follow", "framework", "from", "dx10", "shadow", "volume", "sample", "since", "we", "use", "small", "quadrilateral", "render", "primitive", "we", "can", "control", "thickness", "line", "well", "render", "mesh", "triangle", "white", "hidden", "line", "removal", "all", "single", "render", "pass", "Motion", "blur", "Wloka", "Zeleznik", "-lsb-", "1996", "-rsb-", "describe", "real-time", "technique", "approximate", "blur", "cause", "motion", "object", "relative", "viewer", "approach", "have", "similarity", "shadow", "volume", "mesh", "also", "split", "front", "part", "rear", "part", "silhouette", "edge", "-lrb-", "respect", "motion", "-rrb-", "extrude", "form", "quadrilateral", "previous", "application", "we", "compare", "against", "traditional", "approach", "process", "all", "triangle", "adjacency", "result", "motion", "volume", "render", "par", "tial", "transparency", "use", "geometry", "shader", "program", "can", "all", "do", "single", "render", "pass", "-lrb-", "figure", "8c", "-rrb-", "shadow", "volume", "application", "we", "output", "triangle", "strip", "since", "extruded", "quadrilateral", "share", "vertex", "emit", "triangle", "face", "-lrb-", "figure", "10", "-rrb-", "quantitative", "speedup", "we", "measure", "performance", "speedup", "factor", "use", "we", "approach", "against", "baseline", "method", "outline", "above", "each", "application", "measurement", "be", "perform", "both", "NVIDIA", "GeForce", "8800GTX", "AMD", "ATI", "Radeon", "hd2900", "simulate", "more", "realistic", "graphic", "scene", "measurement", "use", "multiple", "instance", "model", "factor", "out", "overhead", "due", "frame", "setup", "other", "element", "scene", "through", "experimentation", "we", "observe", "best", "result", "we", "application", "AMD", "NVIDIA", "card", "when", "set", "vertex", "cache", "parameter", "12", "24", "vertex", "respectively", "any", "rate", "result", "we", "report", "be", "significantly", "affect", "cache", "size", "parameter", "we", "geometry-shader-bound", "prototype", "application", "which", "just", "use", "Gouraud", "shade", "vertex", "program", "may", "overly", "simple", "we", "have", "verify", "more", "expensive", "vertex", "program", "do", "give", "rise", "greater", "speedup", "likely", "geometry", "shader", "implementation", "may", "become", "more", "efficient", "future", "thus", "further", "increase", "importance", "careful", "primitive", "order", "speedup", "produce", "use", "we", "approach", "report", "Table", "since", "we", "process", "just", "over", "half", "number", "primitive", "speedup", "cover", "computation", "could", "reach", "close", "however", "practice", "do", "occur", "because", "each", "we", "geometry", "shader", "instance", "emit", "more", "datum", "general", "application", "result", "speedup", "between", "1.5", "2.0", "most", "input", "mesh", "other", "application", "many", "other", "application", "would", "also", "benefit", "from", "efficient", "edge", "traversal", "some", "notable", "example", "include", "fur", "rendering", "selective", "extrusion", "fin", "from", "edge", "near", "silhouette", "-lsb-", "Lengyel", "et", "al.", "2001", "-rsb-", "soft-shadow", "use", "penumbra", "wedge", "-lsb-", "assarsson", "akenine-m", "ller", "2003", "-rsb-", "beveled", "edge", "-lsb-", "bahnassus", "bahnassi", "2007", "-rsb-", "one", "final", "note", "set", "cover", "face", "can", "also", "use", "render", "wireframe", "model", "-lrb-", "without", "geometry", "shader", "i.e.", "mode", "d3d10", "fill", "wireframe", "-rrb-", "we", "notice", "speedup", "roughly", "70", "when", "use", "cover", "face", "rather", "than", "all", "face", "model", "naturally", "efficient", "100", "improvement", "can", "obtain", "create", "buffer", "line", "contain", "edge", "model", "however", "may", "practical", "value", "list", "cover", "face", "already", "available", "-lrb-", "e.g.", "one", "above", "application", "-rrb-", "since", "would", "consume", "any", "additional", "video", "memory", "we", "have", "design", "efficient", "representation", "process", "both", "edge", "face", "mesh", "GPU", "we", "optimize", "traversal", "representation", "provide", "two", "separate", "improvement", "over", "prior", "approach", "-lrb-", "-rrb-", "nearly", "two-fold", "reduction", "number", "adjacency", "primitive", "-lrb-", "-rrb-", "additional", "reduction", "vertex", "processing", "memory", "bandwidth", "due", "improve", "vertex", "caching", "optimization", "result", "substantial", "gain", "several", "real-time", "rendering", "method", "future", "hardware", "likely", "include", "larger", "primitive", "form", "surface", "patch", "define", "efficient", "traversal", "patch", "interesting", "area", "continue", "research" ],
  "content" : "Table 1 shows the results of our traversal construction for an assortment of practical meshes. The C/B column represents the ratio between the cover results (C) and our computed lower bound results (B). Remarkably, C/B indicate that Grosso et al. [2007] can find cover solutions that are only 2?3% worse than the lower bound, and therefore at most 2?3% worse than optimal. In practice, both the cover and the assignment steps can be performed efficiently (in seconds for small models, and minutes for large models). Note that this is a pre-processing algorithm and therefore not time-critical. As shown later in the applications, the excellent cover and assignment results translate into significant speedups in practical rendering scenarios. Figure 9 plots the cache efficiency as a function of cache size. The efficiency, denoted CM/V, is given by the number of cache misses divided by the number of vertices. Lower values are better, and the optimal minimum value is 1, given that each vertex must be processed at least once. Note the substantial reduction in the number of cache misses per vertex for both our careful and fast schemes compared to the ordering produced by a representative prior algorithm designed for triangle primitives without adjacency. As shown in Table 1 , the fast scheme is orders of magnitude faster than the careful scheme, and like [Sander et al. 2007], its processing time is independent of the cache size. Figure 7 shows a visualization of the results on 4 meshes from Table 1 . The spatial distribution of cache efficiency is conveyed by coloring each mesh vertex according to its total number of cache misses. The color white corresponds to the optimal single cache miss per vertex. Darker shades of gray indicate progressively more cache misses per vertex. We demonstrate the practical advantages of our efficient edgeprocessing traversal with three applications (see Figure 8 ). Shadow volumes The mesh is rendered as a shadow volume into a screen-space stencil buffer [Heidmann 1991]. The shadow volume is formed within the geometry shader, by displacing triangles to form a front cap and a rear cap (depending on whether they face the light), and by extruding silhouette edges (with respect to the light) to form quadrilaterals spanning these caps. As a baseline, we used sample program ShadowVolume10 of the DirectX 10 SDK, and modified it to use our optimized set of cover primitives (Figure 8a). Note that our geometry shader outputs triangle strips rather than independent triangles ( Figure 10 ). This results in a small speed improvement of 10?20%, and was applied in all measurements. Line illustration Many rendering techniques enhance object appearance by emphasizing silhouettes or other important contours, e.g. [Gooch and Gooch 2001; DeCarlo et al. 2003]. With geometry shaders, silhouette rendering is in some sense an ideal scenario to highlight the efficiency of GPU edge-processing, because the output silhouette often has sub-linear complexity. We developed a simple prototype that renders both silhouettes and sharp features ( Figure 8b ). Again, we used as a baseline the basic approach of processing all faces as triangles with adjacency following the framework from the DX10 shadow volume sample. Since we use small quadrilaterals as the rendering primitive, we can control the thickness of the lines, as well as render the mesh triangles in white for hidden line removal, all in a single rendering pass. Motion blur Wloka and Zeleznik [1996] describe a real-time technique to approximate the blur caused by the motion of an object relative to the viewer. The approach has similarities to shadow volumes, in that the mesh is also split into a front part and a rear part, and silhouette edges (with respect to the motion) are extruded to form quadrilaterals. As in the previous applications, we compared against the traditional approach of processing all triangles with adjacency. The resulting motion volume is rendered with par- tial transparency. Using a geometry shader program, this can all be done in a single rendering pass ( Figure 8c ). As in the shadow volume application, we output triangle strips since the extruded quadrilaterals share vertices with the emitted triangle faces ( Figure 10 ). Quantitative speedups We measured performance speedup factors of using our approach against the baseline methods outlined above for each application. Measurements were performed on both an NVIDIA GeForce 8800GTX and an AMD ATI Radeon HD2900. To simulate a more realistic graphics scene, the measurements used multiple instances of the models to factor out overhead due to frame setup and other elements in the scene. Through experimentation, we observed best results for our applications on the AMD and NVIDIA cards when setting the vertex cache parameter to 12 and 24 vertices, respectively. At any rate, the results we report were not significantly affected by the cache size parameter. For our geometry-shader-bound prototype applications, which just use Gouraud shading, the vertex programs may be overly simple. We have verified that a more expensive vertex program does give rise to greater speedups. It is likely that geometry shader implementations may become more efficient in the future, thus further increasing the importance of careful primitive ordering. The speedups produced by using our approach are reported in Table 2 . Since we are processing just over half of the number of primitives, the speedup of the cover computation could reach close to 2?. However, in practice this does not occur because each of our geometry shader instances emit more data. In general, these applications results in speedups between 1.5? and 2.0? for most input meshes. Other applications Many other applications would also benefit from efficient edge traversal. Some notable examples include fur rendering by selective extrusion of fins from edges near the silhouette [Lengyel et al. 2001], soft-shadows using penumbra wedges [Assarsson and Akenine-M?ller 2003], and beveled edges [Bahnassi and Bahnassi 2007]. One final note is that the set of cover faces can also be used to render the wireframe of the model (without a geometry shader, i.e. with mode D3D10 FILL WIREFRAME). We noticed a speedup of roughly 70% when using the cover faces rather than all faces of the model. This is naturally not as efficient as the 100% improvement that can be obtained by creating a buffer of lines containing the edges of the model. However, it may be of practical value if the list of cover faces is already available (e.g., for one the above applications), since it would not consume any additional video memory. We have designed an efficient representation for processing both edges and faces of a mesh on a GPU. Our optimized traversal representation provides two separate improvements over prior approaches: (1) a nearly two-fold reduction in the number of adjacency primitives, and (2) additional reduction in vertex processing and memory bandwidth due to improved vertex caching. These optimizations result in substantial gains for several real-time rendering methods. Future hardware is likely to include larger primitives in the form of surface patches. Defining efficient traversals for such patches will be an interesting area of continuing research.",
  "resources" : [ ]
}