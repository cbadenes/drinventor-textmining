{
  "uri" : "sig2008a-a126-zhou_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a126-zhou_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Real-Time KD-Tree Construction on Graphics Hardware",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Qiming-Hou",
      "name" : "Qiming",
      "surname" : "Hou"
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Baining-Guo",
      "name" : "Baining",
      "surname" : "Guo"
    } ]
  },
  "bagOfWords" : [ "keyword", "kd-tree", "programable", "graphic", "hardware", "ray", "trace", "photon", "mapping", "point", "cloud", "modeling", "kd-tree", "well-known", "space-partitioning", "datum", "structure", "organize", "point", "k-dimensional", "space", "acceleration", "structure", "have", "be", "use", "variety", "graphic", "application", "include", "triangle", "culling", "ray-triangle", "intersection", "test", "ray", "trace", "nearest", "photon", "query", "photon", "mapping", "nearest", "neighbor", "search", "point", "cloud", "modeling", "particle-based", "fluid", "simulation", "due", "its", "fundamental", "importance", "graphic", "fast", "kd-tree", "construction", "have", "be", "subject", "much", "interest", "recent", "year", "several", "CPU", "algorithm", "propose", "-lsb-", "Popov", "et", "al.", "2006", "Hunt", "et", "al.", "2006", "Shevtsov", "et", "al.", "2007", "-rsb-", "two", "kd-tree", "build", "from", "scratch", "each", "frame", "one", "scene", "geometry", "other", "photon", "large", "node", "upper", "tree", "level", "we", "use", "two", "simple", "inexpensive", "heuristic", "median", "splitting", "empty", "space", "maximize", "-lsb-", "havran", "2001", "Wald", "Havran", "2006", "-rsb-", "estimate", "cost", "ray", "tracer", "achieve", "interactive", "rate", "shadow", "multi-bounce", "reflection/refraction", "GPU", "Photon", "mapping", "we", "implement", "GPU", "photon", "mapping", "which", "photon", "trace", "photon", "kd-tree", "construction", "nearest", "photon", "query", "all", "perform", "GPU", "fly", "-lrb-", "section", "-rrb-", "performance", "have", "be", "achieve", "previous", "work", "optimize", "Kd-trees", "Early", "research", "mainly", "focus", "optimize", "kd-tree", "triangle", "culling", "ray-triangle", "intersection", "simple", "often-used", "method", "spatial", "median", "splitting", "which", "plane", "position", "spatial", "median", "longest", "axis", "tree", "node", "volume", "improve", "effectiveness", "researcher", "propose", "SAH", "kd-tree", "-lsb-", "Goldsmith", "Salmon", "1987", "MacDonald", "Booth", "1990", "Havran", "2001", "-rsb-", "fact", "appearance", "kd-tree", "base", "packet", "trace", "-lsb-", "Wald", "et", "al.", "2001", "-rsb-", "frustum", "traversal", "-lsb-", "Reshetov", "et", "al.", "2005", "-rsb-", "SAH", "kd-tree", "have", "become", "best", "know", "acceleration", "structure", "ray", "trace", "static", "scene", "-lsb-", "Stoll", "2005", "-rsb-", "allow", "tradeoff", "between", "tree", "quality", "construction", "speed", "fast", "kd-tree", "algorithm", "-lsb-", "Popov", "et", "al.", "2006", "Hunt", "et", "al.", "2006", "-rsb-", "approximate", "SAH", "use", "piecewise", "linear", "-lrb-", "quadric", "-rrb-", "function", "-lsb-", "Popov", "et", "al.", "2006", "-rsb-", "also", "propose", "parallel", "algorithm", "construct", "tree", "BFS", "order", "up", "certain", "tree", "level", "Shevstov", "et", "al.", "-lsb-", "2007", "-rsb-", "propose", "parallel", "kd-tree", "algorithm", "share", "memory", "architecture", "multi-core", "cpus", "Ray", "Tracing", "GPUs", "Ray", "trace", "gpus", "have", "stimulate", "much", "interest", "recently", "-lsb-", "Carr", "et", "al.", "2002", "-rsb-", "implement", "ray-triangle", "intersection", "GPU", "-lsb-", "Foley", "Sugerman", "2005", "-rsb-", "introduce", "two", "stackless", "kd-tree", "traversal", "algorithm", "which", "outperform", "uniform", "grid", "approach", "-lsb-", "Carr", "et", "al.", "2006", "-rsb-", "implement", "limited", "GPU", "ray", "tracer", "dynamic", "geometry", "base", "bounding-volume", "hierarchy", "geometry", "image", "both", "technique", "use", "stackless", "kd-tree", "traversal", "packet", "trace", "unfortunately", "two", "technique", "work", "static", "scene", "only", "Photon", "mapping", "have", "be", "implement", "gpus", "-lsb-", "Purcell", "et", "al.", "2003", "-rsb-", "use", "36", "cpus", "achieve", "frame", "rate", "up", "22", "fp", "image", "resolution", "640", "480", "section", "we", "describe", "how", "build", "SAH", "kd-tree", "ray", "trace", "GPU", "we", "focus", "SAH", "kd-tree", "streamline", "discussion", "sort", "triangle", "distribute", "they", "two", "child", "instead", "seek", "globally", "optimal", "solution", "exist", "algorithm", "use", "locally", "greedy", "approximation", "assume", "child", "leaf", "node", "algorithm", "large", "Node", "Stage", "procedure", "rocess", "arge", "ode", "-lrb-", "activelist", "list", "out", "smalllist", "nextlist", "list", "-rrb-", "begin", "group", "triangle", "chunk", "each", "node", "activelist", "parallel", "group", "all", "triangle", "node", "fix", "size", "chunk", "store", "chunk", "chunklist", "compute", "per-node", "bound", "box", "each", "chunk", "chunklist", "parallel", "compute", "bound", "box", "all", "triangle", "use", "standard", "reduction", "Perform", "segmented", "reduction", "per-chunk", "reduction", "result", "compute", "per-node", "bound", "box", "split", "large", "node", "each", "node", "activelist", "parallel", "each", "side", "node", "contain", "more", "than", "empty", "space", "side", "Cut", "off", "i?s", "empty", "space", "side", "split", "node", "spatial", "median", "longest", "axis", "each", "create", "child", "node", "ch", "nextlist.add", "-lrb-", "ch", "-rrb-", "sort", "clip", "triangle", "child", "node", "each", "chunk", "chunklist", "parallel", "k.node", "-lrb-", "-rrb-", "each", "triangle", "parallel", "contain", "both", "child", "sort", "two", "child", "node", "clip", "respective", "owner", "node", "else", "sort", "child", "node", "contain", "count", "triangle", "number", "child", "node", "each", "chunk", "chunklist", "parallel", "k.node", "-lrb-", "-rrb-", "count", "triangle", "number", "i?s", "child", "use", "reduction", "Perform", "segmented", "reduction", "per-chunk", "result", "compute", "per-child-node", "triangle", "number", "small", "node", "filter", "each", "node", "ch", "nextlist", "parallel", "ch", "small", "node", "smalllist.add", "-lrb-", "ch", "-rrb-", "nextlist.delete", "-lrb-", "ch", "-rrb-", "end", "initialization", "stage", "global", "memory", "allocate", "tree", "construction", "root", "node", "create", "triangle-node", "association", "list", "store", "triangle", "index", "contain", "node", "list", "sort", "node", "index", "can", "easily", "do", "use", "split", "operation", "describe", "-lsb-", "Sengupta", "et", "al.", "2007", "-rsb-", "instead", "store", "triangle", "set", "triangle-node", "association", "list", "do", "large", "node", "stage", "we", "now", "store", "triangle", "set", "small", "node", "bit", "mask", "its", "smallroot", "show", "fig.", "show", "Algorithm", "bit", "mask", "left", "child", "compute", "bitwise", "bit", "mask", "current", "node", "bit", "mask", "left", "side", "split", "candidate", "which", "precompute", "reprocess", "mall", "ode", "alternative", "method", "compute", "optimal", "splitting", "plane", "-lrb-", "-rrb-", "sort", "all", "split", "candidate", "preprocess" ],
  "content" : "Keywords: kd-tree, programable graphics hardware, ray tracing, photon mapping, point cloud modeling The kd-tree is a well-known space-partitioning data structure for organizing points in k-dimensional space. As an acceleration structure, it has been used in a variety of graphics applications, including triangle culling for ray-triangle intersection tests in ray tracing, nearest photon queries in photon mapping, and nearest neighbor search in point cloud modeling and particle-based fluid simulation. Due to its fundamental importance in graphics, fast kd-tree construction has been a subject of much interest in recent years, with several CPU algorithms proposed [Popov et al. 2006; Hunt et al. 2006; Shevtsov et al. 2007]. Two kd-trees are built from scratch for each frame, one for the scene geometry and the other for the photons. For large nodes at upper tree levels, we use two simple and inexpensive heuristics, median splitting and ?empty space maximizing? [Havran 2001; Wald and Havran 2006], to estimate the costs. The ray tracer achieves interactive rates with shadow and multi-bounce reflection/refraction. GPU Photon Mapping We implemented GPU photon mapping, in which photon tracing, photon kd-tree construction and nearest photon query are all performed on the GPU on the fly (Section 5). Such performance has not been achieved in previous work. Optimized Kd-trees Early research mainly focused on optimizing kd-trees for triangle culling in ray-triangle intersection. A simple but often-used method is spatial median splitting, in which the plane is positioned at the spatial median of the longest axis of the tree node volume. To improve effectiveness, researchers proposed SAH kd-trees [Goldsmith and Salmon 1987; MacDonald and Booth 1990; Havran 2001]. In fact, with the appearance of kd-tree based packet tracing [Wald et al. 2001] and frustum traversal [Reshetov et al. 2005], SAH kd-trees have become the best known acceleration structures for ray tracing of static scenes [Stoll 2005]. To allow a tradeoff between tree quality and construction speed, fast kd-tree algorithms [Popov et al. 2006; Hunt et al. 2006] approximate SAH using a piecewise linear (or quadric) function. [Popov et al. 2006] also proposed a parallel algorithm by constructing the tree in BFS order up to a certain tree level. Shevstov et al. [2007] proposed a parallel kd-tree algorithm for a shared memory architecture with multi-core CPUs. Ray Tracing on GPUs Ray tracing on GPUs has stimulated much interest recently. [Carr et al. 2002] implemented ray-triangle intersection on the GPU. [Foley and Sugerman 2005] introduced two stackless kd-tree traversal algorithms, which outperform the uniform grid approach. [Carr et al. 2006] implemented a limited GPU ray tracer for dynamic geometry based on bounding-volume hierarchies and geometry images. Both techniques use stackless kd-tree traversal and packet tracing. Unfortunately these two techniques work for static scenes only. Photon mapping has been implemented on GPUs [Purcell et al. 2003]. Using 9 to 36 CPUs, they achieved frame rates of up to 22 fps at the image resolution of 640 ? 480. In this section, we describe how to build SAH kd-trees for ray tracing on the GPU. We focus on SAH kd-trees to streamline the discussion. Sort triangles and distribute them to the two children; Instead of seeking a globally optimal solution, existing algorithms use a locally greedy approximation by assuming the children are leaf nodes. Algorithm 2 Large Node Stage procedure P ROCESS L ARGE N ODES ( in activelist:list; out smalllist, nextlist:list) begin // group triangles into chunks for each node i in activelist in parallel Group all triangles in node i into fixed size chunks, store chunks in chunklist // compute per-node bounding box for each chunk k in chunklist in parallel Compute the bounding box of all triangles in k, using standard reduction Perform segmented reduction on per-chunk reduction result to compute per-node bounding box // split large nodes for each node i in activelist in parallel for each side j of node i if i contains more than C e empty space on side j then Cut off i?s empty space on side j Split node i at spatial median of the longest axis for each created child node ch nextlist.add(ch) // sort and clip triangles to child nodes for each chunk k in chunklist in parallel i ? k.node() for each triangle t in k in parallel if t is contained in both children of i then t 0 ? t t 1 ? t Sort t 0 and t 1 into two child nodes Clip t 0 and t 1 to their respective owner node else Sort t into the child node containing it // count triangle numbers for child nodes for each chunk k in chunklist in parallel i ? k.node() Count triangle numbers in i?s children, using reduction Perform segmented reduction on per-chunk result to compute per-child-node triangle number // small node filtering for each node ch in nextlist in parallel if ch is small node then smalllist.add(ch) nextlist.delete(ch) end\n        In the initialization stage, global memory is allocated for tree construction and the root node is created. The triangle-node association list stores triangle indices contained in the node list, sorted by node index. This can be easily done using the split operation described in [Sengupta et al. 2007]. Instead of storing the triangle sets in the triangle-node association lists as is done in the large node stage, we now store triangle sets in small nodes as a bit mask of its smallRoot as shown in Fig. 3 . As shown in Algorithm 4, the bit mask of the left child is computed as the bitwise AND of the bit mask of the current node s and the bit mask of the left side of the split candidate j, which is precomputed in P REPROCESS S MALL N ODES . An alternative method for computing the optimal splitting plane in O(n) is to sort all split candidates in a preprocess.",
  "resources" : [ ]
}