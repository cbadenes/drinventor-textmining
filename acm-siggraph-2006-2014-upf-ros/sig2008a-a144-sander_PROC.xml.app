{
  "uri" : "sig2008a-a144-sander_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2008a/a144-sander_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Efficient Traversal of Mesh Edges using Adjacency Primitives",
    "published" : "2008",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Pedro V.-Sander",
      "name" : "Pedro V.",
      "surname" : "Sander"
    }, {
      "uri" : "http://drinventor/Diego-Nehab",
      "name" : "Diego",
      "surname" : "Nehab"
    }, {
      "uri" : "http://drinventor/Eden-Chlamtac",
      "name" : "Eden",
      "surname" : "Chlamtac"
    }, {
      "uri" : "http://drinventor/Hugues-Hoppe",
      "name" : "Hugues",
      "surname" : "Hoppe"
    } ]
  },
  "bagOfWords" : [ "processing", "mesh", "edge", "lie", "core", "many", "advanced", "realtime", "render", "technique", "range", "from", "shadow", "silhouette", "computation", "motion", "blur", "fur", "rendering", "we", "scheme", "aim", "minimize", "number", "primitive", "while", "maximize", "simd", "parallelism", "objective", "reduce", "set", "discrete", "optimization", "problem", "dual", "graph", "mesh", "we", "develop", "practical", "solution", "graph", "problem", "addition", "we", "extend", "two", "exist", "vertex", "cache", "optimization", "algorithm", "produce", "cache-efficient", "traversal", "ordering", "adjacency", "primitive", "we", "demonstrate", "significant", "runtime", "speedup", "several", "practical", "real-time", "rendering", "algorithm", "keyword", "real-time", "rendering", "silhouette", "shadow", "volume", "vertex", "locality", "programmable", "geometry", "shader", "many", "advanced", "rendering", "technique", "process", "only", "mesh", "face", "also", "mesh", "edge", "application", "include", "shadow", "volume", "-lsb-", "Crow", "1977", "-rsb-", "silhouette", "render", "-lsb-", "Hertzmann", "1999", "Gooch", "Gooch", "2001", "-rsb-", "motion", "blur", "-lsb-", "wloka", "Zeleznik", "1996", "-rsb-", "fur", "rendering", "-lsb-", "Lengyel", "et", "al.", "2001", "-rsb-", "wireframe", "rendering", "paper", "we", "present", "general", "scheme", "optimize", "traversal", "mesh", "efficient", "GPU", "processing", "its", "edge", "we", "knowledge", "first", "attempt", "optimization", "some", "graphic", "application", "require", "traversal", "triangle", "addition", "edge", "we", "explore", "how", "can", "achieve", "efficiently", "same", "traversal", "pass", "separate", "pass", "use", "same", "vertex", "index", "buffer", "show", "Figure", "2a", "each", "primitive", "use", "index", "encode", "central", "cover", "face", "well", "its", "adjacent", "face", "principle", "primitive", "permit", "processing", "cover", "face", "itself", "all", "its", "edge", "all", "its", "adjacent", "face", "we", "goal", "process", "all", "mesh", "edge", "triangle", "exactly", "once", "use", "same", "list", "primitive", "while", "keep", "overall", "number", "primitive", "minimum", "because", "geometry", "shader", "consider", "many", "primitive", "simultaneously", "simd", "parallelism", "GPU", "crucial", "computational", "efficiency", "processing", "each", "primitive", "require", "same", "sequence", "step", "maximize", "simd", "efficiency", "we", "allow", "each", "adjacency", "primitive", "process", "face", "time", "-lrb-", "figure", "2a", "-rrb-", "central", "cover", "face", "optional", "adjacent", "face", "we", "refer", "assign", "face", "further", "improve", "simd", "parallelism", "we", "place", "some", "restriction", "selection", "assign", "face", "discuss", "section", "other", "hand", "around", "any", "irregular", "vertex", "odd", "degree", "least", "one", "edge", "must", "cover", "twice", "therefore", "some", "redundancy", "inevitable", "-lrb-", "figure", "2c", "-rrb-", "algorithm", "overview", "problem", "we", "face", "can", "formulate", "graph", "theoretical", "problem", "dual", "graph", "induce", "triangle", "mesh", "we", "algorithm", "have", "three", "major", "step", "show", "Figure", "vertex", "cover", "problem", "np-complete", "fortunately", "we", "particular", "setting", "we", "can", "rely", "fast", "approximation", "use", "stochastic", "algorithm", "face", "assignment", "problem", "reduce", "two", "bipartite", "matching", "problem", "can", "therefore", "solve", "quickly", "-lrb-", "1.5", "-rrb-", "time", "e.g.", "only", "sec", "mesh", "75,000", "vertex", "particular", "we", "prove", "surprising", "result", "perfect", "matching", "guarantee", "exist", "even", "add", "restriction", "introduce", "simd", "efficiency", "cover", "assignment", "problem", "always", "solve", "offline", "preprocess", "one", "prior", "technique", "compute", "shadow", "volume", "entirely", "GPU", "introduce", "degenerate", "quadrilateral", "each", "edge", "input", "mesh", "selectively", "translate", "vertex", "expand", "fraction", "degenerate", "face", "form", "side", "shadow", "volume", "-lsb-", "Brennan", "2002", "-rsb-", "several", "sample", "program", "demonstrate", "application", "new", "triangle-with-adjacency", "primitive", "-lsb-", "Microsoft", "Corp", "2007", "Tariq", "2007", "-rsb-", "basic", "approach", "all", "program", "instantiate", "primitive", "each", "input", "triangle", "avoid", "processing", "interior", "edge", "twice", "test", "perform", "geometry", "shader", "appropriately", "skip", "half", "edge", "edge", "connect", "two", "vertex", "only", "associate", "triangle", "share", "edge", "E.", "recall", "we", "goal", "create", "minimum", "set", "triangle-withadjacency", "primitive", "allow", "processing", "all", "edge", "mesh", "-lrb-", "-rrb-", "ideally", "we", "would", "like", "find", "minimum", "vertex", "cover", "however", "problem", "np-complete", "-lsb-", "Garey", "Johnson", "1977", "-rsb-", "even", "graph", "maximum", "degree", "arise", "from", "manifold", "triangle", "mesh", "therefore", "we", "look", "heuristic", "produce", "good", "minimal", "cover", "which", "vertex", "can", "trivially", "remove", "without", "leave", "uncovered", "edge", "efficient", "simd", "load-balancing", "we", "assign", "most", "one", "uncovered", "face", "each", "primitive", "primitive", "lack", "assign", "face", "boundary", "one", "its", "edge", "have", "already", "be", "cover", "neighbor", "primitive", "we", "encode", "degenerate", "face", "duplicate", "some", "vertex", "index", "-lrb-", "also", "show", "Figure", "-rrb-", "therefore", "edge", "must", "process", "another", "primitive", "primitive", "center", "face", "-lcb-", "-rcb-", "which", "must", "cover", "face", "too", "thus", "non-boundary", "cover", "face", "lack", "assign", "face", "must", "adjacent", "another", "cover", "face", "which", "also", "lack", "assign", "face", "boundary", "must", "adjacent", "third", "cover", "face", "etc.", "we", "problem", "find", "perfect", "matching", "graph", "from", "we", "again", "use", "hall?s", "theorem", "which", "we", "can", "apply", "marriage", "condition", "satisfied", "now", "consider", "union", "two", "matching", "-lrb-", "figure", "5c", "-rrb-", "Lin", "Yu", "-lsb-", "2006", "-rsb-", "improve", "cache", "efficiency", "use", "triangle", "fan", "optimize", "selection", "base", "age", "vertex", "cache", "number", "cache", "miss", "would", "result" ],
  "content" : "Processing of mesh edges lies at the core of many advanced realtime rendering techniques, ranging from shadow and silhouette computations, to motion blur and fur rendering. Our scheme aims to minimize the number of primitives while maximizing SIMD parallelism. These objectives reduce to a set of discrete optimization problems on the dual graph of the mesh, and we develop practical solutions to these graph problems. In addition, we extend two existing vertex cache optimization algorithms to produce cache-efficient traversal orderings for adjacency primitives. We demonstrate significant runtime speedups for several practical real-time rendering algorithms. Keywords: real-time rendering, silhouettes, shadow volumes, vertex locality, programmable geometry shader. Many advanced rendering techniques process not only mesh faces but also mesh edges. Applications include shadow volumes [Crow 1977], silhouette rendering [Hertzmann 1999; Gooch and Gooch 2001], motion blur [Wloka and Zeleznik 1996], fur rendering [Lengyel et al. 2001], and wireframe rendering. In this paper, we present a general scheme that optimizes the traversal of a mesh for efficient GPU processing of its edges. To our knowledge, this is the first attempt at such an optimization. Some graphics applications require traversal of triangles in addition to edges, and we explore how this can be achieved efficiently in the same traversal pass, or in separate passes using the same vertex and index buffers. As shown in Figure 2a , each such primitive uses 6 indices to encode a central cover face as well as its 3 adjacent faces. In principle, the primitive permits the processing of the cover face itself, all its 3 edges, and all its 3 adjacent faces. Our goal is to process all mesh edges and triangles exactly once, using the same list of primitives, while keeping the overall number of primitives to a minimum. Because the geometry shaders consider many primitives simultaneously with SIMD parallelism on the GPU, it is crucial for computational efficiency that processing each primitive requires the same sequence of steps. To maximize this SIMD efficiency, we allow each adjacency primitive to process 1 or 2 faces at a time (Figure 2a): the central cover face, and an optional adjacent face that we refer to as the assigned face. To further improve SIMD parallelism, we place some restrictions on the selection of assigned faces, as discussed in Section 5. On the other hand, around any irregular vertex of odd degree, at least one edge must be covered twice, and therefore some redundancy is inevitable ( Figure 2c ). Algorithm overview The problems we face can be formulated as graph theoretical problems on the dual graph induced by the triangle mesh. Our algorithm has three major steps, as shown in Figure 1 : 1. The vertex cover problem is NP-complete, but fortunately in our particular setting we can rely on a fast approximation using a stochastic algorithm. The face assignment problem reduces to two bipartite matching problems, and can therefore be solved quickly in O(n 1.5 ) time; e.g. only 4 sec for a mesh with n = 75,000 vertices. In particular, we prove the surprising result that perfect matchings are guaranteed to exist, even with the added restrictions introduced for SIMD efficiency; 3. The cover and assignment problems are always solved in an offline preprocess. One prior technique for computing shadow volumes entirely on the GPU is to introduce a degenerate quadrilateral on each edge of the input mesh, and to selectively translate vertices to expand a fraction of these degenerate faces to form the sides of the shadow volume [Brennan 2002]. Several sample programs demonstrate applications of the new triangle-with-adjacency primitive [Microsoft Corp 2007; Tariq 2007]. The basic approach in all these programs is to instantiate a primitive for each input triangle. To avoid processing interior edges twice, a test is performed in the geometry shader to appropriately skip half of the edges. The edges in E connect two vertices in V if and only if the associated triangles in T share an edge in E. Recall that our goal is to create a minimum set of triangle-withadjacency primitives that allow the processing of all edges in a mesh M (V, E, T ). Ideally, we would like to find the minimum vertex cover in G ? . However, the problem is NP-complete [Garey and Johnson 1977], even for the graphs with maximum degree 3 arising from manifold triangle meshes. Therefore, we look for heuristics that produce  good minimal covers, in which no vertex can be trivially removed without leaving an uncovered edge. For efficient SIMD load-balancing, we assign at most one uncovered face to each primitive. If the primitive lacks an assigned face, is at the boundary, or if one of its edges has already been covered by a neighboring primitive, we encode a degenerate face by duplicating some vertex indices (also shown in Figure 4 ). Therefore, the edge must be processed by another primitive: the primitive centered on face {0, 1, 2}, which must be a cover face too. Thus, if a non-boundary cover face f 1 lacks an assigned face, it must be adjacent to another cover face f 2 , which if it also lacks an assigned face and is not on the boundary, must be adjacent to a third cover face f 3 , etc. Our problem is to find a perfect matching in this graph from A to C. We again use Hall?s theorem, which we can apply if the marriage condition is satisfied. Now consider the union of the two matchings M ?N ( Figure 5c ). Lin and Yu [2006] improve caching efficiency by using triangle fans and optimizing their selection based on the age of the vertex in the cache and the number of cache misses that would result.",
  "resources" : [ ]
}