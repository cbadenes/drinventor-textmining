{
  "uri" : "sig2009-a21-adams_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a21-adams_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Gaussian KD-Trees for Fast High-Dimensional Filtering",
    "published" : null,
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ ]
  },
  "bagOfWords" : [ "we", "have", "describe", "novel", "method", "compute", "broad", "class", "non-linear", "filter", "which", "can", "describe", "equation", "base", "weighted", "importance", "sampling", "modify", "kd-tree", "class", "filter", "include", "bilateral", "filter", "joint", "bilateral", "filter", "non-local", "means", "filter", "related", "filter", "which", "value", "average", "other", "value", "consider", "nearby", "some", "high-dimensional", "space", "bilateral", "filter", "we", "compare", "method", "5d", "extension", "bilateral", "grid", "-lsb-", "Paris", "Durand", "2006", "-rsb-", "find", "which", "method", "superior", "depend", "filter", "size", "use", "higher", "dimensional", "filter", "non-local", "means", "we", "tree-based", "filter", "exhibit", "excellent", "performance", "its", "runtime", "memory", "use", "both", "scale", "linearly", "dimension", "we", "method", "require", "particular", "structure", "input", "so", "we", "also", "apply", "task", "denoise", "geometry", "produce", "novel", "non-local", "means", "filter", "mesh", "several", "issue", "remain", "address", "future", "work", "firstly", "we", "tree", "building", "take", "significant", "fraction", "we", "total", "runtime", "so", "we", "use", "very", "simple", "splitting", "scheme", "possible", "more", "sophisticated", "building", "algorithm", "could", "improve", "runtime", "later", "stage", "enough", "justify", "its", "cost", "secondly", "case", "value", "many", "more", "than", "log", "-lrb-", "-rrb-", "dimension", "splitting", "take", "place", "we", "tree", "do", "adequately", "constrain", "sample?s", "location", "before", "reach", "leaf", "many", "sample", "return", "very", "small", "weight", "attach", "work", "we", "solve", "throw", "away", "least", "important", "dimension", "pca", "may", "other", "tree", "structure", "still", "amenable", "weighted", "importance", "sampling", "while", "more", "strongly", "constrain", "sample", "location", "may", "also", "beneficial", "store", "value", "leaf", "cell", "rather", "than", "point", "somewhere", "within", "they", "would", "improve", "complexity", "algorithm", "remove", "distance", "evaluation", "currently", "require", "compute", "correct", "probability", "leaf", "node", "make", "importance", "sampling", "exact", "rather", "than", "weighted", "would", "compute", "different", "function", "value", "one", "far", "more", "dependent", "specific", "way", "which", "tree", "build", "finally", "tree", "traversal", "extremely", "irregular", "algorithm", "speedup", "we", "observe", "from", "we", "GPU", "implementation", "significantly", "less", "than", "theoretically", "possible", "more", "intelligent", "software", "caching", "portion", "tree", "other", "datum", "structure", "may", "speed", "up", "further" ],
  "content" : "We have described a novel method for computing the broad class of non-linear filters which can be described by Equation 5, based on weighted importance sampling of a modified kd-tree. This class of filters includes bilateral filters, joint bilateral filters, non-local means filters, and related filters in which values are averaged with other values that are considered nearby in some high-dimensional space. For bilateral filtering, we compare this method to a 5D extension of the bilateral grid of [Paris and Durand 2006], and find that which method is superior depends on the filter size used. For higher dimensional filters, such as non-local means, our tree-based filter exhibits excellent performance, as its runtime and memory use both scale linearly with dimension. Our method requires no particular structure to the input, so we also apply it to the task of denoising  geometry to produce a novel non-local means filter for meshes. Several issues remain to be addressed in future work. Firstly, our tree building takes a significant fraction of our total runtime, and so we use a very simple splitting scheme. It is possible that a more sophisticated building algorithm could improve the runtime of later stages enough to justify its cost. Secondly, in cases with n values and many more than log(n) dimensions, the splitting that takes place in our tree does not adequately constrain a sample?s location before it reaches a leaf, and many samples are returned with very small weights attached. In this work, we solved this by throwing away the least important dimensions with PCA, but it may be that other tree structures are still amenable to weighted importance sampling while more strongly constraining sample locations. It may also be beneficial to store values at leaf cells, rather than at a point somewhere within them. This would improve the complexity of the algorithm by removing the distance evaluation currently required to compute the correct probabilities at the leaf nodes, and making the importance sampling exact rather than weighted, but it would compute a different function of the values one far more dependent on the specific way in which the tree was built. Finally, tree traversal is an extremely irregular algorithm, and the speedup we observed from our GPU implementation is significantly less than theoretically possible. More intelligent software caching of portions of the tree and other data structures may speed this up further.",
  "resources" : [ ]
}