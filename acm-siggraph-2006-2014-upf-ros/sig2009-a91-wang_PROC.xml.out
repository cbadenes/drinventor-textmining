{
  "uri" : "sig2009-a91-wang_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2009/a91-wang_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "An Efficient GPU-based Approach for Interactive Global Illumination",
    "published" : "2009",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Rui Wang-null",
      "name" : "Rui Wang",
      "surname" : null
    }, {
      "uri" : "http://drinventor/Kun-Zhou",
      "name" : "Kun",
      "surname" : "Zhou"
    }, {
      "uri" : "http://drinventor/Minghao-Pan",
      "name" : "Minghao",
      "surname" : "Pan"
    }, {
      "uri" : "http://drinventor/Hujun-Bao",
      "name" : "Hujun",
      "surname" : "Bao"
    } ]
  },
  "bagOfWords" : [ "result", "we", "algorithm", "run", "entirely", "GPU", "achieve", "interactive", "rate", "scene", "complex", "illumination", "effect", "we", "method", "also", "handle", "one-bounce", "low-frequency", "glossy", "reflection", "approximate", "both", "sample", "radiance", "field", "brdf", "onto", "spherical", "harmonic", "-lrb-", "sh", "-rrb-", "basis", "set", "result", "we", "algorithm", "enable", "parallel", "computation", "implement", "entirely", "GPU", "achieve", "interactive", "frame", "rate", "variety", "complex", "global", "illumination", "effect", "involve", "photon", "scattering", "pass", "final", "gather", "pass", "accurately", "simulate", "indirect", "lighting", "Render", "Cache", "-lsb-", "Walter", "et", "al.", "1999", "-rsb-", "reuse", "radiance", "sample", "from", "previous", "frame", "reproject", "they", "current", "frame", "follow", "insertion", "small", "number", "new", "sample", "use", "image-space", "computation", "method", "enable", "fast", "one-bounce", "indirect", "lighting", "do", "handle", "multi-bounce", "interreflection", "imperfect", "shadow", "map", "-lsb-", "Ritschel", "et", "al.", "2008", "-rsb-", "evaluate", "approximate", "shadow", "map", "many", "point", "light", "single", "pass", "GPU", "dramatically", "improve", "computation", "speed", "due", "lack", "ray", "trace", "framework", "method", "only", "suitable", "primarily", "diffuse", "surface", "can", "handle", "caustic", "perfectly", "specular", "material", "-lsb-", "hachisuka", "2005", "-rsb-", "introduce", "fast", "acceleration", "method", "final", "gather", "use", "GPU", "rasterization", "greatly", "improve", "offline", "render", "speed", "recently", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "introduce", "fast", "gpu-based", "kd-tree", "algorithm", "real-time", "ray", "trace", "caustic", "we", "method", "build", "upon", "algorithm", "we", "extend", "work", "include", "complex", "illumination", "effect", "multi-bounce", "interreflection", "caustics-incurred", "indirect", "lighting", "section", "provide", "overview", "we", "algorithm", "we", "assume", "scene", "material", "either", "diffuse", "perfectly", "specular", "standard", "method", "we", "can", "extend", "diffuse", "reflection", "one", "final", "bounce", "glossy", "reflection", "use", "spherical", "harmonic", "where", "incident", "radiance", "due", "indirect", "illumination", "incident", "direction", "surface", "brdf", "hemisphere", "center", "around", "surface", "normal", "irradiance", "use", "photon", "mapping", "-lsb-", "Jensen", "2001", "-rsb-", "we", "can", "evaluate", "two", "pass", "first", "pass", "emit", "scatter", "photon", "from", "main", "light", "source", "build", "global", "photon", "map", "caustic", "photon", "map", "each", "photon", "map", "store", "kd-tree", "efficient", "access", "second", "pass", "perform", "final", "gather", "send", "many", "secondary", "ray", "sample", "its", "incident", "radiance", "field", "radiance", "along", "each", "ray", "evaluate", "use", "density", "estimation", "photon", "map", "integrate", "cosine", "function", "accord", "eq", "indirect", "illumination", "change", "smoothly", "over", "scene", "sparse", "sample", "provide", "good", "approximation", "interpolation", "remain", "shade", "point", "avoid", "sequential", "computation", "we", "select", "irradiance", "sample", "point", "ahead", "time", "single", "pass", "allow", "we", "perform", "subsequent", "computation", "parallel", "GPU", "reduce", "cost", "we", "introduce", "efficient", "approach", "approximate", "photon", "tree", "illumination", "cut", "which", "dynamically", "construct", "GPU", "illumination", "cut", "size", "much", "smaller", "than", "total", "number", "photon", "we", "achieve", "significant", "speedup", "density", "estimation", "figure", "show", "main", "building", "block", "we", "algorithm", "first", "we", "build", "kd-tree", "scene", "GPU", "utilize", "ray", "trace", "photon", "mapping", "step", "follow", "kd-tree", "algorithm", "present", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "clustering", "compute", "use", "gpu-based", "adaptive", "sample", "seeding", "follow", "k-means", "we", "perform", "final", "gather", "each", "cluster", "center", "sample", "its", "incident", "radiance", "field", "order", "reduce", "cost", "density", "estimation", "we", "approximate", "global", "photon", "map", "compact", "illumination", "cut", "contain", "4000", "8000", "node", "each", "node?s", "center", "we", "evaluate", "cache", "irradiance", "value", "use", "density", "estimation", "global", "photon", "map", "result", "perform", "density", "estimation", "illumination", "cut", "signifus", "cantly", "faster", "than", "full", "photon", "tree", "finally", "we", "interpolate", "sample", "irradiance", "value", "all", "shade", "point", "produce", "indirect", "lighting", "result", "further", "combine", "direct", "lighting", "caustic", "produce", "final", "image", "we", "algorithm", "require", "use", "kd-tree", "number", "step", "include", "ray", "trace", "photon", "mapping", "k-means", "clustering", "radiance", "interpolation", "therefore", "efficient", "kd-tree", "implementation", "important", "we", "follow", "method", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "build", "kdtree", "real-time", "use", "nvidia?s", "CUDA", "efficient", "GPU", "processing", "node", "classify", "either", "large", "small", "base", "number", "geometric", "primitive", "belong", "they", "fast", "traversal", "kd-tree", "standard", "stackbased", "method", "implement", "maintain", "local", "stack", "each", "thread", "gpu?s", "share", "memory", "direct", "Lighting", "follow", "-lsb-", "Zhou", "et", "al.", "2008", "-rsb-", "we", "use", "ray", "trace", "compute", "direct", "lighting", "follow", "step", "-rrb-", "build", "kdtree", "scene", "trace", "eye", "ray", "parallel", "-rrb-", "collect", "ray", "hit", "non-specular", "surface", "use", "parallel", "list", "compaction", "-lsb-", "Harris", "et", "al.", "2007", "-rsb-", "-rrb-", "similarly", "collect", "ray", "hit", "specular", "surface", "spawn", "reflect", "refract", "ray", "they", "-rrb-", "repeat", "step", "additional", "bounce", "-rrb-", "all", "non-specular", "hit", "point", "perform", "shadow", "test", "compute", "direct", "shading", "parallel", "note", "absence", "specular", "object", "we", "can", "directly", "produce", "shade", "point", "via", "rasterization", "we", "build", "kd-tree", "each", "photon", "map", "afterwards", "we", "next", "step", "select", "among", "all", "shade", "point", "small", "set", "representative", "point", "sampling", "incident", "irradiance", "standard", "caching", "base", "scheme", "achieve", "progressively", "insert", "sample", "point", "exist", "set", "decision", "insert", "more", "sample", "base", "local", "variation", "irradiance", "sample", "already", "store", "set", "reduce", "datum", "parallelism", "since", "insertion", "sample", "irradiance", "evaluation", "dependent", "upon", "each", "other", "while", "require", "progressive", "insertion", "method", "unsuitable", "on-the-fly", "sample", "generation", "due", "expensive", "computation", "allow", "we", "select", "sample", "point", "advance", "before", "irradiance", "evaluation", "step", "begin", "use", "metric", "we", "can", "partition", "shade", "point", "coherent", "shade", "cluster", "center", "each", "cluster", "become", "irradiance", "sample", "point", "do", "so", "we", "use", "modify", "version", "illumination", "change", "term", "introduce", "irradiance", "caching", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "define", "we", "error", "metric", "weighting", "factor", "determine", "relative", "importance", "position", "normal", "incur", "change", "typically", "vary", "between", "0.1", "0.5", "we", "experiment", "-lrb-", "after", "scene", "geometry", "scale", "normalize", "-rrb-", "similar", "irradiance", "caching", "metric", "compute", "purely", "from", "geometric", "property", "intuition", "point", "geometrically", "close", "each", "other", "likely", "receive", "similar", "incident", "illumination", "note", "we", "have", "omit", "harmonic", "distance", "term", "original", "definition", "from", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "however", "we", "introduce", "adaptive", "sample", "seed", "approach", "account", "effect", "term", "explain", "below", "adaptive", "seeding", "Sample", "Points", "term", "original", "irradiance", "cache", "formulation", "account", "effect", "area", "close", "other", "surface", "likely", "experience", "rapid", "illumination", "change", "therefore", "more", "sample", "point", "should", "distribute", "account", "effect", "we", "use", "approximation", "distribute", "initial", "sample", "point", "accord", "local", "geometric", "variation", "scene", "we", "construct", "static", "screen-space", "quadtree", "all", "shade", "point", "each", "quadtree", "node", "we", "compute", "its", "geometric", "variation", "accord", "eq", "treat", "all", "shade", "point", "belong", "quadtree", "node", "cluster", "we", "compute", "efficiently", "GPU", "evaluate", "all", "quadtree", "node", "parallel", "follow", "step", "we", "seed", "initial", "sample", "point", "hierarchically", "accord", "magnitude", "specifically", "we", "from", "root", "node", "quadtree", "each", "node", "we", "distribute", "sample", "point", "its", "four", "child", "node", "proportion", "its", "child", "node", "when", "node", "have", "only", "one", "sample", "distribute", "we", "use", "jitter", "sampling", "randomly", "select", "sample", "point", "within", "quad", "we", "process", "each", "level", "quadtree", "parallel", "k-means", "cluster", "after", "initial", "seeding", "we", "refine", "sample", "point", "use", "k-means", "partition", "all", "shade", "point", "coherent", "cluster", "do", "so", "we", "treat", "seed", "point", "we", "initial", "cluster", "center", "follow", "standard", "k-means", "classify", "every", "shading", "point", "its", "closest", "center", "use", "metric", "define", "eq", "after", "every", "shading", "point", "classify", "we", "recompute", "cluster", "center", "even", "GPU", "above", "algorithm", "still", "quite", "expensive", "run", "reduce", "cost", "we", "need", "avoid", "search", "among", "all", "cluster", "center", "do", "so", "we", "build", "kdtree", "all", "cluster", "center", "beginning", "each", "k-means", "iteration", "every", "shading", "point", "classify", "we", "utilize", "kd-tree", "constrain", "search", "within", "small", "euclidean", "distance", "shade", "point", "thereby", "significantly", "reduce", "search", "range", "Figure", "-lrb-", "-rrb-", "show", "we", "clustering", "result", "Cornell", "box", "scene", "compute", "1600", "cluster", "-lrb-", "-rrb-", "show", "cluster", "center", "top", "accurate", "irradiance", "image", "compute", "use", "offline", "raytracing", "note", "area", "rapid", "illumination", "change", "sample", "densely", "small", "cluster", "while", "those", "slow", "change", "sample", "sparsely", "large", "cluster", "example", "demonstrate", "sample", "we", "select", "conform", "underlie", "illumination", "change", "temporal", "coherence", "since", "we", "recompute", "irradiance", "sample", "point", "among", "shade", "point", "every", "frame", "we", "method", "viewdependent", "subject", "temporal", "artifact", "example", "camera", "move", "quickly", "select", "irradiance", "sample", "point", "differ", "from", "frame", "frame", "cause", "potential", "flicker", "artifact", "beginning", "each", "new", "frame", "we", "fix", "cluster", "center", "compute", "from", "previous", "frame", "estimate", "whether", "every", "shading", "point", "new", "frame", "can", "classify", "exist", "cluster", "do", "so", "we", "keep", "each", "cluster", "largest", "error", "-lrb-", "eq", "-rrb-", "its", "current", "member", "cluster", "center", "use", "value", "threshold", "check", "whether", "new", "shade", "point", "can", "classify", "cluster", "end", "estimation", "we", "eliminate", "those", "cluster", "do", "have", "any", "shading", "point", "associate", "they", "new", "cluster", "generate", "use", "same", "algorithm", "describe", "above", "overall", "we", "maintain", "roughly", "same", "number", "shade", "cluster", "-lrb-", "hence", "irradiance", "sample", "point", "-rrb-", "each", "frame", "once", "irradiance", "sample", "point", "select", "we", "sample", "incident", "radiance", "field", "send", "250", "500", "final", "gather", "ray", "distribute", "accord", "pdf", "cosine", "function", "evaluate", "radiance", "each", "final", "gather", "ray", "standard", "photon", "mapping", "require", "density", "estimation", "which", "perform", "knn", "search", "photon", "tree", "find", "nearby", "photon", "around", "ray?s", "hit", "point", "due", "large", "number", "photon", "search", "cost", "typically", "quite", "high", "idea", "perform", "knn", "search", "reduce", "set", "point", "significantly", "improve", "search", "speed", "we", "achieve", "reduction", "dynamically", "compute", "illumination", "cut", "from", "photon", "tree", "although", "-lsb-", "Walter", "et", "al.", "2005", "-rsb-", "have", "introduce", "efficient", "method", "compute", "cut", "from", "set", "diffuse", "point", "light", "here", "we", "present", "new", "approach", "compute", "illumination", "cut", "directly", "from", "photon", "map", "more", "amenable", "GPU", "do", "so", "we", "first", "estimate", "approximate", "irradiance", "each", "photon", "tree", "node", "compute", "its", "illumination", "density", "define", "where", "power", "photon", "belong", "node", "incoming", "direction", "photon", "normal", "node", "center", "maximum", "side", "length", "node?s", "bound", "box", "equivalent", "perform", "density", "estimation", "use", "all", "photon", "area", "estimation", "overestimate", "search", "neighborhood", "reduce", "estimation", "cost", "note", "compute", "store", "when", "kd-tree", "photon", "map", "build", "thus", "we", "do", "have", "compute", "separately", "we", "next", "step", "find", "cut", "through", "tree", "approximate", "illumination", "give", "approximate", "irradiance", "each", "node", "coarse", "tree-cut", "select", "from", "photon", "tree", "parallel", "first", "node", "irradiance", "larger", "than", "predefined", "threshold", "min", "select", "add", "cut", "different", "level", "tree", "traverse", "iteratively", "ensure", "construction", "valid", "complete", "tree-cut", "we", "pick", "threshold", "min", "average", "node", "12", "13-th", "level", "photon", "tree", "give", "coarse", "tree", "cut", "we", "perform", "optimization", "improve", "its", "accuracy", "do", "compare", "accurate", "irradiance", "evaluate", "node", "p?s", "center", "use", "standard", "density", "estimation", "approximate", "irradiance", "compute", "above", "difference", "between", "two", "larger", "than", "user", "define", "threshold", "-lrb-", "which", "we", "typically", "set", "1.2", "-rrb-", "node", "remove", "from", "cut", "replace", "its", "child", "node", "thereby", "improve", "its", "accuracy", "we", "perform", "iteration", "refinement", "during", "each", "iteration", "node", "independently", "compute", "parallel", "once", "cut", "select", "each", "node", "cut", "become", "sample", "point", "illumination", "we", "therefore", "cache", "accurate", "irradiance", "value", "center", "each", "node", "use", "value", "smooth", "interpolation", "we", "use", "set", "spatial", "radial", "basis", "function", "-lrb-", "rbf", "-rrb-", "center", "each", "cut", "node", "interpolation", "basis", "specifically", "give", "hit", "point", "final", "gather", "ray", "radiance", "ray", "evaluate", "locate", "set", "nearby", "cut", "node", "interpolate", "from", "they", "use", "follow", "weight", "where", "-lrb-", "-rrb-", "maximum", "side", "length", "node", "bound", "box", "note", "subtree", "define", "from", "root", "photon", "tree", "illumination", "cut", "can", "use", "directly", "kd-tree", "neighborhood", "search", "intuitively", "each", "node", "influence", "its", "surrounding", "space", "up", "size", "its", "bound", "box", "quadratic", "falloff", "weight", "represent", "Radiance", "Fields", "use", "SH", "order", "allow", "glossy", "brdf", "final", "bounce", "similar", "previous", "work", "we", "approximate", "directional", "information", "sample", "radiance", "field", "-lrb-", "-rrb-", "use", "spherical", "harmonic", "-lrb-", "sh", "-rrb-", "basis", "-lrb-", "-rrb-", "where", "degree", "order", "sh", "function", "respectively", "we", "use", "4-th", "order", "sh", "we", "experiment", "result", "16", "project", "coefficient", "represent", "vector", "-lrb-", "-rrb-", "diffuse", "material", "we", "can", "treat", "sample", "irradiance", "value", "sh", "vector", "non-zero", "dc", "term", "while", "all", "other", "term", "zero", "interpolation", "render", "we", "interpolate", "irradiance", "value", "store", "each", "irradiance", "sample", "point", "glossy", "material", "we", "interpolate", "sh", "coefficient", "instead", "integrate", "result", "glossy", "brdf", "-lrb-", "also", "project", "onto", "sh", "-rrb-", "step", "require", "scatter", "datum", "interpolation", "which", "involve", "find", "nearby", "irradiance", "sample", "point", "each", "shade", "point", "perform", "smooth", "interpolation", "before", "we", "use", "kd-tree", "irradiance", "sample", "point", "efficient", "neighborhood", "search", "we", "perform", "interpolation", "same", "way", "irradiance", "caching", "-lsb-", "Ward", "et", "al.", "1988", "-rsb-", "j?s", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "j?s", "-lrb-", "-rrb-", "where", "set", "nearby", "irradiance", "sample", "point", "located", "around", "shading", "point", "sample", "-lrb-", "-rrb-", "denote", "sh", "coefficient", "-lrb-", "-rrb-", "interpolation", "weight", "compute", "-lrb-", "-rrb-", "x?s", "-lrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-rrb-", "where", "harmonic", "mean", "distance", "object", "visible", "from", "evaluate", "during", "final", "gather", "keep", "track", "intersection", "distance", "each", "final", "gather", "ray", "perform", "parallel", "reduction", "afterwards", "compute", "harmonic", "distance", "lighting", "complex", "scene", "second", "due", "use", "low-order", "sh", "we", "final", "gather", "step", "limit", "low-frequency", "glossy", "material", "fact", "happen", "reason", "why", "low-dimensional", "illumination", "cut", "suffice", "provide", "high", "quality", "result", "semus", "highly", "glossy", "material", "however", "we", "current", "approach", "inefficient", "material", "would", "require", "much", "longer", "illumination", "cut", "cause", "reduce", "search", "speed", "note", "since", "we", "keep", "full", "global", "photon", "map", "memory", "we", "could", "use", "perform", "more", "accurate", "density", "estimation", "highly", "glossy", "material", "remain", "direction", "we", "future", "work", "addition", "we", "recompute", "irradiance", "sample", "from", "scratch", "each", "frame", "we", "method", "subject", "temporal", "flicker", "artifact", "although", "we", "clustering", "method", "have", "incorporate", "temporal", "coherence", "irradiance", "sample", "artifact", "still", "difficult", "avoid", "completely", "finally", "work", "we", "encounter", "many", "engineering", "challenge", "successfully", "implement", "we", "algorithm", "onto", "GPU", "give", "emerge", "trend", "many-core", "architecture", "design", "we", "believe", "develop", "new", "algorithm", "exploit", "architecture", "longer", "mere", "engineering", "practice", "necessity", "continued", "performance", "improvement", "future", "generation", "hardware", "work", "support", "part", "nsfc", "-lrb-", "no.", "60825201", "-rrb-", "973", "program", "China", "-lrb-", "No.", "2009cb320801", "-rrb-", "NSF", "CAREER", "grant", "ccf-0746577" ],
  "content" : "As a result, our algorithm runs entirely on the GPU, achieving interactive rates for scenes with complex illumination effects. Our method also handles one-bounce of low-frequency glossy reflections by approximating both the sampled radiance fields and BRDFs onto a spherical harmonics (SH) basis set. As a result, our algorithm enables parallel computation and is implemented entirely on the GPU, achieving interactive frame rates for a variety of complex global illumination effects. It involves a photon scattering pass and a final gather pass to accurately simulate indirect lighting. The Render Cache [Walter et al. 1999] reuses radiance samples from previous frames by reprojecting them to the current frame, followed by the insertion of a small number of new samples. Using image-space computation, this method enables fast one-bounce indirect lighting, but does not handle multi-bounce interreflections. Imperfect shadow maps [Ritschel et al. 2008] evaluate approximate shadow maps for many point lights in a single pass on the GPU, dramatically improving the computation speed. Due to the lack of a ray tracing framework, these methods are only suitable for primarily diffuse surfaces, and cannot handle caustics or perfectly specular materials. [Hachisuka 2005] introduced a fast acceleration method for final gather by using GPU rasterization. This greatly improves offline rendering speed. Recently [Zhou et al. 2008] introduced a fast GPU-based kd-tree algorithm for real-time ray tracing and caustics. Our method builds upon this algorithm, and we extend their work to include complex illumination effects such as multi-bounce interreflections and caustics-incurred indirect lighting. This section provides an overview of our algorithm. We assume the scene materials to be either diffuse or perfectly specular. As in standard methods, we can extend diffuse reflections to one final bounce of glossy reflections using spherical harmonics. where L i is the incident radiance due to indirect illumination, ? i is an incident direction, ? is the surface BRDF, H 2 is the hemisphere centered around the surface normal n, and E is the irradiance. Using photon mapping [Jensen 2001], we can evaluate E in two passes. The first pass emits and scatters photons from the main light source, building a global photon map and a caustics photon map. Each photon map is stored in a kd-tree for efficient access. The second pass performs final gather by sending many secondary rays at x to sample its incident radiance field L i . The radiance along each ray is evaluated using density estimation in the photon map, and then integrated with the cosine function according to Eq 1. As indirect illumination changes smoothly over the scene, these sparse samples provide a good approximation for interpolation at the remaining shading points. To avoid the sequential computation, we select irradiance sample points ahead of time in a single pass, allowing us to perform the subsequent computation in parallel on the GPU. To reduce this cost, we introduce an efficient approach that approximates the photon tree as an illumination cut which is dynamically constructed on the GPU. As the illumination cut size is much smaller than the total number of photons, we achieve significant speedup in density estimation. Figure 2 shows the main building blocks of our algorithm. First, we build a kd-tree of the scene on the GPU, and utilize it for ray tracing and photon mapping. These steps follow the kd-tree algorithms presented in [Zhou et al. 2008]. This clustering is computed using GPU-based adaptive sample seeding followed by k-means. We then perform final gather at each cluster center to sample its incident radiance field. In order to reduce the cost of density estimation, we approximate the global photon map as a compact illumination cut containing 4000 ? 8000 nodes. At each node?s center we evaluate and cache an irradiance value by using density estimation in the global photon map. As a result, performing density estimation with the illumination cut is signifi- cantly faster than with the full photon tree. Finally we interpolate the sampled irradiance values at all shading points to produce indirect lighting. The results are further combined with direct lighting and caustics to produce the final image. Our algorithm requires the use of kd-tree in a number of steps, including ray tracing, photon mapping, k-means clustering, and radiance interpolation. Therefore an efficient kd-tree implementation is important. We follow the method in [Zhou et al. 2008] to build kdtrees in real-time using NVIDIA?s CUDA. For efficient GPU processing, nodes are classified as either large or small based on the number of geometric primitives belonging to them. For fast traversal in the kd-tree, a standard stackbased method is implemented by maintaining a local stack for each thread in the GPU?s shared memory. Direct Lighting Following [Zhou et al. 2008], we use ray tracing to compute direct lighting with the following steps: 1) build a kdtree of the scene, and trace eye rays in parallel; 2) collect rays that hit non-specular surfaces using a parallel list compaction [Harris et al. 2007]; 3) similarly, collect rays that hit specular surfaces, and then spawn reflected and refracted rays for them; 4) repeat steps 2 and 3 for additional bounces; 5) for all non-specular hit points, perform shadow tests and compute direct shading in parallel. Note that in the absence of specular objects, we can directly produce shading points via rasterization. We build a kd-tree for each photon map afterwards. Our next step is to select, among all shading points, a small set of representative points for sampling incident irradiance. In standard caching based schemes, this is achieved by progressively inserting sample points into an existing set; and the decision to insert more samples is based on the  local variations of irradiance samples already stored in the set. This reduces data parallelism since the insertion of samples and the irradiance evaluation are dependent upon each other. While not requiring progressive insertions, this method is unsuitable for on-the-fly sample generation due to the expensive computation. This allows us to select sample points in advance, before the irradiance evaluation step begins. Using this metric, we can partition shading points into coherent shading clusters, and the center of each cluster then becomes an irradiance sample point. To do so, we use a modified version of the illumination change term introduced in irradiance caching [Ward et al. 1988] to define our error metric: ? is a weighting factor that determines the relative importance of position and normal incurred changes, and it typically varies between 0.1 ? 0.5 in our experiments (after the scene geometry scale is normalized). Similar to irradiance caching, this metric is computed purely from geometric properties. The intuition is that points that are geometrically close to each other are likely to receive similar incident illumination. Note that we have omitted the harmonic distance term R k in the original definition from [Ward et al. 1988]. However, we introduce an adaptive sample seeding approach to account for the effect of the R k term, as explained below. Adaptive Seeding of Sample Points The R k term in the original irradiance cache formulation accounts for the effect that areas close to other surfaces are likely to experience rapid illumination changes, therefore more sample points should be distributed there. To account for this effect, we use an approximation that distributes initial sample points according to the local geometric variations in the scene. We start by constructing a static, screen-space quadtree of all the shading points. For each quadtree node q, we compute its geometric variation ? q according to Eq 2 by treating all shading points belonging to quadtree node q as a cluster. We compute this efficiently on the GPU by evaluating ? q for all quadtree nodes in parallel. Following this step, we seed K initial sample points hierarchically according to the magnitude of ? q . Specifically, we start from the root node of the quadtree, and at each node we distribute sample points to its four children nodes in proportion to the ? q of its child nodes. When a node has only one sample to distribute, we use jittered sampling to randomly select a sample point within the quad. We process each level of the quadtree in parallel. K-Means Clustering After the initial seeding, we refine the sample points by using k-means to partition all shading points into coherent clusters. To do so, we treat the seeded points as our initial cluster centers, and follow standard k-means to classify every shading point to its closest center using the metric defined in Eq 2. After every shading point is classified, we recompute the cluster center  Even on the GPU, the above algorithm is still quite expensive to run. To reduce this cost, we need to avoid searching among all cluster centers. To do so, we build a kdtree of all cluster centers at the beginning of each k-means iteration; then for every shading point to be classified, we utilize the kd-tree to constrain the search within a small Euclidean distance to that shading point, thereby significantly reducing the search range. Figure 3(a) shows our clustering result for a Cornell box scene computed with 1600 clusters; (b) shows the cluster centers on top of an accurate irradiance image computed using offline raytracing. Note that areas with rapid illumination changes are sampled densely with small clusters, while those with slow changes are sampled sparsely by large clusters. This example demonstrates that the samples we select conform with the underlying illumination changes. Temporal Coherence Since we recompute irradiance sample points among shading points at every frame, our method is viewdependent and is subject to temporal artifacts. For example, if the camera moves quickly, the selected irradiance sample points will differ from frame to frame, causing potential flickering artifacts. At the beginning of each new frame, we fix cluster centers x k computed from the previous frame, then estimate whether every shading point in the new frame can be classified into an existing cluster x k . To do so, we keep at each cluster the largest error (Eq 2) of its current members with the cluster center, then use this value as a threshold to check whether new shading points can be classified into this cluster. At the end of this estimation, we eliminate those clusters in x k that do not have any shading point associated with them. The new clusters are generated using the same algorithm described above. Overall we maintain roughly the same number of shading clusters (hence irradiance sample points) at each frame. Once the irradiance sample points are selected, we sample their incident radiance fields by sending 250 ? 500 final gather rays distributed according to the PDF of a cosine function. To evaluate the radiance for each final gather ray, standard photon mapping requires density estimation, which performs a KNN search in the photon tree to find nearby photons around a ray?s hit point. Due to the large number of photons, the search cost is typically quite high. The idea is that performing KNN search with this reduced set of points significantly improves the search speed. We achieve the reduction by dynamically computing an illumination cut from the photon tree. Although [Walter et al. 2005] have introduced an efficient method for computing cuts from a set of diffuse point lights, here we present a new approach that computes an illumination cut directly from the photon map, and is more amenable to the GPU. To do so, we first estimate an approximate irradiance for each photon tree node p by computing its illumination density, defined as: where ? i is the power of a photon belonging to node p, ? i is the incoming direction of the photon, n p is the normal at the node center, and r p is the maximum side length of the node?s bounding box. This is equivalent to performing a density estimation but using all the photons in p and r p 2 as the area for estimation. This overestimates the search neighborhood but reduces the estimation cost. Note that E p is computed and stored when the kd-tree of the photon map is built, thus we do not have to compute it separately. Our next step is to find a cut through the tree to approximate the illumination. Given the approximated irradiance at each node, a coarse tree-cut is selected from the photon tree in parallel: first, nodes with irradiance larger than a predefined threshold E min are selected and added in the cut. Then, different levels of the tree are traversed iteratively to ensure the construction of a valid and complete tree-cut. We pick the threshold E min as the average E p of nodes at the 12?13-th level of the photon tree. Given the coarse tree cut, we perform an optimization to improve its accuracy. This is done by comparing the accurate irradiance, E p , evaluated at node p?s center using standard density estimation, with the approximated irradiance E p computed above. If the difference between the two is larger than a user defined threshold ? E (which we typically set to 1.2 E p ), the node is removed from the cut and replaced by its children nodes, thereby improving its accuracy. We perform 3?5 iterations of this refinement. During each iteration, nodes are independently computed in parallel. Once the cut is selected, each node of the cut becomes a sample point for illumination. We therefore cache the accurate irradiance value E p at the center of each node and use these values for smooth interpolation. We use a set of spatial radial basis functions (RBFs) centered at each cut node as an interpolation basis. Specifically, given a hit point y of a final gather ray, the radiance of the ray is evaluated by locating a set of nearby cut nodes p j , and interpolating from them using the following weight: where r(p j ) is the maximum side length of node p j ?s bounding box. Note that the subtree defined from the root of the photon tree to the illumination cut can be used directly as a kd-tree for neighborhood search. Intuitively, each node p j influences its surrounding space, up to the size of its bounding box, by a quadratic falloff weight. Representing Radiance Fields using SH In order to allow for glossy BRDFs in the final bounce, similar to previous work, we approximate the directional information of the sampled radiance fields L i (x, ? i ) using a spherical harmonics (SH) basis Y l m (? i ), where l and m are the degree and order of an SH function respectively. We use 4-th order SH in our experiments, resulting in 16 projected l,m coefficients, represented as a vector L i (x). For diffuse materials, we can treat their sampled irradiance value as an SH vector with a non-zero DC term while all other terms are zero. Interpolation To render, we interpolate irradiance values stored at each irradiance sample point. For glossy materials, we interpolate the SH coefficients instead, and integrate the results with glossy BRDFs (also projected onto SH). This step requires scattered data interpolation, which involves finding the nearby irradiance sample points for each shading point, and performing smooth interpolation. As before, we use a kd-tree of the irradiance sample points for efficient neighborhood search. We then perform interpolation in the same way as irradiance caching [Ward et al. 1988]: l,m l,m j?S w(s j )L i (s j ) L i (x) = j?S w(s j ) where S is the set of nearby irradiance sample points located around l,m shading point x, s j is a sample in S, L i (s j ) denotes the SH coefficients, and w(s j ) is the interpolation weight, computed by: 1 w(s j ) = ||x?s R j j || + 2 ? 2 (n(x) ? n(s j )) where R j is the harmonic mean distance to objects visible from s i . It is evaluated during final gather, by keeping track of the intersection distance of each final gather ray, and performing a parallel reduction afterwards to compute the harmonic distance. lighting in a complex scene. Second, due to the use of low-order SH, our final gather step is limited to low-frequency glossy materials. In fact this happens to be the reason why a low-dimensional illumination cut suffices to provide high quality results. For semi to highly glossy materials, however, our current approach is inefficient as these materials would require a much longer illumination cut, causing reduced search speed. Note that since we keep the full global photon map in memory, we could use it to perform more accurate density estimations for these highly glossy materials. This remains a direction for our future work. In addition, as we recompute irradiance samples from scratch at each frame, our method is subject to temporal flickering artifacts. Although our clustering method has incorporated the temporal coherence of irradiance samples, such artifacts are still difficult to avoid completely. Finally, in this work we encountered many engineering challenges in successfully implementing our algorithms onto the GPU. Given the emerging trends of many-core architecture design, we believe that developing new algorithms to exploit such architecture is no longer a mere engineering practice, but a necessity for continued performance improvement on future generations of hardware. This work was supported in part by NSFC (No. 60825201), the 973 program of China (No. 2009CB320801), and NSF CAREER grant CCF-0746577.",
  "resources" : [ ]
}