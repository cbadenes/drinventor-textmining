{
  "uri" : "sig2006-p519-weiss_PROC.xml",
  "url" : "/Users/cbadenes/Documents/OEG/Projects/DrInventor/datasets/acm-siggraph-2006-2014-upf/sig2006/p519-weiss_PROC.xml",
  "source" : {
    "name" : "SIGGRAPH",
    "uri" : "http://drinventor/SIGGRAPH",
    "url" : "http://drinventor/SIGGRAPH",
    "protocol" : "http"
  },
  "metainformation" : {
    "title" : "Fast Median and Bilateral Filtering",
    "published" : "2006",
    "format" : "pdf",
    "language" : "en",
    "rights" : "GPLv2",
    "description" : "",
    "creators" : [ {
      "uri" : "http://drinventor/Ben-Weiss",
      "name" : "Ben",
      "surname" : "Weiss"
    } ]
  },
  "bagOfWords" : [ "f0acc0026248ee23c5d0cf53046bd73183cc0036405d71eab25f10b0d37a8306", "mhd", "http://dx.doi.org/10.1145/1179352.1141918", "name", "identification", "possible", "fast", "median", "bilateral", "filter", "Ben", "Weiss", "Shell", "Slate", "Software", "Corp.", "median", "filter", "cornerstone", "modern", "image", "processing", "use", "extensively", "smoothing", "de-noising", "application", "fastest", "commercial", "implementation", "-lrb-", "e.g.", "Adobe", "Photoshop", "cs2", "-rrb-", "exhibit", "-lrb-", "-rrb-", "runtime", "radius", "filter", "which", "limit", "usefulness", "realtime", "resolution-independent", "context", "we", "introduce", "cpu-based", "vectorizable", "-lrb-", "log", "-rrb-", "algorithm", "median", "filter", "we", "knowledge", "most", "efficient", "yet", "develop", "we", "algorithm", "extend", "image", "any", "bit-depth", "can", "also", "adapt", "perform", "bilateral", "filter", "8-bit", "datum", "we", "median", "filter", "outperform", "photoshop?s", "implementation", "up", "factor", "fifty", "cr", "category", "F.", "2.2", "-lsb-", "analysis", "algorithm", "Problem", "Complexity", "-rsb-", "nonnumerical", "algorithm", "problem", "sort", "searching", "i.", "4.3", "-lsb-", "image", "processing", "computer", "Vision", "-rsb-", "enhancement", "filter", "D.", "2.8", "-lsb-", "Software", "Engineering", "-rsb-", "metric", "Complexity", "measure", "E.", "-lsb-", "datum", "structure", "-rsb-", "array", "keyword", "median", "filter", "bilateral", "filter", "rank-order", "filter", "sort", "image", "processing", "algorithm", "histogram", "datum", "structure", "complexity", "simd", "vector", "processing", "introduction", "1.1", "median", "filter", "median", "filter", "introduce", "tukey", "-lsb-", "1977", "-rsb-", "over", "year", "tremendous", "effort", "have", "go", "its", "optimization", "refinement", "provide", "mechanism", "reduce", "image", "noise", "while", "preserve", "edge", "more", "effectively", "than", "linear", "smoothing", "filter", "many", "common", "image-processing", "technique", "rank-order", "morphological", "processing", "variation", "basic", "median", "algorithm", "filter", "can", "use", "steppingstone", "more", "sophisticated", "effect", "however", "due", "exist", "algorithm", "fundamental", "slowness", "its", "practical", "use", "have", "typically", "be", "restrict", "small", "kernel", "size", "and/or", "low-resolution", "image", "________________________________________", "ben@shellandslate.com", "Adobe", "Photoshop", "cs2", "de", "facto", "standard", "highperformance", "image", "processing", "median", "filter", "scale", "radius", "100", "filter", "exhibit", "roughly", "-lrb-", "-rrb-", "runtime", "per", "pixel", "constraint", "which", "significantly", "reduce", "its", "performance", "large", "filter", "kernel", "variety", "-lrb-", "-rrb-", "algorithm", "well", "know", "-lrb-", "e.g.", "huang", "1981", "-rrb-", "obvious", "faster", "algorithm", "should", "exist", "median", "filter", "separable", "nor", "linear", "iterative", "strategy", "produce", "final", "result", "e.g.", "gaussian", "blur", "-lsb-", "heckbert", "1986", "-rsb-", "fast", "fourier", "transform", "-lsb-", "Cooley", "et", "al.", "1965", "-rsb-", "fast", "high-radius", "implementation", "would", "considerable", "theoretical", "practical", "value", "Gil", "et", "al.", "-lsb-", "1993", "-rsb-", "make", "significant", "progress", "tree-based", "-lrb-", "log", "-rrb-", "median-filtering", "algorithm", "its", "per-pixel", "branch", "nature", "render", "ill-suited", "deep-pipelined", "vector-capable", "modern", "processor", "other", "effort", "have", "resort", "massive", "parallelism", "presumption", "single", "processor", "insufficient", "accord", "Wu", "et", "al.", "-lsb-", "2003", "-rsb-", "...", "design", "parallel", "algorithm", "process", "-lsb-", "median", "filter", "-rsb-", "only", "way", "get", "real-time", "response", "Ranka", "et", "al.", "-lsb-", "1989", "-rsb-", "propose", "parallel", "algorithm", "processor-time", "complexity", "-lrb-", "log", "-rrb-", "curve", "actually", "scale", "worse", "than", "linear", "55", "-lrb-", "-rrb-", "point", "which", "increase", "radius", "correspond", "increase", "computation", "we", "algorithm", "overcome", "all", "limitation", "achieve", "-lrb-", "log", "-rrb-", "runtime", "per", "pixel", "8-bit", "datum", "both", "median", "bilateral", "filter", "fully", "vectorizable", "use", "just", "-lrb-", "-rrb-", "storage", "also", "adapt", "-lrb-", "log", "-rrb-", "algorithm", "arbitrary-depth", "image", "which", "run", "up", "twenty", "time", "fast", "photoshop?s", "16-bit", "median", "filter", "we", "knowledge", "present", "-lrb-", "log", "-rrb-", "algorithm", "most", "efficient", "2d", "median", "filter", "yet", "develop", "process", "8-bit", "datum", "up", "fifty", "time", "faster", "than", "Photoshop?s", "median", "filter", "copyright", "2006", "Association", "Computing", "Machinery", "Inc.", "permission", "make", "digital", "hard", "copy", "part", "all", "work", "personal", "classroom", "use", "grant", "without", "fee", "provide", "copy", "make", "distribute", "commercial", "advantage", "copy", "bear", "notice", "full", "citation", "first", "page", "copyright", "component", "work", "own", "other", "than", "ACM", "must", "honor", "abstract", "credit", "permit", "copy", "otherwise", "republish", "post", "server", "redistribute", "list", "require", "prior", "specific", "permission", "and/or", "fee", "request", "permission", "from", "Permissions", "Dept", "ACM", "Inc.", "fax", "+1", "-lrb-212-rrb-Â 869-0481", "e-mail", "figure", "8-bit", "median", "Filter", "Performance", "permissions@acm.org", "2006", "ACM", "0730-0301/06", "07000519", "5.00", "519", "figure", "median", "Filter", "Variations", "top", "row", "original", "sharpen", "gaussian", "sharpen", "median", "-lrb-", "note", "fewer", "halo", "artifact", "-rrb-", "Middle", "row", "filter", "20th", "50th", "-lsb-", "median", "-rsb-", "80th", "percentile", "bottom", "row", "high", "pass", "use", "median", "bilateral", "smoothing", "filter", "logarithmic", "bilateral", "filter", "1.2", "Bilateral", "Filtering", "Bilateral", "filter", "introduce", "Tomasi", "et", "al.", "-lsb-", "1998", "-rsb-", "non-iterative", "means", "smooth", "image", "while", "retain", "edge", "detail", "involve", "weighted", "convolution", "which", "weight", "each", "pixel", "depend", "only", "its", "distance", "from", "center", "pixel", "also", "its", "relative", "intensity", "describe", "bilateral", "filter", "have", "nominal", "-lrb-", "-rrb-", "computational", "cost", "per", "pixel", "Photoshop", "cs2?s", "16-bit", "surface", "blur", "filter", "reflect", "-lrb-", "-rrb-", "complexity", "become", "unusably", "slow", "even", "moderate", "radius", "8-bit", "datum", "Photoshop?s", "surface", "blur", "exhibit", "performance", "curve", "nearly", "identical", "its", "8-bit", "median", "filter", "suggest", "share", "same", "core", "-lrb-", "-rrb-", "algorithm", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "develop", "much", "more", "efficient", "technique", "refine", "accelerate", "Paris", "et", "al.", "-lsb-", "2006", "-rsb-", "durand?s", "method", "approximate", "bilateral", "filter", "subsampled", "copy", "image", "discrete", "intensity", "kernel", "recombine", "result", "use", "linear", "interpolation", "have", "paradoxical", "property", "become", "faster", "radius", "increase", "-lrb-", "due", "greater", "subsampling", "-rrb-", "also", "have", "some", "potential", "drawback", "one", "translation-invariant", "exact", "output", "dependent", "phase", "subsampling", "grid", "also", "discretization", "may", "lead", "further", "loss", "precision", "particularly", "high-dynamic-range", "image", "narrow", "intensity-weighting", "function", "we", "bilateral", "filter", "algorithm", "maintain", "high", "resolution", "both", "space", "intensity", "translation-invariant", "base", "box", "spatial", "kernel", "which", "can", "iterate", "yield", "smooth", "spatial", "falloff", "derive", "from", "same", "core", "algorithm", "we", "fast", "-lrb-", "log", "-rrb-", "median", "filter", "adapt", "16-bit", "HDR", "datum", "minimal", "loss", "precision", "1.3", "structure", "we", "approach", "paper", "first", "illustrate", "conventional", "-lrb-", "-rrb-", "median", "algorithm", "8-bit", "image", "analyze", "its", "performance", "limitation", "we", "show", "step", "how", "improve", "first", "constant", "factor", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "algorithm", "from", "-lrb-", "log", "-rrb-", "algorithm", "we", "show", "how", "we", "approach", "adapt", "higher", "bit-depth", "datum", "16-bit", "HDR", "floating-point", "finally", "we", "show", "how", "algorithm", "can", "adapt", "perform", "bilateral", "filter", "compare", "previous", "method", "basic", "algorithm", "-lrb-", "-rrb-", "consider", "case", "apply", "radius-r", "median", "filter", "8-bit", "image", "assume", "source", "image", "larger", "than", "destination", "pixel", "all", "side", "sidestep", "edge-related", "concern", "-lrb-", "practice", "we", "repeat", "edge", "pixel", "fill", "undefined", "area", "process", "color", "image", "per-channel", "basis", "-rrb-", "because", "median", "filter", "local", "can", "apply", "arbitrary-size", "image", "tile", "consequence", "its", "total", "runtime", "scale", "linearly", "image", "area", "-lrb-", "-rrb-", "s-by-s", "image", "fundamental", "property", "concern", "we", "here", "runtime", "per", "pixel", "function", "filter", "radius", "correspond", "performance", "user", "experience", "while", "adjust", "filter", "radius", "primary", "differentiate", "characteristic", "between", "medianfilter", "algorithm", "reference", "brute-force", "implementation", "can", "calculate", "each", "output", "pixel", "-lrb-", "log", "-rrb-", "time", "sort", "corresponding", "-lrb-", "2r", "-rrb-", "pixel", "input", "window", "select", "median", "value", "output", "discrete", "datum", "radix-sort", "can", "use", "reduce", "sort", "complexity", "-lrb-", "-rrb-", "operation", "can", "do", "some", "floating-point", "datum", "well", "-lsb-", "Terdiman", "2000", "-rsb-", "case", "8-bit", "datum", "we", "use", "256-element", "histogram", "once", "input", "value", "add", "median", "value", "lie", "first", "index", "which", "sum", "value", "index", "reach", "2r", "2r", "median", "index", "can", "find", "integrate", "histogram", "from", "one", "end", "until", "appropriate", "sum", "reach", "improve", "algorithm", "propose", "Huang", "-lsb-", "1981", "-rsb-", "base", "observation", "adjacent", "window", "overlap", "considerable", "extent", "huang?s", "algorithm", "make", "use", "sequential", "overlap", "consolidate", "redundant", "calculation", "reduce", "computational", "complexity", "-lrb-", "-rrb-", "modify", "version", "huang?s", "algorithm", "below", "huang?s", "algorithm", "significant", "improvement", "over", "bruteforce", "method", "however", "window-sliding", "step", "dominate", "calculation", "-lrb-", "-rrb-", "runtime", "per", "pixel", "while", "histogramscanning", "take", "constant", "time", "per", "pixel", "suggest", "we", "should", "look", "way", "make", "window-sliding", "faster", "even", "expense", "make", "histogram-scanning", "slower", "observe", "window", "zigzag", "through", "image", "pass", "through", "each", "region", "several", "time", "perform", "nearly", "same", "operation", "each", "pass", "-lrb-", "Picture", "mow", "you", "lawn", "back", "forth", "shift", "sideways", "one", "centimeter", "each", "time", "-rrb-", "redundancy", "considerable", "mirror", "adjacent-window", "overlap", "lead", "huang?s", "algorithm", "difficulty", "redundant", "calculation", "occur", "widely", "space", "time", "interval", "computation", "perhaps", "ten", "thousand", "processor", "cycle", "apart", "so", "can", "combine", "use", "same", "sequential", "logic", "lead", "-lrb-", "-rrb-", "technique", "yet", "eliminate", "redundancy", "key", "dramatically", "faster", "algorithm", "520", "radius", "median", "filter", "-lrb-", "show", "above", "-rrb-", "256-element", "histogram", "input", "image", "2r", "pixel", "square", "output", "image", "-lsb-", "inset", "-rsb-", "pixel", "square", "initialize", "-lsb-", "2r", "-rsb-", "-lsb-", "2r", "-rsb-", "yellow", "region", "find", "median", "value", "write", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "row", "add", "value", "-lsb-", "2r", "row", "-rsb-", "-lsb-", "2r", "-rsb-", "H.", "subtract", "value", "-lsb-", "row", "-rsb-", "-lsb-", "2r", "-rsb-", "from", "H.", "find", "median", "value", "write", "-lsb-", "row", "-rsb-", "-lsb-", "-rsb-", "step", "sideways", "next", "column", "-lrb-", "process", "bottom", "top", "etc.", "-rrb-", "Figure", "pseudocode", "huang?s", "-lrb-", "-rrb-", "algorithm", "algorithm", "-lrb-", "log", "-rrb-", "3.1", "synchronicity", "fundamental", "idea", "behind", "paper", "mechanism", "enable", "we", "fast", "algorithm", "observation", "multiple", "column", "process", "once", "aforementioned", "redundant", "calculation", "become", "sequential", "give", "we", "opportunity", "consolidate", "they", "result", "huge", "increase", "performance", "3.2", "Distributive", "Histograms", "straightforward", "adaptation", "huang?s", "algorithm", "process", "column", "once", "involve", "maintenance", "histogram", "one", "per", "output", "column", "n-1", "essentially", "just", "rearrangement", "operation", "runtime", "complexity", "unchanged", "each", "input", "pixel", "get", "add", "2r", "histogram", "over", "course", "filter", "image", "lead", "-lrb-", "-rrb-", "runtime", "complexity", "fortunately", "explicit", "maintenance", "each", "histogram", "unnecessary", "due", "distributive", "property", "histogram", "where", "we", "approach", "diverge", "from", "huang?s", "algorithm", "histogram", "distributivity", "mean", "disjoint", "image", "region", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "-rsb-", "-lrb-", "-rrb-", "other", "word", "image", "window", "union", "two", "disjoint", "region", "its", "histogram", "equal", "median", "element", "can", "find", "scan", "implicit", "histogram", "splicing", "together", "from", "fly", "-lrb-", "extend", "sign", "linear", "combination", "etc.", "-rrb-", "case", "median-filtering", "column", "we", "approach", "form", "set", "partial", "histogram", "n-1", "-lrb-", "whose", "element", "may", "sign", "-rrb-", "each", "histogram", "n-1", "representable", "sum", "partial", "histogram", "from", "Figure", "show", "how", "row", "pixel", "2r", "+8", "add", "case", "histogram", "set", "arrange", "like", "tree", "central", "histogram", "-lrb-", "-rrb-", "represent", "input", "window", "central", "column", "other", "partial", "histogram", "represent", "difference", "between", "central", "adjacent", "window", "sum", "each", "partial", "plus", "central", "histogram", "yield", "full", "histogram", "corresponding", "square", "input", "window", "widen", "yellow", "central", "region", "fitting", "partial", "histogram", "its", "edge", "9-column", "technique", "can", "adapt", "perform", "median", "filter", "arbitrary", "radius", "time", "spend", "modify", "still", "-lrb-", "-rrb-", "much", "lower", "constant", "than", "huang?s", "algorithm", "median", "extraction", "time", "from", "remain", "constant", "regardless", "more", "fundamental", "improvement", "efficiency", "come", "when", "we", "allow", "number", "column", "vary", "conceptually", "add", "more", "plane", "Figure", "output", "column", "number", "modification", "per", "output", "pixel", "-lrb-", "4r", "-rrb-", "N.", "-lrb-", "graphic", "Figure", "show", "case", "require", "98", "adjustment", "per", "row", "about", "11", "per", "output", "pixel", "-rrb-", "solve", "minimize", "number", "adjustment", "give", "which", "yield", "-lrb-", "-rrb-", "histogram", "modification", "per", "pixel", "thus", "complexity", "variable-n", "adaptive", "algorithm", "-lrb-", "-rrb-", "Huang", "we", "Method", "mapping", "-lsb-", "2r", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "2r", "+1", "2r", "+4", "-rsb-", "--", "-lsb-", "2r", "+1", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "2r", "+2", "2r", "+4", "-rsb-", "--", "-lsb-", "2r", "+2", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "2r", "+3", "2r", "+4", "-rsb-", "--", "-lsb-", "2r", "+3", "-rsb-", "-lsb-", "-rsb-", "-lsb-", "2r", "+4", "-rsb-", "--", "-lsb-", "2r", "+4", "-rsb-", "-lsb-", "...", "...", "...", "...", "...", "2r", "+4", "-rsb-", "-lsb-", "2r", "+5", "-rsb-", "-lsb-", "-rsb-", "--", "-lsb-", "2r", "+5", "-rsb-", "-lsb-", "2r", "+6", "-rsb-", "-lsb-", "-rsb-", "--", "-lsb-", "2r", "+5", "2r", "+6", "-rsb-", "-lsb-", "2r", "+7", "-rsb-", "-lsb-", "-rsb-", "--", "-lsb-", "2r", "+5", "2r", "+7", "-rsb-", "-lsb-", "2r", "+8", "-rsb-", "-lsb-", "-rsb-", "--", "-lsb-", "2r", "+5", "2r", "+8", "-rsb-", "18r", "operation", "2r", "41", "operation", "figure", "add", "row", "pixel", "case", "each", "layer", "show", "how", "corresponding", "histogram", "form", "from", "partial", "histogram", "pseudocode", "show", "how", "row", "pixel", "2r", "+8", "add", "hole", "represent", "pixel", "add", "central", "histogram", "subtract", "from", "partial", "histogram", "cancel", "themselves", "out", "521", "3.3", "three", "tier", "Beyond", "Figure", "Histogram", "Layout", "63", "Figure", "show", "layout", "processing", "sixty-three", "column", "once", "three-tiered", "analogue", "Figure", "time", "view", "from", "side", "single", "shared", "histogram", "31", "-lsb-", "yellow", "-rsb-", "correspond", "central", "window", "eight", "partial", "histogram", "-lsb-", "orange", "-rsb-", "seven-pixel", "interval", "each", "six", "small", "partial", "histogram", "-lsb-", "red", "-rsb-", "unit", "interval", "sixty-three", "histogram", "altogether", "each", "input", "pixel", "added/subtracted", "each", "histogram", "intersect", "its", "column", "example", "63-by-1", "block", "output", "produce", "each", "iteration", "mapping", "become", "31", "n/7", "+3", "-lrb-", "-rrb-", "where", "second", "third", "term", "ignore", "match", "earlier", "term", "-lrb-", "e.g.", "24", "31", "24", "-rrb-", "structure", "recursive", "central", "yellow", "histogram", "form", "rough", "approximation", "any", "particular", "orange", "partial", "histogram", "refine", "approximation", "red", "histogram", "provide", "final", "correction", "make", "sum", "exact", "once", "initialize", "full", "histogram", "each", "63", "square", "input", "window", "expressible", "per", "eq", "sum", "one", "red", "histogram", "-lrb-", "none", "-rrb-", "one", "orange", "histogram", "-lrb-", "none", "-rrb-", "yellow", "central", "histogram", "illustrated", "case", "63", "31", "require", "18", "histogram", "modification", "per", "output", "pixel", "median-extraction", "from", "take", "constant", "time", "three", "partial", "histogram", "splice", "together", "fly", "general", "case", "3-tiered", "structure", "process", "column", "once", "tier", "radix", "number", "histogram", "adjustment", "per", "output", "pixel", "become", "-lrb-", "-lrb-", "4r", "-rrb-", "-rrb-", "radius", "solve", "optimal", "yield", "4r", "runtime", "threetiered", "adaptive", "algorithm", "therefore", "-lrb-", "-rrb-", "practice", "three", "tier", "cover", "realistic", "range", "implementation", "-lrb-", "hundred", "-rrb-", "we", "technique", "can", "extend", "arbitrary", "limit", "radius-r", "median", "filter", "can", "compute", "across", "-lrb-", "-rrb-", "column", "once", "use", "histogram", "arrange", "-lrb-", "log", "-rrb-", "tier", "constant", "radix", "example", "radius", "one-million", "median", "filter", "can", "compute", "across", "531,441", "column", "once", "use", "partial", "histogram", "arrange", "seven", "tier", "radix", "occupy", "roughly", "500", "megabyte", "storage", "slide", "window", "from", "one", "row", "next", "require", "-lrb-", "log", "-rrb-", "114", "histogram", "modification", "per", "output", "pixel", "extract", "each", "median", "take", "-lrb-", "log", "-rrb-", "step", "case", "splicing", "up", "seven", "partial", "histogram", "together", "construct", "each", "counterbalance", "-lrb-", "log", "-rrb-", "complexity", "write", "therefore", "overall", "computational", "cost", "per", "pixel", "-lrb-", "log", "-rrb-", "radius", "median", "filter", "array", "partial", "histogram", "process", "column", "input", "image", "2r", "pixel", "square", "output", "image", "pixel", "square", "each", "row", "-lsb-", "2r", "-rsb-", "initialize", "add", "row", "-lsb-", "row", "-rsb-", "-lsb-", "2r", "-rsb-", "per", "figure", "each", "output", "pixel", "-lsb-", "-rsb-", "-lsb-", "col", "-rsb-", "compute", "first", "median", "value", "scan", "col", "-lrb-", "implicit", "-rrb-", "find", "median", "write", "-lsb-", "-rsb-", "-lsb-", "col", "-rsb-", "m.", "row", "step", "from", "top", "bottom", "image", "add", "new", "bottom", "row", "-lsb-", "row", "2r", "-rsb-", "-lsb-", "2r", "-rsb-", "subtract", "old", "top", "row", "-lsb-", "row", "-rsb-", "-lsb-", "2r", "-rsb-", "from", "find", "new", "median", "value", "write", "-lsb-", "row", "-rsb-", "-lsb-", "-rsb-", "Figure", "pseudocode", "-lrb-", "log", "-rrb-", "algorithm", "522", "3.4", "Implementation", "Notes", "scan", "histogram", "from", "index", "zero", "find", "median", "take", "about", "128", "step", "average", "Huang", "-lsb-", "1981", "-rsb-", "suggest", "use", "each", "output", "value", "pivot", "find", "next", "median", "value", "scan", "find", "we", "keep", "track", "number", "value", "we", "add", "remove", "pixel", "from", "we", "keep", "run", "count", "how", "many", "value", "satisfy", "allow", "we", "scan", "update", "histogram", "start", "from", "which", "typically", "much", "faster", "than", "start", "from", "index", "zero", "heuristic", "adapt", "-lrb-", "log", "-rrb-", "algorithm", "use", "-lrb-", "log", "-rrb-", "pivot", "across", "column", "each", "pivot", "track", "smallest", "median", "value", "its", "respective", "column", "approach", "obtain", "much", "benefit", "heuristic", "while", "preserve", "-lrb-", "log", "-rrb-", "complexity", "since", "pivot", "tracking", "involve", "many", "consecutive", "bytewise", "compare", "ideally", "suit", "vector", "optimization", "finally", "useful", "interleave", "partial", "histogram", "memory", "so", "multiple", "adjacent", "histogram", "can", "modify", "simultaneously", "use", "vector", "load", "store", "greatly", "accelerate", "reading", "writing", "Figure", "Pivot", "Tracking", "middle", "image", "show", "approximation", "obtain", "use", "one", "pivot", "per", "sixteen", "column", "track", "smallest", "median", "value", "scan", "upward", "from", "pivot", "-lrb-", "several", "column", "time", "vectorize", "-rrb-", "yield", "exact", "median", "result", "right", "Higher-Depth", "median", "filtering", "4.1", "adapt", "8-bit", "algorithm", "16-bit", "hdr", "image", "have", "already", "become", "mainstream", "so", "important", "we", "median", "filter", "work", "image", "arbitrary", "bitdepth", "direct", "extension", "8-bit", "algorithm", "problematic", "because", "histogram", "must", "stretch", "accommodate", "every", "possible", "value", "grow", "exponentially", "bit-depth", "algorithm", "still", "remain", "-lrb-", "log", "-rrb-", "storage", "consideration", "render", "impractical", "16-bit", "image", "impossible", "floating-point", "image", "4.2", "ordinal", "transform", "reduce", "manageable", "size", "through", "technique", "we", "call", "ordinal", "transform", "involve", "sort", "input", "image", "value", "store", "sort", "list", "replace", "each", "cardinal", "value", "its", "ordinal", "equivalent", "-lrb-", "duplicate", "cardinal", "value", "map", "consecutive", "ordinal", "value", "-rrb-", "median", "filter", "apply", "ordinal", "image", "transform", "invert", "restore", "cardinalvalued", "result", "ordinal", "transform", "operate", "image", "any", "depth", "logarithmic", "constant", "time", "per", "pixel", "operation", "nonlinearity", "median", "filter", "crucial", "any", "linear", "filter", "-lrb-", "e.g.", "gaussian", "blur", "-rrb-", "would", "invariant", "under", "ordinal", "transform", "median", "filter", "because", "rank-order", "preserve", "th", "smallest", "cardinal", "value", "map", "th", "smallest", "ordinal", "value", "after", "ordinal", "transform", "apply", "median", "filter", "proceeds", "section", "time", "use", "single-bit", "histogram", "-lrb-", "sufficient", "here", "because", "each", "ordinal", "value", "unique", "image", "-rrb-", "result", "inversetransform", "yield", "final", "filtered", "image", "recall", "histogram", "element", "can", "go", "negative", "first", "appear", "problematic", "because", "require", "range", "-lsb-", "-1", "-rsb-", "doesn?t", "fit", "single", "bit", "however", "since", "each", "sum", "implicit", "histogram", "value", "-lsb-", "-rsb-", "can", "only", "either", "zero", "one", "only", "lowest", "bit", "from", "each", "partial", "histogram", "must", "participate", "summation", "hence", "single", "bit", "sufficient", "each", "element", "splicing", "accomplish", "through", "bitwise", "xor", "Figure", "Ordinal", "Transform", "duplicate", "cardinal", "value", "-lrb-", "e.g.", "94", "94", "leave", "-rrb-", "map", "consecutive", "ordinal", "value", "-lrb-", "right", "-rrb-", "4.3", "compound", "histogram", "process", "column", "parallel", "approach", "still", "require", "allocation", "maintenance", "single-bit", "histogram", "however", "due", "uniqueness", "value", "ordinal", "image", "we", "can", "take", "advantage", "much", "more", "efficient", "encoding", "consider", "full", "histogram", "obtain", "splicing", "th", "set", "partial", "histogram", "-lrb-", "consist", "central", "histogram", "plus", "one", "partial", "histogram", "from", "each", "tier", "-rrb-", "yield", "single-bit", "histogram", "th", "input", "window", "label", "binary", "histogram", "definition", "single", "bit", "-lsb-", "-rsb-", "indicate", "whether", "ordinal", "value", "lie", "input", "window", "n.", "now", "min", "-lrb-", "2r", "128", "-rrb-", "instead", "allocate", "binary", "histogram", "we", "allocate", "single", "8-bit", "compound", "histogram", "row", "pixel", "-lsb-", "row", "-rsb-", "-lsb-", "col", "-rsb-", "add", "we", "adjust", "follow", "0xff", "col", "col", "-lsb-", "-rsb-", "0x80", "col", "2r", "0x80", "-lrb-", "col", "2r", "-rrb-", "col", "2r", "since", "ordinal", "value", "can", "have", "any", "arrangement", "compound", "histogram", "fill", "arbitrary", "order", "row", "pixel", "remove", "corresponding", "element", "zero", "power", "technique", "become", "clear", "when", "come", "time", "scan", "implicit", "histogram", "find", "th", "median", "output", "value", "we", "initial", "approach", "each", "implicit", "histogram", "splice", "together", "from", "-lrb-", "log", "-rrb-", "partial", "histogram", "take", "-lrb-", "log", "-rrb-", "time", "per", "element", "compound", "histogram", "use", "8-bit", "modular", "arithmetic", "element", "can", "now", "compute", "constant", "time", "523", "Figure", "compound", "histogram", "-lsb-", "-rsb-", "-lrb-", "-lsb-", "-rsb-", "-rrb-", ">>", "128", "technique", "extend", "straightforward", "manner", "16-bit", "compound", "histogram", "sufficient", "32768", "so", "computational", "complexity", "independent", "element", "size", "4.4", "Coarse-To-Fine", "Recursion", "one", "final", "detail", "radius", "increase", "histogram", "size", "scale", "-lrb-", "-rrb-", "which", "directly", "affect", "histogram", "scanning", "distance", "thus", "algorithm?s", "time-complexity", "complication", "address", "compute", "median", "stage", "from", "coarse", "fine", "precision", "Alparone", "et", "al.", "-lsb-", "1994", "-rsb-", "apply", "similar", "technique", "-lrb-", "-rrb-", "algorithm", "employ", "two", "level", "resolution", "process", "10", "12", "14-bit", "image", "faster", "-lrb-", "still", "-lrb-", "-rrb-", "-rrb-", "time", "here", "we", "apply", "analogous", "technique", "we", "log-time", "algorithm", "we", "case", "coarse-to-fine", "calculation", "perform", "rightshift", "ordinal", "image", "bit", "time", "-lrb-", "similar", "radix", "-rrb-", "until", "reach", "fixed", "low", "resolution", "e.g.", "10", "bit", "per", "pixel", "-lrb-", "log", "-rrb-", "algorithm", "from", "section", "apply", "low-resolution", "datum", "-lrb-", "whose", "value", "longer", "unique", "-rrb-", "store", "only", "median", "value", "also", "number", "value", "strictly", "below", "median", "result", "form", "pivot", "from", "which", "we", "calculate", "median", "next-higher", "level", "resolution", "example", "lowest-resolution", "median", "value", "pixel", "0x84", "value", "below", "0x84", "its", "histogram", "value", "below", "0x8400", "next-higher-resolution", "histogram", "median", "-lsb-", "0x8400", "0x84ff", "-rsb-", "scanning", "bound", "constant", "-lsb-", "256", "-rsb-", "number", "step", "per", "iteration", "each", "iteration", "add", "eight", "bit", "precision", "output", "final", "iteration", "perform", "use", "compound", "histogram", "which", "yield", "full-precision", "ordinal", "result", "entire", "process", "require", "-lrb-", "log", "-rrb-", "level", "recursion", "each", "take", "-lrb-", "log", "-rrb-", "time", "show", "section", "overall", "computational", "complexity", "-lrb-", "log", "-rrb-", "4.5", "Implementation", "Notes", "apply", "radius-r", "median", "filter", "ordinal", "image", "can", "output", "any", "lowest", "-lrb-", "2r", "2r", "-rrb-", "ordinal", "value", "because", "definition", "median", "must", "exceed", "many", "value", "filter", "can", "thus", "treat", "all", "value", "single", "low", "constant", "likewise", "-lrb-", "2r", "2r", "-rrb-", "highest", "value", "single", "high", "constant", "without", "affect", "final", "result", "endpoint", "compression", "can", "incorporate", "ordinal", "transform", "allow", "input", "window", "significantly", "larger", "than", "16", "pixel", "filter", "use", "16-bit", "ordinal", "image", "interestingly", "since", "each", "ordinal", "value", "unique", "median", "output", "each", "pixel", "also", "tell", "we", "where", "source", "image", "value", "come", "from", "generate", "vector", "field", "high-frequency", "image", "field", "quite", "noisy", "smoother", "image", "exhibit", "surprising", "structure", "-lrb-", "figure", "14", "last", "page", "emergent", "example", "structure", "-rrb-", "also", "variation", "where", "both", "row", "column", "information", "store", "each", "index", "can", "allow", "histogram", "element", "any", "computable", "region", "-lrb-", "e.g.", "circle", "-rrb-", "determine", "constant", "time", "we", "have", "fully", "explore", "property", "suggest", "possible", "direction", "future", "research", "we", "implement", "range", "radius", "-lsb-", "...", "127", "-rsb-", "compound", "histogram", "efficient", "enough", "require", "coarse-to-fine", "recursion", "all", "except", "carefully-constructed", "worst-case", "datum", "-lrb-", "realworld", "image", "invariably", "close", "best-case", "-rrb-", "fact", "ordinal", "transform", "itself", "often", "performance", "bottleneck", "show", "Figure", "10", "we", "implementation", "outperform", "16-bit", "median", "filter", "Photoshop", "cs2", "up", "factor", "20", "identical", "numerical", "result", "Figure", "10", "16-bit", "median", "Filter", "Performance", "bilateral", "Filter", "bilateral", "filter", "normalize", "convolution", "which", "weighting", "each", "pixel", "determine", "spatial", "distance", "from", "center", "pixel", "well", "its", "relative", "difference", "intensity", "literature", "-lrb-", "Tomasi", "et", "al.", "-lsb-", "1998", "-rsb-", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "-rrb-", "spatial", "intensity", "weighting", "function", "typically", "gaussian", "Photoshop", "cs2", "implement", "box", "spatial", "filter", "triangular", "intensity", "filter", "function", "multiply", "together", "produce", "weighting", "each", "pixel", "input", "image", "output", "image", "window", "bilateral", "define", "follow", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "??", "??", "special", "case", "spatial", "box-filter", "-lrb-", "arbitrary", "intensity", "function", "-rrb-", "worth", "study", "because", "weighting", "function", "become", "constant", "all", "pixel", "give", "intensity", "under", "condition", "histogram", "each", "spatial", "window", "become", "sufficient", "perform", "filter", "operation", "we", "-lrb-", "log", "-rrb-", "median-filtering", "algorithm", "already", "generate", "histogram", "so", "bilateral", "convolution", "can", "append", "constant", "time", "per", "pixel", "scale", "support", "intensity", "function", "g.", "higher-precision", "datum", "one", "can", "either", "dither", "source", "datum", "bit", "before", "processing", "-lrb-", "which", "introduce", "surprisingly", "little", "error", "-rrb-", "else", "downsample", "source", "intensity", "histogram", "-lrb-", "along", "line", "Paris", "et", "al.", "-lsb-", "2006", "-rsb-", "-rrb-", "which", "require", "larger", "histogram", "element", "yield", "better", "accuracy", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "apply", "bilateral", "log-scaled", "image", "re-expand", "result", "approach", "can", "pose", "precision", "problem", "when", "filter", "8-bit", "datum", "fortunately", "logarithmic", "approach", "can", "approximate", "linear", "datum", "scale", "width", "proportion", "intensity", "center", "pixel", "while", "bias", "weight", "toward", "smaller", "value", "yield", "new", "function", "rightmost", "image", "Figure", "11", "show", "result", "logarithmic", "bilateral", "8-bit", "datum", "use", "simple", "variable-width", "triangular", "function", "-lrb-", "note", "improve", "lip", "color", "hair", "detail", "-rrb-", "more", "sophisticated", "intensity", "function", "can", "precompute", "all", "-lrb-", "-rrb-", "we", "linear-data", "approximation", "logarithmic", "bilateral", "follow", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "??", "??", "where", "-lrb-", "-rrb-", "-lrb-", "log", "-rrb-", "x.", "-lrb-", "-rrb-", "one", "potential", "concern", "we", "histogram-based", "method", "imperfect", "frequency", "response", "spatial", "box", "filter", "visual", "artifact", "may", "resemble", "faint", "mach", "band", "artifact", "tend", "drown", "out", "signal", "preserved", "image", "-lrb-", "e.g.", "image", "Figure", "11", "box-filtered", "-rrb-", "still", "smooth", "spatial", "falloff", "achievable", "we", "method", "use", "iterative", "technique", "direct", "iteration", "bilateral", "can", "yield", "unintentionally", "cartoonish", "look", "-lsb-", "tomasi", "1998", "-rsb-", "indirect", "iteration", "more", "effective", "each", "step", "output", "re-filtered", "while", "continue", "use", "original", "datum", "intensity", "window", "homogeneous", "area", "wide", "intensity", "kernel", "converge", "gaussian", "without", "create", "cartoonish", "look", "524", "figure", "11", "Bilateral", "Filter", "from", "left", "8-bit", "source", "image", "Linear-Intensity", "Bilateral", "-lrb-", "Eq", "-rrb-", "Logarithmic-Intensity", "Bilateral", "-lrb-", "Eq", "-rrb-", "+1", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "-lrb-", "-rrb-", "??", "??", "Figure", "12", "original", "one", "iteration", "three", "iteration", "-lrb-", "eq", "-rrb-", "special", "case", "box-weighted", "bilateral", "we", "technique", "achieve", "discrete-segments", "result", "Durand", "et", "al.", "-lsb-", "2002", "-rsb-", "similar", "time", "256", "segment", "instead", "10-20", "full", "spatial", "resolution", "make", "result", "translation-invariant", "-lrb-", "avoid", "artifact", "due", "phase", "subsampling", "grid", "-rrb-", "high", "segment", "count", "allow", "high-dynamic-range", "image", "filter", "minimal", "loss", "precision", "slight", "color", "artifact", "may", "introduce", "result", "process", "image", "channel", "we", "have", "find", "also", "imperceptible", "typical", "image", "single", "iteration", "fix", "triangular", "intensity", "function", "-lrb-", "support", "80", "level", "-rrb-", "we", "result", "numerically", "match", "Photoshop?s", "surface", "blur", "output", "up", "twenty-fold", "acceleration", "performance", "bottleneck", "-lrb-", "over", "80", "calculation", "-rrb-", "constant", "time", "spend", "multiply", "each", "window?s", "histogram", "intensity", "function", "which", "account", "flatness", "we", "performance", "curve", "reduce", "we", "implementation", "64", "segment", "should", "nearly", "triple", "its", "speed", "while", "maintain", "very", "high", "quality", "result", "Figure", "13", "Bilateral", "Filter", "Performance", "525", "conclusion", "we", "have", "present", "logarithmic-time", "median", "filter", "algorithm", "scalable", "arbitrary", "radius", "adaptable", "image", "any", "bitdepth", "we", "believe", "most", "efficient", "median", "algorithm", "yet", "develop", "both", "term", "theoretical", "complexity", "real-world", "performance", "we", "algorithm", "can", "extend", "perform", "general", "rank-order", "filter", "flexible", "enough", "accomplish", "wide", "variety", "practical", "creative", "task", "significantly", "we", "have", "show", "we", "algorithm", "can", "adapt", "perform", "bilateral", "filter", "where", "become", "highly", "effective", "noise-removal", "tool", "we", "algorithm", "provide", "high-precision", "translation-invariant", "realtime", "implementation", "bilateral", "filter", "support", "nonlinear", "intensity", "scaling", "which", "greatly", "enhance", "quality", "result", "we", "algorithm", "have", "show", "advantage", "only", "high", "radius", "across", "spectrum", "time", "take", "Photoshop", "cs2", "process", "5x5", "median", "bilateral", "filter", "we", "implementation", "can", "process", "any", "kernel", "up", "255x255", "we", "have", "adapt", "we", "algorithm", "multiple", "processor", "near-linear", "performance", "gain", "up", "3.2", "faster", "four-processor", "system", "versus", "single", "processor", "accompany", "video", "demonstrate", "realtime", "performance", "we", "median", "bilateral", "filter", "now", "speed", "median", "filter", "have", "be", "bring", "onto", "par", "workhorse", "filter", "image-processing", "-lrb-", "e.g.", "gaussian", "blur", "fft", "-rrb-", "we", "anticipate", "median", "filter", "its", "derivative", "become", "more", "widely", "use", "part", "standard", "imageprocessing", "repertoire", "we", "hope", "we", "algorithm", "spark", "renew", "interest", "line", "research", "we", "confident", "new", "application", "discovery", "lie", "just", "around", "corner", "Acknowledgments", "special", "thanks", "Paul", "Heckbert", "provide", "invaluable", "feedback", "early", "stage", "also", "thanks", "Blaise", "Ag?era", "Arcas", "Michael", "Herf", "Klaus", "Schauser", "Tobias", "H?llerer", "Ian", "Gilman", "constructive", "critique", "talented", "Gretchen", "Elise", "use", "she", "photo", "reviewer", "time", "insightful", "comment", "finally", "Kai", "Krause", "String", "Theory", "technique", "reference", "lparone", "L.", "APPELLINI", "V.", "arzellus", "a.", "1994", "coarse-to-fine", "omasus", "c.", "anduchus", "R.", "1998", "bilateral", "filter", "gray", "algorithm", "fast", "median", "filter", "image", "datum", "huge", "number", "color", "image", "Proc", "IEEE", "Int", "Conf", "Computer", "Vision", "836", "846", "level", "signal", "processing", "Vol", "39", "no.", "1-2", "pp.", "33-41", "ukey", "J.W.", "1977", "Exploratory", "Data", "analysis", "read", "MA", "Addison", "ooley", "J.", "H.", "ukey", "J.", "1965", "algorithm", "machine", "calcuwesley", "lation", "complex", "fourier", "series", "mathematics", "Computation", "vol", "19", "pp.", "297-301", "EISS", "B.", "2006", "method", "apparatus", "Processing", "image", "datum", "US", "Patent", "7,010,163", "urand", "F.", "ORSEY", "J.", "2002", "fast", "Bilateral", "Filtering", "display", "High-Dynamic-Range", "Images", "ACM", "SIGGRAPH", "2002", "C.", "H.", "ORNG", "S.", "J.", "2003", "fast", "scalable", "selection", "algorithm", "application", "median", "filtering", "IEEE", "transaction", "parallel", "ECKBERT", "P.", "1986", "filter", "repeated", "integration", "ACM", "SIGGRAPH", "distribute", "Systems", "vol", "14", "no.", "10", "pp.", "983-992", "1986", "__________________________", "work", "protect", "US", "patent", "7,010,163", "Patents", "Pending", "Adobe", "Photoshop", "register", "trademark", "trademark", "Adobe", "Systems", "Incorporated", "United", "States", "and/or", "other", "country", "Figure", "14", "kai?s", "String", "Theory", "high-precision", "median", "filter", "apply", "soft", "16-bit", "mask", "before-after", "difference", "-lrb-", "amplify", "250x", "colorize", "-rrb-", "show", "above", "far", "from", "lowfrequency", "result", "one", "might", "expect", "contour", "soft", "mask", "beat", "against", "median", "filter?s", "discrete", "sampling", "grid", "produce", "intricate", "filigree", "along", "rational", "field", "line", "effect", "ordinarily", "imperceptible", "high", "amplification", "lend", "itself", "unusual", "creative", "use", "median", "filter", "uang", "T.S.", "1981", "two-dimensional", "signal", "processing", "ii", "transform", "median", "filter", "Berlin", "Springer-Verlag", "pp.", "209-211", "il", "J.", "ERMAN", "M.", "1993", "Computing", "2-D", "Min", "median", "Max", "Filters", "IEEE", "Trans", "pattern", "analysis", "machine", "Intelligence", "Vol", "15", "no.", "pp.", "504-507", "ABIR", "I.", "1996", "high", "Performance", "Computer", "Imaging", "Greenwich", "CT.", "man", "Publications", "p.", "181-192", "ari", "S.", "URAND", "F.", "2006", "fast", "approximation", "Bilateral", "Filter", "use", "signal", "Processing", "Approach", "eccv", "2006", "ha", "t.", "Q.", "LIET", "L.", "J.", "V.", "2005", "separable", "bilateral", "filter", "fast", "video", "preprocessing", "IEEE", "Int", "Conf", "Multimedia", "Expo", "cd1-4", "anka", "S.", "AHNI", "S.", "1989", "efficient", "serial", "parallel", "algorithm", "median", "filtering", "proceed", "1989", "International", "Conference", "parallel", "processing", "iii-56", "iii-62", "erdiman", "P.", "2000", "Radix", "Sort", "Revisited", "http://www.codercorner.com", "radixsortrevisited.htm", "ANIMOTO", "S.", "L.", "1995", "fast", "median", "filtering", "algorithm", "Mesh", "Computers", "pattern", "recognition", "vol", "28", "no.", "12", "pp.", "1965-1972", "526" ],
  "content" : "\n  \n    f0acc0026248ee23c5d0cf53046bd73183cc0036405d71eab25f10b0d37a8306\n    mhd\n    http://dx.doi.org/10.1145/1179352.1141918\n    Name identification was not possible. \n  \n  \n    \n      \n        Fast Median and Bilateral Filtering\n      \n      Ben Weiss Shell & Slate Software Corp.\n      \n        \n      \n      Median filtering is a cornerstone of modern image processing and is used extensively in smoothing and de-noising applications. The fastest commercial implementations (e.g. in Adobe ? Photoshop ? CS2) exhibit O(r) runtime in the radius of the filter, which limits their usefulness in realtime or resolution-independent contexts. We introduce a CPU-based, vectorizable O(log r) algorithm for median filtering, to our knowledge the most efficient yet developed. Our algorithm extends to images of any bit-depth, and can also be adapted to perform bilateral filtering. On 8-bit data our median filter outperforms Photoshop?s implementation by up to a factor of fifty. CR Categories: F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems ? Sorting and Searching; I.4.3 [Image Processing and Computer Vision]: Enhancement ? Filtering ; D.2.8 [Software Engineering]: Metrics ? Complexity Measures; E.1 [Data Structures]: Arrays Keywords: median filtering, bilateral filtering, rank-order filtering, sorting, image processing, algorithms, histograms, data structures, complexity, SIMD, vector processing\n    \n    \n      \n        1 Introduction\n      \n      \n        1.1 Median Filtering\n      \n      The median filter was introduced by Tukey [1977], and over the years tremendous effort has gone into its optimization and refinement. It provides a mechanism for reducing image noise, while preserving edges more effectively than a linear smoothing filter. Many common image-processing techniques such as rank-order and morphological processing are variations on the basic median algorithm, and the filter can be used as a steppingstone to more sophisticated effects. However, due to existing algorithms? fundamental slowness, its practical use has typically been restricted to small kernel sizes and/or low-resolution images. ________________________________________ ? ben@shellandslate.com Adobe ? Photoshop ? CS2 is the de facto standard for highperformance image processing, with a median filter that scales to radius 100. This filter exhibits roughly O(r) runtime per pixel, a constraint which significantly reduces its performance for large filtering kernels. A variety of O(r) algorithms are well known (e.g. Huang 1981), but it is not obvious that a faster algorithm should exist. The median filter is not separable, nor is it linear, and there is no iterative strategy for producing the final result, as there is with e.g. Gaussian Blur [Heckbert 1986], or the Fast Fourier Transform [Cooley et al. 1965]. A fast, high-radius implementation would be of considerable theoretical and practical value. Gil et al. [1993] made significant progress with a tree-based O(log 2 r) median-filtering algorithm, but its per-pixel branching nature renders it ill-suited for deep-pipelined, vector-capable modern processors. Other efforts have resorted to massive parallelism on the presumption that a single processor is insufficient: according to Wu et al. [2003], ?...designing a parallel algorithm to process [the median filter] is the only way to get a real-time response.? Ranka et al. [1989] proposed a parallel algorithm with a processor-time complexity of O(log 4 r), but this curve actually scales worse than linear for r < 55 (= e 4 ), the point at which a 1% increase in radius corresponds to a 1% increase in computation. Our algorithm overcomes all of these limitations and achieves O(log r) runtime per pixel on 8-bit data, for both median and bilateral filtering. It is fully vectorizable and uses just O(r) storage. It also adapts as an O(log 2 r) algorithm to arbitrary-depth images, on which it runs up to twenty times as fast as Photoshop?s 16-bit Median filter. To our knowledge, the presented O(log r) algorithm is the most efficient 2D median filter yet developed, and processes 8-bit data up to fifty times faster than Photoshop?s Median filter.\n      Copyright ? 2006 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Permissions Dept, ACM Inc., fax +1 (212) 869-0481 or e-mail\n      \n        Figure 1: 8-Bit Median Filter Performance\n      \n       permissions@acm.org . ? 2006 ACM 0730-0301/06/07000519 $5.00\n      519\n      \n        \n        Figure 2: Median Filter Variations. Top row: original; sharpened with Gaussian; sharpened with median (note fewer halo artifacts.) Middle row: Filtered at 20th; 50th [median]; and 80th percentiles. Bottom row: ?High Pass? using median; bilateral smoothing filter; logarithmic bilateral filter.\n      \n      \n        1.2 Bilateral Filtering\n        The Bilateral filter was introduced by Tomasi et al. [1998] as a non-iterative means of smoothing images while retaining edge detail. It involves a weighted convolution in which the weight for each pixel depends not only on its distance from the center pixel, but also its relative intensity. As described, the bilateral filter has nominal O(r 2 ) computational cost per pixel. Photoshop ? CS2?s 16-bit Surface Blur filter reflects this O(r 2 ) complexity, and becomes unusably slow for even moderate radii. On 8-bit data, Photoshop?s Surface Blur exhibits a performance curve nearly identical to its 8-bit Median filter, suggesting that they share the same core O(r) algorithm.  Durand et al. [2002] developed a much more efficient technique, refined and accelerated by Paris et al. [2006]. Durand?s method approximates the bilateral by filtering subsampled copies of the image with discrete intensity kernels, and recombining the results using linear interpolation. It has the paradoxical property of becoming faster as the radius increases (due to greater subsampling), but also has some potential drawbacks. For one, it is not translation-invariant: the exact output is dependent on the phase of the subsampling grid. Also, the discretization may lead to a further loss of precision, particularly on high-dynamic-range images with narrow intensity-weighting functions. Our bilateral filtering algorithm maintains high resolution in both space and intensity, and is translation-invariant. It is based on a box spatial kernel, which can be iterated to yield smooth spatial falloff. It is derived from the same core algorithm as our fast O(log r) median filter, and adapts to 16-bit and HDR data with minimal loss of precision.\n      \n      \n        1.3 Structure\n        Our approach in this paper will be first to illustrate the conventional O(r) median algorithm for 8-bit images, and analyze its performance and limitations. Then we will show in steps how to improve it; first by constant factors, then into O(?r) and O(?r) algorithms, and from there into an O(log r) algorithm. We will show how our approach adapts to higher bit-depth data, such as 16-bit and HDR floating-point. Finally, we will show how the algorithm can be adapted to perform bilateral filtering, and compare it with previous methods.\n      \n      \n        2 The Basic Algorithm\n        \n          O(r)\n          \n            \n          \n          Consider the case of applying a radius-r median filter to an 8-bit image. Assume a source image that is larger than the destination by r pixels on all sides, to sidestep edge-related concerns. (In practice, we repeat edge pixels to fill undefined areas, and process color images on a per-channel basis.) Because the median filter is local, it can be applied to arbitrary-size images in tiles. As a consequence, its total runtime scales linearly with image area: O(S 2 ) for an S-by-S image.  The fundamental property that concerns us here is runtime per pixel, as a function of filter radius. This corresponds to the performance a user will experience while adjusting the filter radius, and is the primary differentiating characteristic between medianfiltering algorithms. For reference, a brute-force implementation can calculate each output pixel in O(r 2 log r) time, by sorting the corresponding (2r + 1) 2 -pixel input window and selecting the median value as output. On discrete data, a radix-sort can be used to reduce the sorting complexity to O(r 2 ) operations; this can be done for some floating-point data as well [Terdiman 2000]. In the case of 8-bit data, we use a 256-element histogram, H. Once the input values are added to H, the median value lies in the first index for which the sum of values to that index reaches 2r 2 + 2r + 1. The median index can be found by integrating the histogram from one end until the appropriate sum is reached. An improved algorithm was proposed by Huang [1981], based on the observation that adjacent windows overlap to a considerable extent. Huang?s algorithm makes use of this sequential overlap to consolidate the redundant calculations, reducing the computational complexity to O(r). A modified version of Huang?s algorithm is below: Huang?s algorithm is a significant improvement over the bruteforce method. However, the window-sliding step dominates the calculation with O(r) runtime per pixel, while the histogramscanning takes constant time per pixel. This suggests that we should look for a way to make the window-sliding faster, even at the expense of making the histogram-scanning slower. Observe that as the window zigzags through the image, it passes through each region several times, performing nearly the same operations on each pass. (Picture mowing your lawn back and forth, shifting sideways one centimeter each time.) This redundancy is considerable, and mirrors the adjacent-window overlap that led to Huang?s algorithm. The difficulty is that these redundant calculations occur at widely spaced time intervals in the computation; perhaps tens of thousands of processor cycles apart, so they cannot be combined using the same sequential logic that led to the O(r) technique. Yet, eliminating these redundancies is the key to a dramatically faster algorithm.\n          520\n          \n            \n          \n          r: radius of median filter. (shown above as r = 3.) H: 256-element histogram. I: input image, S + 2r pixels square. O: output image [inset], S pixels square. initialize H to I[0 .. 2r][0 .. 2r]. // yellow region find median value m in H, write m to O[0][0]. for row = 1 to S 1: add values I[2r + row][0 .. 2r] to H. subtract values I[row 1][0 .. 2r] from H. find median value m in H; write m to O[row][0]. step sideways to next column (and process bottom to top, etc.).\n          \n            Figure 3: Pseudocode for Huang?s O(r) Algorithm\n          \n        \n      \n      \n        3 The Algorithm\n        \n          O(log r)\n        \n      \n      \n        3.1 Synchronicity\n        The fundamental idea behind this paper, and the mechanism that enables our fast algorithm, is the observation that if multiple columns are processed at once, the aforementioned redundant calculations become sequential. This gives us the opportunity to consolidate them, resulting in huge increases in performance.\n      \n      \n        3.2 Distributive Histograms\n        A straightforward adaptation of Huang?s algorithm to process N columns at once involves the maintenance of N histograms, one per output column: H 0 .. H N-1 . This is essentially just a rearrangement of operations; the runtime complexity is unchanged. Each input pixel gets added to 2r + 1 histograms over the course of filtering the image, leading to the O(r) runtime complexity.  Fortunately, the explicit maintenance of each histogram H n is unnecessary, due to the distributive property of histograms. This is where our approach diverges from Huang?s algorithm. Histogram distributivity means that for disjoint image regions A and B:\n        H A B [v] ? H A [v] + H B [v] (1)\n        In other words, if an image window W is the union of two disjoint regions A and B, then its histogram H W is equal to H A + H B . The median element of W can then be found by scanning the implicit histogram H W , splicing it together from H A and H B on the fly. (This extends to signed linear combinations; H A ? H W H B , etc.)  In the case of median-filtering N columns, our approach is to form a set H* of partial histograms P 0 .. P N-1 (whose elements may be signed), such that each histogram H 0 .. H N-1 is representable as the sum of T partial histograms from H*. Figure 4 shows how a row of pixels v 0 .. v 2r+8 is added to H*, for the case N = 9, T = 2. The histogram set H* is arranged like a tree, with a central histogram (P 4 ) representing the input window for the central column, and the other partial histograms P n representing the difference between the central and adjacent windows. The sum of each partial plus central histogram yields the full histogram for the corresponding square input window. By widening the yellow central region and fitting the partial histograms to its edges, the 9-column technique can be adapted to perform median filtering of arbitrary radius. The time spent modifying H* is still O(r), but with a much lower constant than Huang?s algorithm. The median extraction time from H* remains constant regardless of r. The more fundamental improvement in efficiency comes when we allow the number of columns N to vary with r, conceptually adding more planes to Figure 4 . For N output columns, the number of modifications to H* per output pixel is (N 2 + 4r + 1) / N. (The graphic in Figure 4 show the case of N = 9, r = 4, requiring 98 adjustments to H* per row or about 11 per output pixel.) Solving for N to minimize the number of adjustments gives N ? 2?r, which yields O(?r) histogram modifications per pixel. Thus, the complexity of the T = 2, variable-N adaptive algorithm is O(?r).\n        \n          \n        \n        Huang: H 0 .. H 8 Our Method: P 0 .. P 8 H* Mapping: H 0 [v 0 .. v 2r ]++; P 0 [v 0 ..v 3 ]++; P 0 [v 2r+1 ..v 2r+4 ]--; H 0 ? P 0 + P 4 H 1 [v 1 .. v 2r+1 ]++; P 1 [v 1 ..v 3 ]++; P 1 [v 2r+2 ..v 2r+4 ]--; H 1 ? P 1 + P 4 H 2 [v 2 .. v 2r+2 ]++; P 2 [v 2 ..v 3 ]++; P 2 [v 2r+3 ..v 2r+4 ]--; H 2 ? P 2 + P 4 H 3 [v 3 .. v 2r+3 ]++; P 3 [ v 3 ]++; P 3 [ v 2r+4 ]--; H 3 ? P 3 + P 4 H 4 [v 4 .. v 2r+4 ]++; P 4 [v 4 .......................... v 2r+4 ]++; H 4 ? P 4 H 5 [v 5 .. v 2r+5 ]++; P 5 [v 4 ]--; P 5 [v 2r+5 ]++; H 5 ? P 5 + P 4 H 6 [v 6 .. v 2r+6 ]++; P 6 [v 4 ..v 5 ]--; P 6 [v 2r+5 ..v 2r+6 ]++; H 6 ? P 6 + P 4 H 7 [v 7 .. v 2r+7 ]++; P 7 [v 4 ..v 6 ]--; P 7 [v 2r+5 ..v 2r+7 ]++; H 7 ? P 7 + P 4 H 8 [v 8 .. v 2r+8 ]++; P 8 [v 4 ..v 7 ]--; P 8 [v 2r+5 ..v 2r+8 ]++; H 8 ? P 8 + P 4 18r + 9 operations 2r + 41 operations T =2\n        \n          Figure 4: Adding a row of pixels to H*, for the case N = 9, T = 2. Each layer shows how the corresponding histogram H n is formed from partial histograms P n in H*. The pseudocode shows how a row of pixels v 0 .. v 2r+8 is added to H*. The ?holes? represent pixels that are added to the central histogram P 4 but subtracted from partial histograms, canceling themselves out.\n        \n        521\n      \n      \n        3.3 Three Tiers and Beyond\n        \n          \n          Figure 5: H* Histogram Layout for N = 63, T = 3.\n        \n         Figure 5 shows a layout for processing sixty-three columns at once. It is the three-tiered analogue of Figure 4 , this time ?viewed? from the side. There is a single shared histogram P 31 [yellow] corresponding to the central window; eight partial histograms [orange] at seven-pixel intervals; and for each of these, six small partial histograms [red] at unit intervals; sixty-three histograms altogether. Each input pixel is added/subtracted to each histogram intersecting its column. In this example, a 63-by-1 block of output is produced at each iteration. The mapping of P n to H n becomes:\n        H n = P 31 + P 7 n/7 +3 + P n\n        (2)\n        where the second and third terms are ignored if they match earlier terms (e.g., H 24 = P 31 + P 24 .) The structure of H* is recursive; the central yellow histogram forms a rough approximation to any particular H n ; the orange partial histograms refine that approximation, and the red histograms provide the final correction to make the sums exact. Once H* is initialized, the full histogram of each of the 63 square input windows is expressible per Eq. 2 as the sum  of one red histogram (or none), one orange histogram (or none), and the yellow central histogram. The illustrated case of N = 63, T = 3, r = 31 requires ~18 histogram modifications per output pixel. The median-extraction from H* takes constant time, as the three partial histograms are spliced together on the fly. For the general case of 3-tiered structures, processing N columns at once and with tier radix ?N, the number of histogram adjustments per output pixel becomes ?N + ((4r + 2) / N). For radius r, solving for optimal N yields N ? 4r 2?3 , and the runtime of the threetiered adaptive algorithm is therefore O(?r). In practice, three tiers covers the realistic range of implementation (into the hundreds), but our technique can be extended to arbitrary T. In the limit, a radius-r median filter can be computed across N = O(r) columns at once, using N histograms arranged into T = O(log r) tiers of constant radix. For example, a radius one-million median filter can be computed across N = 9 6 = 531,441 columns at once, using 9 6 partial histograms arranged in seven tiers of radix 9, occupying roughly 500 megabytes of storage. Sliding the window from one row to the next requires O(log r) ? 114 histogram modifications per output pixel. Extracting each median takes O(log r) steps; in this case splicing up to seven partial histograms together to construct each H n , counterbalancing the O(log r) complexity of writing to H*. Therefore, the overall computational cost per pixel is O(log r). ?\n        \n          \n        \n        r: radius of median filter. H*: Array of partial histograms, processing N columns. I: input image, N + 2r pixels square. O: output image, N pixels square. for each row in [0 .. 2r]: // Initialize H* Add row, I[row][0 .. 2r + N 1] to H*, as per Figure 4 for each output pixel in O[0][col]: // compute first N median values scan H col (implicit in H*) to the find the median m, write O[0][col] = m. for row = 1 to N 1: // step from top to bottom of image add new bottom row, I[row + 2r][0 .. 2r + N 1], to H*. subtract old top row, I[row 1][0 .. 2r + N 1], from H*. find N new median values in H*; write to O[row][0 .. N 1].\n        \n          Figure 6: Pseudocode for O(log r) Algorithm\n        \n        522\n      \n      \n        3.4 Implementation Notes\n        Scanning the histogram from index zero to find the median takes about 128 steps on average. Huang [1981] suggested using each output value as a ?pivot? to find the next median value: as H is scanned to find m, we keep track of the number of values v < m in H. Then as we add and remove pixels from H, we keep a running count of how many values satisfy v < m. This allows us to scan the updated histogram starting from m, which is typically much faster than starting from index zero.  This heuristic adapts to the O(log r) algorithm by using O(log r) pivots across the N columns, with each pivot tracking the smallest median value in its respective columns. This approach obtains much of the benefit of the heuristic while preserving the O(log r) complexity. Since the pivot tracking involves many consecutive bytewise compares, it is ideally suited for vector optimization. Finally, it is useful to interleave the partial histograms P n in memory, so that multiple adjacent histograms can be modified simultaneously using vector loads and stores. This greatly accelerates the reading and writing of H*.\n        \n          \n          Figure 7: Pivot Tracking. The middle image shows the approximation obtained using one pivot per sixteen columns to track the smallest median values. H* is then scanned upwards from these pivots (several columns at a time, vectorized) to yield the exact median result, right.\n        \n      \n      \n        4 Higher-Depth Median Filtering 4.1 Adapting the 8-bit Algorithm\n        16-bit and HDR images have already become mainstream, so it is important that our median filter work with images of arbitrary bitdepth. A direct extension of the 8-bit algorithm is problematic, because the histograms must stretch to accommodate every possible value, growing exponentially with bit-depth. The algorithm still remains O(log r), but storage considerations render it impractical for 16-bit images and impossible for floating-point images.\n      \n      \n        4.2 The Ordinal Transform\n        H* is reduced to a manageable size through a technique we call the ordinal transform. This involves sorting the input image values, storing the sorted list, and replacing each cardinal value with its ordinal equivalent. (Duplicate cardinal values map to consecutive ordinal values.) The median filter is then applied to the ordinal image, and the transform is inverted to restore the cardinalvalued result. The ordinal transform operates on images of any depth, in logarithmic or constant time per pixel.  In this operation, the nonlinearity of the median filter is crucial. Any linear filter (e.g., Gaussian blur) would not be invariant under the ordinal transform, but the median filter is! That is because rank-order is preserved; the k th -smallest cardinal value maps to the k th -smallest ordinal value. After the ordinal transform is applied, the median filtering proceeds as in Section 3, this time using single-bit histograms P n (sufficient here because each ordinal value is unique in the image), and the results are inversetransformed to yield the final filtered image. Recall that the histogram elements in H* can go negative. At first this appears problematic because the required range [-1, 0, 1] doesn?t fit into a single bit. However, since each summed implicit histogram value H n [v] can only be either zero or one, only the lowest bit from each partial histogram must participate in the summation. Hence a single bit is sufficient for each element of P n , and the splicing accomplished through a bitwise XOR.\n        \n          \n          Figure 8: The Ordinal Transform. Duplicate cardinal values (e.g. 94, 94, left) map to consecutive ordinal values (2 and 3, right).\n        \n      \n      \n        4.3 The Compound Histogram\n        For processing N columns in parallel, this approach still requires the allocation and maintenance of N single-bit histograms. However, due to the uniqueness of values in the ordinal image, we can take advantage of a much more efficient encoding.  Consider the full histogram obtained by splicing the n th set of partial histograms in H* (consisting of the central histogram plus one partial histogram from each tier), to yield the single-bit histogram for the n th input window. Label this binary histogram B n . By definition, the single bit B n [v] indicates whether the ordinal value v lies in the input window n.\n        Now, for N <= min(2r, 128), instead of allocating N binary histograms, we allocate a single 8-bit compound histogram H c . As rows of pixels v = I[row][col] are added, we adjust H c as follows:\n        \n          3\n          0xFF col, col < N 1 H c [v] = 0x80, N 1 <= col <= 2r 0x80 (col 2r), col > 2r\n        \n        Since the ordinal values in I can have any arrangement, the compound histogram H c is filled in arbitrary order. As rows of pixels are removed, the corresponding elements of H c are zeroed. The power of this technique becomes clear when it comes time to scan the implicit histogram B n to find the n th median output value.  In our initial approach, each implicit histogram B n was spliced together from O(log r) partial histograms, taking O(log r) time per element. With the compound histogram, using 8-bit modular arithmetic, elements of B n can now be computed in constant time:\n        523\n        \n          \n          Figure 9: The Compound Histogram H c\n        \n        \n          4\n          B n [v] = (H c [v] + n) >> 7.\n        \n        For N > 128, this technique extends in a straightforward manner to 16-bit compound histograms, sufficient for N <= 32768, and so on. The computational complexity is independent of element size.\n      \n      \n        4.4 Coarse-To-Fine Recursion\n        There is one final detail. As the radius increases, the histogram size scales as O(r 2 ), which directly affects the histogram scanning distance and thus the algorithm?s time-complexity. This complication is addressed by computing the median in stages from coarse to fine precision. Alparone et al. [1994] applied a similar technique to the O(r) algorithm, employing two levels of resolution to process 10, 12, or 14-bit images in faster (but still O(r)) time. Here we apply an analogous technique to our log-time algorithm.  In our case, the coarse-to-fine calculation is performed by rightshifting the ordinal image 8 bits at a time (or similar radix) until it reaches a fixed low resolution; e.g., 10 bits per pixel. Then the O(log r) algorithm from Section 3 is applied to the low-resolution data (whose values are no longer unique), storing not only the median values, but also the number of values strictly below the median. This result forms a pivot from which we calculate the median at the next-higher level of resolution. For example, if the lowest-resolution median value for a pixel is 0x84, and there are n values below 0x84 in its histogram, then there will be n values below 0x8400 in the next-higher-resolution histogram, and the median will be in [0x8400 .. 0x84FF]. This scanning is bounded by a constant [256] number of steps per iteration, with each iteration adding eight bits of precision to the output. The final iteration is performed using the compound histogram, which yields the full-precision ordinal result. The entire process requires O(log r) levels of recursion, each taking O(log r) time as shown in Section 3, for an overall computational complexity of O(log 2 r). ?\n      \n      \n        4.5 Implementation Notes\n        Applying a radius-r median filter to an ordinal image cannot output any of the lowest (2r 2 + 2r) ordinal values, because by definition the median must exceed that many values. The filter can thus  treat all such values as a single low constant, and likewise the (2r 2 + 2r) highest values as a single high constant, without affecting the final result. This ?endpoint compression? can be incorporated into the ordinal transform, allowing input windows significantly larger than 2 16 pixels to be filtered using 16-bit ordinal images. Interestingly, since each ordinal value is unique, the median output for each pixel also tells us where in the source image that value came from, generating a vector field. On high-frequency images this field is quite noisy, but on smoother images it exhibits surprising structure. ( Figure 14 on the last page is an emergent example of this structure.) Also, a variation of H c where both row and column information is stored at each index can allow histogram elements of any computable region (e.g., a circle) to be determined in constant time. We have not fully explored these properties, but they suggest possible directions for future research. For our implemented range of radii [1...127], the compound histogram is efficient enough not to require the coarse-to-fine recursion at all, except on carefully-constructed worst-case data. (Realworld images are invariably close to best-case.) In fact, the ordinal transform by itself is often the performance bottleneck. As shown in Figure 10 , our implementation outperforms the 16-bit Median filter in Photoshop ? CS2 by up to a factor of 20, with identical numerical results.\n        \n          \n          Figure 10: 16-Bit Median Filter Performance\n        \n      \n      \n        5 The Bilateral Filter\n        The bilateral filter is a normalized convolution in which the weighting for each pixel p is determined by the spatial distance from the center pixel s, as well as its relative difference in intensity. In the literature (Tomasi et al. [1998] and Durand et al. [2002]), the spatial and intensity weighting functions f and g are typically Gaussian; Photoshop ? CS2 implements a box spatial filter and triangular intensity filter. These functions multiply together to produce the weighting for each pixel. For input image I, output image J and window ?, the bilateral is defined as follows:\n        \n          5\n          J s = f (p ? s)g(I p ? I s )I p f (p ? s)g(I p ? I s ). p?? p??\n        \n        The special case of a spatial box-filter (with arbitrary intensity function) is worth studying, because the weighting function becomes constant for all pixels of a given intensity. Under this condition, the histogram of each spatial window becomes sufficient  to perform the filtering operation. Our O(log r) median-filtering algorithm already generates these histograms, so the bilateral convolution can be appended in constant time per pixel, scaling with the support of the intensity function g. For higher-precision data, one can either dither the source data into 8 bits before processing (which introduces surprisingly little error), or else downsample the source intensities into the histograms (along the lines of Paris et al. [2006]), which requires larger histogram elements but yields better accuracy. Durand et al. [2002] applied the bilateral to log-scaled images and re-expanded the result, but this approach can pose precision problems when filtering 8-bit data. Fortunately, this logarithmic approach can be approximated on linear data by scaling the width of g in proportion to the intensity of the center pixel while biasing the weight toward smaller values, yielding a new function g?. The rightmost image in Figure 11 shows the result of this logarithmic bilateral on 8-bit data, using a simple variable-width triangular function for g?. (Note the improved lip color and hair detail.) More sophisticated intensity functions can be precomputed for all (I p , I s ). Our linear-data approximation to the logarithmic bilateral is as follows: J s = f (p ? s)g (I p /I s )I p f (p ? s)g (I p /I s ). (6) p?? p?? where g (x) = g(log x)/ ? x. (7) One potential concern with our histogram-based method is the imperfect frequency response of the spatial box filter. Visual artifacts may resemble faint mach bands, but these artifacts tend to be drowned out by the signal of the preserved image (e.g., the images in Figure 11 are box-filtered.) Still, smooth spatial falloff is achievable with our method, using an iterative technique. Direct iteration of the bilateral can yield an unintentionally cartoonish look [Tomasi 1998], but indirect iteration is more effective. At each step the output is re-filtered, while continuing to use the original data for the intensity windows. For homogeneous areas or with wide intensity kernels, this converges to a Gaussian without creating the cartoonish look:\n        524\n        \n          \n          Figure 11: The Bilateral Filter. From left: 8-Bit Source Image; Linear-Intensity Bilateral (Eq. 5); Logarithmic-Intensity Bilateral (Eq. 6).\n        \n        \n          8\n          I s n+1 = f (p ? s)g(I p n , I s 0 )I p n f (p ? s)g(I p n , I s 0 ). p?? p??\n        \n        \n          \n          Figure 12: Original; One iteration; Three iterations (Eq. 8).\n        \n        For the special case of the box-weighted bilateral, our technique achieves the discrete-segments result of Durand et al. [2002] in similar time, but with 256 segments instead of 10-20, and at full spatial resolution. This makes the result translation-invariant (avoiding artifacts due to the phase of the subsampling grid), and the high segment count allows high-dynamic-range images to be filtered with minimal loss of precision. Slight color artifacts may be introduced as a result of processing the image by channel, but we have found these also to be imperceptible on typical images.  With a single iteration and a fixed triangular intensity function (support 80 levels), our results numerically match Photoshop?s Surface Blur output, with up to twenty-fold acceleration. The performance bottleneck (over 80% of the calculation) is the constant time spent multiplying each window?s histogram by the intensity function, which accounts for the flatness of our performance curve. Reducing our implementation to 64 segments should nearly triple its speed, while maintaining very high quality results.\n        \n          \n          Figure 13: Bilateral Filter Performance\n        \n        525\n      \n      \n        6 Conclusion\n        We have presented a logarithmic-time median filter algorithm, scalable to arbitrary radius and adaptable to images of any bitdepth. We believe this is the most efficient median algorithm yet developed, both in terms of theoretical complexity and real-world performance. Our algorithm can be extended to perform general rank-order filtering, and it is flexible enough to accomplish a wide variety of practical and creative tasks.  Significantly, we have shown that our algorithm can be adapted to perform bilateral filtering, where it becomes a highly effective noise-removal tool. Our algorithm provides a high-precision, translation-invariant, realtime implementation of the bilateral filter, and supports nonlinear intensity scaling, which greatly enhances the quality of the result. Our algorithms have shown their advantage not only at high radii but across the spectrum. In the time it takes Photoshop ? CS2 to process a 5x5 median or bilateral filter, our implementation can process any kernel up to 255x255. We have adapted our algorithm to multiple processors with near-linear performance gains, up to 3.2x faster on a four-processor system versus a single processor. The accompanying videos demonstrate the realtime performance of our median and bilateral filters. Now that the speed of the median filter has been brought onto par with the workhorse filters of image-processing (e.g. Gaussian blur and FFT), we anticipate that the median filter and its derivatives will become a more widely used part of the standard imageprocessing repertoire. It is our hope that our algorithms spark renewed interest in this line of research, and we are confident that new applications and discoveries lie just around the corner.\n      \n      \n        Acknowledgments\n        Special thanks to Paul Heckbert for providing invaluable feedback in the early stages. Also thanks to Blaise Ag?era y Arcas, Michael Herf, Klaus Schauser, Tobias H?llerer and Ian Gilman for their constructive critiques. To the talented Gretchen Elise for the use of her photo. To the reviewers for their time and insightful comments. Finally to Kai Krause, for the String Theory technique!\n      \n      \n        References\n        \n          A LPARONE , L., C APPELLINI , V., AND G ARZELLI , A. 1994. A coarse-to-fine T OMASI , C. AND M ANDUCHI , R. 1998. Bilateral filtering for gray and algorithm for fast median filtering of image data with a huge number color images. In Proc. IEEE Int. Conf. on Computer Vision, 836?846. of levels. Signal Processing, Vol. 39 No. 1-2, pp. 33-41. T UKEY , J.W. 1977. Exploratory Data Analysis. Reading, MA. Addison-\n          C OOLEY , J. H. AND T UKEY , J. 1965. An Algorithm for the Machine CalcuWesley. lation of the Complex Fourier series. Mathematics of Computation, vol. 19, pp. 297-301. W EISS , B. 2006. Method and Apparatus for Processing Image Data. US Patent 7,010,163.\n          D URAND , F. AND D ORSEY , J. 2002. Fast Bilateral Filtering for the Display of High-Dynamic-Range Images. ACM SIGGRAPH 2002. W U , C. H. AND H ORNG , S. J. 2003. Fast and Scalable Selection Algorithms with Applications to Median Filtering. IEEE Transactions on Parallel\n          H ECKBERT , P. 1986. Filtering by Repeated Integration. ACM SIGGRAPH and Distributed Systems, vol. 14, no. 10, pp. 983-992. 1986.\n          __________________________ This work is protected by US Patent 7,010,163 and Patents Pending. Adobe and Photoshop are registered trademarks or trademarks of Adobe Systems Incorporated in the United States and/or other countries.\n        \n        \n          \n          Figure 14: Kai?s String Theory. A high-precision median filter is applied to a soft 16-bit mask, and the before-after difference (amplified 250x and colorized) is shown above. Far from the lowfrequency result one might expect, the contours of the soft mask ?beat? against the median filter?s discrete sampling grid, producing an intricate filigree along rational field lines. This effect is ordinarily imperceptible, but with high amplification it lends itself to an unusual creative use of the median filter.\n        \n        H UANG , T.S. 1981. Two-Dimensional Signal Processing II: Transforms and Median Filters. Berlin: Springer-Verlag, pp. 209-211. G IL , J. AND W ERMAN , M. 1993. Computing 2-D Min, Median, and Max Filters. IEEE Trans. Pattern Analysis and Machine Intelligence, Vol. 15 No. 5, pp. 504-507. K ABIR , I. 1996. High Performance Computer Imaging. Greenwich, CT. Manning Publications. pp. 181-192. P ARIS , S. AND D URAND , F. 2006. A Fast Approximation of the Bilateral Filter using a Signal Processing Approach. ECCV 2006. P HA , T. Q. AND V LIET , L. J. V. 2005. Separable bilateral filtering for fast video preprocessing. IEEE Int. Conf. on Multimedia & Expo. CD1-4. R ANKA , S. AND S AHNI , S. 1989. Efficient Serial and Parallel Algorithms for Median Filtering. Proceeding 1989 International Conference on Parallel Processing, III-56 -III-62. T ERDIMAN , P. 2000. Radix Sort Revisited. <http://www.codercorner.com /RadixSortRevisited.htm> T ANIMOTO , S. L. 1995. Fast Median Filtering Algorithms for Mesh Computers. Pattern Recognition, vol. 28, no. 12, pp. 1965-1972.\n        526\n      \n    \n  ",
  "resources" : [ ]
}